
example/example.elf:     file format elf32-littlearm


Disassembly of section .text:

00000410 <__do_global_dtors_aux>:
     410:	b510      	push	{r4, lr}
     412:	4c05      	ldr	r4, [pc, #20]	; (428 <__UVISOR_FLASH_OFFSET+0x18>)
     414:	7823      	ldrb	r3, [r4, #0]
     416:	b933      	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	4b04      	ldr	r3, [pc, #16]	; (42c <__UVISOR_FLASH_OFFSET+0x1c>)
     41a:	b113      	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	4804      	ldr	r0, [pc, #16]	; (430 <__UVISOR_FLASH_OFFSET+0x20>)
     41e:	f3af 8000 	nop.w
     422:	2301      	movs	r3, #1
     424:	7023      	strb	r3, [r4, #0]
     426:	bd10      	pop	{r4, pc}
     428:	20000b80 	.word	0x20000b80
     42c:	00000000 	.word	0x00000000
     430:	00012ce4 	.word	0x00012ce4

00000434 <frame_dummy>:
     434:	4b0c      	ldr	r3, [pc, #48]	; (468 <frame_dummy+0x34>)
     436:	b143      	cbz	r3, 44a <frame_dummy+0x16>
     438:	480c      	ldr	r0, [pc, #48]	; (46c <frame_dummy+0x38>)
     43a:	490d      	ldr	r1, [pc, #52]	; (470 <frame_dummy+0x3c>)
     43c:	b510      	push	{r4, lr}
     43e:	f3af 8000 	nop.w
     442:	480c      	ldr	r0, [pc, #48]	; (474 <frame_dummy+0x40>)
     444:	6803      	ldr	r3, [r0, #0]
     446:	b923      	cbnz	r3, 452 <frame_dummy+0x1e>
     448:	bd10      	pop	{r4, pc}
     44a:	480a      	ldr	r0, [pc, #40]	; (474 <frame_dummy+0x40>)
     44c:	6803      	ldr	r3, [r0, #0]
     44e:	b933      	cbnz	r3, 45e <frame_dummy+0x2a>
     450:	4770      	bx	lr
     452:	4b09      	ldr	r3, [pc, #36]	; (478 <frame_dummy+0x44>)
     454:	2b00      	cmp	r3, #0
     456:	d0f7      	beq.n	448 <frame_dummy+0x14>
     458:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     45c:	4718      	bx	r3
     45e:	4b06      	ldr	r3, [pc, #24]	; (478 <frame_dummy+0x44>)
     460:	2b00      	cmp	r3, #0
     462:	d0f5      	beq.n	450 <frame_dummy+0x1c>
     464:	4718      	bx	r3
     466:	bf00      	nop
     468:	00000000 	.word	0x00000000
     46c:	00012ce4 	.word	0x00012ce4
     470:	20000b84 	.word	0x20000b84
     474:	20000b6c 	.word	0x20000b6c
     478:	00000000 	.word	0x00000000

0000047c <_mainCRTStartup>:
     47c:	4b15      	ldr	r3, [pc, #84]	; (4d4 <_mainCRTStartup+0x58>)
     47e:	2b00      	cmp	r3, #0
     480:	bf08      	it	eq
     482:	4b13      	ldreq	r3, [pc, #76]	; (4d0 <_mainCRTStartup+0x54>)
     484:	469d      	mov	sp, r3
     486:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
     48a:	2100      	movs	r1, #0
     48c:	468b      	mov	fp, r1
     48e:	460f      	mov	r7, r1
     490:	4813      	ldr	r0, [pc, #76]	; (4e0 <_mainCRTStartup+0x64>)
     492:	4a14      	ldr	r2, [pc, #80]	; (4e4 <_mainCRTStartup+0x68>)
     494:	1a12      	subs	r2, r2, r0
     496:	f00b f805 	bl	b4a4 <memset>
     49a:	4b0f      	ldr	r3, [pc, #60]	; (4d8 <_mainCRTStartup+0x5c>)
     49c:	2b00      	cmp	r3, #0
     49e:	d000      	beq.n	4a2 <_mainCRTStartup+0x26>
     4a0:	4798      	blx	r3
     4a2:	4b0e      	ldr	r3, [pc, #56]	; (4dc <_mainCRTStartup+0x60>)
     4a4:	2b00      	cmp	r3, #0
     4a6:	d000      	beq.n	4aa <_mainCRTStartup+0x2e>
     4a8:	4798      	blx	r3
     4aa:	2000      	movs	r0, #0
     4ac:	2100      	movs	r1, #0
     4ae:	0004      	movs	r4, r0
     4b0:	000d      	movs	r5, r1
     4b2:	480d      	ldr	r0, [pc, #52]	; (4e8 <_mainCRTStartup+0x6c>)
     4b4:	2800      	cmp	r0, #0
     4b6:	d002      	beq.n	4be <_mainCRTStartup+0x42>
     4b8:	480c      	ldr	r0, [pc, #48]	; (4ec <_mainCRTStartup+0x70>)
     4ba:	f003 fafd 	bl	3ab8 <__wrap_atexit>
     4be:	f00a fc01 	bl	acc4 <__libc_init_array>
     4c2:	0020      	movs	r0, r4
     4c4:	0029      	movs	r1, r5
     4c6:	f003 fea7 	bl	4218 <__wrap_main>
     4ca:	f003 faeb 	bl	3aa4 <__wrap_exit>
     4ce:	bf00      	nop
     4d0:	00080000 	.word	0x00080000
     4d4:	20030000 	.word	0x20030000
     4d8:	00000000 	.word	0x00000000
     4dc:	000042d9 	.word	0x000042d9
     4e0:	20000b80 	.word	0x20000b80
     4e4:	20003050 	.word	0x20003050
     4e8:	00003ab9 	.word	0x00003ab9
     4ec:	00000000 	.word	0x00000000

000004f0 <HardFault_Handler>:
     4f0:	f04f 0310 	mov.w	r3, #16
     4f4:	f000 b80c 	b.w	510 <Fault_Handler>

000004f8 <MemManage_Handler>:
     4f8:	f04f 0320 	mov.w	r3, #32
     4fc:	f000 b808 	b.w	510 <Fault_Handler>

00000500 <BusFault_Handler>:
     500:	f04f 0330 	mov.w	r3, #48	; 0x30
     504:	f000 b804 	b.w	510 <Fault_Handler>

00000508 <UsageFault_Handler>:
     508:	f04f 0340 	mov.w	r3, #64	; 0x40
     50c:	f000 b800 	b.w	510 <Fault_Handler>

00000510 <Fault_Handler>:
     510:	f3ef 8008 	mrs	r0, MSP
     514:	f04f 0104 	mov.w	r1, #4
     518:	4672      	mov	r2, lr
     51a:	420a      	tst	r2, r1
     51c:	d001      	beq.n	522 <Fault_Handler_Continue>
     51e:	f3ef 8009 	mrs	r0, PSP

00000522 <Fault_Handler_Continue>:
     522:	469c      	mov	ip, r3
     524:	4924      	ldr	r1, [pc, #144]	; (5b8 <Fault_Handler_Continue2+0x2e>)
     526:	6802      	ldr	r2, [r0, #0]
     528:	600a      	str	r2, [r1, #0]
     52a:	3104      	adds	r1, #4
     52c:	6842      	ldr	r2, [r0, #4]
     52e:	600a      	str	r2, [r1, #0]
     530:	3104      	adds	r1, #4
     532:	6882      	ldr	r2, [r0, #8]
     534:	600a      	str	r2, [r1, #0]
     536:	3104      	adds	r1, #4
     538:	68c2      	ldr	r2, [r0, #12]
     53a:	600a      	str	r2, [r1, #0]
     53c:	3104      	adds	r1, #4
     53e:	c1f0      	stmia	r1!, {r4, r5, r6, r7}
     540:	4647      	mov	r7, r8
     542:	600f      	str	r7, [r1, #0]
     544:	3104      	adds	r1, #4
     546:	464f      	mov	r7, r9
     548:	600f      	str	r7, [r1, #0]
     54a:	3104      	adds	r1, #4
     54c:	4657      	mov	r7, sl
     54e:	600f      	str	r7, [r1, #0]
     550:	3104      	adds	r1, #4
     552:	465f      	mov	r7, fp
     554:	600f      	str	r7, [r1, #0]
     556:	3104      	adds	r1, #4
     558:	6902      	ldr	r2, [r0, #16]
     55a:	600a      	str	r2, [r1, #0]
     55c:	3108      	adds	r1, #8
     55e:	6942      	ldr	r2, [r0, #20]
     560:	600a      	str	r2, [r1, #0]
     562:	3104      	adds	r1, #4
     564:	6982      	ldr	r2, [r0, #24]
     566:	600a      	str	r2, [r1, #0]
     568:	3104      	adds	r1, #4
     56a:	69c2      	ldr	r2, [r0, #28]
     56c:	600a      	str	r2, [r1, #0]
     56e:	3104      	adds	r1, #4
     570:	4603      	mov	r3, r0
     572:	3320      	adds	r3, #32
     574:	f44f 7600 	mov.w	r6, #512	; 0x200
     578:	4232      	tst	r2, r6
     57a:	d000      	beq.n	57e <Fault_Handler_Continue1>
     57c:	3304      	adds	r3, #4

0000057e <Fault_Handler_Continue1>:
     57e:	4675      	mov	r5, lr
     580:	f04f 0610 	mov.w	r6, #16
     584:	4235      	tst	r5, r6
     586:	d100      	bne.n	58a <Fault_Handler_Continue2>
     588:	3348      	adds	r3, #72	; 0x48

0000058a <Fault_Handler_Continue2>:
     58a:	460c      	mov	r4, r1
     58c:	3c10      	subs	r4, #16
     58e:	6023      	str	r3, [r4, #0]
     590:	f3ef 8209 	mrs	r2, PSP
     594:	600a      	str	r2, [r1, #0]
     596:	3104      	adds	r1, #4
     598:	f3ef 8208 	mrs	r2, MSP
     59c:	600a      	str	r2, [r1, #0]
     59e:	3104      	adds	r1, #4
     5a0:	4672      	mov	r2, lr
     5a2:	600a      	str	r2, [r1, #0]
     5a4:	3104      	adds	r1, #4
     5a6:	f3ef 8214 	mrs	r2, CONTROL
     5aa:	600a      	str	r2, [r1, #0]
     5ac:	4b03      	ldr	r3, [pc, #12]	; (5bc <Fault_Handler_Continue2+0x32>)
     5ae:	4660      	mov	r0, ip
     5b0:	4901      	ldr	r1, [pc, #4]	; (5b8 <Fault_Handler_Continue2+0x2e>)
     5b2:	4a03      	ldr	r2, [pc, #12]	; (5c0 <Fault_Handler_Continue2+0x36>)
     5b4:	4798      	blx	r3
     5b6:	e7fe      	b.n	5b6 <Fault_Handler_Continue2+0x2c>
     5b8:	20001e00 	.word	0x20001e00
     5bc:	00003eed 	.word	0x00003eed
     5c0:	20000110 	.word	0x20000110

000005c4 <SVC_Handler>:
     5c4:	f01e 0f04 	tst.w	lr, #4
     5c8:	bf0c      	ite	eq
     5ca:	f3ef 8008 	mrseq	r0, MSP
     5ce:	f3ef 8009 	mrsne	r0, PSP
     5d2:	6981      	ldr	r1, [r0, #24]
     5d4:	f811 1c02 	ldrb.w	r1, [r1, #-2]
     5d8:	bbb9      	cbnz	r1, 64a <SVC_User>
     5da:	b501      	push	{r0, lr}
     5dc:	e890 100f 	ldmia.w	r0, {r0, r1, r2, r3, ip}
     5e0:	47e0      	blx	ip
     5e2:	e8bd 5000 	ldmia.w	sp!, {ip, lr}
     5e6:	e88c 0003 	stmia.w	ip, {r0, r1}

000005ea <SVC_Context>:
     5ea:	4b27      	ldr	r3, [pc, #156]	; (688 <SysTick_Handler+0x12>)
     5ec:	e893 0006 	ldmia.w	r3, {r1, r2}
     5f0:	4291      	cmp	r1, r2
     5f2:	bf08      	it	eq
     5f4:	4770      	bxeq	lr
     5f6:	b941      	cbnz	r1, 60a <SVC_ContextSave>
     5f8:	f01e 0f10 	tst.w	lr, #16
     5fc:	d110      	bne.n	620 <SVC_ContextSwitch>
     5fe:	4923      	ldr	r1, [pc, #140]	; (68c <SysTick_Handler+0x16>)
     600:	6808      	ldr	r0, [r1, #0]
     602:	f020 0001 	bic.w	r0, r0, #1
     606:	6008      	str	r0, [r1, #0]
     608:	e00a      	b.n	620 <SVC_ContextSwitch>

0000060a <SVC_ContextSave>:
     60a:	e92c 0ff0 	stmdb	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
     60e:	f01e 0f10 	tst.w	lr, #16
     612:	bf08      	it	eq
     614:	ed2c 8a10 	vstmdbeq	ip!, {s16-s31}
     618:	f8c1 c038 	str.w	ip, [r1, #56]	; 0x38
     61c:	f881 e022 	strb.w	lr, [r1, #34]	; 0x22

00000620 <SVC_ContextSwitch>:
        /* The call to thread_switch_helper can clobber R2 and R3, but we don't
         * want to clobber R2 or R3. We can't save R2 and R3 to the stack (as
         * the stack we save them onto is likely to be inaccessible after the
         * call to thread_switch_helper). So, we just re-obtain the values from
         * osRtxInfo again. */
        BL       thread_switch_helper
     620:	f006 fd1a 	bl	7058 <thread_switch_helper>
        LDR      R3,=osRtxInfo+I_T_RUN_OFS // Load address of osRtxInfo.run
     624:	4b18      	ldr	r3, [pc, #96]	; (688 <SysTick_Handler+0x12>)
        LDM      R3,{R1,R2}             // Load osRtxInfo.thread.run: curr & next
     626:	e893 0006 	ldmia.w	r3, {r1, r2}

        STR      R2,[R3]                // osRtxInfo.thread.run: curr = next
     62a:	601a      	str	r2, [r3, #0]

0000062c <SVC_ContextRestore>:

SVC_ContextRestore:
        LDRB     R1,[R2,#TCB_SF_OFS]    // Load stack frame information
     62c:	f892 1022 	ldrb.w	r1, [r2, #34]	; 0x22
        LDR      R0,[R2,#TCB_SP_OFS]    // Load SP
     630:	6b90      	ldr	r0, [r2, #56]	; 0x38
        ORR      LR,R1,#0xFFFFFF00      // Set EXC_RETURN
     632:	f061 0eff 	orn	lr, r1, #255	; 0xff

#ifdef __FPU_PRESENT
        TST      LR,#0x10               // Check if extended stack frame
     636:	f01e 0f10 	tst.w	lr, #16
        IT       EQ
     63a:	bf08      	it	eq
        VLDMIAEQ R0!,{S16-S31}          //  Restore VFP S16..S31
     63c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
#endif
        LDMIA    R0!,{R4-R11}           // Restore R4..R11
     640:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
        MSR      PSP,R0                 // Set PSP
     644:	f380 8809 	msr	PSP, r0

00000648 <SVC_Exit>:
#ifdef FEATURE_UVISOR
        CPSIE I                         // The PSP has been set. Re-enable interrupts.
#endif

SVC_Exit:
        BX       LR                     // Exit from handler
     648:	4770      	bx	lr

0000064a <SVC_User>:

SVC_User:
        LDR      R2,=osRtxUserSVC       // Load address of SVC table
     64a:	4a11      	ldr	r2, [pc, #68]	; (690 <SysTick_Handler+0x1a>)
        LDR      R3,[R2]                // Load SVC maximum number
     64c:	6813      	ldr	r3, [r2, #0]
        CMP      R1,R3                  // Check SVC number range
     64e:	4299      	cmp	r1, r3
        BHI      SVC_Exit               // Branch if out of range
     650:	d8fa      	bhi.n	648 <SVC_Exit>

        PUSH     {R0,LR}                // Save SP and EXC_RETURN
     652:	b501      	push	{r0, lr}
        LDR      R12,[R2,R1,LSL #2]     // Load address of SVC function
     654:	f852 c021 	ldr.w	ip, [r2, r1, lsl #2]
        LDM      R0,{R0-R3}             // Load function parameters from stack
     658:	c80f      	ldmia	r0, {r0, r1, r2, r3}
        BLX      R12                    // Call service function
     65a:	47e0      	blx	ip
        POP      {R12,LR}               // Restore SP and EXC_RETURN
     65c:	e8bd 5000 	ldmia.w	sp!, {ip, lr}
        STR      R0,[R12]               // Store function return value
     660:	f8cc 0000 	str.w	r0, [ip]

        BX       LR                     // Return from handler
     664:	4770      	bx	lr

00000666 <PendSV_Handler>:
        .global  PendSV_Handler
        .fnstart
        .cantunwind
PendSV_Handler:

        PUSH     {R0,LR}                // Save EXC_RETURN
     666:	b501      	push	{r0, lr}
        BL       osRtxPendSV_Handler    // Call osRtxPendSV_Handler
     668:	f006 f930 	bl	68cc <osRtxPendSV_Handler>
        POP      {R0,LR}                // Restore EXC_RETURN
     66c:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
        MRS      R12,PSP
     670:	f3ef 8c09 	mrs	ip, PSP
        B        SVC_Context
     674:	e7b9      	b.n	5ea <SVC_Context>

00000676 <SysTick_Handler>:
        .global  SysTick_Handler
        .fnstart
        .cantunwind
SysTick_Handler:

        PUSH     {R0,LR}                // Save EXC_RETURN
     676:	b501      	push	{r0, lr}
        BL       osRtxTick_Handler      // Call osRtxTick_Handler
     678:	f006 f8c2 	bl	6800 <osRtxTick_Handler>
        POP      {R0,LR}                // Restore EXC_RETURN
     67c:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
        MRS      R12,PSP
     680:	f3ef 8c09 	mrs	ip, PSP
        B        SVC_Context
     684:	e7b1      	b.n	5ea <SVC_Context>
     686:	0000      	.short	0x0000
     688:	20000124 	.word	0x20000124
     68c:	e000ef34 	.word	0xe000ef34
        LDR      R2,=osRtxUserSVC       // Load address of SVC table
     690:	0001262c 	.word	0x0001262c

00000694 <Reset_Handler>:
    .align 2
    .globl   Reset_Handler
    .weak    Reset_Handler
    .type    Reset_Handler, %function
Reset_Handler:
    cpsid   i               /* Mask interrupts */
     694:	b672      	cpsid	i
    .equ    VTOR, 0xE000ED08
    ldr     r0, =VTOR
     696:	4809      	ldr	r0, [pc, #36]	; (6bc <Reset_Handler+0x28>)
    ldr     r1, =__isr_vector
     698:	4909      	ldr	r1, [pc, #36]	; (6c0 <Reset_Handler+0x2c>)
    str     r1, [r0]
     69a:	6001      	str	r1, [r0, #0]
#ifndef __NO_SYSTEM_INIT
    ldr   r0,=SystemInit
     69c:	4809      	ldr	r0, [pc, #36]	; (6c4 <Reset_Handler+0x30>)
    blx   r0
     69e:	4780      	blx	r0
 *      linker script.
 *      __etext: End of code section, i.e., begin of data sections to copy from.
 *      __data_start__/__data_end__: RAM address range that data should be
 *      copied to. Both must be aligned to 4 bytes boundary.  */

    ldr    r1, =__etext
     6a0:	4909      	ldr	r1, [pc, #36]	; (6c8 <Reset_Handler+0x34>)
    ldr    r2, =__data_start__
     6a2:	4a0a      	ldr	r2, [pc, #40]	; (6cc <Reset_Handler+0x38>)
    ldr    r3, =__data_end__
     6a4:	4b0a      	ldr	r3, [pc, #40]	; (6d0 <Reset_Handler+0x3c>)
#if 1
/* Here are two copies of loop implemenations. First one favors code size
 * and the second one favors performance. Default uses the first one.
 * Change to "#if 0" to use the second one */
.LC0:
    cmp     r2, r3
     6a6:	429a      	cmp	r2, r3
    ittt    lt
     6a8:	bfbe      	ittt	lt
    ldrlt   r0, [r1], #4
     6aa:	f851 0b04 	ldrlt.w	r0, [r1], #4
    strlt   r0, [r2], #4
     6ae:	f842 0b04 	strlt.w	r0, [r2], #4
    blt    .LC0
     6b2:	e7f8      	blt.n	6a6 <Reset_Handler+0x12>
    itt    lt
    strlt   r0, [r1], #4
    blt    .LC2
#endif /* __STARTUP_CLEAR_BSS */

    cpsie   i               /* Unmask interrupts */
     6b4:	b662      	cpsie	i
#ifndef __START
#define __START _start
#endif
#ifndef __ATOLLIC__
    ldr   r0,=__START
     6b6:	4807      	ldr	r0, [pc, #28]	; (6d4 <Reset_Handler+0x40>)
    blx   r0
     6b8:	4780      	blx	r0
     6ba:	0000      	.short	0x0000
    ldr     r0, =VTOR
     6bc:	e000ed08 	.word	0xe000ed08
    ldr     r1, =__isr_vector
     6c0:	00000000 	.word	0x00000000
    ldr   r0,=SystemInit
     6c4:	00007fc9 	.word	0x00007fc9
    ldr    r1, =__etext
     6c8:	00012d14 	.word	0x00012d14
    ldr    r2, =__data_start__
     6cc:	20000000 	.word	0x20000000
    ldr    r3, =__data_end__
     6d0:	20000b70 	.word	0x20000b70
    ldr   r0,=__START
     6d4:	0000047d 	.word	0x0000047d

000006d8 <ADC0_IRQHandler>:
    .align  1
    .thumb_func
    .weak DefaultISR
    .type DefaultISR, %function
DefaultISR:
    b DefaultISR
     6d8:	f7ff bffe 	b.w	6d8 <ADC0_IRQHandler>
    .align 1
    .thumb_func
    .weak NMI_Handler
    .type NMI_Handler, %function
NMI_Handler:
    ldr   r0,=NMI_Handler
     6dc:	4835      	ldr	r0, [pc, #212]	; (7b4 <ENET_1588_Timer_IRQHandler+0x10>)
    bx    r0
     6de:	4700      	bx	r0
    .align 1
    .thumb_func
    .weak HardFault_Handler
    .type HardFault_Handler, %function
HardFault_Handler:
    ldr   r0,=HardFault_Handler
     6e0:	4835      	ldr	r0, [pc, #212]	; (7b8 <ENET_1588_Timer_IRQHandler+0x14>)
    bx    r0
     6e2:	4700      	bx	r0
    .align 1
    .thumb_func
    .weak SVC_Handler
    .type SVC_Handler, %function
SVC_Handler:
    ldr   r0,=SVC_Handler
     6e4:	4835      	ldr	r0, [pc, #212]	; (7bc <ENET_1588_Timer_IRQHandler+0x18>)
    bx    r0
     6e6:	4700      	bx	r0
    .align 1
    .thumb_func
    .weak PendSV_Handler
    .type PendSV_Handler, %function
PendSV_Handler:
    ldr   r0,=PendSV_Handler
     6e8:	4835      	ldr	r0, [pc, #212]	; (7c0 <ENET_1588_Timer_IRQHandler+0x1c>)
    bx    r0
     6ea:	4700      	bx	r0
    .align 1
    .thumb_func
    .weak SysTick_Handler
    .type SysTick_Handler, %function
SysTick_Handler:
    ldr   r0,=SysTick_Handler
     6ec:	4835      	ldr	r0, [pc, #212]	; (7c4 <ENET_1588_Timer_IRQHandler+0x20>)
    bx    r0
     6ee:	4700      	bx	r0

000006f0 <DMA0_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA0_IRQHandler
    .type DMA0_IRQHandler, %function
DMA0_IRQHandler:
    ldr   r0,=DMA0_DriverIRQHandler
     6f0:	4835      	ldr	r0, [pc, #212]	; (7c8 <ENET_1588_Timer_IRQHandler+0x24>)
    bx    r0
     6f2:	4700      	bx	r0

000006f4 <DMA1_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA1_IRQHandler
    .type DMA1_IRQHandler, %function
DMA1_IRQHandler:
    ldr   r0,=DMA1_DriverIRQHandler
     6f4:	4835      	ldr	r0, [pc, #212]	; (7cc <ENET_1588_Timer_IRQHandler+0x28>)
    bx    r0
     6f6:	4700      	bx	r0

000006f8 <DMA2_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA2_IRQHandler
    .type DMA2_IRQHandler, %function
DMA2_IRQHandler:
    ldr   r0,=DMA2_DriverIRQHandler
     6f8:	4835      	ldr	r0, [pc, #212]	; (7d0 <ENET_1588_Timer_IRQHandler+0x2c>)
    bx    r0
     6fa:	4700      	bx	r0

000006fc <DMA3_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA3_IRQHandler
    .type DMA3_IRQHandler, %function
DMA3_IRQHandler:
    ldr   r0,=DMA3_DriverIRQHandler
     6fc:	4835      	ldr	r0, [pc, #212]	; (7d4 <ENET_1588_Timer_IRQHandler+0x30>)
    bx    r0
     6fe:	4700      	bx	r0

00000700 <DMA4_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA4_IRQHandler
    .type DMA4_IRQHandler, %function
DMA4_IRQHandler:
    ldr   r0,=DMA4_DriverIRQHandler
     700:	4835      	ldr	r0, [pc, #212]	; (7d8 <ENET_1588_Timer_IRQHandler+0x34>)
    bx    r0
     702:	4700      	bx	r0

00000704 <DMA5_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA5_IRQHandler
    .type DMA5_IRQHandler, %function
DMA5_IRQHandler:
    ldr   r0,=DMA5_DriverIRQHandler
     704:	4835      	ldr	r0, [pc, #212]	; (7dc <ENET_1588_Timer_IRQHandler+0x38>)
    bx    r0
     706:	4700      	bx	r0

00000708 <DMA6_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA6_IRQHandler
    .type DMA6_IRQHandler, %function
DMA6_IRQHandler:
    ldr   r0,=DMA6_DriverIRQHandler
     708:	4835      	ldr	r0, [pc, #212]	; (7e0 <ENET_1588_Timer_IRQHandler+0x3c>)
    bx    r0
     70a:	4700      	bx	r0

0000070c <DMA7_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA7_IRQHandler
    .type DMA7_IRQHandler, %function
DMA7_IRQHandler:
    ldr   r0,=DMA7_DriverIRQHandler
     70c:	4835      	ldr	r0, [pc, #212]	; (7e4 <ENET_1588_Timer_IRQHandler+0x40>)
    bx    r0
     70e:	4700      	bx	r0

00000710 <DMA8_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA8_IRQHandler
    .type DMA8_IRQHandler, %function
DMA8_IRQHandler:
    ldr   r0,=DMA8_DriverIRQHandler
     710:	4835      	ldr	r0, [pc, #212]	; (7e8 <ENET_1588_Timer_IRQHandler+0x44>)
    bx    r0
     712:	4700      	bx	r0

00000714 <DMA9_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA9_IRQHandler
    .type DMA9_IRQHandler, %function
DMA9_IRQHandler:
    ldr   r0,=DMA9_DriverIRQHandler
     714:	4835      	ldr	r0, [pc, #212]	; (7ec <ENET_1588_Timer_IRQHandler+0x48>)
    bx    r0
     716:	4700      	bx	r0

00000718 <DMA10_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA10_IRQHandler
    .type DMA10_IRQHandler, %function
DMA10_IRQHandler:
    ldr   r0,=DMA10_DriverIRQHandler
     718:	4835      	ldr	r0, [pc, #212]	; (7f0 <ENET_1588_Timer_IRQHandler+0x4c>)
    bx    r0
     71a:	4700      	bx	r0

0000071c <DMA11_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA11_IRQHandler
    .type DMA11_IRQHandler, %function
DMA11_IRQHandler:
    ldr   r0,=DMA11_DriverIRQHandler
     71c:	4835      	ldr	r0, [pc, #212]	; (7f4 <ENET_1588_Timer_IRQHandler+0x50>)
    bx    r0
     71e:	4700      	bx	r0

00000720 <DMA12_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA12_IRQHandler
    .type DMA12_IRQHandler, %function
DMA12_IRQHandler:
    ldr   r0,=DMA12_DriverIRQHandler
     720:	4835      	ldr	r0, [pc, #212]	; (7f8 <ENET_1588_Timer_IRQHandler+0x54>)
    bx    r0
     722:	4700      	bx	r0

00000724 <DMA13_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA13_IRQHandler
    .type DMA13_IRQHandler, %function
DMA13_IRQHandler:
    ldr   r0,=DMA13_DriverIRQHandler
     724:	4835      	ldr	r0, [pc, #212]	; (7fc <ENET_1588_Timer_IRQHandler+0x58>)
    bx    r0
     726:	4700      	bx	r0

00000728 <DMA14_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA14_IRQHandler
    .type DMA14_IRQHandler, %function
DMA14_IRQHandler:
    ldr   r0,=DMA14_DriverIRQHandler
     728:	4835      	ldr	r0, [pc, #212]	; (800 <USB_RAM_GAP>)
    bx    r0
     72a:	4700      	bx	r0

0000072c <DMA15_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA15_IRQHandler
    .type DMA15_IRQHandler, %function
DMA15_IRQHandler:
    ldr   r0,=DMA15_DriverIRQHandler
     72c:	4835      	ldr	r0, [pc, #212]	; (804 <USB_RAM_GAP+0x4>)
    bx    r0
     72e:	4700      	bx	r0

00000730 <DMA_Error_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA_Error_IRQHandler
    .type DMA_Error_IRQHandler, %function
DMA_Error_IRQHandler:
    ldr   r0,=DMA_Error_DriverIRQHandler
     730:	4835      	ldr	r0, [pc, #212]	; (808 <USB_RAM_GAP+0x8>)
    bx    r0
     732:	4700      	bx	r0

00000734 <I2C0_IRQHandler>:
    .align 1
    .thumb_func
    .weak I2C0_IRQHandler
    .type I2C0_IRQHandler, %function
I2C0_IRQHandler:
    ldr   r0,=I2C0_DriverIRQHandler
     734:	4835      	ldr	r0, [pc, #212]	; (80c <USB_RAM_GAP+0xc>)
    bx    r0
     736:	4700      	bx	r0

00000738 <I2C1_IRQHandler>:
    .align 1
    .thumb_func
    .weak I2C1_IRQHandler
    .type I2C1_IRQHandler, %function
I2C1_IRQHandler:
    ldr   r0,=I2C1_DriverIRQHandler
     738:	4835      	ldr	r0, [pc, #212]	; (810 <USB_RAM_GAP+0x10>)
    bx    r0
     73a:	4700      	bx	r0

0000073c <SPI0_IRQHandler>:
    .align 1
    .thumb_func
    .weak SPI0_IRQHandler
    .type SPI0_IRQHandler, %function
SPI0_IRQHandler:
    ldr   r0,=SPI0_DriverIRQHandler
     73c:	4835      	ldr	r0, [pc, #212]	; (814 <USB_RAM_GAP+0x14>)
    bx    r0
     73e:	4700      	bx	r0

00000740 <SPI1_IRQHandler>:
    .align 1
    .thumb_func
    .weak SPI1_IRQHandler
    .type SPI1_IRQHandler, %function
SPI1_IRQHandler:
    ldr   r0,=SPI1_DriverIRQHandler
     740:	4835      	ldr	r0, [pc, #212]	; (818 <USB_RAM_GAP+0x18>)
    bx    r0
     742:	4700      	bx	r0

00000744 <I2S0_Tx_IRQHandler>:
    .align 1
    .thumb_func
    .weak I2S0_Tx_IRQHandler
    .type I2S0_Tx_IRQHandler, %function
I2S0_Tx_IRQHandler:
    ldr   r0,=I2S0_Tx_DriverIRQHandler
     744:	4835      	ldr	r0, [pc, #212]	; (81c <USB_RAM_GAP+0x1c>)
    bx    r0
     746:	4700      	bx	r0

00000748 <I2S0_Rx_IRQHandler>:
    .align 1
    .thumb_func
    .weak I2S0_Rx_IRQHandler
    .type I2S0_Rx_IRQHandler, %function
I2S0_Rx_IRQHandler:
    ldr   r0,=I2S0_Rx_DriverIRQHandler
     748:	4835      	ldr	r0, [pc, #212]	; (820 <USB_RAM_GAP+0x20>)
    bx    r0
     74a:	4700      	bx	r0

0000074c <UART0_LON_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART0_LON_IRQHandler
    .type UART0_LON_IRQHandler, %function
UART0_LON_IRQHandler:
    ldr   r0,=UART0_LON_DriverIRQHandler
     74c:	4835      	ldr	r0, [pc, #212]	; (824 <USB_RAM_GAP+0x24>)
    bx    r0
     74e:	4700      	bx	r0

00000750 <UART0_RX_TX_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART0_RX_TX_IRQHandler
    .type UART0_RX_TX_IRQHandler, %function
UART0_RX_TX_IRQHandler:
    ldr   r0,=UART0_RX_TX_DriverIRQHandler
     750:	4835      	ldr	r0, [pc, #212]	; (828 <USB_RAM_GAP+0x28>)
    bx    r0
     752:	4700      	bx	r0

00000754 <UART0_ERR_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART0_ERR_IRQHandler
    .type UART0_ERR_IRQHandler, %function
UART0_ERR_IRQHandler:
    ldr   r0,=UART0_ERR_DriverIRQHandler
     754:	4835      	ldr	r0, [pc, #212]	; (82c <USB_RAM_GAP+0x2c>)
    bx    r0
     756:	4700      	bx	r0

00000758 <UART1_RX_TX_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART1_RX_TX_IRQHandler
    .type UART1_RX_TX_IRQHandler, %function
UART1_RX_TX_IRQHandler:
    ldr   r0,=UART1_RX_TX_DriverIRQHandler
     758:	4835      	ldr	r0, [pc, #212]	; (830 <USB_RAM_GAP+0x30>)
    bx    r0
     75a:	4700      	bx	r0

0000075c <UART1_ERR_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART1_ERR_IRQHandler
    .type UART1_ERR_IRQHandler, %function
UART1_ERR_IRQHandler:
    ldr   r0,=UART1_ERR_DriverIRQHandler
     75c:	4835      	ldr	r0, [pc, #212]	; (834 <USB_RAM_GAP+0x34>)
    bx    r0
     75e:	4700      	bx	r0

00000760 <UART2_RX_TX_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART2_RX_TX_IRQHandler
    .type UART2_RX_TX_IRQHandler, %function
UART2_RX_TX_IRQHandler:
    ldr   r0,=UART2_RX_TX_DriverIRQHandler
     760:	4835      	ldr	r0, [pc, #212]	; (838 <USB_RAM_GAP+0x38>)
    bx    r0
     762:	4700      	bx	r0

00000764 <UART2_ERR_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART2_ERR_IRQHandler
    .type UART2_ERR_IRQHandler, %function
UART2_ERR_IRQHandler:
    ldr   r0,=UART2_ERR_DriverIRQHandler
     764:	4835      	ldr	r0, [pc, #212]	; (83c <USB_RAM_GAP+0x3c>)
    bx    r0
     766:	4700      	bx	r0

00000768 <UART3_RX_TX_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART3_RX_TX_IRQHandler
    .type UART3_RX_TX_IRQHandler, %function
UART3_RX_TX_IRQHandler:
    ldr   r0,=UART3_RX_TX_DriverIRQHandler
     768:	4835      	ldr	r0, [pc, #212]	; (840 <USB_RAM_GAP+0x40>)
    bx    r0
     76a:	4700      	bx	r0

0000076c <UART3_ERR_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART3_ERR_IRQHandler
    .type UART3_ERR_IRQHandler, %function
UART3_ERR_IRQHandler:
    ldr   r0,=UART3_ERR_DriverIRQHandler
     76c:	4835      	ldr	r0, [pc, #212]	; (844 <USB_RAM_GAP+0x44>)
    bx    r0
     76e:	4700      	bx	r0

00000770 <SPI2_IRQHandler>:
    .align 1
    .thumb_func
    .weak SPI2_IRQHandler
    .type SPI2_IRQHandler, %function
SPI2_IRQHandler:
    ldr   r0,=SPI2_DriverIRQHandler
     770:	4835      	ldr	r0, [pc, #212]	; (848 <USB_RAM_GAP+0x48>)
    bx    r0
     772:	4700      	bx	r0

00000774 <UART4_RX_TX_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART4_RX_TX_IRQHandler
    .type UART4_RX_TX_IRQHandler, %function
UART4_RX_TX_IRQHandler:
    ldr   r0,=UART4_RX_TX_DriverIRQHandler
     774:	4835      	ldr	r0, [pc, #212]	; (84c <USB_RAM_GAP+0x4c>)
    bx    r0
     776:	4700      	bx	r0

00000778 <UART4_ERR_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART4_ERR_IRQHandler
    .type UART4_ERR_IRQHandler, %function
UART4_ERR_IRQHandler:
    ldr   r0,=UART4_ERR_DriverIRQHandler
     778:	4835      	ldr	r0, [pc, #212]	; (850 <USB_RAM_GAP+0x50>)
    bx    r0
     77a:	4700      	bx	r0

0000077c <UART5_RX_TX_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART5_RX_TX_IRQHandler
    .type UART5_RX_TX_IRQHandler, %function
UART5_RX_TX_IRQHandler:
    ldr   r0,=UART5_RX_TX_DriverIRQHandler
     77c:	4835      	ldr	r0, [pc, #212]	; (854 <USB_RAM_GAP+0x54>)
    bx    r0
     77e:	4700      	bx	r0

00000780 <UART5_ERR_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART5_ERR_IRQHandler
    .type UART5_ERR_IRQHandler, %function
UART5_ERR_IRQHandler:
    ldr   r0,=UART5_ERR_DriverIRQHandler
     780:	4835      	ldr	r0, [pc, #212]	; (858 <USB_RAM_GAP+0x58>)
    bx    r0
     782:	4700      	bx	r0

00000784 <I2C2_IRQHandler>:
    .align 1
    .thumb_func
    .weak I2C2_IRQHandler
    .type I2C2_IRQHandler, %function
I2C2_IRQHandler:
    ldr   r0,=I2C2_DriverIRQHandler
     784:	4835      	ldr	r0, [pc, #212]	; (85c <USB_RAM_GAP+0x5c>)
    bx    r0
     786:	4700      	bx	r0

00000788 <CAN0_ORed_Message_buffer_IRQHandler>:
    .align 1
    .thumb_func
    .weak CAN0_ORed_Message_buffer_IRQHandler
    .type CAN0_ORed_Message_buffer_IRQHandler, %function
CAN0_ORed_Message_buffer_IRQHandler:
    ldr   r0,=CAN0_DriverIRQHandler
     788:	4835      	ldr	r0, [pc, #212]	; (860 <USB_RAM_GAP+0x60>)
    bx    r0
     78a:	4700      	bx	r0

0000078c <CAN0_Bus_Off_IRQHandler>:
    .align 1
    .thumb_func
    .weak CAN0_Bus_Off_IRQHandler
    .type CAN0_Bus_Off_IRQHandler, %function
CAN0_Bus_Off_IRQHandler:
    ldr   r0,=CAN0_DriverIRQHandler
     78c:	4834      	ldr	r0, [pc, #208]	; (860 <USB_RAM_GAP+0x60>)
    bx    r0
     78e:	4700      	bx	r0

00000790 <CAN0_Error_IRQHandler>:
    .align 1
    .thumb_func
    .weak CAN0_Error_IRQHandler
    .type CAN0_Error_IRQHandler, %function
CAN0_Error_IRQHandler:
    ldr   r0,=CAN0_DriverIRQHandler
     790:	4833      	ldr	r0, [pc, #204]	; (860 <USB_RAM_GAP+0x60>)
    bx    r0
     792:	4700      	bx	r0

00000794 <CAN0_Tx_Warning_IRQHandler>:
    .align 1
    .thumb_func
    .weak CAN0_Tx_Warning_IRQHandler
    .type CAN0_Tx_Warning_IRQHandler, %function
CAN0_Tx_Warning_IRQHandler:
    ldr   r0,=CAN0_DriverIRQHandler
     794:	4832      	ldr	r0, [pc, #200]	; (860 <USB_RAM_GAP+0x60>)
    bx    r0
     796:	4700      	bx	r0

00000798 <CAN0_Rx_Warning_IRQHandler>:
    .align 1
    .thumb_func
    .weak CAN0_Rx_Warning_IRQHandler
    .type CAN0_Rx_Warning_IRQHandler, %function
CAN0_Rx_Warning_IRQHandler:
    ldr   r0,=CAN0_DriverIRQHandler
     798:	4831      	ldr	r0, [pc, #196]	; (860 <USB_RAM_GAP+0x60>)
    bx    r0
     79a:	4700      	bx	r0

0000079c <CAN0_Wake_Up_IRQHandler>:
    .align 1
    .thumb_func
    .weak CAN0_Wake_Up_IRQHandler
    .type CAN0_Wake_Up_IRQHandler, %function
CAN0_Wake_Up_IRQHandler:
    ldr   r0,=CAN0_DriverIRQHandler
     79c:	4830      	ldr	r0, [pc, #192]	; (860 <USB_RAM_GAP+0x60>)
    bx    r0
     79e:	4700      	bx	r0

000007a0 <SDHC_IRQHandler>:
    .align 1
    .thumb_func
    .weak SDHC_IRQHandler
    .type SDHC_IRQHandler, %function
SDHC_IRQHandler:
    ldr   r0,=SDHC_DriverIRQHandler
     7a0:	4830      	ldr	r0, [pc, #192]	; (864 <USB_RAM_GAP+0x64>)
    bx    r0
     7a2:	4700      	bx	r0

000007a4 <ENET_1588_Timer_IRQHandler>:
    .align 1
    .thumb_func
    .weak ENET_1588_Timer_IRQHandler
    .type ENET_1588_Timer_IRQHandler, %function
ENET_1588_Timer_IRQHandler:
    ldr   r0,=ENET_1588_Timer_DriverIRQHandler
     7a4:	4830      	ldr	r0, [pc, #192]	; (868 <USB_RAM_GAP+0x68>)
    bx    r0
     7a6:	4700      	bx	r0
    .align 1
    .thumb_func
    .weak ENET_Transmit_IRQHandler
    .type ENET_Transmit_IRQHandler, %function
ENET_Transmit_IRQHandler:
    ldr   r0,=ENET_Transmit_DriverIRQHandler
     7a8:	4830      	ldr	r0, [pc, #192]	; (86c <USB_RAM_GAP+0x6c>)
    bx    r0
     7aa:	4700      	bx	r0
    .align 1
    .thumb_func
    .weak ENET_Receive_IRQHandler
    .type ENET_Receive_IRQHandler, %function
ENET_Receive_IRQHandler:
    ldr   r0,=ENET_Receive_DriverIRQHandler
     7ac:	4830      	ldr	r0, [pc, #192]	; (870 <USB_RAM_GAP+0x70>)
    bx    r0
     7ae:	4700      	bx	r0
    .align 1
    .thumb_func
    .weak ENET_Error_IRQHandler
    .type ENET_Error_IRQHandler, %function
ENET_Error_IRQHandler:
    ldr   r0,=ENET_Error_DriverIRQHandler
     7b0:	4830      	ldr	r0, [pc, #192]	; (874 <USB_RAM_GAP+0x74>)
    bx    r0
     7b2:	4700      	bx	r0
    ldr   r0,=NMI_Handler
     7b4:	00007fb3 	.word	0x00007fb3
    ldr   r0,=HardFault_Handler
     7b8:	000004f1 	.word	0x000004f1
    ldr   r0,=SVC_Handler
     7bc:	000005c5 	.word	0x000005c5
    ldr   r0,=PendSV_Handler
     7c0:	00000667 	.word	0x00000667
    ldr   r0,=SysTick_Handler
     7c4:	00000677 	.word	0x00000677
    ldr   r0,=DMA0_DriverIRQHandler
     7c8:	00008d8d 	.word	0x00008d8d
    ldr   r0,=DMA1_DriverIRQHandler
     7cc:	00008da1 	.word	0x00008da1
    ldr   r0,=DMA2_DriverIRQHandler
     7d0:	00008db5 	.word	0x00008db5
    ldr   r0,=DMA3_DriverIRQHandler
     7d4:	00008dc9 	.word	0x00008dc9
    ldr   r0,=DMA4_DriverIRQHandler
     7d8:	00008ddd 	.word	0x00008ddd
    ldr   r0,=DMA5_DriverIRQHandler
     7dc:	00008df1 	.word	0x00008df1
    ldr   r0,=DMA6_DriverIRQHandler
     7e0:	00008e05 	.word	0x00008e05
    ldr   r0,=DMA7_DriverIRQHandler
     7e4:	00008e19 	.word	0x00008e19
    ldr   r0,=DMA8_DriverIRQHandler
     7e8:	00008e2d 	.word	0x00008e2d
    ldr   r0,=DMA9_DriverIRQHandler
     7ec:	00008e41 	.word	0x00008e41
    ldr   r0,=DMA10_DriverIRQHandler
     7f0:	00008e55 	.word	0x00008e55
    ldr   r0,=DMA11_DriverIRQHandler
     7f4:	00008e69 	.word	0x00008e69
    ldr   r0,=DMA12_DriverIRQHandler
     7f8:	00008e7d 	.word	0x00008e7d
    ldr   r0,=DMA13_DriverIRQHandler
     7fc:	00008e91 	.word	0x00008e91
    ldr   r0,=DMA14_DriverIRQHandler
     800:	00008ea5 	.word	0x00008ea5
    ldr   r0,=DMA15_DriverIRQHandler
     804:	00008eb9 	.word	0x00008eb9
    ldr   r0,=DMA_Error_DriverIRQHandler
     808:	000006d9 	.word	0x000006d9
    ldr   r0,=I2C0_DriverIRQHandler
     80c:	00008fc1 	.word	0x00008fc1
    ldr   r0,=I2C1_DriverIRQHandler
     810:	00008fdd 	.word	0x00008fdd
    ldr   r0,=SPI0_DriverIRQHandler
     814:	00008b79 	.word	0x00008b79
    ldr   r0,=SPI1_DriverIRQHandler
     818:	00008bb5 	.word	0x00008bb5
    ldr   r0,=I2S0_Tx_DriverIRQHandler
     81c:	00009101 	.word	0x00009101
    ldr   r0,=I2S0_Rx_DriverIRQHandler
     820:	00009145 	.word	0x00009145
    ldr   r0,=UART0_LON_DriverIRQHandler
     824:	000006d9 	.word	0x000006d9
    ldr   r0,=UART0_RX_TX_DriverIRQHandler
     828:	000097f9 	.word	0x000097f9
    ldr   r0,=UART0_ERR_DriverIRQHandler
     82c:	000006d9 	.word	0x000006d9
    ldr   r0,=UART1_RX_TX_DriverIRQHandler
     830:	00009825 	.word	0x00009825
    ldr   r0,=UART1_ERR_DriverIRQHandler
     834:	000006d9 	.word	0x000006d9
    ldr   r0,=UART2_RX_TX_DriverIRQHandler
     838:	00009851 	.word	0x00009851
    ldr   r0,=UART2_ERR_DriverIRQHandler
     83c:	000006d9 	.word	0x000006d9
    ldr   r0,=UART3_RX_TX_DriverIRQHandler
     840:	0000987d 	.word	0x0000987d
    ldr   r0,=UART3_ERR_DriverIRQHandler
     844:	000006d9 	.word	0x000006d9
    ldr   r0,=SPI2_DriverIRQHandler
     848:	00008bf1 	.word	0x00008bf1
    ldr   r0,=UART4_RX_TX_DriverIRQHandler
     84c:	000098a9 	.word	0x000098a9
    ldr   r0,=UART4_ERR_DriverIRQHandler
     850:	000006d9 	.word	0x000006d9
    ldr   r0,=UART5_RX_TX_DriverIRQHandler
     854:	000098d5 	.word	0x000098d5
    ldr   r0,=UART5_ERR_DriverIRQHandler
     858:	000006d9 	.word	0x000006d9
    ldr   r0,=I2C2_DriverIRQHandler
     85c:	00008ff9 	.word	0x00008ff9
    ldr   r0,=CAN0_DriverIRQHandler
     860:	00008f2d 	.word	0x00008f2d
    ldr   r0,=SDHC_DriverIRQHandler
     864:	00009189 	.word	0x00009189
    ldr   r0,=ENET_1588_Timer_DriverIRQHandler
     868:	000006d9 	.word	0x000006d9
    ldr   r0,=ENET_Transmit_DriverIRQHandler
     86c:	000006d9 	.word	0x000006d9
    ldr   r0,=ENET_Receive_DriverIRQHandler
     870:	000006d9 	.word	0x000006d9
    ldr   r0,=ENET_Error_DriverIRQHandler
     874:	000006d9 	.word	0x000006d9
	...

00000880 <memchr>:
     880:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     884:	2a10      	cmp	r2, #16
     886:	db2b      	blt.n	8e0 <memchr+0x60>
     888:	f010 0f07 	tst.w	r0, #7
     88c:	d008      	beq.n	8a0 <memchr+0x20>
     88e:	f810 3b01 	ldrb.w	r3, [r0], #1
     892:	3a01      	subs	r2, #1
     894:	428b      	cmp	r3, r1
     896:	d02d      	beq.n	8f4 <memchr+0x74>
     898:	f010 0f07 	tst.w	r0, #7
     89c:	b342      	cbz	r2, 8f0 <memchr+0x70>
     89e:	d1f6      	bne.n	88e <memchr+0xe>
     8a0:	b4f0      	push	{r4, r5, r6, r7}
     8a2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
     8a6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
     8aa:	f022 0407 	bic.w	r4, r2, #7
     8ae:	f07f 0700 	mvns.w	r7, #0
     8b2:	2300      	movs	r3, #0
     8b4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
     8b8:	3c08      	subs	r4, #8
     8ba:	ea85 0501 	eor.w	r5, r5, r1
     8be:	ea86 0601 	eor.w	r6, r6, r1
     8c2:	fa85 f547 	uadd8	r5, r5, r7
     8c6:	faa3 f587 	sel	r5, r3, r7
     8ca:	fa86 f647 	uadd8	r6, r6, r7
     8ce:	faa5 f687 	sel	r6, r5, r7
     8d2:	b98e      	cbnz	r6, 8f8 <memchr+0x78>
     8d4:	d1ee      	bne.n	8b4 <memchr+0x34>
     8d6:	bcf0      	pop	{r4, r5, r6, r7}
     8d8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     8dc:	f002 0207 	and.w	r2, r2, #7
     8e0:	b132      	cbz	r2, 8f0 <memchr+0x70>
     8e2:	f810 3b01 	ldrb.w	r3, [r0], #1
     8e6:	3a01      	subs	r2, #1
     8e8:	ea83 0301 	eor.w	r3, r3, r1
     8ec:	b113      	cbz	r3, 8f4 <memchr+0x74>
     8ee:	d1f8      	bne.n	8e2 <memchr+0x62>
     8f0:	2000      	movs	r0, #0
     8f2:	4770      	bx	lr
     8f4:	3801      	subs	r0, #1
     8f6:	4770      	bx	lr
     8f8:	2d00      	cmp	r5, #0
     8fa:	bf06      	itte	eq
     8fc:	4635      	moveq	r5, r6
     8fe:	3803      	subeq	r0, #3
     900:	3807      	subne	r0, #7
     902:	f015 0f01 	tst.w	r5, #1
     906:	d107      	bne.n	918 <memchr+0x98>
     908:	3001      	adds	r0, #1
     90a:	f415 7f80 	tst.w	r5, #256	; 0x100
     90e:	bf02      	ittt	eq
     910:	3001      	addeq	r0, #1
     912:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
     916:	3001      	addeq	r0, #1
     918:	bcf0      	pop	{r4, r5, r6, r7}
     91a:	3801      	subs	r0, #1
     91c:	4770      	bx	lr
     91e:	bf00      	nop

00000920 <memcpy>:
     920:	4684      	mov	ip, r0
     922:	ea41 0300 	orr.w	r3, r1, r0
     926:	f013 0303 	ands.w	r3, r3, #3
     92a:	d16d      	bne.n	a08 <memcpy+0xe8>
     92c:	3a40      	subs	r2, #64	; 0x40
     92e:	d341      	bcc.n	9b4 <memcpy+0x94>
     930:	f851 3b04 	ldr.w	r3, [r1], #4
     934:	f840 3b04 	str.w	r3, [r0], #4
     938:	f851 3b04 	ldr.w	r3, [r1], #4
     93c:	f840 3b04 	str.w	r3, [r0], #4
     940:	f851 3b04 	ldr.w	r3, [r1], #4
     944:	f840 3b04 	str.w	r3, [r0], #4
     948:	f851 3b04 	ldr.w	r3, [r1], #4
     94c:	f840 3b04 	str.w	r3, [r0], #4
     950:	f851 3b04 	ldr.w	r3, [r1], #4
     954:	f840 3b04 	str.w	r3, [r0], #4
     958:	f851 3b04 	ldr.w	r3, [r1], #4
     95c:	f840 3b04 	str.w	r3, [r0], #4
     960:	f851 3b04 	ldr.w	r3, [r1], #4
     964:	f840 3b04 	str.w	r3, [r0], #4
     968:	f851 3b04 	ldr.w	r3, [r1], #4
     96c:	f840 3b04 	str.w	r3, [r0], #4
     970:	f851 3b04 	ldr.w	r3, [r1], #4
     974:	f840 3b04 	str.w	r3, [r0], #4
     978:	f851 3b04 	ldr.w	r3, [r1], #4
     97c:	f840 3b04 	str.w	r3, [r0], #4
     980:	f851 3b04 	ldr.w	r3, [r1], #4
     984:	f840 3b04 	str.w	r3, [r0], #4
     988:	f851 3b04 	ldr.w	r3, [r1], #4
     98c:	f840 3b04 	str.w	r3, [r0], #4
     990:	f851 3b04 	ldr.w	r3, [r1], #4
     994:	f840 3b04 	str.w	r3, [r0], #4
     998:	f851 3b04 	ldr.w	r3, [r1], #4
     99c:	f840 3b04 	str.w	r3, [r0], #4
     9a0:	f851 3b04 	ldr.w	r3, [r1], #4
     9a4:	f840 3b04 	str.w	r3, [r0], #4
     9a8:	f851 3b04 	ldr.w	r3, [r1], #4
     9ac:	f840 3b04 	str.w	r3, [r0], #4
     9b0:	3a40      	subs	r2, #64	; 0x40
     9b2:	d2bd      	bcs.n	930 <memcpy+0x10>
     9b4:	3230      	adds	r2, #48	; 0x30
     9b6:	d311      	bcc.n	9dc <memcpy+0xbc>
     9b8:	f851 3b04 	ldr.w	r3, [r1], #4
     9bc:	f840 3b04 	str.w	r3, [r0], #4
     9c0:	f851 3b04 	ldr.w	r3, [r1], #4
     9c4:	f840 3b04 	str.w	r3, [r0], #4
     9c8:	f851 3b04 	ldr.w	r3, [r1], #4
     9cc:	f840 3b04 	str.w	r3, [r0], #4
     9d0:	f851 3b04 	ldr.w	r3, [r1], #4
     9d4:	f840 3b04 	str.w	r3, [r0], #4
     9d8:	3a10      	subs	r2, #16
     9da:	d2ed      	bcs.n	9b8 <memcpy+0x98>
     9dc:	320c      	adds	r2, #12
     9de:	d305      	bcc.n	9ec <memcpy+0xcc>
     9e0:	f851 3b04 	ldr.w	r3, [r1], #4
     9e4:	f840 3b04 	str.w	r3, [r0], #4
     9e8:	3a04      	subs	r2, #4
     9ea:	d2f9      	bcs.n	9e0 <memcpy+0xc0>
     9ec:	3204      	adds	r2, #4
     9ee:	d008      	beq.n	a02 <memcpy+0xe2>
     9f0:	07d2      	lsls	r2, r2, #31
     9f2:	bf1c      	itt	ne
     9f4:	f811 3b01 	ldrbne.w	r3, [r1], #1
     9f8:	f800 3b01 	strbne.w	r3, [r0], #1
     9fc:	d301      	bcc.n	a02 <memcpy+0xe2>
     9fe:	880b      	ldrh	r3, [r1, #0]
     a00:	8003      	strh	r3, [r0, #0]
     a02:	4660      	mov	r0, ip
     a04:	4770      	bx	lr
     a06:	bf00      	nop
     a08:	2a08      	cmp	r2, #8
     a0a:	d313      	bcc.n	a34 <memcpy+0x114>
     a0c:	078b      	lsls	r3, r1, #30
     a0e:	d08d      	beq.n	92c <memcpy+0xc>
     a10:	f010 0303 	ands.w	r3, r0, #3
     a14:	d08a      	beq.n	92c <memcpy+0xc>
     a16:	f1c3 0304 	rsb	r3, r3, #4
     a1a:	1ad2      	subs	r2, r2, r3
     a1c:	07db      	lsls	r3, r3, #31
     a1e:	bf1c      	itt	ne
     a20:	f811 3b01 	ldrbne.w	r3, [r1], #1
     a24:	f800 3b01 	strbne.w	r3, [r0], #1
     a28:	d380      	bcc.n	92c <memcpy+0xc>
     a2a:	f831 3b02 	ldrh.w	r3, [r1], #2
     a2e:	f820 3b02 	strh.w	r3, [r0], #2
     a32:	e77b      	b.n	92c <memcpy+0xc>
     a34:	3a04      	subs	r2, #4
     a36:	d3d9      	bcc.n	9ec <memcpy+0xcc>
     a38:	3a01      	subs	r2, #1
     a3a:	f811 3b01 	ldrb.w	r3, [r1], #1
     a3e:	f800 3b01 	strb.w	r3, [r0], #1
     a42:	d2f9      	bcs.n	a38 <memcpy+0x118>
     a44:	780b      	ldrb	r3, [r1, #0]
     a46:	7003      	strb	r3, [r0, #0]
     a48:	784b      	ldrb	r3, [r1, #1]
     a4a:	7043      	strb	r3, [r0, #1]
     a4c:	788b      	ldrb	r3, [r1, #2]
     a4e:	7083      	strb	r3, [r0, #2]
     a50:	4660      	mov	r0, ip
     a52:	4770      	bx	lr
	...

00000a80 <strlen>:
     a80:	f890 f000 	pld	[r0]
     a84:	e96d 4502 	strd	r4, r5, [sp, #-8]!
     a88:	f020 0107 	bic.w	r1, r0, #7
     a8c:	f06f 0c00 	mvn.w	ip, #0
     a90:	f010 0407 	ands.w	r4, r0, #7
     a94:	f891 f020 	pld	[r1, #32]
     a98:	f040 8049 	bne.w	b2e <strlen+0xae>
     a9c:	f04f 0400 	mov.w	r4, #0
     aa0:	f06f 0007 	mvn.w	r0, #7
     aa4:	e9d1 2300 	ldrd	r2, r3, [r1]
     aa8:	f891 f040 	pld	[r1, #64]	; 0x40
     aac:	f100 0008 	add.w	r0, r0, #8
     ab0:	fa82 f24c 	uadd8	r2, r2, ip
     ab4:	faa4 f28c 	sel	r2, r4, ip
     ab8:	fa83 f34c 	uadd8	r3, r3, ip
     abc:	faa2 f38c 	sel	r3, r2, ip
     ac0:	bb4b      	cbnz	r3, b16 <strlen+0x96>
     ac2:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
     ac6:	fa82 f24c 	uadd8	r2, r2, ip
     aca:	f100 0008 	add.w	r0, r0, #8
     ace:	faa4 f28c 	sel	r2, r4, ip
     ad2:	fa83 f34c 	uadd8	r3, r3, ip
     ad6:	faa2 f38c 	sel	r3, r2, ip
     ada:	b9e3      	cbnz	r3, b16 <strlen+0x96>
     adc:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
     ae0:	fa82 f24c 	uadd8	r2, r2, ip
     ae4:	f100 0008 	add.w	r0, r0, #8
     ae8:	faa4 f28c 	sel	r2, r4, ip
     aec:	fa83 f34c 	uadd8	r3, r3, ip
     af0:	faa2 f38c 	sel	r3, r2, ip
     af4:	b97b      	cbnz	r3, b16 <strlen+0x96>
     af6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
     afa:	f101 0120 	add.w	r1, r1, #32
     afe:	fa82 f24c 	uadd8	r2, r2, ip
     b02:	f100 0008 	add.w	r0, r0, #8
     b06:	faa4 f28c 	sel	r2, r4, ip
     b0a:	fa83 f34c 	uadd8	r3, r3, ip
     b0e:	faa2 f38c 	sel	r3, r2, ip
     b12:	2b00      	cmp	r3, #0
     b14:	d0c6      	beq.n	aa4 <strlen+0x24>
     b16:	2a00      	cmp	r2, #0
     b18:	bf04      	itt	eq
     b1a:	3004      	addeq	r0, #4
     b1c:	461a      	moveq	r2, r3
     b1e:	ba12      	rev	r2, r2
     b20:	fab2 f282 	clz	r2, r2
     b24:	e8fd 4502 	ldrd	r4, r5, [sp], #8
     b28:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
     b2c:	4770      	bx	lr
     b2e:	e9d1 2300 	ldrd	r2, r3, [r1]
     b32:	f004 0503 	and.w	r5, r4, #3
     b36:	f1c4 0000 	rsb	r0, r4, #0
     b3a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
     b3e:	f014 0f04 	tst.w	r4, #4
     b42:	f891 f040 	pld	[r1, #64]	; 0x40
     b46:	fa0c f505 	lsl.w	r5, ip, r5
     b4a:	ea62 0205 	orn	r2, r2, r5
     b4e:	bf1c      	itt	ne
     b50:	ea63 0305 	ornne	r3, r3, r5
     b54:	4662      	movne	r2, ip
     b56:	f04f 0400 	mov.w	r4, #0
     b5a:	e7a9      	b.n	ab0 <strlen+0x30>

00000b5c <__aeabi_drsub>:
     b5c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
     b60:	e002      	b.n	b68 <__adddf3>
     b62:	bf00      	nop

00000b64 <__aeabi_dsub>:
     b64:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00000b68 <__adddf3>:
     b68:	b530      	push	{r4, r5, lr}
     b6a:	ea4f 0441 	mov.w	r4, r1, lsl #1
     b6e:	ea4f 0543 	mov.w	r5, r3, lsl #1
     b72:	ea94 0f05 	teq	r4, r5
     b76:	bf08      	it	eq
     b78:	ea90 0f02 	teqeq	r0, r2
     b7c:	bf1f      	itttt	ne
     b7e:	ea54 0c00 	orrsne.w	ip, r4, r0
     b82:	ea55 0c02 	orrsne.w	ip, r5, r2
     b86:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
     b8a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
     b8e:	f000 80e2 	beq.w	d56 <__adddf3+0x1ee>
     b92:	ea4f 5454 	mov.w	r4, r4, lsr #21
     b96:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
     b9a:	bfb8      	it	lt
     b9c:	426d      	neglt	r5, r5
     b9e:	dd0c      	ble.n	bba <__adddf3+0x52>
     ba0:	442c      	add	r4, r5
     ba2:	ea80 0202 	eor.w	r2, r0, r2
     ba6:	ea81 0303 	eor.w	r3, r1, r3
     baa:	ea82 0000 	eor.w	r0, r2, r0
     bae:	ea83 0101 	eor.w	r1, r3, r1
     bb2:	ea80 0202 	eor.w	r2, r0, r2
     bb6:	ea81 0303 	eor.w	r3, r1, r3
     bba:	2d36      	cmp	r5, #54	; 0x36
     bbc:	bf88      	it	hi
     bbe:	bd30      	pophi	{r4, r5, pc}
     bc0:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
     bc4:	ea4f 3101 	mov.w	r1, r1, lsl #12
     bc8:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
     bcc:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
     bd0:	d002      	beq.n	bd8 <__adddf3+0x70>
     bd2:	4240      	negs	r0, r0
     bd4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     bd8:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
     bdc:	ea4f 3303 	mov.w	r3, r3, lsl #12
     be0:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
     be4:	d002      	beq.n	bec <__adddf3+0x84>
     be6:	4252      	negs	r2, r2
     be8:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     bec:	ea94 0f05 	teq	r4, r5
     bf0:	f000 80a7 	beq.w	d42 <__adddf3+0x1da>
     bf4:	f1a4 0401 	sub.w	r4, r4, #1
     bf8:	f1d5 0e20 	rsbs	lr, r5, #32
     bfc:	db0d      	blt.n	c1a <__adddf3+0xb2>
     bfe:	fa02 fc0e 	lsl.w	ip, r2, lr
     c02:	fa22 f205 	lsr.w	r2, r2, r5
     c06:	1880      	adds	r0, r0, r2
     c08:	f141 0100 	adc.w	r1, r1, #0
     c0c:	fa03 f20e 	lsl.w	r2, r3, lr
     c10:	1880      	adds	r0, r0, r2
     c12:	fa43 f305 	asr.w	r3, r3, r5
     c16:	4159      	adcs	r1, r3
     c18:	e00e      	b.n	c38 <__adddf3+0xd0>
     c1a:	f1a5 0520 	sub.w	r5, r5, #32
     c1e:	f10e 0e20 	add.w	lr, lr, #32
     c22:	2a01      	cmp	r2, #1
     c24:	fa03 fc0e 	lsl.w	ip, r3, lr
     c28:	bf28      	it	cs
     c2a:	f04c 0c02 	orrcs.w	ip, ip, #2
     c2e:	fa43 f305 	asr.w	r3, r3, r5
     c32:	18c0      	adds	r0, r0, r3
     c34:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
     c38:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
     c3c:	d507      	bpl.n	c4e <__adddf3+0xe6>
     c3e:	f04f 0e00 	mov.w	lr, #0
     c42:	f1dc 0c00 	rsbs	ip, ip, #0
     c46:	eb7e 0000 	sbcs.w	r0, lr, r0
     c4a:	eb6e 0101 	sbc.w	r1, lr, r1
     c4e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
     c52:	d31b      	bcc.n	c8c <__adddf3+0x124>
     c54:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
     c58:	d30c      	bcc.n	c74 <__adddf3+0x10c>
     c5a:	0849      	lsrs	r1, r1, #1
     c5c:	ea5f 0030 	movs.w	r0, r0, rrx
     c60:	ea4f 0c3c 	mov.w	ip, ip, rrx
     c64:	f104 0401 	add.w	r4, r4, #1
     c68:	ea4f 5244 	mov.w	r2, r4, lsl #21
     c6c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
     c70:	f080 809a 	bcs.w	da8 <__adddf3+0x240>
     c74:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
     c78:	bf08      	it	eq
     c7a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
     c7e:	f150 0000 	adcs.w	r0, r0, #0
     c82:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
     c86:	ea41 0105 	orr.w	r1, r1, r5
     c8a:	bd30      	pop	{r4, r5, pc}
     c8c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
     c90:	4140      	adcs	r0, r0
     c92:	eb41 0101 	adc.w	r1, r1, r1
     c96:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
     c9a:	f1a4 0401 	sub.w	r4, r4, #1
     c9e:	d1e9      	bne.n	c74 <__adddf3+0x10c>
     ca0:	f091 0f00 	teq	r1, #0
     ca4:	bf04      	itt	eq
     ca6:	4601      	moveq	r1, r0
     ca8:	2000      	moveq	r0, #0
     caa:	fab1 f381 	clz	r3, r1
     cae:	bf08      	it	eq
     cb0:	3320      	addeq	r3, #32
     cb2:	f1a3 030b 	sub.w	r3, r3, #11
     cb6:	f1b3 0220 	subs.w	r2, r3, #32
     cba:	da0c      	bge.n	cd6 <__adddf3+0x16e>
     cbc:	320c      	adds	r2, #12
     cbe:	dd08      	ble.n	cd2 <__adddf3+0x16a>
     cc0:	f102 0c14 	add.w	ip, r2, #20
     cc4:	f1c2 020c 	rsb	r2, r2, #12
     cc8:	fa01 f00c 	lsl.w	r0, r1, ip
     ccc:	fa21 f102 	lsr.w	r1, r1, r2
     cd0:	e00c      	b.n	cec <__adddf3+0x184>
     cd2:	f102 0214 	add.w	r2, r2, #20
     cd6:	bfd8      	it	le
     cd8:	f1c2 0c20 	rsble	ip, r2, #32
     cdc:	fa01 f102 	lsl.w	r1, r1, r2
     ce0:	fa20 fc0c 	lsr.w	ip, r0, ip
     ce4:	bfdc      	itt	le
     ce6:	ea41 010c 	orrle.w	r1, r1, ip
     cea:	4090      	lslle	r0, r2
     cec:	1ae4      	subs	r4, r4, r3
     cee:	bfa2      	ittt	ge
     cf0:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
     cf4:	4329      	orrge	r1, r5
     cf6:	bd30      	popge	{r4, r5, pc}
     cf8:	ea6f 0404 	mvn.w	r4, r4
     cfc:	3c1f      	subs	r4, #31
     cfe:	da1c      	bge.n	d3a <__adddf3+0x1d2>
     d00:	340c      	adds	r4, #12
     d02:	dc0e      	bgt.n	d22 <__adddf3+0x1ba>
     d04:	f104 0414 	add.w	r4, r4, #20
     d08:	f1c4 0220 	rsb	r2, r4, #32
     d0c:	fa20 f004 	lsr.w	r0, r0, r4
     d10:	fa01 f302 	lsl.w	r3, r1, r2
     d14:	ea40 0003 	orr.w	r0, r0, r3
     d18:	fa21 f304 	lsr.w	r3, r1, r4
     d1c:	ea45 0103 	orr.w	r1, r5, r3
     d20:	bd30      	pop	{r4, r5, pc}
     d22:	f1c4 040c 	rsb	r4, r4, #12
     d26:	f1c4 0220 	rsb	r2, r4, #32
     d2a:	fa20 f002 	lsr.w	r0, r0, r2
     d2e:	fa01 f304 	lsl.w	r3, r1, r4
     d32:	ea40 0003 	orr.w	r0, r0, r3
     d36:	4629      	mov	r1, r5
     d38:	bd30      	pop	{r4, r5, pc}
     d3a:	fa21 f004 	lsr.w	r0, r1, r4
     d3e:	4629      	mov	r1, r5
     d40:	bd30      	pop	{r4, r5, pc}
     d42:	f094 0f00 	teq	r4, #0
     d46:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
     d4a:	bf06      	itte	eq
     d4c:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
     d50:	3401      	addeq	r4, #1
     d52:	3d01      	subne	r5, #1
     d54:	e74e      	b.n	bf4 <__adddf3+0x8c>
     d56:	ea7f 5c64 	mvns.w	ip, r4, asr #21
     d5a:	bf18      	it	ne
     d5c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
     d60:	d029      	beq.n	db6 <__adddf3+0x24e>
     d62:	ea94 0f05 	teq	r4, r5
     d66:	bf08      	it	eq
     d68:	ea90 0f02 	teqeq	r0, r2
     d6c:	d005      	beq.n	d7a <__adddf3+0x212>
     d6e:	ea54 0c00 	orrs.w	ip, r4, r0
     d72:	bf04      	itt	eq
     d74:	4619      	moveq	r1, r3
     d76:	4610      	moveq	r0, r2
     d78:	bd30      	pop	{r4, r5, pc}
     d7a:	ea91 0f03 	teq	r1, r3
     d7e:	bf1e      	ittt	ne
     d80:	2100      	movne	r1, #0
     d82:	2000      	movne	r0, #0
     d84:	bd30      	popne	{r4, r5, pc}
     d86:	ea5f 5c54 	movs.w	ip, r4, lsr #21
     d8a:	d105      	bne.n	d98 <__adddf3+0x230>
     d8c:	0040      	lsls	r0, r0, #1
     d8e:	4149      	adcs	r1, r1
     d90:	bf28      	it	cs
     d92:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
     d96:	bd30      	pop	{r4, r5, pc}
     d98:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
     d9c:	bf3c      	itt	cc
     d9e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
     da2:	bd30      	popcc	{r4, r5, pc}
     da4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
     da8:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
     dac:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
     db0:	f04f 0000 	mov.w	r0, #0
     db4:	bd30      	pop	{r4, r5, pc}
     db6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
     dba:	bf1a      	itte	ne
     dbc:	4619      	movne	r1, r3
     dbe:	4610      	movne	r0, r2
     dc0:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
     dc4:	bf1c      	itt	ne
     dc6:	460b      	movne	r3, r1
     dc8:	4602      	movne	r2, r0
     dca:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
     dce:	bf06      	itte	eq
     dd0:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
     dd4:	ea91 0f03 	teqeq	r1, r3
     dd8:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
     ddc:	bd30      	pop	{r4, r5, pc}
     dde:	bf00      	nop

00000de0 <__aeabi_ui2d>:
     de0:	f090 0f00 	teq	r0, #0
     de4:	bf04      	itt	eq
     de6:	2100      	moveq	r1, #0
     de8:	4770      	bxeq	lr
     dea:	b530      	push	{r4, r5, lr}
     dec:	f44f 6480 	mov.w	r4, #1024	; 0x400
     df0:	f104 0432 	add.w	r4, r4, #50	; 0x32
     df4:	f04f 0500 	mov.w	r5, #0
     df8:	f04f 0100 	mov.w	r1, #0
     dfc:	e750      	b.n	ca0 <__adddf3+0x138>
     dfe:	bf00      	nop

00000e00 <__aeabi_i2d>:
     e00:	f090 0f00 	teq	r0, #0
     e04:	bf04      	itt	eq
     e06:	2100      	moveq	r1, #0
     e08:	4770      	bxeq	lr
     e0a:	b530      	push	{r4, r5, lr}
     e0c:	f44f 6480 	mov.w	r4, #1024	; 0x400
     e10:	f104 0432 	add.w	r4, r4, #50	; 0x32
     e14:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
     e18:	bf48      	it	mi
     e1a:	4240      	negmi	r0, r0
     e1c:	f04f 0100 	mov.w	r1, #0
     e20:	e73e      	b.n	ca0 <__adddf3+0x138>
     e22:	bf00      	nop

00000e24 <__aeabi_f2d>:
     e24:	0042      	lsls	r2, r0, #1
     e26:	ea4f 01e2 	mov.w	r1, r2, asr #3
     e2a:	ea4f 0131 	mov.w	r1, r1, rrx
     e2e:	ea4f 7002 	mov.w	r0, r2, lsl #28
     e32:	bf1f      	itttt	ne
     e34:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
     e38:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
     e3c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
     e40:	4770      	bxne	lr
     e42:	f092 0f00 	teq	r2, #0
     e46:	bf14      	ite	ne
     e48:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
     e4c:	4770      	bxeq	lr
     e4e:	b530      	push	{r4, r5, lr}
     e50:	f44f 7460 	mov.w	r4, #896	; 0x380
     e54:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
     e58:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
     e5c:	e720      	b.n	ca0 <__adddf3+0x138>
     e5e:	bf00      	nop

00000e60 <__aeabi_ul2d>:
     e60:	ea50 0201 	orrs.w	r2, r0, r1
     e64:	bf08      	it	eq
     e66:	4770      	bxeq	lr
     e68:	b530      	push	{r4, r5, lr}
     e6a:	f04f 0500 	mov.w	r5, #0
     e6e:	e00a      	b.n	e86 <__aeabi_l2d+0x16>

00000e70 <__aeabi_l2d>:
     e70:	ea50 0201 	orrs.w	r2, r0, r1
     e74:	bf08      	it	eq
     e76:	4770      	bxeq	lr
     e78:	b530      	push	{r4, r5, lr}
     e7a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
     e7e:	d502      	bpl.n	e86 <__aeabi_l2d+0x16>
     e80:	4240      	negs	r0, r0
     e82:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     e86:	f44f 6480 	mov.w	r4, #1024	; 0x400
     e8a:	f104 0432 	add.w	r4, r4, #50	; 0x32
     e8e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
     e92:	f43f aedc 	beq.w	c4e <__adddf3+0xe6>
     e96:	f04f 0203 	mov.w	r2, #3
     e9a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
     e9e:	bf18      	it	ne
     ea0:	3203      	addne	r2, #3
     ea2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
     ea6:	bf18      	it	ne
     ea8:	3203      	addne	r2, #3
     eaa:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
     eae:	f1c2 0320 	rsb	r3, r2, #32
     eb2:	fa00 fc03 	lsl.w	ip, r0, r3
     eb6:	fa20 f002 	lsr.w	r0, r0, r2
     eba:	fa01 fe03 	lsl.w	lr, r1, r3
     ebe:	ea40 000e 	orr.w	r0, r0, lr
     ec2:	fa21 f102 	lsr.w	r1, r1, r2
     ec6:	4414      	add	r4, r2
     ec8:	e6c1      	b.n	c4e <__adddf3+0xe6>
     eca:	bf00      	nop

00000ecc <__aeabi_dmul>:
     ecc:	b570      	push	{r4, r5, r6, lr}
     ece:	f04f 0cff 	mov.w	ip, #255	; 0xff
     ed2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
     ed6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
     eda:	bf1d      	ittte	ne
     edc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
     ee0:	ea94 0f0c 	teqne	r4, ip
     ee4:	ea95 0f0c 	teqne	r5, ip
     ee8:	f000 f8de 	bleq	10a8 <__aeabi_dmul+0x1dc>
     eec:	442c      	add	r4, r5
     eee:	ea81 0603 	eor.w	r6, r1, r3
     ef2:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
     ef6:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
     efa:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
     efe:	bf18      	it	ne
     f00:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
     f04:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     f08:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
     f0c:	d038      	beq.n	f80 <__aeabi_dmul+0xb4>
     f0e:	fba0 ce02 	umull	ip, lr, r0, r2
     f12:	f04f 0500 	mov.w	r5, #0
     f16:	fbe1 e502 	umlal	lr, r5, r1, r2
     f1a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
     f1e:	fbe0 e503 	umlal	lr, r5, r0, r3
     f22:	f04f 0600 	mov.w	r6, #0
     f26:	fbe1 5603 	umlal	r5, r6, r1, r3
     f2a:	f09c 0f00 	teq	ip, #0
     f2e:	bf18      	it	ne
     f30:	f04e 0e01 	orrne.w	lr, lr, #1
     f34:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
     f38:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
     f3c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
     f40:	d204      	bcs.n	f4c <__aeabi_dmul+0x80>
     f42:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
     f46:	416d      	adcs	r5, r5
     f48:	eb46 0606 	adc.w	r6, r6, r6
     f4c:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
     f50:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
     f54:	ea4f 20c5 	mov.w	r0, r5, lsl #11
     f58:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
     f5c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
     f60:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
     f64:	bf88      	it	hi
     f66:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
     f6a:	d81e      	bhi.n	faa <__aeabi_dmul+0xde>
     f6c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
     f70:	bf08      	it	eq
     f72:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
     f76:	f150 0000 	adcs.w	r0, r0, #0
     f7a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
     f7e:	bd70      	pop	{r4, r5, r6, pc}
     f80:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
     f84:	ea46 0101 	orr.w	r1, r6, r1
     f88:	ea40 0002 	orr.w	r0, r0, r2
     f8c:	ea81 0103 	eor.w	r1, r1, r3
     f90:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
     f94:	bfc2      	ittt	gt
     f96:	ebd4 050c 	rsbsgt	r5, r4, ip
     f9a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
     f9e:	bd70      	popgt	{r4, r5, r6, pc}
     fa0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     fa4:	f04f 0e00 	mov.w	lr, #0
     fa8:	3c01      	subs	r4, #1
     faa:	f300 80ab 	bgt.w	1104 <__aeabi_dmul+0x238>
     fae:	f114 0f36 	cmn.w	r4, #54	; 0x36
     fb2:	bfde      	ittt	le
     fb4:	2000      	movle	r0, #0
     fb6:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
     fba:	bd70      	pople	{r4, r5, r6, pc}
     fbc:	f1c4 0400 	rsb	r4, r4, #0
     fc0:	3c20      	subs	r4, #32
     fc2:	da35      	bge.n	1030 <__aeabi_dmul+0x164>
     fc4:	340c      	adds	r4, #12
     fc6:	dc1b      	bgt.n	1000 <__aeabi_dmul+0x134>
     fc8:	f104 0414 	add.w	r4, r4, #20
     fcc:	f1c4 0520 	rsb	r5, r4, #32
     fd0:	fa00 f305 	lsl.w	r3, r0, r5
     fd4:	fa20 f004 	lsr.w	r0, r0, r4
     fd8:	fa01 f205 	lsl.w	r2, r1, r5
     fdc:	ea40 0002 	orr.w	r0, r0, r2
     fe0:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
     fe4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
     fe8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
     fec:	fa21 f604 	lsr.w	r6, r1, r4
     ff0:	eb42 0106 	adc.w	r1, r2, r6
     ff4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
     ff8:	bf08      	it	eq
     ffa:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
     ffe:	bd70      	pop	{r4, r5, r6, pc}
    1000:	f1c4 040c 	rsb	r4, r4, #12
    1004:	f1c4 0520 	rsb	r5, r4, #32
    1008:	fa00 f304 	lsl.w	r3, r0, r4
    100c:	fa20 f005 	lsr.w	r0, r0, r5
    1010:	fa01 f204 	lsl.w	r2, r1, r4
    1014:	ea40 0002 	orr.w	r0, r0, r2
    1018:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    101c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    1020:	f141 0100 	adc.w	r1, r1, #0
    1024:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    1028:	bf08      	it	eq
    102a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    102e:	bd70      	pop	{r4, r5, r6, pc}
    1030:	f1c4 0520 	rsb	r5, r4, #32
    1034:	fa00 f205 	lsl.w	r2, r0, r5
    1038:	ea4e 0e02 	orr.w	lr, lr, r2
    103c:	fa20 f304 	lsr.w	r3, r0, r4
    1040:	fa01 f205 	lsl.w	r2, r1, r5
    1044:	ea43 0302 	orr.w	r3, r3, r2
    1048:	fa21 f004 	lsr.w	r0, r1, r4
    104c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    1050:	fa21 f204 	lsr.w	r2, r1, r4
    1054:	ea20 0002 	bic.w	r0, r0, r2
    1058:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    105c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    1060:	bf08      	it	eq
    1062:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    1066:	bd70      	pop	{r4, r5, r6, pc}
    1068:	f094 0f00 	teq	r4, #0
    106c:	d10f      	bne.n	108e <__aeabi_dmul+0x1c2>
    106e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    1072:	0040      	lsls	r0, r0, #1
    1074:	eb41 0101 	adc.w	r1, r1, r1
    1078:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    107c:	bf08      	it	eq
    107e:	3c01      	subeq	r4, #1
    1080:	d0f7      	beq.n	1072 <__aeabi_dmul+0x1a6>
    1082:	ea41 0106 	orr.w	r1, r1, r6
    1086:	f095 0f00 	teq	r5, #0
    108a:	bf18      	it	ne
    108c:	4770      	bxne	lr
    108e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    1092:	0052      	lsls	r2, r2, #1
    1094:	eb43 0303 	adc.w	r3, r3, r3
    1098:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    109c:	bf08      	it	eq
    109e:	3d01      	subeq	r5, #1
    10a0:	d0f7      	beq.n	1092 <__aeabi_dmul+0x1c6>
    10a2:	ea43 0306 	orr.w	r3, r3, r6
    10a6:	4770      	bx	lr
    10a8:	ea94 0f0c 	teq	r4, ip
    10ac:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    10b0:	bf18      	it	ne
    10b2:	ea95 0f0c 	teqne	r5, ip
    10b6:	d00c      	beq.n	10d2 <__aeabi_dmul+0x206>
    10b8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    10bc:	bf18      	it	ne
    10be:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    10c2:	d1d1      	bne.n	1068 <__aeabi_dmul+0x19c>
    10c4:	ea81 0103 	eor.w	r1, r1, r3
    10c8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    10cc:	f04f 0000 	mov.w	r0, #0
    10d0:	bd70      	pop	{r4, r5, r6, pc}
    10d2:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    10d6:	bf06      	itte	eq
    10d8:	4610      	moveq	r0, r2
    10da:	4619      	moveq	r1, r3
    10dc:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    10e0:	d019      	beq.n	1116 <__aeabi_dmul+0x24a>
    10e2:	ea94 0f0c 	teq	r4, ip
    10e6:	d102      	bne.n	10ee <__aeabi_dmul+0x222>
    10e8:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    10ec:	d113      	bne.n	1116 <__aeabi_dmul+0x24a>
    10ee:	ea95 0f0c 	teq	r5, ip
    10f2:	d105      	bne.n	1100 <__aeabi_dmul+0x234>
    10f4:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    10f8:	bf1c      	itt	ne
    10fa:	4610      	movne	r0, r2
    10fc:	4619      	movne	r1, r3
    10fe:	d10a      	bne.n	1116 <__aeabi_dmul+0x24a>
    1100:	ea81 0103 	eor.w	r1, r1, r3
    1104:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    1108:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    110c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    1110:	f04f 0000 	mov.w	r0, #0
    1114:	bd70      	pop	{r4, r5, r6, pc}
    1116:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    111a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    111e:	bd70      	pop	{r4, r5, r6, pc}

00001120 <__aeabi_ddiv>:
    1120:	b570      	push	{r4, r5, r6, lr}
    1122:	f04f 0cff 	mov.w	ip, #255	; 0xff
    1126:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    112a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    112e:	bf1d      	ittte	ne
    1130:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    1134:	ea94 0f0c 	teqne	r4, ip
    1138:	ea95 0f0c 	teqne	r5, ip
    113c:	f000 f8a7 	bleq	128e <__aeabi_ddiv+0x16e>
    1140:	eba4 0405 	sub.w	r4, r4, r5
    1144:	ea81 0e03 	eor.w	lr, r1, r3
    1148:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    114c:	ea4f 3101 	mov.w	r1, r1, lsl #12
    1150:	f000 8088 	beq.w	1264 <__aeabi_ddiv+0x144>
    1154:	ea4f 3303 	mov.w	r3, r3, lsl #12
    1158:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    115c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    1160:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    1164:	ea4f 2202 	mov.w	r2, r2, lsl #8
    1168:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    116c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    1170:	ea4f 2600 	mov.w	r6, r0, lsl #8
    1174:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    1178:	429d      	cmp	r5, r3
    117a:	bf08      	it	eq
    117c:	4296      	cmpeq	r6, r2
    117e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    1182:	f504 7440 	add.w	r4, r4, #768	; 0x300
    1186:	d202      	bcs.n	118e <__aeabi_ddiv+0x6e>
    1188:	085b      	lsrs	r3, r3, #1
    118a:	ea4f 0232 	mov.w	r2, r2, rrx
    118e:	1ab6      	subs	r6, r6, r2
    1190:	eb65 0503 	sbc.w	r5, r5, r3
    1194:	085b      	lsrs	r3, r3, #1
    1196:	ea4f 0232 	mov.w	r2, r2, rrx
    119a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    119e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    11a2:	ebb6 0e02 	subs.w	lr, r6, r2
    11a6:	eb75 0e03 	sbcs.w	lr, r5, r3
    11aa:	bf22      	ittt	cs
    11ac:	1ab6      	subcs	r6, r6, r2
    11ae:	4675      	movcs	r5, lr
    11b0:	ea40 000c 	orrcs.w	r0, r0, ip
    11b4:	085b      	lsrs	r3, r3, #1
    11b6:	ea4f 0232 	mov.w	r2, r2, rrx
    11ba:	ebb6 0e02 	subs.w	lr, r6, r2
    11be:	eb75 0e03 	sbcs.w	lr, r5, r3
    11c2:	bf22      	ittt	cs
    11c4:	1ab6      	subcs	r6, r6, r2
    11c6:	4675      	movcs	r5, lr
    11c8:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    11cc:	085b      	lsrs	r3, r3, #1
    11ce:	ea4f 0232 	mov.w	r2, r2, rrx
    11d2:	ebb6 0e02 	subs.w	lr, r6, r2
    11d6:	eb75 0e03 	sbcs.w	lr, r5, r3
    11da:	bf22      	ittt	cs
    11dc:	1ab6      	subcs	r6, r6, r2
    11de:	4675      	movcs	r5, lr
    11e0:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    11e4:	085b      	lsrs	r3, r3, #1
    11e6:	ea4f 0232 	mov.w	r2, r2, rrx
    11ea:	ebb6 0e02 	subs.w	lr, r6, r2
    11ee:	eb75 0e03 	sbcs.w	lr, r5, r3
    11f2:	bf22      	ittt	cs
    11f4:	1ab6      	subcs	r6, r6, r2
    11f6:	4675      	movcs	r5, lr
    11f8:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    11fc:	ea55 0e06 	orrs.w	lr, r5, r6
    1200:	d018      	beq.n	1234 <__aeabi_ddiv+0x114>
    1202:	ea4f 1505 	mov.w	r5, r5, lsl #4
    1206:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    120a:	ea4f 1606 	mov.w	r6, r6, lsl #4
    120e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1212:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    1216:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    121a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    121e:	d1c0      	bne.n	11a2 <__aeabi_ddiv+0x82>
    1220:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    1224:	d10b      	bne.n	123e <__aeabi_ddiv+0x11e>
    1226:	ea41 0100 	orr.w	r1, r1, r0
    122a:	f04f 0000 	mov.w	r0, #0
    122e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    1232:	e7b6      	b.n	11a2 <__aeabi_ddiv+0x82>
    1234:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    1238:	bf04      	itt	eq
    123a:	4301      	orreq	r1, r0
    123c:	2000      	moveq	r0, #0
    123e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    1242:	bf88      	it	hi
    1244:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    1248:	f63f aeaf 	bhi.w	faa <__aeabi_dmul+0xde>
    124c:	ebb5 0c03 	subs.w	ip, r5, r3
    1250:	bf04      	itt	eq
    1252:	ebb6 0c02 	subseq.w	ip, r6, r2
    1256:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    125a:	f150 0000 	adcs.w	r0, r0, #0
    125e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    1262:	bd70      	pop	{r4, r5, r6, pc}
    1264:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    1268:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    126c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    1270:	bfc2      	ittt	gt
    1272:	ebd4 050c 	rsbsgt	r5, r4, ip
    1276:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    127a:	bd70      	popgt	{r4, r5, r6, pc}
    127c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    1280:	f04f 0e00 	mov.w	lr, #0
    1284:	3c01      	subs	r4, #1
    1286:	e690      	b.n	faa <__aeabi_dmul+0xde>
    1288:	ea45 0e06 	orr.w	lr, r5, r6
    128c:	e68d      	b.n	faa <__aeabi_dmul+0xde>
    128e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    1292:	ea94 0f0c 	teq	r4, ip
    1296:	bf08      	it	eq
    1298:	ea95 0f0c 	teqeq	r5, ip
    129c:	f43f af3b 	beq.w	1116 <__aeabi_dmul+0x24a>
    12a0:	ea94 0f0c 	teq	r4, ip
    12a4:	d10a      	bne.n	12bc <__aeabi_ddiv+0x19c>
    12a6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    12aa:	f47f af34 	bne.w	1116 <__aeabi_dmul+0x24a>
    12ae:	ea95 0f0c 	teq	r5, ip
    12b2:	f47f af25 	bne.w	1100 <__aeabi_dmul+0x234>
    12b6:	4610      	mov	r0, r2
    12b8:	4619      	mov	r1, r3
    12ba:	e72c      	b.n	1116 <__aeabi_dmul+0x24a>
    12bc:	ea95 0f0c 	teq	r5, ip
    12c0:	d106      	bne.n	12d0 <__aeabi_ddiv+0x1b0>
    12c2:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    12c6:	f43f aefd 	beq.w	10c4 <__aeabi_dmul+0x1f8>
    12ca:	4610      	mov	r0, r2
    12cc:	4619      	mov	r1, r3
    12ce:	e722      	b.n	1116 <__aeabi_dmul+0x24a>
    12d0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    12d4:	bf18      	it	ne
    12d6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    12da:	f47f aec5 	bne.w	1068 <__aeabi_dmul+0x19c>
    12de:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    12e2:	f47f af0d 	bne.w	1100 <__aeabi_dmul+0x234>
    12e6:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    12ea:	f47f aeeb 	bne.w	10c4 <__aeabi_dmul+0x1f8>
    12ee:	e712      	b.n	1116 <__aeabi_dmul+0x24a>

000012f0 <__gedf2>:
    12f0:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
    12f4:	e006      	b.n	1304 <__cmpdf2+0x4>
    12f6:	bf00      	nop

000012f8 <__ledf2>:
    12f8:	f04f 0c01 	mov.w	ip, #1
    12fc:	e002      	b.n	1304 <__cmpdf2+0x4>
    12fe:	bf00      	nop

00001300 <__cmpdf2>:
    1300:	f04f 0c01 	mov.w	ip, #1
    1304:	f84d cd04 	str.w	ip, [sp, #-4]!
    1308:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    130c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    1310:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    1314:	bf18      	it	ne
    1316:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
    131a:	d01b      	beq.n	1354 <__cmpdf2+0x54>
    131c:	b001      	add	sp, #4
    131e:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
    1322:	bf0c      	ite	eq
    1324:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
    1328:	ea91 0f03 	teqne	r1, r3
    132c:	bf02      	ittt	eq
    132e:	ea90 0f02 	teqeq	r0, r2
    1332:	2000      	moveq	r0, #0
    1334:	4770      	bxeq	lr
    1336:	f110 0f00 	cmn.w	r0, #0
    133a:	ea91 0f03 	teq	r1, r3
    133e:	bf58      	it	pl
    1340:	4299      	cmppl	r1, r3
    1342:	bf08      	it	eq
    1344:	4290      	cmpeq	r0, r2
    1346:	bf2c      	ite	cs
    1348:	17d8      	asrcs	r0, r3, #31
    134a:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
    134e:	f040 0001 	orr.w	r0, r0, #1
    1352:	4770      	bx	lr
    1354:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    1358:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    135c:	d102      	bne.n	1364 <__cmpdf2+0x64>
    135e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    1362:	d107      	bne.n	1374 <__cmpdf2+0x74>
    1364:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    1368:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    136c:	d1d6      	bne.n	131c <__cmpdf2+0x1c>
    136e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    1372:	d0d3      	beq.n	131c <__cmpdf2+0x1c>
    1374:	f85d 0b04 	ldr.w	r0, [sp], #4
    1378:	4770      	bx	lr
    137a:	bf00      	nop

0000137c <__aeabi_cdrcmple>:
    137c:	4684      	mov	ip, r0
    137e:	4610      	mov	r0, r2
    1380:	4662      	mov	r2, ip
    1382:	468c      	mov	ip, r1
    1384:	4619      	mov	r1, r3
    1386:	4663      	mov	r3, ip
    1388:	e000      	b.n	138c <__aeabi_cdcmpeq>
    138a:	bf00      	nop

0000138c <__aeabi_cdcmpeq>:
    138c:	b501      	push	{r0, lr}
    138e:	f7ff ffb7 	bl	1300 <__cmpdf2>
    1392:	2800      	cmp	r0, #0
    1394:	bf48      	it	mi
    1396:	f110 0f00 	cmnmi.w	r0, #0
    139a:	bd01      	pop	{r0, pc}

0000139c <__aeabi_dcmpeq>:
    139c:	f84d ed08 	str.w	lr, [sp, #-8]!
    13a0:	f7ff fff4 	bl	138c <__aeabi_cdcmpeq>
    13a4:	bf0c      	ite	eq
    13a6:	2001      	moveq	r0, #1
    13a8:	2000      	movne	r0, #0
    13aa:	f85d fb08 	ldr.w	pc, [sp], #8
    13ae:	bf00      	nop

000013b0 <__aeabi_dcmplt>:
    13b0:	f84d ed08 	str.w	lr, [sp, #-8]!
    13b4:	f7ff ffea 	bl	138c <__aeabi_cdcmpeq>
    13b8:	bf34      	ite	cc
    13ba:	2001      	movcc	r0, #1
    13bc:	2000      	movcs	r0, #0
    13be:	f85d fb08 	ldr.w	pc, [sp], #8
    13c2:	bf00      	nop

000013c4 <__aeabi_dcmple>:
    13c4:	f84d ed08 	str.w	lr, [sp, #-8]!
    13c8:	f7ff ffe0 	bl	138c <__aeabi_cdcmpeq>
    13cc:	bf94      	ite	ls
    13ce:	2001      	movls	r0, #1
    13d0:	2000      	movhi	r0, #0
    13d2:	f85d fb08 	ldr.w	pc, [sp], #8
    13d6:	bf00      	nop

000013d8 <__aeabi_dcmpge>:
    13d8:	f84d ed08 	str.w	lr, [sp, #-8]!
    13dc:	f7ff ffce 	bl	137c <__aeabi_cdrcmple>
    13e0:	bf94      	ite	ls
    13e2:	2001      	movls	r0, #1
    13e4:	2000      	movhi	r0, #0
    13e6:	f85d fb08 	ldr.w	pc, [sp], #8
    13ea:	bf00      	nop

000013ec <__aeabi_dcmpgt>:
    13ec:	f84d ed08 	str.w	lr, [sp, #-8]!
    13f0:	f7ff ffc4 	bl	137c <__aeabi_cdrcmple>
    13f4:	bf34      	ite	cc
    13f6:	2001      	movcc	r0, #1
    13f8:	2000      	movcs	r0, #0
    13fa:	f85d fb08 	ldr.w	pc, [sp], #8
    13fe:	bf00      	nop

00001400 <__aeabi_dcmpun>:
    1400:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    1404:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    1408:	d102      	bne.n	1410 <__aeabi_dcmpun+0x10>
    140a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    140e:	d10a      	bne.n	1426 <__aeabi_dcmpun+0x26>
    1410:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    1414:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    1418:	d102      	bne.n	1420 <__aeabi_dcmpun+0x20>
    141a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    141e:	d102      	bne.n	1426 <__aeabi_dcmpun+0x26>
    1420:	f04f 0000 	mov.w	r0, #0
    1424:	4770      	bx	lr
    1426:	f04f 0001 	mov.w	r0, #1
    142a:	4770      	bx	lr

0000142c <__aeabi_d2iz>:
    142c:	ea4f 0241 	mov.w	r2, r1, lsl #1
    1430:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    1434:	d215      	bcs.n	1462 <__aeabi_d2iz+0x36>
    1436:	d511      	bpl.n	145c <__aeabi_d2iz+0x30>
    1438:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    143c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    1440:	d912      	bls.n	1468 <__aeabi_d2iz+0x3c>
    1442:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    1446:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    144a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    144e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    1452:	fa23 f002 	lsr.w	r0, r3, r2
    1456:	bf18      	it	ne
    1458:	4240      	negne	r0, r0
    145a:	4770      	bx	lr
    145c:	f04f 0000 	mov.w	r0, #0
    1460:	4770      	bx	lr
    1462:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    1466:	d105      	bne.n	1474 <__aeabi_d2iz+0x48>
    1468:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
    146c:	bf08      	it	eq
    146e:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
    1472:	4770      	bx	lr
    1474:	f04f 0000 	mov.w	r0, #0
    1478:	4770      	bx	lr
    147a:	bf00      	nop

0000147c <__aeabi_uldivmod>:
    147c:	b953      	cbnz	r3, 1494 <__aeabi_uldivmod+0x18>
    147e:	b94a      	cbnz	r2, 1494 <__aeabi_uldivmod+0x18>
    1480:	2900      	cmp	r1, #0
    1482:	bf08      	it	eq
    1484:	2800      	cmpeq	r0, #0
    1486:	bf1c      	itt	ne
    1488:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    148c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    1490:	f000 b97a 	b.w	1788 <__aeabi_idiv0>
    1494:	f1ad 0c08 	sub.w	ip, sp, #8
    1498:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    149c:	f000 f806 	bl	14ac <__udivmoddi4>
    14a0:	f8dd e004 	ldr.w	lr, [sp, #4]
    14a4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    14a8:	b004      	add	sp, #16
    14aa:	4770      	bx	lr

000014ac <__udivmoddi4>:
    14ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    14b0:	468c      	mov	ip, r1
    14b2:	460d      	mov	r5, r1
    14b4:	4604      	mov	r4, r0
    14b6:	9e08      	ldr	r6, [sp, #32]
    14b8:	2b00      	cmp	r3, #0
    14ba:	d151      	bne.n	1560 <__udivmoddi4+0xb4>
    14bc:	428a      	cmp	r2, r1
    14be:	4617      	mov	r7, r2
    14c0:	d96d      	bls.n	159e <__udivmoddi4+0xf2>
    14c2:	fab2 fe82 	clz	lr, r2
    14c6:	f1be 0f00 	cmp.w	lr, #0
    14ca:	d00b      	beq.n	14e4 <__udivmoddi4+0x38>
    14cc:	f1ce 0c20 	rsb	ip, lr, #32
    14d0:	fa01 f50e 	lsl.w	r5, r1, lr
    14d4:	fa20 fc0c 	lsr.w	ip, r0, ip
    14d8:	fa02 f70e 	lsl.w	r7, r2, lr
    14dc:	ea4c 0c05 	orr.w	ip, ip, r5
    14e0:	fa00 f40e 	lsl.w	r4, r0, lr
    14e4:	ea4f 4a17 	mov.w	sl, r7, lsr #16
    14e8:	0c25      	lsrs	r5, r4, #16
    14ea:	fbbc f8fa 	udiv	r8, ip, sl
    14ee:	fa1f f987 	uxth.w	r9, r7
    14f2:	fb0a cc18 	mls	ip, sl, r8, ip
    14f6:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
    14fa:	fb08 f309 	mul.w	r3, r8, r9
    14fe:	42ab      	cmp	r3, r5
    1500:	d90a      	bls.n	1518 <__udivmoddi4+0x6c>
    1502:	19ed      	adds	r5, r5, r7
    1504:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
    1508:	f080 8123 	bcs.w	1752 <__udivmoddi4+0x2a6>
    150c:	42ab      	cmp	r3, r5
    150e:	f240 8120 	bls.w	1752 <__udivmoddi4+0x2a6>
    1512:	f1a8 0802 	sub.w	r8, r8, #2
    1516:	443d      	add	r5, r7
    1518:	1aed      	subs	r5, r5, r3
    151a:	b2a4      	uxth	r4, r4
    151c:	fbb5 f0fa 	udiv	r0, r5, sl
    1520:	fb0a 5510 	mls	r5, sl, r0, r5
    1524:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
    1528:	fb00 f909 	mul.w	r9, r0, r9
    152c:	45a1      	cmp	r9, r4
    152e:	d909      	bls.n	1544 <__udivmoddi4+0x98>
    1530:	19e4      	adds	r4, r4, r7
    1532:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
    1536:	f080 810a 	bcs.w	174e <__udivmoddi4+0x2a2>
    153a:	45a1      	cmp	r9, r4
    153c:	f240 8107 	bls.w	174e <__udivmoddi4+0x2a2>
    1540:	3802      	subs	r0, #2
    1542:	443c      	add	r4, r7
    1544:	eba4 0409 	sub.w	r4, r4, r9
    1548:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
    154c:	2100      	movs	r1, #0
    154e:	2e00      	cmp	r6, #0
    1550:	d061      	beq.n	1616 <__udivmoddi4+0x16a>
    1552:	fa24 f40e 	lsr.w	r4, r4, lr
    1556:	2300      	movs	r3, #0
    1558:	6034      	str	r4, [r6, #0]
    155a:	6073      	str	r3, [r6, #4]
    155c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1560:	428b      	cmp	r3, r1
    1562:	d907      	bls.n	1574 <__udivmoddi4+0xc8>
    1564:	2e00      	cmp	r6, #0
    1566:	d054      	beq.n	1612 <__udivmoddi4+0x166>
    1568:	2100      	movs	r1, #0
    156a:	e886 0021 	stmia.w	r6, {r0, r5}
    156e:	4608      	mov	r0, r1
    1570:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1574:	fab3 f183 	clz	r1, r3
    1578:	2900      	cmp	r1, #0
    157a:	f040 808e 	bne.w	169a <__udivmoddi4+0x1ee>
    157e:	42ab      	cmp	r3, r5
    1580:	d302      	bcc.n	1588 <__udivmoddi4+0xdc>
    1582:	4282      	cmp	r2, r0
    1584:	f200 80fa 	bhi.w	177c <__udivmoddi4+0x2d0>
    1588:	1a84      	subs	r4, r0, r2
    158a:	eb65 0503 	sbc.w	r5, r5, r3
    158e:	2001      	movs	r0, #1
    1590:	46ac      	mov	ip, r5
    1592:	2e00      	cmp	r6, #0
    1594:	d03f      	beq.n	1616 <__udivmoddi4+0x16a>
    1596:	e886 1010 	stmia.w	r6, {r4, ip}
    159a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    159e:	b912      	cbnz	r2, 15a6 <__udivmoddi4+0xfa>
    15a0:	2701      	movs	r7, #1
    15a2:	fbb7 f7f2 	udiv	r7, r7, r2
    15a6:	fab7 fe87 	clz	lr, r7
    15aa:	f1be 0f00 	cmp.w	lr, #0
    15ae:	d134      	bne.n	161a <__udivmoddi4+0x16e>
    15b0:	1beb      	subs	r3, r5, r7
    15b2:	0c3a      	lsrs	r2, r7, #16
    15b4:	fa1f fc87 	uxth.w	ip, r7
    15b8:	2101      	movs	r1, #1
    15ba:	fbb3 f8f2 	udiv	r8, r3, r2
    15be:	0c25      	lsrs	r5, r4, #16
    15c0:	fb02 3318 	mls	r3, r2, r8, r3
    15c4:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
    15c8:	fb0c f308 	mul.w	r3, ip, r8
    15cc:	42ab      	cmp	r3, r5
    15ce:	d907      	bls.n	15e0 <__udivmoddi4+0x134>
    15d0:	19ed      	adds	r5, r5, r7
    15d2:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
    15d6:	d202      	bcs.n	15de <__udivmoddi4+0x132>
    15d8:	42ab      	cmp	r3, r5
    15da:	f200 80d1 	bhi.w	1780 <__udivmoddi4+0x2d4>
    15de:	4680      	mov	r8, r0
    15e0:	1aed      	subs	r5, r5, r3
    15e2:	b2a3      	uxth	r3, r4
    15e4:	fbb5 f0f2 	udiv	r0, r5, r2
    15e8:	fb02 5510 	mls	r5, r2, r0, r5
    15ec:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
    15f0:	fb0c fc00 	mul.w	ip, ip, r0
    15f4:	45a4      	cmp	ip, r4
    15f6:	d907      	bls.n	1608 <__udivmoddi4+0x15c>
    15f8:	19e4      	adds	r4, r4, r7
    15fa:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
    15fe:	d202      	bcs.n	1606 <__udivmoddi4+0x15a>
    1600:	45a4      	cmp	ip, r4
    1602:	f200 80b8 	bhi.w	1776 <__udivmoddi4+0x2ca>
    1606:	4618      	mov	r0, r3
    1608:	eba4 040c 	sub.w	r4, r4, ip
    160c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
    1610:	e79d      	b.n	154e <__udivmoddi4+0xa2>
    1612:	4631      	mov	r1, r6
    1614:	4630      	mov	r0, r6
    1616:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    161a:	f1ce 0420 	rsb	r4, lr, #32
    161e:	fa05 f30e 	lsl.w	r3, r5, lr
    1622:	fa07 f70e 	lsl.w	r7, r7, lr
    1626:	fa20 f804 	lsr.w	r8, r0, r4
    162a:	0c3a      	lsrs	r2, r7, #16
    162c:	fa25 f404 	lsr.w	r4, r5, r4
    1630:	ea48 0803 	orr.w	r8, r8, r3
    1634:	fbb4 f1f2 	udiv	r1, r4, r2
    1638:	ea4f 4518 	mov.w	r5, r8, lsr #16
    163c:	fb02 4411 	mls	r4, r2, r1, r4
    1640:	fa1f fc87 	uxth.w	ip, r7
    1644:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
    1648:	fb01 f30c 	mul.w	r3, r1, ip
    164c:	42ab      	cmp	r3, r5
    164e:	fa00 f40e 	lsl.w	r4, r0, lr
    1652:	d909      	bls.n	1668 <__udivmoddi4+0x1bc>
    1654:	19ed      	adds	r5, r5, r7
    1656:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
    165a:	f080 808a 	bcs.w	1772 <__udivmoddi4+0x2c6>
    165e:	42ab      	cmp	r3, r5
    1660:	f240 8087 	bls.w	1772 <__udivmoddi4+0x2c6>
    1664:	3902      	subs	r1, #2
    1666:	443d      	add	r5, r7
    1668:	1aeb      	subs	r3, r5, r3
    166a:	fa1f f588 	uxth.w	r5, r8
    166e:	fbb3 f0f2 	udiv	r0, r3, r2
    1672:	fb02 3310 	mls	r3, r2, r0, r3
    1676:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
    167a:	fb00 f30c 	mul.w	r3, r0, ip
    167e:	42ab      	cmp	r3, r5
    1680:	d907      	bls.n	1692 <__udivmoddi4+0x1e6>
    1682:	19ed      	adds	r5, r5, r7
    1684:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
    1688:	d26f      	bcs.n	176a <__udivmoddi4+0x2be>
    168a:	42ab      	cmp	r3, r5
    168c:	d96d      	bls.n	176a <__udivmoddi4+0x2be>
    168e:	3802      	subs	r0, #2
    1690:	443d      	add	r5, r7
    1692:	1aeb      	subs	r3, r5, r3
    1694:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
    1698:	e78f      	b.n	15ba <__udivmoddi4+0x10e>
    169a:	f1c1 0720 	rsb	r7, r1, #32
    169e:	fa22 f807 	lsr.w	r8, r2, r7
    16a2:	408b      	lsls	r3, r1
    16a4:	fa05 f401 	lsl.w	r4, r5, r1
    16a8:	ea48 0303 	orr.w	r3, r8, r3
    16ac:	fa20 fe07 	lsr.w	lr, r0, r7
    16b0:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    16b4:	40fd      	lsrs	r5, r7
    16b6:	ea4e 0e04 	orr.w	lr, lr, r4
    16ba:	fbb5 f9fc 	udiv	r9, r5, ip
    16be:	ea4f 441e 	mov.w	r4, lr, lsr #16
    16c2:	fb0c 5519 	mls	r5, ip, r9, r5
    16c6:	fa1f f883 	uxth.w	r8, r3
    16ca:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
    16ce:	fb09 f408 	mul.w	r4, r9, r8
    16d2:	42ac      	cmp	r4, r5
    16d4:	fa02 f201 	lsl.w	r2, r2, r1
    16d8:	fa00 fa01 	lsl.w	sl, r0, r1
    16dc:	d908      	bls.n	16f0 <__udivmoddi4+0x244>
    16de:	18ed      	adds	r5, r5, r3
    16e0:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    16e4:	d243      	bcs.n	176e <__udivmoddi4+0x2c2>
    16e6:	42ac      	cmp	r4, r5
    16e8:	d941      	bls.n	176e <__udivmoddi4+0x2c2>
    16ea:	f1a9 0902 	sub.w	r9, r9, #2
    16ee:	441d      	add	r5, r3
    16f0:	1b2d      	subs	r5, r5, r4
    16f2:	fa1f fe8e 	uxth.w	lr, lr
    16f6:	fbb5 f0fc 	udiv	r0, r5, ip
    16fa:	fb0c 5510 	mls	r5, ip, r0, r5
    16fe:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
    1702:	fb00 f808 	mul.w	r8, r0, r8
    1706:	45a0      	cmp	r8, r4
    1708:	d907      	bls.n	171a <__udivmoddi4+0x26e>
    170a:	18e4      	adds	r4, r4, r3
    170c:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
    1710:	d229      	bcs.n	1766 <__udivmoddi4+0x2ba>
    1712:	45a0      	cmp	r8, r4
    1714:	d927      	bls.n	1766 <__udivmoddi4+0x2ba>
    1716:	3802      	subs	r0, #2
    1718:	441c      	add	r4, r3
    171a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
    171e:	eba4 0408 	sub.w	r4, r4, r8
    1722:	fba0 8902 	umull	r8, r9, r0, r2
    1726:	454c      	cmp	r4, r9
    1728:	46c6      	mov	lr, r8
    172a:	464d      	mov	r5, r9
    172c:	d315      	bcc.n	175a <__udivmoddi4+0x2ae>
    172e:	d012      	beq.n	1756 <__udivmoddi4+0x2aa>
    1730:	b156      	cbz	r6, 1748 <__udivmoddi4+0x29c>
    1732:	ebba 030e 	subs.w	r3, sl, lr
    1736:	eb64 0405 	sbc.w	r4, r4, r5
    173a:	fa04 f707 	lsl.w	r7, r4, r7
    173e:	40cb      	lsrs	r3, r1
    1740:	431f      	orrs	r7, r3
    1742:	40cc      	lsrs	r4, r1
    1744:	6037      	str	r7, [r6, #0]
    1746:	6074      	str	r4, [r6, #4]
    1748:	2100      	movs	r1, #0
    174a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    174e:	4618      	mov	r0, r3
    1750:	e6f8      	b.n	1544 <__udivmoddi4+0x98>
    1752:	4690      	mov	r8, r2
    1754:	e6e0      	b.n	1518 <__udivmoddi4+0x6c>
    1756:	45c2      	cmp	sl, r8
    1758:	d2ea      	bcs.n	1730 <__udivmoddi4+0x284>
    175a:	ebb8 0e02 	subs.w	lr, r8, r2
    175e:	eb69 0503 	sbc.w	r5, r9, r3
    1762:	3801      	subs	r0, #1
    1764:	e7e4      	b.n	1730 <__udivmoddi4+0x284>
    1766:	4628      	mov	r0, r5
    1768:	e7d7      	b.n	171a <__udivmoddi4+0x26e>
    176a:	4640      	mov	r0, r8
    176c:	e791      	b.n	1692 <__udivmoddi4+0x1e6>
    176e:	4681      	mov	r9, r0
    1770:	e7be      	b.n	16f0 <__udivmoddi4+0x244>
    1772:	4601      	mov	r1, r0
    1774:	e778      	b.n	1668 <__udivmoddi4+0x1bc>
    1776:	3802      	subs	r0, #2
    1778:	443c      	add	r4, r7
    177a:	e745      	b.n	1608 <__udivmoddi4+0x15c>
    177c:	4608      	mov	r0, r1
    177e:	e708      	b.n	1592 <__udivmoddi4+0xe6>
    1780:	f1a8 0802 	sub.w	r8, r8, #2
    1784:	443d      	add	r5, r7
    1786:	e72b      	b.n	15e0 <__udivmoddi4+0x134>

00001788 <__aeabi_idiv0>:
    1788:	4770      	bx	lr
    178a:	bf00      	nop

0000178c <_ZN4mbed10DigitalOutC1E7PinName>:
public:
    /** Create a DigitalOut connected to the specified pin
     *
     *  @param pin DigitalOut pin to connect to
     */
    DigitalOut(PinName pin) : gpio()
    178c:	b500      	push	{lr}
    178e:	b083      	sub	sp, #12
    1790:	9001      	str	r0, [sp, #4]
    1792:	9100      	str	r1, [sp, #0]
    1794:	9b01      	ldr	r3, [sp, #4]
    1796:	2200      	movs	r2, #0
    1798:	601a      	str	r2, [r3, #0]
    {
        // No lock needed in the constructor
        gpio_init_out(&gpio, pin);
    179a:	9b01      	ldr	r3, [sp, #4]
    179c:	9900      	ldr	r1, [sp, #0]
    179e:	4618      	mov	r0, r3
    17a0:	f000 faaa 	bl	1cf8 <gpio_init_out>
    }
    17a4:	9b01      	ldr	r3, [sp, #4]
    17a6:	4618      	mov	r0, r3
    17a8:	b003      	add	sp, #12
    17aa:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000017b0 <_Z17print_memory_infov>:
#include "mbed.h"
#include "mbed_mem_trace.h"

DigitalOut led1(LED1);

void print_memory_info() {
    17b0:	b500      	push	{lr}
    17b2:	b08b      	sub	sp, #44	; 0x2c
    // allocate enough room for every thread's stack statistics
    int cnt = osThreadGetCount();
    17b4:	f006 fa28 	bl	7c08 <osThreadGetCount>
    17b8:	4603      	mov	r3, r0
    17ba:	9308      	str	r3, [sp, #32]
    mbed_stats_stack_t *stats = (mbed_stats_stack_t*) malloc(cnt * sizeof(mbed_stats_stack_t));
    17bc:	9b08      	ldr	r3, [sp, #32]
    17be:	011b      	lsls	r3, r3, #4
    17c0:	4618      	mov	r0, r3
    17c2:	f009 fb35 	bl	ae30 <malloc>
    17c6:	9007      	str	r0, [sp, #28]

    cnt = mbed_stats_stack_get_each(stats, cnt);
    17c8:	9b08      	ldr	r3, [sp, #32]
    17ca:	4619      	mov	r1, r3
    17cc:	9807      	ldr	r0, [sp, #28]
    17ce:	f002 fa3d 	bl	3c4c <mbed_stats_stack_get_each>
    17d2:	4603      	mov	r3, r0
    17d4:	9308      	str	r3, [sp, #32]
    for (int i = 0; i < cnt; i++) {
    17d6:	2300      	movs	r3, #0
    17d8:	9309      	str	r3, [sp, #36]	; 0x24
    17da:	9a09      	ldr	r2, [sp, #36]	; 0x24
    17dc:	9b08      	ldr	r3, [sp, #32]
    17de:	429a      	cmp	r2, r3
    17e0:	da16      	bge.n	1810 <_Z17print_memory_infov+0x60>
        printf("Thread: 0x%lX, Stack size: %lu / %lu\r\n", stats[i].thread_id, stats[i].max_size, stats[i].reserved_size);
    17e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    17e4:	011b      	lsls	r3, r3, #4
    17e6:	9a07      	ldr	r2, [sp, #28]
    17e8:	4413      	add	r3, r2
    17ea:	6819      	ldr	r1, [r3, #0]
    17ec:	9b09      	ldr	r3, [sp, #36]	; 0x24
    17ee:	011b      	lsls	r3, r3, #4
    17f0:	9a07      	ldr	r2, [sp, #28]
    17f2:	4413      	add	r3, r2
    17f4:	6858      	ldr	r0, [r3, #4]
    17f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    17f8:	011b      	lsls	r3, r3, #4
    17fa:	9a07      	ldr	r2, [sp, #28]
    17fc:	4413      	add	r3, r2
    17fe:	689b      	ldr	r3, [r3, #8]
    1800:	4602      	mov	r2, r0
    1802:	480c      	ldr	r0, [pc, #48]	; (1834 <_Z17print_memory_infov+0x84>)
    1804:	f009 fe9c 	bl	b540 <printf>
    for (int i = 0; i < cnt; i++) {
    1808:	9b09      	ldr	r3, [sp, #36]	; 0x24
    180a:	3301      	adds	r3, #1
    180c:	9309      	str	r3, [sp, #36]	; 0x24
    180e:	e7e4      	b.n	17da <_Z17print_memory_infov+0x2a>
    }
    free(stats);
    1810:	9807      	ldr	r0, [sp, #28]
    1812:	f009 fb15 	bl	ae40 <free>

    // Grab the heap statistics
    mbed_stats_heap_t heap_stats;
    mbed_stats_heap_get(&heap_stats);
    1816:	ab01      	add	r3, sp, #4
    1818:	4618      	mov	r0, r3
    181a:	f000 ffb9 	bl	2790 <mbed_stats_heap_get>
    printf("Heap size: %lu / %lu bytes\r\n", heap_stats.current_size, heap_stats.reserved_size);
    181e:	9b01      	ldr	r3, [sp, #4]
    1820:	9a04      	ldr	r2, [sp, #16]
    1822:	4619      	mov	r1, r3
    1824:	4804      	ldr	r0, [pc, #16]	; (1838 <_Z17print_memory_infov+0x88>)
    1826:	f009 fe8b 	bl	b540 <printf>
}
    182a:	bf00      	nop
    182c:	b00b      	add	sp, #44	; 0x2c
    182e:	f85d fb04 	ldr.w	pc, [sp], #4
    1832:	bf00      	nop
    1834:	00010a04 	.word	0x00010a04
    1838:	00010a2c 	.word	0x00010a2c

0000183c <main>:

int main() {
    183c:	b510      	push	{r4, lr}
    183e:	b08a      	sub	sp, #40	; 0x28
    print_memory_info();
    1840:	f7ff ffb6 	bl	17b0 <_Z17print_memory_infov>
    mbed_mem_trace_set_callback(mbed_mem_trace_default_callback);
    1844:	481d      	ldr	r0, [pc, #116]	; (18bc <main+0x80>)
    1846:	f001 fb99 	bl	2f7c <mbed_mem_trace_set_callback>

    while (true) {
        wait(2.0);
    184a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    184e:	f002 fa6f 	bl	3d30 <wait>

        void *ptr1 = malloc(512);
    1852:	f44f 7000 	mov.w	r0, #512	; 0x200
    1856:	f009 faeb 	bl	ae30 <malloc>
    185a:	9009      	str	r0, [sp, #36]	; 0x24
        void *ptr2 = calloc(768, 1);
    185c:	2101      	movs	r1, #1
    185e:	f44f 7040 	mov.w	r0, #768	; 0x300
    1862:	f008 fd7d 	bl	a360 <calloc>
    1866:	9008      	str	r0, [sp, #32]
        void *ptr3 = (void*)new DigitalOut(LED1);
    1868:	2004      	movs	r0, #4
    186a:	f002 f99d 	bl	3ba8 <_Znwj>
    186e:	4603      	mov	r3, r0
    1870:	461c      	mov	r4, r3
    1872:	f241 0116 	movw	r1, #4118	; 0x1016
    1876:	4620      	mov	r0, r4
    1878:	f7ff ff88 	bl	178c <_ZN4mbed10DigitalOutC1E7PinName>
    187c:	9407      	str	r4, [sp, #28]
        void *ptr4 = malloc(256);
    187e:	f44f 7080 	mov.w	r0, #256	; 0x100
    1882:	f009 fad5 	bl	ae30 <malloc>
    1886:	9006      	str	r0, [sp, #24]

        ptr4 = realloc(ptr4, 512);
    1888:	f44f 7100 	mov.w	r1, #512	; 0x200
    188c:	9806      	ldr	r0, [sp, #24]
    188e:	f009 fe6b 	bl	b568 <realloc>
    1892:	9006      	str	r0, [sp, #24]

        // Grab the heap statistics
        mbed_stats_heap_t heap_stats;
        mbed_stats_heap_get(&heap_stats);
    1894:	466b      	mov	r3, sp
    1896:	4618      	mov	r0, r3
    1898:	f000 ff7a 	bl	2790 <mbed_stats_heap_get>
        printf("Heap size: %lu / %lu bytes\r\n", heap_stats.current_size, heap_stats.reserved_size);
    189c:	9b00      	ldr	r3, [sp, #0]
    189e:	9a03      	ldr	r2, [sp, #12]
    18a0:	4619      	mov	r1, r3
    18a2:	4807      	ldr	r0, [pc, #28]	; (18c0 <main+0x84>)
    18a4:	f009 fe4c 	bl	b540 <printf>

        // Forget to free a pointer
        free(ptr1);
    18a8:	9809      	ldr	r0, [sp, #36]	; 0x24
    18aa:	f009 fac9 	bl	ae40 <free>
        free(ptr3);
    18ae:	9807      	ldr	r0, [sp, #28]
    18b0:	f009 fac6 	bl	ae40 <free>
        free(ptr4);
    18b4:	9806      	ldr	r0, [sp, #24]
    18b6:	f009 fac3 	bl	ae40 <free>
    }
    18ba:	e7c6      	b.n	184a <main+0xe>
    18bc:	000030d1 	.word	0x000030d1
    18c0:	00010a2c 	.word	0x00010a2c

000018c4 <_Z41__static_initialization_and_destruction_0ii>:
}
    18c4:	b500      	push	{lr}
    18c6:	b083      	sub	sp, #12
    18c8:	9001      	str	r0, [sp, #4]
    18ca:	9100      	str	r1, [sp, #0]
    18cc:	9b01      	ldr	r3, [sp, #4]
    18ce:	2b01      	cmp	r3, #1
    18d0:	d109      	bne.n	18e6 <_Z41__static_initialization_and_destruction_0ii+0x22>
    18d2:	9b00      	ldr	r3, [sp, #0]
    18d4:	f64f 72ff 	movw	r2, #65535	; 0xffff
    18d8:	4293      	cmp	r3, r2
    18da:	d104      	bne.n	18e6 <_Z41__static_initialization_and_destruction_0ii+0x22>
DigitalOut led1(LED1);
    18dc:	f241 0116 	movw	r1, #4118	; 0x1016
    18e0:	4803      	ldr	r0, [pc, #12]	; (18f0 <_Z41__static_initialization_and_destruction_0ii+0x2c>)
    18e2:	f7ff ff53 	bl	178c <_ZN4mbed10DigitalOutC1E7PinName>
}
    18e6:	bf00      	nop
    18e8:	b003      	add	sp, #12
    18ea:	f85d fb04 	ldr.w	pc, [sp], #4
    18ee:	bf00      	nop
    18f0:	20000b9c 	.word	0x20000b9c

000018f4 <_GLOBAL__sub_I_led1>:
    18f4:	b508      	push	{r3, lr}
    18f6:	f64f 71ff 	movw	r1, #65535	; 0xffff
    18fa:	2001      	movs	r0, #1
    18fc:	f7ff ffe2 	bl	18c4 <_Z41__static_initialization_and_destruction_0ii>
    1900:	bd08      	pop	{r3, pc}

00001902 <_ZnwjPv>:
  __attribute__((__externally_visible__));
#endif

// Default placement versions of operator new.
inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
{ return __p; }
    1902:	b082      	sub	sp, #8
    1904:	9001      	str	r0, [sp, #4]
    1906:	9100      	str	r1, [sp, #0]
    1908:	9b00      	ldr	r3, [sp, #0]
    190a:	4618      	mov	r0, r3
    190c:	b002      	add	sp, #8
    190e:	4770      	bx	lr

00001910 <_ZL14singleton_lockv>:
 * This function is typically used to provide
 * exclusive access when initializing a
 * global object.
 */
inline static void singleton_lock(void)
{
    1910:	b508      	push	{r3, lr}
#ifdef MBED_CONF_RTOS_PRESENT
    osMutexAcquire(singleton_mutex_id, osWaitForever);
    1912:	4b04      	ldr	r3, [pc, #16]	; (1924 <_ZL14singleton_lockv+0x14>)
    1914:	681b      	ldr	r3, [r3, #0]
    1916:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    191a:	4618      	mov	r0, r3
    191c:	f004 fe38 	bl	6590 <osMutexAcquire>
#endif
}
    1920:	bf00      	nop
    1922:	bd08      	pop	{r3, pc}
    1924:	20001ed0 	.word	0x20001ed0

00001928 <_ZL16singleton_unlockv>:
 * This function is typically used to provide
 * exclusive access when initializing a
 * global object.
 */
inline static void singleton_unlock(void)
{
    1928:	b508      	push	{r3, lr}
#ifdef MBED_CONF_RTOS_PRESENT
    osMutexRelease(singleton_mutex_id);
    192a:	4b03      	ldr	r3, [pc, #12]	; (1938 <_ZL16singleton_unlockv+0x10>)
    192c:	681b      	ldr	r3, [r3, #0]
    192e:	4618      	mov	r0, r3
    1930:	f004 fe5c 	bl	65ec <osMutexRelease>
#endif
}
    1934:	bf00      	nop
    1936:	bd08      	pop	{r3, pc}
    1938:	20001ed0 	.word	0x20001ed0

0000193c <_ZN12SingletonPtrIN4rtos5MutexEEptEv>:
    /** Get a pointer to the underlying singleton
     *
     * @returns
     *   A pointer to the singleton
     */
    T *operator->()
    193c:	b500      	push	{lr}
    193e:	b083      	sub	sp, #12
    1940:	9001      	str	r0, [sp, #4]
    {
        return get();
    1942:	9801      	ldr	r0, [sp, #4]
    1944:	f000 f806 	bl	1954 <_ZN12SingletonPtrIN4rtos5MutexEE3getEv>
    1948:	4603      	mov	r3, r0
    }
    194a:	4618      	mov	r0, r3
    194c:	b003      	add	sp, #12
    194e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00001954 <_ZN12SingletonPtrIN4rtos5MutexEE3getEv>:
    T *get()
    1954:	b510      	push	{r4, lr}
    1956:	b082      	sub	sp, #8
    1958:	9001      	str	r0, [sp, #4]
        if (NULL == _ptr) {
    195a:	9b01      	ldr	r3, [sp, #4]
    195c:	681b      	ldr	r3, [r3, #0]
    195e:	2b00      	cmp	r3, #0
    1960:	d118      	bne.n	1994 <_ZN12SingletonPtrIN4rtos5MutexEE3getEv+0x40>
            singleton_lock();
    1962:	f7ff ffd5 	bl	1910 <_ZL14singleton_lockv>
            if (NULL == _ptr) {
    1966:	9b01      	ldr	r3, [sp, #4]
    1968:	681b      	ldr	r3, [r3, #0]
    196a:	2b00      	cmp	r3, #0
    196c:	d110      	bne.n	1990 <_ZN12SingletonPtrIN4rtos5MutexEE3getEv+0x3c>
                _ptr = new (_data) T();
    196e:	9b01      	ldr	r3, [sp, #4]
    1970:	3304      	adds	r3, #4
    1972:	4619      	mov	r1, r3
    1974:	2024      	movs	r0, #36	; 0x24
    1976:	f7ff ffc4 	bl	1902 <_ZnwjPv>
    197a:	4604      	mov	r4, r0
    197c:	2c00      	cmp	r4, #0
    197e:	d004      	beq.n	198a <_ZN12SingletonPtrIN4rtos5MutexEE3getEv+0x36>
    1980:	4620      	mov	r0, r4
    1982:	f002 fa37 	bl	3df4 <_ZN4rtos5MutexC1Ev>
    1986:	4622      	mov	r2, r4
    1988:	e000      	b.n	198c <_ZN12SingletonPtrIN4rtos5MutexEE3getEv+0x38>
    198a:	4622      	mov	r2, r4
    198c:	9b01      	ldr	r3, [sp, #4]
    198e:	601a      	str	r2, [r3, #0]
            singleton_unlock();
    1990:	f7ff ffca 	bl	1928 <_ZL16singleton_unlockv>
        MBED_ASSERT(_ptr == (T *)&_data);
    1994:	9b01      	ldr	r3, [sp, #4]
    1996:	681a      	ldr	r2, [r3, #0]
    1998:	9b01      	ldr	r3, [sp, #4]
    199a:	3304      	adds	r3, #4
    199c:	429a      	cmp	r2, r3
    199e:	d004      	beq.n	19aa <_ZN12SingletonPtrIN4rtos5MutexEE3getEv+0x56>
    19a0:	225e      	movs	r2, #94	; 0x5e
    19a2:	4904      	ldr	r1, [pc, #16]	; (19b4 <_ZN12SingletonPtrIN4rtos5MutexEE3getEv+0x60>)
    19a4:	4804      	ldr	r0, [pc, #16]	; (19b8 <_ZN12SingletonPtrIN4rtos5MutexEE3getEv+0x64>)
    19a6:	f001 f835 	bl	2a14 <mbed_assert_internal>
        return _ptr;
    19aa:	9b01      	ldr	r3, [sp, #4]
    19ac:	681b      	ldr	r3, [r3, #0]
    }
    19ae:	4618      	mov	r0, r3
    19b0:	b002      	add	sp, #8
    19b2:	bd10      	pop	{r4, pc}
    19b4:	00010a4c 	.word	0x00010a4c
    19b8:	00010a70 	.word	0x00010a70

000019bc <_ZN4mbed10FileHandle5lseekEli>:
     *    -1 on failure or unsupported
     *  @deprecated Replaced by `off_t FileHandle::seek(off_t offset, int whence = SEEK_SET)'
     *
     */
    MBED_DEPRECATED_SINCE("mbed-os-5.4", "Replaced by FileHandle::seek")
    virtual off_t lseek(off_t offset, int whence)
    19bc:	b500      	push	{lr}
    19be:	b085      	sub	sp, #20
    19c0:	9003      	str	r0, [sp, #12]
    19c2:	9102      	str	r1, [sp, #8]
    19c4:	9201      	str	r2, [sp, #4]
    {
        return seek(offset, whence);
    19c6:	9b03      	ldr	r3, [sp, #12]
    19c8:	681b      	ldr	r3, [r3, #0]
    19ca:	3310      	adds	r3, #16
    19cc:	681b      	ldr	r3, [r3, #0]
    19ce:	9a01      	ldr	r2, [sp, #4]
    19d0:	9902      	ldr	r1, [sp, #8]
    19d2:	9803      	ldr	r0, [sp, #12]
    19d4:	4798      	blx	r3
    19d6:	4603      	mov	r3, r0
    }
    19d8:	4618      	mov	r0, r3
    19da:	b005      	add	sp, #20
    19dc:	f85d fb04 	ldr.w	pc, [sp], #4

000019e0 <_ZN4mbed10FileHandle5fsyncEv>:
     *    0 on success or un-needed,
     *   -1 on error
     *  @deprecated Replaced by `int FileHandle::sync()'
     */
    MBED_DEPRECATED_SINCE("mbed-os-5.4", "Replaced by FileHandle::sync")
    virtual int fsync()
    19e0:	b500      	push	{lr}
    19e2:	b083      	sub	sp, #12
    19e4:	9001      	str	r0, [sp, #4]
    {
        return sync();
    19e6:	9b01      	ldr	r3, [sp, #4]
    19e8:	681b      	ldr	r3, [r3, #0]
    19ea:	3318      	adds	r3, #24
    19ec:	681b      	ldr	r3, [r3, #0]
    19ee:	9801      	ldr	r0, [sp, #4]
    19f0:	4798      	blx	r3
    19f2:	4603      	mov	r3, r0
    }
    19f4:	4618      	mov	r0, r3
    19f6:	b003      	add	sp, #12
    19f8:	f85d fb04 	ldr.w	pc, [sp], #4

000019fc <_ZN4mbed10FileHandle4flenEv>:
     *  @returns
     *   Length of the file
     *  @deprecated Replaced by `off_t FileHandle::size()'
     */
    MBED_DEPRECATED_SINCE("mbed-os-5.4", "Replaced by FileHandle::size")
    virtual off_t flen()
    19fc:	b500      	push	{lr}
    19fe:	b083      	sub	sp, #12
    1a00:	9001      	str	r0, [sp, #4]
    {
        return size();
    1a02:	9b01      	ldr	r3, [sp, #4]
    1a04:	681b      	ldr	r3, [r3, #0]
    1a06:	3328      	adds	r3, #40	; 0x28
    1a08:	681b      	ldr	r3, [r3, #0]
    1a0a:	9801      	ldr	r0, [sp, #4]
    1a0c:	4798      	blx	r3
    1a0e:	4603      	mov	r3, r0
    }
    1a10:	4618      	mov	r0, r3
    1a12:	b003      	add	sp, #12
    1a14:	f85d fb04 	ldr.w	pc, [sp], #4

00001a18 <_ZN4mbed10FileHandle12set_blockingEb>:
     *  @param blocking     true for blocking mode, false for non-blocking mode.
     *
     *  @return             0 on success
     *  @return             Negative error code on failure
     */
    virtual int set_blocking(bool blocking)
    1a18:	b082      	sub	sp, #8
    1a1a:	9001      	str	r0, [sp, #4]
    1a1c:	460b      	mov	r3, r1
    1a1e:	f88d 3003 	strb.w	r3, [sp, #3]
    {
        return blocking ? 0 : -ENOTTY;
    1a22:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1a26:	2b00      	cmp	r3, #0
    1a28:	d001      	beq.n	1a2e <_ZN4mbed10FileHandle12set_blockingEb+0x16>
    1a2a:	2300      	movs	r3, #0
    1a2c:	e001      	b.n	1a32 <_ZN4mbed10FileHandle12set_blockingEb+0x1a>
    1a2e:	f06f 0318 	mvn.w	r3, #24
    }
    1a32:	4618      	mov	r0, r3
    1a34:	b002      	add	sp, #8
    1a36:	4770      	bx	lr

00001a38 <_ZNK4mbed10FileHandle11is_blockingEv>:

    /** Check current blocking or non-blocking mode for file operations.
     *
     *  @return             true for blocking mode, false for non-blocking mode.
     */
    virtual bool is_blocking() const
    1a38:	b082      	sub	sp, #8
    1a3a:	9001      	str	r0, [sp, #4]
    {
        return true;
    1a3c:	2301      	movs	r3, #1
    }
    1a3e:	4618      	mov	r0, r3
    1a40:	b002      	add	sp, #8
    1a42:	4770      	bx	lr

00001a44 <_ZNK4mbed10FileHandle4pollEs>:
     *
     * @param events        bitmask of poll events we're interested in - POLLIN/POLLOUT etc.
     *
     * @returns             bitmask of poll events that have occurred.
     */
    virtual short poll(short events) const
    1a44:	b082      	sub	sp, #8
    1a46:	9001      	str	r0, [sp, #4]
    1a48:	460b      	mov	r3, r1
    1a4a:	f8ad 3002 	strh.w	r3, [sp, #2]
    {
        // Possible default for real files
        return POLLIN | POLLOUT;
    1a4e:	2311      	movs	r3, #17
    }
    1a50:	4618      	mov	r0, r3
    1a52:	b002      	add	sp, #8
    1a54:	4770      	bx	lr

00001a56 <_ZN4mbed10FileHandle5sigioENS_8CallbackIFvvEEE>:
     *  is called is not guaranteed and susceptible to change. It should be used
     *  as a cue to make read/write/poll calls to find the current state.
     *
     *  @param func     Function to call on state change
     */
    virtual void sigio(Callback<void()> func)
    1a56:	b082      	sub	sp, #8
    1a58:	9001      	str	r0, [sp, #4]
    1a5a:	9100      	str	r1, [sp, #0]
    {
        //Default for real files. Do nothing for real files.
    }
    1a5c:	bf00      	nop
    1a5e:	b002      	add	sp, #8
    1a60:	4770      	bx	lr
	...

00001a64 <_ZN4mbed10FileHandleD1Ev>:
    virtual ~FileHandle() {}
    1a64:	b500      	push	{lr}
    1a66:	b083      	sub	sp, #12
    1a68:	9001      	str	r0, [sp, #4]
    1a6a:	4a05      	ldr	r2, [pc, #20]	; (1a80 <_ZN4mbed10FileHandleD1Ev+0x1c>)
    1a6c:	9b01      	ldr	r3, [sp, #4]
    1a6e:	601a      	str	r2, [r3, #0]
    1a70:	9801      	ldr	r0, [sp, #4]
    1a72:	f000 f845 	bl	1b00 <_ZN4mbed11NonCopyableINS_10FileHandleEED1Ev>
    1a76:	9b01      	ldr	r3, [sp, #4]
    1a78:	4618      	mov	r0, r3
    1a7a:	b003      	add	sp, #12
    1a7c:	f85d fb04 	ldr.w	pc, [sp], #4
    1a80:	00012534 	.word	0x00012534

00001a84 <_ZN4mbed10FileHandleD0Ev>:
    1a84:	b500      	push	{lr}
    1a86:	b083      	sub	sp, #12
    1a88:	9001      	str	r0, [sp, #4]
    1a8a:	9801      	ldr	r0, [sp, #4]
    1a8c:	f7ff ffea 	bl	1a64 <_ZN4mbed10FileHandleD1Ev>
    1a90:	9801      	ldr	r0, [sp, #4]
    1a92:	f002 f8ab 	bl	3bec <_ZdlPv>
    1a96:	9b01      	ldr	r3, [sp, #4]
    1a98:	4618      	mov	r0, r3
    1a9a:	b003      	add	sp, #12
    1a9c:	f85d fb04 	ldr.w	pc, [sp], #4

00001aa0 <_ZN4mbed10FileHandle4tellEv>:
    virtual off_t tell()
    1aa0:	b500      	push	{lr}
    1aa2:	b083      	sub	sp, #12
    1aa4:	9001      	str	r0, [sp, #4]
        return seek(0, SEEK_CUR);
    1aa6:	9b01      	ldr	r3, [sp, #4]
    1aa8:	681b      	ldr	r3, [r3, #0]
    1aaa:	3310      	adds	r3, #16
    1aac:	681b      	ldr	r3, [r3, #0]
    1aae:	2201      	movs	r2, #1
    1ab0:	2100      	movs	r1, #0
    1ab2:	9801      	ldr	r0, [sp, #4]
    1ab4:	4798      	blx	r3
    1ab6:	4603      	mov	r3, r0
    }
    1ab8:	4618      	mov	r0, r3
    1aba:	b003      	add	sp, #12
    1abc:	f85d fb04 	ldr.w	pc, [sp], #4

00001ac0 <_ZN4mbed10FileHandle6rewindEv>:
    virtual void rewind()
    1ac0:	b500      	push	{lr}
    1ac2:	b083      	sub	sp, #12
    1ac4:	9001      	str	r0, [sp, #4]
        seek(0, SEEK_SET);
    1ac6:	9b01      	ldr	r3, [sp, #4]
    1ac8:	681b      	ldr	r3, [r3, #0]
    1aca:	3310      	adds	r3, #16
    1acc:	681b      	ldr	r3, [r3, #0]
    1ace:	2200      	movs	r2, #0
    1ad0:	2100      	movs	r1, #0
    1ad2:	9801      	ldr	r0, [sp, #4]
    1ad4:	4798      	blx	r3
    }
    1ad6:	bf00      	nop
    1ad8:	b003      	add	sp, #12
    1ada:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00001ae0 <_ZN4mbed10FileHandleC1Ev>:
class FileHandle : private NonCopyable<FileHandle> {
    1ae0:	b500      	push	{lr}
    1ae2:	b083      	sub	sp, #12
    1ae4:	9001      	str	r0, [sp, #4]
    1ae6:	9801      	ldr	r0, [sp, #4]
    1ae8:	f000 f810 	bl	1b0c <_ZN4mbed11NonCopyableINS_10FileHandleEEC1Ev>
    1aec:	4a03      	ldr	r2, [pc, #12]	; (1afc <_ZN4mbed10FileHandleC1Ev+0x1c>)
    1aee:	9b01      	ldr	r3, [sp, #4]
    1af0:	601a      	str	r2, [r3, #0]
    1af2:	9b01      	ldr	r3, [sp, #4]
    1af4:	4618      	mov	r0, r3
    1af6:	b003      	add	sp, #12
    1af8:	f85d fb04 	ldr.w	pc, [sp], #4
    1afc:	00012534 	.word	0x00012534

00001b00 <_ZN4mbed11NonCopyableINS_10FileHandleEED1Ev>:
     */
    NonCopyable() { }
    /**
     * Disallow destruction of NonCopyable objects from outside of its hierarchy.
     */
    ~NonCopyable() { }
    1b00:	b082      	sub	sp, #8
    1b02:	9001      	str	r0, [sp, #4]
    1b04:	9b01      	ldr	r3, [sp, #4]
    1b06:	4618      	mov	r0, r3
    1b08:	b002      	add	sp, #8
    1b0a:	4770      	bx	lr

00001b0c <_ZN4mbed11NonCopyableINS_10FileHandleEEC1Ev>:
    NonCopyable() { }
    1b0c:	b082      	sub	sp, #8
    1b0e:	9001      	str	r0, [sp, #4]
    1b10:	9b01      	ldr	r3, [sp, #4]
    1b12:	4618      	mov	r0, r3
    1b14:	b002      	add	sp, #8
    1b16:	4770      	bx	lr

00001b18 <_ZN13StorageVolumeC1Ev>:

class StorageVolume {
public:
    MBED_DEPRECATED_SINCE("mbed-os-5.5", "StorageVolume is deprecated. "
                          "Use MBRBlockDevice for volumes instead")
    StorageVolume() : allocated(false) { /* empty */ }
    1b18:	b082      	sub	sp, #8
    1b1a:	9001      	str	r0, [sp, #4]
    1b1c:	9b01      	ldr	r3, [sp, #4]
    1b1e:	2200      	movs	r2, #0
    1b20:	701a      	strb	r2, [r3, #0]
    1b22:	9b01      	ldr	r3, [sp, #4]
    1b24:	4618      	mov	r0, r3
    1b26:	b002      	add	sp, #8
    1b28:	4770      	bx	lr

00001b2a <_ZN20StorageVolumeManagerC1Ev>:

class StorageVolumeManager {
public:
    MBED_DEPRECATED_SINCE("mbed-os-5.5", "StorageVolumeManager is deprecated. "
                          "Use MBRBlockDevice to manage volumes instead")
    StorageVolumeManager()  { /* empty */ }
    1b2a:	b530      	push	{r4, r5, lr}
    1b2c:	b083      	sub	sp, #12
    1b2e:	9001      	str	r0, [sp, #4]
    1b30:	9b01      	ldr	r3, [sp, #4]
    1b32:	3338      	adds	r3, #56	; 0x38
    1b34:	2403      	movs	r4, #3
    1b36:	461d      	mov	r5, r3
    1b38:	2c00      	cmp	r4, #0
    1b3a:	db05      	blt.n	1b48 <_ZN20StorageVolumeManagerC1Ev+0x1e>
    1b3c:	4628      	mov	r0, r5
    1b3e:	f7ff ffeb 	bl	1b18 <_ZN13StorageVolumeC1Ev>
    1b42:	3520      	adds	r5, #32
    1b44:	3c01      	subs	r4, #1
    1b46:	e7f7      	b.n	1b38 <_ZN20StorageVolumeManagerC1Ev+0xe>
    1b48:	9b01      	ldr	r3, [sp, #4]
    1b4a:	4618      	mov	r0, r3
    1b4c:	b003      	add	sp, #12
    1b4e:	bd30      	pop	{r4, r5, pc}

00001b50 <_ZN20StorageVolumeManagerD1Ev>:
    ~StorageVolumeManager() { /* empty */ }
    1b50:	b082      	sub	sp, #8
    1b52:	9001      	str	r0, [sp, #4]
    1b54:	9b01      	ldr	r3, [sp, #4]
    1b56:	4618      	mov	r0, r3
    1b58:	b002      	add	sp, #8
    1b5a:	4770      	bx	lr

00001b5c <_Z41__static_initialization_and_destruction_0ii>:
    if(ret < ARM_DRIVER_OK) {
        CFSTORE_ERRLOG("%s:debug: storage_mtd->initialize() failed for storage_mtd=%p (ret=%d)", __func__, storage_mtd, (int) ret);
        return ret;
    }
    return ret;
}
    1b5c:	b500      	push	{lr}
    1b5e:	b083      	sub	sp, #12
    1b60:	9001      	str	r0, [sp, #4]
    1b62:	9100      	str	r1, [sp, #0]
    1b64:	9b01      	ldr	r3, [sp, #4]
    1b66:	2b01      	cmp	r3, #1
    1b68:	d10c      	bne.n	1b84 <_Z41__static_initialization_and_destruction_0ii+0x28>
    1b6a:	9b00      	ldr	r3, [sp, #0]
    1b6c:	f64f 72ff 	movw	r2, #65535	; 0xffff
    1b70:	4293      	cmp	r3, r2
    1b72:	d107      	bne.n	1b84 <_Z41__static_initialization_and_destruction_0ii+0x28>
StorageVolumeManager volumeManager;
    1b74:	4805      	ldr	r0, [pc, #20]	; (1b8c <_Z41__static_initialization_and_destruction_0ii+0x30>)
    1b76:	f7ff ffd8 	bl	1b2a <_ZN20StorageVolumeManagerC1Ev>
    1b7a:	4a05      	ldr	r2, [pc, #20]	; (1b90 <_Z41__static_initialization_and_destruction_0ii+0x34>)
    1b7c:	4905      	ldr	r1, [pc, #20]	; (1b94 <_Z41__static_initialization_and_destruction_0ii+0x38>)
    1b7e:	4803      	ldr	r0, [pc, #12]	; (1b8c <_Z41__static_initialization_and_destruction_0ii+0x30>)
    1b80:	f001 ff88 	bl	3a94 <__aeabi_atexit>
}
    1b84:	bf00      	nop
    1b86:	b003      	add	sp, #12
    1b88:	f85d fb04 	ldr.w	pc, [sp], #4
    1b8c:	20000ba0 	.word	0x20000ba0
    1b90:	20000000 	.word	0x20000000
    1b94:	00001b51 	.word	0x00001b51

00001b98 <_GLOBAL__sub_I_volumeManager>:
    1b98:	b508      	push	{r3, lr}
    1b9a:	f64f 71ff 	movw	r1, #65535	; 0xffff
    1b9e:	2001      	movs	r0, #1
    1ba0:	f7ff ffdc 	bl	1b5c <_Z41__static_initialization_and_destruction_0ii>
    1ba4:	bd08      	pop	{r3, pc}

00001ba6 <are_interrupts_enabled>:

static volatile bool critical_interrupts_enabled = false;
static volatile bool state_saved = false;

static bool are_interrupts_enabled(void)
{
    1ba6:	b082      	sub	sp, #8
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    1ba8:	f3ef 8310 	mrs	r3, PRIMASK
    1bac:	9301      	str	r3, [sp, #4]
  return(result);
    1bae:	9b01      	ldr	r3, [sp, #4]
#if defined(__CORTEX_A9)
    return ((__get_CPSR() & 0x80) == 0);
#else
    return ((__get_PRIMASK() & 0x1) == 0);
    1bb0:	f003 0301 	and.w	r3, r3, #1
    1bb4:	2b00      	cmp	r3, #0
    1bb6:	bf0c      	ite	eq
    1bb8:	2301      	moveq	r3, #1
    1bba:	2300      	movne	r3, #0
    1bbc:	b2db      	uxtb	r3, r3
#endif
}
    1bbe:	4618      	mov	r0, r3
    1bc0:	b002      	add	sp, #8
    1bc2:	4770      	bx	lr

00001bc4 <hal_critical_section_enter>:


MBED_WEAK void hal_critical_section_enter(void)
{
    1bc4:	b500      	push	{lr}
    1bc6:	b083      	sub	sp, #12
    const bool interrupt_state = are_interrupts_enabled();
    1bc8:	f7ff ffed 	bl	1ba6 <are_interrupts_enabled>
    1bcc:	4603      	mov	r3, r0
    1bce:	f88d 3007 	strb.w	r3, [sp, #7]
  __ASM volatile ("cpsid i" : : : "memory");
    1bd2:	b672      	cpsid	i

    __disable_irq();

    if (state_saved == true) {
    1bd4:	4b08      	ldr	r3, [pc, #32]	; (1bf8 <hal_critical_section_enter+0x34>)
    1bd6:	781b      	ldrb	r3, [r3, #0]
    1bd8:	b2db      	uxtb	r3, r3
    1bda:	2b00      	cmp	r3, #0
    1bdc:	d107      	bne.n	1bee <hal_critical_section_enter+0x2a>
        return;
    }

    critical_interrupts_enabled = interrupt_state;
    1bde:	4a07      	ldr	r2, [pc, #28]	; (1bfc <hal_critical_section_enter+0x38>)
    1be0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1be4:	7013      	strb	r3, [r2, #0]
    state_saved = true;
    1be6:	4b04      	ldr	r3, [pc, #16]	; (1bf8 <hal_critical_section_enter+0x34>)
    1be8:	2201      	movs	r2, #1
    1bea:	701a      	strb	r2, [r3, #0]
    1bec:	e000      	b.n	1bf0 <hal_critical_section_enter+0x2c>
        return;
    1bee:	bf00      	nop
}
    1bf0:	b003      	add	sp, #12
    1bf2:	f85d fb04 	ldr.w	pc, [sp], #4
    1bf6:	bf00      	nop
    1bf8:	20000c59 	.word	0x20000c59
    1bfc:	20000c58 	.word	0x20000c58

00001c00 <hal_critical_section_exit>:

MBED_WEAK void hal_critical_section_exit(void)
{
    1c00:	b508      	push	{r3, lr}
#ifndef FEATURE_UVISOR
    // Interrupts must be disabled on invoking an exit from a critical section
    MBED_ASSERT(!are_interrupts_enabled());
    1c02:	f7ff ffd0 	bl	1ba6 <are_interrupts_enabled>
    1c06:	4603      	mov	r3, r0
    1c08:	2b00      	cmp	r3, #0
    1c0a:	d004      	beq.n	1c16 <hal_critical_section_exit+0x16>
    1c0c:	2236      	movs	r2, #54	; 0x36
    1c0e:	4907      	ldr	r1, [pc, #28]	; (1c2c <hal_critical_section_exit+0x2c>)
    1c10:	4807      	ldr	r0, [pc, #28]	; (1c30 <hal_critical_section_exit+0x30>)
    1c12:	f000 feff 	bl	2a14 <mbed_assert_internal>
#endif
    state_saved = false;
    1c16:	4b07      	ldr	r3, [pc, #28]	; (1c34 <hal_critical_section_exit+0x34>)
    1c18:	2200      	movs	r2, #0
    1c1a:	701a      	strb	r2, [r3, #0]

    // Restore the IRQs to their state prior to entering the critical section
    if (critical_interrupts_enabled == true) {
    1c1c:	4b06      	ldr	r3, [pc, #24]	; (1c38 <hal_critical_section_exit+0x38>)
    1c1e:	781b      	ldrb	r3, [r3, #0]
    1c20:	b2db      	uxtb	r3, r3
    1c22:	2b00      	cmp	r3, #0
    1c24:	d000      	beq.n	1c28 <hal_critical_section_exit+0x28>
  __ASM volatile ("cpsie i" : : : "memory");
    1c26:	b662      	cpsie	i
        __enable_irq();
    }
}
    1c28:	bf00      	nop
    1c2a:	bd08      	pop	{r3, pc}
    1c2c:	00010a84 	.word	0x00010a84
    1c30:	00010ab0 	.word	0x00010ab0
    1c34:	20000c59 	.word	0x20000c59
    1c38:	20000c58 	.word	0x20000c58

00001c3c <_gpio_init_in>:
 * limitations under the License.
 */
#include "hal/gpio_api.h"

static inline void _gpio_init_in(gpio_t *gpio, PinName pin, PinMode mode)
{
    1c3c:	b500      	push	{lr}
    1c3e:	b085      	sub	sp, #20
    1c40:	9003      	str	r0, [sp, #12]
    1c42:	9102      	str	r1, [sp, #8]
    1c44:	4613      	mov	r3, r2
    1c46:	f88d 3007 	strb.w	r3, [sp, #7]
    gpio_init(gpio, pin);
    1c4a:	9902      	ldr	r1, [sp, #8]
    1c4c:	9803      	ldr	r0, [sp, #12]
    1c4e:	f008 fa05 	bl	a05c <gpio_init>
    if (pin != NC) {
    1c52:	9b02      	ldr	r3, [sp, #8]
    1c54:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1c58:	d009      	beq.n	1c6e <_gpio_init_in+0x32>
        gpio_dir(gpio, PIN_INPUT);
    1c5a:	2100      	movs	r1, #0
    1c5c:	9803      	ldr	r0, [sp, #12]
    1c5e:	f008 fa23 	bl	a0a8 <gpio_dir>
        gpio_mode(gpio, mode);
    1c62:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1c66:	4619      	mov	r1, r3
    1c68:	9803      	ldr	r0, [sp, #12]
    1c6a:	f008 fa0b 	bl	a084 <gpio_mode>
    }
}
    1c6e:	bf00      	nop
    1c70:	b005      	add	sp, #20
    1c72:	f85d fb04 	ldr.w	pc, [sp], #4

00001c76 <_gpio_init_out>:

static inline void _gpio_init_out(gpio_t *gpio, PinName pin, PinMode mode, int value)
{
    1c76:	b500      	push	{lr}
    1c78:	b085      	sub	sp, #20
    1c7a:	9003      	str	r0, [sp, #12]
    1c7c:	9102      	str	r1, [sp, #8]
    1c7e:	9300      	str	r3, [sp, #0]
    1c80:	4613      	mov	r3, r2
    1c82:	f88d 3007 	strb.w	r3, [sp, #7]
    gpio_init(gpio, pin);
    1c86:	9902      	ldr	r1, [sp, #8]
    1c88:	9803      	ldr	r0, [sp, #12]
    1c8a:	f008 f9e7 	bl	a05c <gpio_init>
    if (pin != NC) {
    1c8e:	9b02      	ldr	r3, [sp, #8]
    1c90:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1c94:	d00d      	beq.n	1cb2 <_gpio_init_out+0x3c>
        gpio_write(gpio, value);
    1c96:	9900      	ldr	r1, [sp, #0]
    1c98:	9803      	ldr	r0, [sp, #12]
    1c9a:	f008 fa49 	bl	a130 <gpio_write>
        gpio_dir(gpio, PIN_OUTPUT);
    1c9e:	2101      	movs	r1, #1
    1ca0:	9803      	ldr	r0, [sp, #12]
    1ca2:	f008 fa01 	bl	a0a8 <gpio_dir>
        gpio_mode(gpio, mode);
    1ca6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1caa:	4619      	mov	r1, r3
    1cac:	9803      	ldr	r0, [sp, #12]
    1cae:	f008 f9e9 	bl	a084 <gpio_mode>
    }
}
    1cb2:	bf00      	nop
    1cb4:	b005      	add	sp, #20
    1cb6:	f85d fb04 	ldr.w	pc, [sp], #4

00001cba <gpio_init_in>:

void gpio_init_in(gpio_t *gpio, PinName pin)
{
    1cba:	b500      	push	{lr}
    1cbc:	b083      	sub	sp, #12
    1cbe:	9001      	str	r0, [sp, #4]
    1cc0:	9100      	str	r1, [sp, #0]
    gpio_init_in_ex(gpio, pin, PullDefault);
    1cc2:	2202      	movs	r2, #2
    1cc4:	9900      	ldr	r1, [sp, #0]
    1cc6:	9801      	ldr	r0, [sp, #4]
    1cc8:	f000 f804 	bl	1cd4 <gpio_init_in_ex>
}
    1ccc:	bf00      	nop
    1cce:	b003      	add	sp, #12
    1cd0:	f85d fb04 	ldr.w	pc, [sp], #4

00001cd4 <gpio_init_in_ex>:

void gpio_init_in_ex(gpio_t *gpio, PinName pin, PinMode mode)
{
    1cd4:	b500      	push	{lr}
    1cd6:	b085      	sub	sp, #20
    1cd8:	9003      	str	r0, [sp, #12]
    1cda:	9102      	str	r1, [sp, #8]
    1cdc:	4613      	mov	r3, r2
    1cde:	f88d 3007 	strb.w	r3, [sp, #7]
    _gpio_init_in(gpio, pin, mode);
    1ce2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1ce6:	461a      	mov	r2, r3
    1ce8:	9902      	ldr	r1, [sp, #8]
    1cea:	9803      	ldr	r0, [sp, #12]
    1cec:	f7ff ffa6 	bl	1c3c <_gpio_init_in>
}
    1cf0:	bf00      	nop
    1cf2:	b005      	add	sp, #20
    1cf4:	f85d fb04 	ldr.w	pc, [sp], #4

00001cf8 <gpio_init_out>:

void gpio_init_out(gpio_t *gpio, PinName pin)
{
    1cf8:	b500      	push	{lr}
    1cfa:	b083      	sub	sp, #12
    1cfc:	9001      	str	r0, [sp, #4]
    1cfe:	9100      	str	r1, [sp, #0]
    gpio_init_out_ex(gpio, pin, 0);
    1d00:	2200      	movs	r2, #0
    1d02:	9900      	ldr	r1, [sp, #0]
    1d04:	9801      	ldr	r0, [sp, #4]
    1d06:	f000 f804 	bl	1d12 <gpio_init_out_ex>
}
    1d0a:	bf00      	nop
    1d0c:	b003      	add	sp, #12
    1d0e:	f85d fb04 	ldr.w	pc, [sp], #4

00001d12 <gpio_init_out_ex>:

void gpio_init_out_ex(gpio_t *gpio, PinName pin, int value)
{
    1d12:	b500      	push	{lr}
    1d14:	b085      	sub	sp, #20
    1d16:	9003      	str	r0, [sp, #12]
    1d18:	9102      	str	r1, [sp, #8]
    1d1a:	9201      	str	r2, [sp, #4]
    _gpio_init_out(gpio, pin, PullNone, value);
    1d1c:	9b01      	ldr	r3, [sp, #4]
    1d1e:	2200      	movs	r2, #0
    1d20:	9902      	ldr	r1, [sp, #8]
    1d22:	9803      	ldr	r0, [sp, #12]
    1d24:	f7ff ffa7 	bl	1c76 <_gpio_init_out>
}
    1d28:	bf00      	nop
    1d2a:	b005      	add	sp, #20
    1d2c:	f85d fb04 	ldr.w	pc, [sp], #4

00001d30 <pinmap_pinout>:
 */
#include "hal/pinmap.h"
#include "platform/mbed_error.h"

void pinmap_pinout(PinName pin, const PinMap *map)
{
    1d30:	b500      	push	{lr}
    1d32:	b085      	sub	sp, #20
    1d34:	9003      	str	r0, [sp, #12]
    1d36:	9102      	str	r1, [sp, #8]
    if (pin == NC) {
    1d38:	9b03      	ldr	r3, [sp, #12]
    1d3a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1d3e:	d021      	beq.n	1d84 <pinmap_pinout+0x54>
        return;
    }

    while (map->pin != NC) {
    1d40:	e012      	b.n	1d68 <pinmap_pinout+0x38>
        if (map->pin == pin) {
    1d42:	9b02      	ldr	r3, [sp, #8]
    1d44:	681a      	ldr	r2, [r3, #0]
    1d46:	9b03      	ldr	r3, [sp, #12]
    1d48:	429a      	cmp	r2, r3
    1d4a:	d10a      	bne.n	1d62 <pinmap_pinout+0x32>
            pin_function(pin, map->function);
    1d4c:	9b02      	ldr	r3, [sp, #8]
    1d4e:	689b      	ldr	r3, [r3, #8]
    1d50:	4619      	mov	r1, r3
    1d52:	9803      	ldr	r0, [sp, #12]
    1d54:	f008 fa46 	bl	a1e4 <pin_function>

            pin_mode(pin, PullNone);
    1d58:	2100      	movs	r1, #0
    1d5a:	9803      	ldr	r0, [sp, #12]
    1d5c:	f008 fa78 	bl	a250 <pin_mode>
            return;
    1d60:	e011      	b.n	1d86 <pinmap_pinout+0x56>
        }
        map++;
    1d62:	9b02      	ldr	r3, [sp, #8]
    1d64:	330c      	adds	r3, #12
    1d66:	9302      	str	r3, [sp, #8]
    while (map->pin != NC) {
    1d68:	9b02      	ldr	r3, [sp, #8]
    1d6a:	681b      	ldr	r3, [r3, #0]
    1d6c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1d70:	d1e7      	bne.n	1d42 <pinmap_pinout+0x12>
    }
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_PINMAP_INVALID), "could not pinout", pin);
    1d72:	9a03      	ldr	r2, [sp, #12]
    1d74:	2300      	movs	r3, #0
    1d76:	9300      	str	r3, [sp, #0]
    1d78:	2300      	movs	r3, #0
    1d7a:	4904      	ldr	r1, [pc, #16]	; (1d8c <pinmap_pinout+0x5c>)
    1d7c:	4804      	ldr	r0, [pc, #16]	; (1d90 <pinmap_pinout+0x60>)
    1d7e:	f001 f82b 	bl	2dd8 <mbed_error>
    1d82:	e000      	b.n	1d86 <pinmap_pinout+0x56>
        return;
    1d84:	bf00      	nop
}
    1d86:	b005      	add	sp, #20
    1d88:	f85d fb04 	ldr.w	pc, [sp], #4
    1d8c:	00010acc 	.word	0x00010acc
    1d90:	80010130 	.word	0x80010130

00001d94 <pinmap_merge>:

uint32_t pinmap_merge(uint32_t a, uint32_t b)
{
    1d94:	b500      	push	{lr}
    1d96:	b085      	sub	sp, #20
    1d98:	9003      	str	r0, [sp, #12]
    1d9a:	9102      	str	r1, [sp, #8]
    // both are the same (inc both NC)
    if (a == b) {
    1d9c:	9a03      	ldr	r2, [sp, #12]
    1d9e:	9b02      	ldr	r3, [sp, #8]
    1da0:	429a      	cmp	r2, r3
    1da2:	d101      	bne.n	1da8 <pinmap_merge+0x14>
        return a;
    1da4:	9b03      	ldr	r3, [sp, #12]
    1da6:	e015      	b.n	1dd4 <pinmap_merge+0x40>
    }

    // one (or both) is not connected
    if (a == (uint32_t)NC) {
    1da8:	9b03      	ldr	r3, [sp, #12]
    1daa:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1dae:	d101      	bne.n	1db4 <pinmap_merge+0x20>
        return b;
    1db0:	9b02      	ldr	r3, [sp, #8]
    1db2:	e00f      	b.n	1dd4 <pinmap_merge+0x40>
    }
    if (b == (uint32_t)NC) {
    1db4:	9b02      	ldr	r3, [sp, #8]
    1db6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1dba:	d101      	bne.n	1dc0 <pinmap_merge+0x2c>
        return a;
    1dbc:	9b03      	ldr	r3, [sp, #12]
    1dbe:	e009      	b.n	1dd4 <pinmap_merge+0x40>
    }

    // mis-match error case
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_PINMAP_INVALID), "pinmap mis-match", a);
    1dc0:	2300      	movs	r3, #0
    1dc2:	9300      	str	r3, [sp, #0]
    1dc4:	2300      	movs	r3, #0
    1dc6:	9a03      	ldr	r2, [sp, #12]
    1dc8:	4904      	ldr	r1, [pc, #16]	; (1ddc <pinmap_merge+0x48>)
    1dca:	4805      	ldr	r0, [pc, #20]	; (1de0 <pinmap_merge+0x4c>)
    1dcc:	f001 f804 	bl	2dd8 <mbed_error>
    return (uint32_t)NC;
    1dd0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
    1dd4:	4618      	mov	r0, r3
    1dd6:	b005      	add	sp, #20
    1dd8:	f85d fb04 	ldr.w	pc, [sp], #4
    1ddc:	00010ae0 	.word	0x00010ae0
    1de0:	80010130 	.word	0x80010130

00001de4 <pinmap_find_peripheral>:

uint32_t pinmap_find_peripheral(PinName pin, const PinMap *map)
{
    1de4:	b082      	sub	sp, #8
    1de6:	9001      	str	r0, [sp, #4]
    1de8:	9100      	str	r1, [sp, #0]
    while (map->pin != NC) {
    1dea:	e00a      	b.n	1e02 <pinmap_find_peripheral+0x1e>
        if (map->pin == pin) {
    1dec:	9b00      	ldr	r3, [sp, #0]
    1dee:	681a      	ldr	r2, [r3, #0]
    1df0:	9b01      	ldr	r3, [sp, #4]
    1df2:	429a      	cmp	r2, r3
    1df4:	d102      	bne.n	1dfc <pinmap_find_peripheral+0x18>
            return map->peripheral;
    1df6:	9b00      	ldr	r3, [sp, #0]
    1df8:	685b      	ldr	r3, [r3, #4]
    1dfa:	e009      	b.n	1e10 <pinmap_find_peripheral+0x2c>
        }
        map++;
    1dfc:	9b00      	ldr	r3, [sp, #0]
    1dfe:	330c      	adds	r3, #12
    1e00:	9300      	str	r3, [sp, #0]
    while (map->pin != NC) {
    1e02:	9b00      	ldr	r3, [sp, #0]
    1e04:	681b      	ldr	r3, [r3, #0]
    1e06:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1e0a:	d1ef      	bne.n	1dec <pinmap_find_peripheral+0x8>
    }
    return (uint32_t)NC;
    1e0c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
    1e10:	4618      	mov	r0, r3
    1e12:	b002      	add	sp, #8
    1e14:	4770      	bx	lr
	...

00001e18 <pinmap_peripheral>:

uint32_t pinmap_peripheral(PinName pin, const PinMap *map)
{
    1e18:	b500      	push	{lr}
    1e1a:	b087      	sub	sp, #28
    1e1c:	9003      	str	r0, [sp, #12]
    1e1e:	9102      	str	r1, [sp, #8]
    uint32_t peripheral = (uint32_t)NC;
    1e20:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1e24:	9305      	str	r3, [sp, #20]

    if (pin == (PinName)NC) {
    1e26:	9b03      	ldr	r3, [sp, #12]
    1e28:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1e2c:	d102      	bne.n	1e34 <pinmap_peripheral+0x1c>
        return (uint32_t)NC;
    1e2e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1e32:	e011      	b.n	1e58 <pinmap_peripheral+0x40>
    }
    peripheral = pinmap_find_peripheral(pin, map);
    1e34:	9902      	ldr	r1, [sp, #8]
    1e36:	9803      	ldr	r0, [sp, #12]
    1e38:	f7ff ffd4 	bl	1de4 <pinmap_find_peripheral>
    1e3c:	9005      	str	r0, [sp, #20]
    if ((uint32_t)NC == peripheral) { // no mapping available
    1e3e:	9b05      	ldr	r3, [sp, #20]
    1e40:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1e44:	d107      	bne.n	1e56 <pinmap_peripheral+0x3e>
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_PINMAP_INVALID), "pinmap not found for peripheral", peripheral);
    1e46:	2300      	movs	r3, #0
    1e48:	9300      	str	r3, [sp, #0]
    1e4a:	2300      	movs	r3, #0
    1e4c:	9a05      	ldr	r2, [sp, #20]
    1e4e:	4904      	ldr	r1, [pc, #16]	; (1e60 <pinmap_peripheral+0x48>)
    1e50:	4804      	ldr	r0, [pc, #16]	; (1e64 <pinmap_peripheral+0x4c>)
    1e52:	f000 ffc1 	bl	2dd8 <mbed_error>
    }
    return peripheral;
    1e56:	9b05      	ldr	r3, [sp, #20]
}
    1e58:	4618      	mov	r0, r3
    1e5a:	b007      	add	sp, #28
    1e5c:	f85d fb04 	ldr.w	pc, [sp], #4
    1e60:	00010af4 	.word	0x00010af4
    1e64:	80010130 	.word	0x80010130

00001e68 <read_us>:
#if defined(MBED_CPU_STATS_ENABLED) && defined(DEVICE_LPTICKER)
static ticker_data_t *sleep_ticker = NULL;
#endif

static inline us_timestamp_t read_us(void)
{
    1e68:	b410      	push	{r4}
    if (NULL == sleep_ticker) {
        sleep_ticker = (ticker_data_t *)get_lp_ticker_data();
    }
    return ticker_read_us(sleep_ticker);
#else
    return 0;
    1e6a:	f04f 0300 	mov.w	r3, #0
    1e6e:	f04f 0400 	mov.w	r4, #0
#endif
}
    1e72:	4618      	mov	r0, r3
    1e74:	4621      	mov	r1, r4
    1e76:	f85d 4b04 	ldr.w	r4, [sp], #4
    1e7a:	4770      	bx	lr

00001e7c <sleep_manager_lock_deep_sleep_internal>:
}

#endif // MBED_SLEEP_TRACING_ENABLED

void sleep_manager_lock_deep_sleep_internal(void)
{
    1e7c:	b500      	push	{lr}
    1e7e:	b083      	sub	sp, #12
    core_util_critical_section_enter();
    1e80:	f000 fe96 	bl	2bb0 <core_util_critical_section_enter>
    if (deep_sleep_lock == USHRT_MAX) {
    1e84:	4b0d      	ldr	r3, [pc, #52]	; (1ebc <sleep_manager_lock_deep_sleep_internal+0x40>)
    1e86:	881b      	ldrh	r3, [r3, #0]
    1e88:	f64f 72ff 	movw	r2, #65535	; 0xffff
    1e8c:	4293      	cmp	r3, r2
    1e8e:	d10b      	bne.n	1ea8 <sleep_manager_lock_deep_sleep_internal+0x2c>
        core_util_critical_section_exit();
    1e90:	f000 fea8 	bl	2be4 <core_util_critical_section_exit>
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_HAL, MBED_ERROR_CODE_OVERFLOW), "DeepSleepLock overflow (> USHRT_MAX)", deep_sleep_lock);
    1e94:	4b09      	ldr	r3, [pc, #36]	; (1ebc <sleep_manager_lock_deep_sleep_internal+0x40>)
    1e96:	881b      	ldrh	r3, [r3, #0]
    1e98:	461a      	mov	r2, r3
    1e9a:	2300      	movs	r3, #0
    1e9c:	9300      	str	r3, [sp, #0]
    1e9e:	2300      	movs	r3, #0
    1ea0:	4907      	ldr	r1, [pc, #28]	; (1ec0 <sleep_manager_lock_deep_sleep_internal+0x44>)
    1ea2:	4808      	ldr	r0, [pc, #32]	; (1ec4 <sleep_manager_lock_deep_sleep_internal+0x48>)
    1ea4:	f000 ff98 	bl	2dd8 <mbed_error>
    }
    core_util_atomic_incr_u16(&deep_sleep_lock, 1);
    1ea8:	2101      	movs	r1, #1
    1eaa:	4804      	ldr	r0, [pc, #16]	; (1ebc <sleep_manager_lock_deep_sleep_internal+0x40>)
    1eac:	f000 feb0 	bl	2c10 <core_util_atomic_incr_u16>
    core_util_critical_section_exit();
    1eb0:	f000 fe98 	bl	2be4 <core_util_critical_section_exit>
}
    1eb4:	bf00      	nop
    1eb6:	b003      	add	sp, #12
    1eb8:	f85d fb04 	ldr.w	pc, [sp], #4
    1ebc:	20000c5a 	.word	0x20000c5a
    1ec0:	00010b34 	.word	0x00010b34
    1ec4:	80040123 	.word	0x80040123

00001ec8 <sleep_manager_unlock_deep_sleep_internal>:

void sleep_manager_unlock_deep_sleep_internal(void)
{
    1ec8:	b500      	push	{lr}
    1eca:	b083      	sub	sp, #12
    core_util_critical_section_enter();
    1ecc:	f000 fe70 	bl	2bb0 <core_util_critical_section_enter>
    if (deep_sleep_lock == 0) {
    1ed0:	4b0c      	ldr	r3, [pc, #48]	; (1f04 <sleep_manager_unlock_deep_sleep_internal+0x3c>)
    1ed2:	881b      	ldrh	r3, [r3, #0]
    1ed4:	2b00      	cmp	r3, #0
    1ed6:	d10b      	bne.n	1ef0 <sleep_manager_unlock_deep_sleep_internal+0x28>
        core_util_critical_section_exit();
    1ed8:	f000 fe84 	bl	2be4 <core_util_critical_section_exit>
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_HAL, MBED_ERROR_CODE_UNDERFLOW), "DeepSleepLock underflow (< 0)", deep_sleep_lock);
    1edc:	4b09      	ldr	r3, [pc, #36]	; (1f04 <sleep_manager_unlock_deep_sleep_internal+0x3c>)
    1ede:	881b      	ldrh	r3, [r3, #0]
    1ee0:	461a      	mov	r2, r3
    1ee2:	2300      	movs	r3, #0
    1ee4:	9300      	str	r3, [sp, #0]
    1ee6:	2300      	movs	r3, #0
    1ee8:	4907      	ldr	r1, [pc, #28]	; (1f08 <sleep_manager_unlock_deep_sleep_internal+0x40>)
    1eea:	4808      	ldr	r0, [pc, #32]	; (1f0c <sleep_manager_unlock_deep_sleep_internal+0x44>)
    1eec:	f000 ff74 	bl	2dd8 <mbed_error>
    }
    core_util_atomic_decr_u16(&deep_sleep_lock, 1);
    1ef0:	2101      	movs	r1, #1
    1ef2:	4804      	ldr	r0, [pc, #16]	; (1f04 <sleep_manager_unlock_deep_sleep_internal+0x3c>)
    1ef4:	f000 feb2 	bl	2c5c <core_util_atomic_decr_u16>
    core_util_critical_section_exit();
    1ef8:	f000 fe74 	bl	2be4 <core_util_critical_section_exit>
}
    1efc:	bf00      	nop
    1efe:	b003      	add	sp, #12
    1f00:	f85d fb04 	ldr.w	pc, [sp], #4
    1f04:	20000c5a 	.word	0x20000c5a
    1f08:	00010b5c 	.word	0x00010b5c
    1f0c:	80040124 	.word	0x80040124

00001f10 <sleep_manager_sleep_auto>:
{
    return deep_sleep_lock == 0 ? true : false;
}

void sleep_manager_sleep_auto(void)
{
    1f10:	b510      	push	{r4, lr}
    1f12:	b086      	sub	sp, #24
#ifdef MBED_SLEEP_TRACING_ENABLED
    sleep_tracker_print_stats();
#endif
    core_util_critical_section_enter();
    1f14:	f000 fe4c 	bl	2bb0 <core_util_critical_section_enter>
    us_timestamp_t start = read_us();
    1f18:	f7ff ffa6 	bl	1e68 <read_us>
    1f1c:	e9cd 0104 	strd	r0, r1, [sp, #16]
    bool deep = false;
    1f20:	2300      	movs	r3, #0
    1f22:	f88d 300f 	strb.w	r3, [sp, #15]

// debug profile should keep debuggers attached, no deep sleep allowed
#ifdef MBED_DEBUG
    hal_sleep();
    1f26:	f008 f9f1 	bl	a30c <hal_sleep>
    } else {
        hal_sleep();
    }
#endif

    us_timestamp_t end = read_us();
    1f2a:	f7ff ff9d 	bl	1e68 <read_us>
    1f2e:	e9cd 0100 	strd	r0, r1, [sp]
    if (true == deep) {
    1f32:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1f36:	2b00      	cmp	r3, #0
    1f38:	d010      	beq.n	1f5c <sleep_manager_sleep_auto+0x4c>
        deep_sleep_time += end - start;
    1f3a:	e9dd 1200 	ldrd	r1, r2, [sp]
    1f3e:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
    1f42:	1ac9      	subs	r1, r1, r3
    1f44:	eb62 0204 	sbc.w	r2, r2, r4
    1f48:	4b0f      	ldr	r3, [pc, #60]	; (1f88 <sleep_manager_sleep_auto+0x78>)
    1f4a:	e9d3 3400 	ldrd	r3, r4, [r3]
    1f4e:	185b      	adds	r3, r3, r1
    1f50:	eb44 0402 	adc.w	r4, r4, r2
    1f54:	4a0c      	ldr	r2, [pc, #48]	; (1f88 <sleep_manager_sleep_auto+0x78>)
    1f56:	e9c2 3400 	strd	r3, r4, [r2]
    1f5a:	e00f      	b.n	1f7c <sleep_manager_sleep_auto+0x6c>
    } else {
        sleep_time += end - start;
    1f5c:	e9dd 1200 	ldrd	r1, r2, [sp]
    1f60:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
    1f64:	1ac9      	subs	r1, r1, r3
    1f66:	eb62 0204 	sbc.w	r2, r2, r4
    1f6a:	4b08      	ldr	r3, [pc, #32]	; (1f8c <sleep_manager_sleep_auto+0x7c>)
    1f6c:	e9d3 3400 	ldrd	r3, r4, [r3]
    1f70:	185b      	adds	r3, r3, r1
    1f72:	eb44 0402 	adc.w	r4, r4, r2
    1f76:	4a05      	ldr	r2, [pc, #20]	; (1f8c <sleep_manager_sleep_auto+0x7c>)
    1f78:	e9c2 3400 	strd	r3, r4, [r2]
    }
    core_util_critical_section_exit();
    1f7c:	f000 fe32 	bl	2be4 <core_util_critical_section_exit>
}
    1f80:	bf00      	nop
    1f82:	b006      	add	sp, #24
    1f84:	bd10      	pop	{r4, pc}
    1f86:	bf00      	nop
    1f88:	20000c68 	.word	0x20000c68
    1f8c:	20000c60 	.word	0x20000c60

00001f90 <initialize>:

/*
 * Initialize a ticker instance.
 */
static void initialize(const ticker_data_t *ticker)
{
    1f90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1f94:	b08c      	sub	sp, #48	; 0x30
    1f96:	9003      	str	r0, [sp, #12]
    // return if the queue has already been initialized, in that case the
    // interface used by the queue is already initialized.
    if (ticker->queue->initialized) {
    1f98:	9b03      	ldr	r3, [sp, #12]
    1f9a:	685b      	ldr	r3, [r3, #4]
    1f9c:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
    1fa0:	2b00      	cmp	r3, #0
    1fa2:	f040 80e4 	bne.w	216e <initialize+0x1de>
        return;
    }

    ticker->interface->init();
    1fa6:	9b03      	ldr	r3, [sp, #12]
    1fa8:	681b      	ldr	r3, [r3, #0]
    1faa:	681b      	ldr	r3, [r3, #0]
    1fac:	4798      	blx	r3

    const ticker_info_t *info = ticker->interface->get_info();
    1fae:	9b03      	ldr	r3, [sp, #12]
    1fb0:	681b      	ldr	r3, [r3, #0]
    1fb2:	699b      	ldr	r3, [r3, #24]
    1fb4:	4798      	blx	r3
    1fb6:	9008      	str	r0, [sp, #32]
    uint32_t frequency = info->frequency;
    1fb8:	9b08      	ldr	r3, [sp, #32]
    1fba:	681b      	ldr	r3, [r3, #0]
    1fbc:	930b      	str	r3, [sp, #44]	; 0x2c
    if (info->frequency == 0) {
    1fbe:	9b08      	ldr	r3, [sp, #32]
    1fc0:	681b      	ldr	r3, [r3, #0]
    1fc2:	2b00      	cmp	r3, #0
    1fc4:	d106      	bne.n	1fd4 <initialize+0x44>
        MBED_ASSERT(0);
    1fc6:	2229      	movs	r2, #41	; 0x29
    1fc8:	496b      	ldr	r1, [pc, #428]	; (2178 <initialize+0x1e8>)
    1fca:	486c      	ldr	r0, [pc, #432]	; (217c <initialize+0x1ec>)
    1fcc:	f000 fd22 	bl	2a14 <mbed_assert_internal>
        frequency = 1000000;
    1fd0:	4b6b      	ldr	r3, [pc, #428]	; (2180 <initialize+0x1f0>)
    1fd2:	930b      	str	r3, [sp, #44]	; 0x2c
    }

    uint8_t frequency_shifts = 0;
    1fd4:	2300      	movs	r3, #0
    1fd6:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
    for (uint8_t i = 31; i > 0; --i) {
    1fda:	231f      	movs	r3, #31
    1fdc:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    1fe0:	e012      	b.n	2008 <initialize+0x78>
        if ((1 << i) == frequency) {
    1fe2:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
    1fe6:	2201      	movs	r2, #1
    1fe8:	fa02 f303 	lsl.w	r3, r2, r3
    1fec:	461a      	mov	r2, r3
    1fee:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1ff0:	429a      	cmp	r2, r3
    1ff2:	d104      	bne.n	1ffe <initialize+0x6e>
            frequency_shifts = i;
    1ff4:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
    1ff8:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
            break;
    1ffc:	e008      	b.n	2010 <initialize+0x80>
    for (uint8_t i = 31; i > 0; --i) {
    1ffe:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
    2002:	3b01      	subs	r3, #1
    2004:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    2008:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
    200c:	2b00      	cmp	r3, #0
    200e:	d1e8      	bne.n	1fe2 <initialize+0x52>
        }
    }

    uint32_t bits = info->bits;
    2010:	9b08      	ldr	r3, [sp, #32]
    2012:	685b      	ldr	r3, [r3, #4]
    2014:	9309      	str	r3, [sp, #36]	; 0x24
    if ((info->bits > 32) || (info->bits < 4)) {
    2016:	9b08      	ldr	r3, [sp, #32]
    2018:	685b      	ldr	r3, [r3, #4]
    201a:	2b20      	cmp	r3, #32
    201c:	d803      	bhi.n	2026 <initialize+0x96>
    201e:	9b08      	ldr	r3, [sp, #32]
    2020:	685b      	ldr	r3, [r3, #4]
    2022:	2b03      	cmp	r3, #3
    2024:	d806      	bhi.n	2034 <initialize+0xa4>
        MBED_ASSERT(0);
    2026:	2237      	movs	r2, #55	; 0x37
    2028:	4953      	ldr	r1, [pc, #332]	; (2178 <initialize+0x1e8>)
    202a:	4854      	ldr	r0, [pc, #336]	; (217c <initialize+0x1ec>)
    202c:	f000 fcf2 	bl	2a14 <mbed_assert_internal>
        bits = 32;
    2030:	2320      	movs	r3, #32
    2032:	9309      	str	r3, [sp, #36]	; 0x24
    }
    uint32_t max_delta = 0x7 << (bits - 4); // 7/16th
    2034:	9b09      	ldr	r3, [sp, #36]	; 0x24
    2036:	3b04      	subs	r3, #4
    2038:	2207      	movs	r2, #7
    203a:	fa02 f303 	lsl.w	r3, r2, r3
    203e:	9307      	str	r3, [sp, #28]
    uint64_t max_delta_us =
        ((uint64_t)max_delta * 1000000 + frequency - 1) / frequency;
    2040:	9b07      	ldr	r3, [sp, #28]
    2042:	4619      	mov	r1, r3
    2044:	f04f 0200 	mov.w	r2, #0
    2048:	460b      	mov	r3, r1
    204a:	4614      	mov	r4, r2
    204c:	0160      	lsls	r0, r4, #5
    204e:	9001      	str	r0, [sp, #4]
    2050:	9801      	ldr	r0, [sp, #4]
    2052:	ea40 60d3 	orr.w	r0, r0, r3, lsr #27
    2056:	9001      	str	r0, [sp, #4]
    2058:	015b      	lsls	r3, r3, #5
    205a:	9300      	str	r3, [sp, #0]
    205c:	e9dd 3400 	ldrd	r3, r4, [sp]
    2060:	1a5b      	subs	r3, r3, r1
    2062:	eb64 0402 	sbc.w	r4, r4, r2
    2066:	ea4f 2a44 	mov.w	sl, r4, lsl #9
    206a:	ea4a 5ad3 	orr.w	sl, sl, r3, lsr #23
    206e:	ea4f 2943 	mov.w	r9, r3, lsl #9
    2072:	464b      	mov	r3, r9
    2074:	4654      	mov	r4, sl
    2076:	185b      	adds	r3, r3, r1
    2078:	eb44 0402 	adc.w	r4, r4, r2
    207c:	01a6      	lsls	r6, r4, #6
    207e:	ea46 6693 	orr.w	r6, r6, r3, lsr #26
    2082:	019d      	lsls	r5, r3, #6
    2084:	1aed      	subs	r5, r5, r3
    2086:	eb66 0604 	sbc.w	r6, r6, r4
    208a:	1949      	adds	r1, r1, r5
    208c:	eb42 0206 	adc.w	r2, r2, r6
    2090:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2092:	f04f 0400 	mov.w	r4, #0
    2096:	185b      	adds	r3, r3, r1
    2098:	eb44 0402 	adc.w	r4, r4, r2
    209c:	f113 30ff 	adds.w	r0, r3, #4294967295	; 0xffffffff
    20a0:	f144 31ff 	adc.w	r1, r4, #4294967295	; 0xffffffff
    20a4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    20a6:	f04f 0400 	mov.w	r4, #0
    uint64_t max_delta_us =
    20aa:	461a      	mov	r2, r3
    20ac:	4623      	mov	r3, r4
    20ae:	f7ff f9e5 	bl	147c <__aeabi_uldivmod>
    20b2:	4603      	mov	r3, r0
    20b4:	460c      	mov	r4, r1
    20b6:	e9cd 3404 	strd	r3, r4, [sp, #16]

    ticker->queue->event_handler = NULL;
    20ba:	9b03      	ldr	r3, [sp, #12]
    20bc:	685b      	ldr	r3, [r3, #4]
    20be:	2200      	movs	r2, #0
    20c0:	601a      	str	r2, [r3, #0]
    ticker->queue->head = NULL;
    20c2:	9b03      	ldr	r3, [sp, #12]
    20c4:	685b      	ldr	r3, [r3, #4]
    20c6:	2200      	movs	r2, #0
    20c8:	605a      	str	r2, [r3, #4]
    ticker->queue->tick_last_read = ticker->interface->read();
    20ca:	9b03      	ldr	r3, [sp, #12]
    20cc:	685c      	ldr	r4, [r3, #4]
    20ce:	9b03      	ldr	r3, [sp, #12]
    20d0:	681b      	ldr	r3, [r3, #0]
    20d2:	685b      	ldr	r3, [r3, #4]
    20d4:	4798      	blx	r3
    20d6:	4603      	mov	r3, r0
    20d8:	6223      	str	r3, [r4, #32]
    ticker->queue->tick_remainder = 0;
    20da:	9b03      	ldr	r3, [sp, #12]
    20dc:	685a      	ldr	r2, [r3, #4]
    20de:	f04f 0300 	mov.w	r3, #0
    20e2:	f04f 0400 	mov.w	r4, #0
    20e6:	e9c2 340a 	strd	r3, r4, [r2, #40]	; 0x28
    ticker->queue->frequency = frequency;
    20ea:	9b03      	ldr	r3, [sp, #12]
    20ec:	685b      	ldr	r3, [r3, #4]
    20ee:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    20f0:	609a      	str	r2, [r3, #8]
    ticker->queue->frequency_shifts = frequency_shifts;
    20f2:	9b03      	ldr	r3, [sp, #12]
    20f4:	685b      	ldr	r3, [r3, #4]
    20f6:	f89d 202b 	ldrb.w	r2, [sp, #43]	; 0x2b
    20fa:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    ticker->queue->bitmask = ((uint64_t)1 << bits) - 1;
    20fe:	9b03      	ldr	r3, [sp, #12]
    2100:	685d      	ldr	r5, [r3, #4]
    2102:	f04f 0301 	mov.w	r3, #1
    2106:	f04f 0400 	mov.w	r4, #0
    210a:	9a09      	ldr	r2, [sp, #36]	; 0x24
    210c:	f1a2 0020 	sub.w	r0, r2, #32
    2110:	f1c2 0120 	rsb	r1, r2, #32
    2114:	fa04 f802 	lsl.w	r8, r4, r2
    2118:	fa03 f000 	lsl.w	r0, r3, r0
    211c:	ea48 0800 	orr.w	r8, r8, r0
    2120:	fa23 f101 	lsr.w	r1, r3, r1
    2124:	ea48 0801 	orr.w	r8, r8, r1
    2128:	fa03 f702 	lsl.w	r7, r3, r2
    212c:	463b      	mov	r3, r7
    212e:	3b01      	subs	r3, #1
    2130:	60eb      	str	r3, [r5, #12]
    ticker->queue->max_delta = max_delta;
    2132:	9b03      	ldr	r3, [sp, #12]
    2134:	685b      	ldr	r3, [r3, #4]
    2136:	9a07      	ldr	r2, [sp, #28]
    2138:	611a      	str	r2, [r3, #16]
    ticker->queue->max_delta_us = max_delta_us;
    213a:	9b03      	ldr	r3, [sp, #12]
    213c:	685a      	ldr	r2, [r3, #4]
    213e:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
    2142:	e9c2 3406 	strd	r3, r4, [r2, #24]
    ticker->queue->present_time = 0;
    2146:	9b03      	ldr	r3, [sp, #12]
    2148:	685a      	ldr	r2, [r3, #4]
    214a:	f04f 0300 	mov.w	r3, #0
    214e:	f04f 0400 	mov.w	r4, #0
    2152:	e9c2 340c 	strd	r3, r4, [r2, #48]	; 0x30
    ticker->queue->initialized = true;
    2156:	9b03      	ldr	r3, [sp, #12]
    2158:	685b      	ldr	r3, [r3, #4]
    215a:	2201      	movs	r2, #1
    215c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    update_present_time(ticker);
    2160:	9803      	ldr	r0, [sp, #12]
    2162:	f000 f80f 	bl	2184 <update_present_time>
    schedule_interrupt(ticker);
    2166:	9803      	ldr	r0, [sp, #12]
    2168:	f000 fa06 	bl	2578 <schedule_interrupt>
    216c:	e000      	b.n	2170 <initialize+0x1e0>
        return;
    216e:	bf00      	nop
}
    2170:	b00c      	add	sp, #48	; 0x30
    2172:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2176:	bf00      	nop
    2178:	00010b7c 	.word	0x00010b7c
    217c:	00010b9c 	.word	0x00010b9c
    2180:	000f4240 	.word	0x000f4240

00002184 <update_present_time>:

/**
 * Update the present timestamp value of a ticker.
 */
static void update_present_time(const ticker_data_t *const ticker)
{
    2184:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2188:	b096      	sub	sp, #88	; 0x58
    218a:	900b      	str	r0, [sp, #44]	; 0x2c
    ticker_event_queue_t *queue = ticker->queue;
    218c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    218e:	685b      	ldr	r3, [r3, #4]
    2190:	9313      	str	r3, [sp, #76]	; 0x4c
    uint32_t ticker_time = ticker->interface->read();
    2192:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2194:	681b      	ldr	r3, [r3, #0]
    2196:	685b      	ldr	r3, [r3, #4]
    2198:	4798      	blx	r3
    219a:	9012      	str	r0, [sp, #72]	; 0x48
    if (ticker_time == ticker->queue->tick_last_read) {
    219c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    219e:	685b      	ldr	r3, [r3, #4]
    21a0:	6a1a      	ldr	r2, [r3, #32]
    21a2:	9b12      	ldr	r3, [sp, #72]	; 0x48
    21a4:	429a      	cmp	r2, r3
    21a6:	f000 812e 	beq.w	2406 <update_present_time+0x282>
        // No work to do
        return;
    }

    uint64_t elapsed_ticks = (ticker_time - queue->tick_last_read) & queue->bitmask;
    21aa:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    21ac:	6a1a      	ldr	r2, [r3, #32]
    21ae:	9b12      	ldr	r3, [sp, #72]	; 0x48
    21b0:	1a9a      	subs	r2, r3, r2
    21b2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    21b4:	68db      	ldr	r3, [r3, #12]
    21b6:	4013      	ands	r3, r2
    21b8:	f04f 0400 	mov.w	r4, #0
    21bc:	e9cd 3410 	strd	r3, r4, [sp, #64]	; 0x40
    queue->tick_last_read = ticker_time;
    21c0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    21c2:	9b12      	ldr	r3, [sp, #72]	; 0x48
    21c4:	6213      	str	r3, [r2, #32]

    uint64_t elapsed_us;
    if (1000000 == queue->frequency) {
    21c6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    21c8:	689a      	ldr	r2, [r3, #8]
    21ca:	4b91      	ldr	r3, [pc, #580]	; (2410 <update_present_time+0x28c>)
    21cc:	429a      	cmp	r2, r3
    21ce:	d104      	bne.n	21da <update_present_time+0x56>
        // Optimized for 1MHz

        elapsed_us = elapsed_ticks;
    21d0:	e9dd 3410 	ldrd	r3, r4, [sp, #64]	; 0x40
    21d4:	e9cd 3414 	strd	r3, r4, [sp, #80]	; 0x50
    21d8:	e109      	b.n	23ee <update_present_time+0x26a>
    } else if (0 != queue->frequency_shifts) {
    21da:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    21dc:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
    21e0:	2b00      	cmp	r3, #0
    21e2:	f000 808f 	beq.w	2304 <update_present_time+0x180>
        // Optimized for frequencies divisible by 2
        uint64_t us_x_ticks = elapsed_ticks * 1000000;
    21e6:	e9dd 1210 	ldrd	r1, r2, [sp, #64]	; 0x40
    21ea:	460b      	mov	r3, r1
    21ec:	4614      	mov	r4, r2
    21ee:	0160      	lsls	r0, r4, #5
    21f0:	9001      	str	r0, [sp, #4]
    21f2:	9801      	ldr	r0, [sp, #4]
    21f4:	ea40 60d3 	orr.w	r0, r0, r3, lsr #27
    21f8:	9001      	str	r0, [sp, #4]
    21fa:	015b      	lsls	r3, r3, #5
    21fc:	9300      	str	r3, [sp, #0]
    21fe:	e9dd 3400 	ldrd	r3, r4, [sp]
    2202:	1a5b      	subs	r3, r3, r1
    2204:	eb64 0402 	sbc.w	r4, r4, r2
    2208:	0260      	lsls	r0, r4, #9
    220a:	9003      	str	r0, [sp, #12]
    220c:	9803      	ldr	r0, [sp, #12]
    220e:	ea40 50d3 	orr.w	r0, r0, r3, lsr #23
    2212:	9003      	str	r0, [sp, #12]
    2214:	025b      	lsls	r3, r3, #9
    2216:	9302      	str	r3, [sp, #8]
    2218:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
    221c:	185b      	adds	r3, r3, r1
    221e:	eb44 0402 	adc.w	r4, r4, r2
    2222:	01a0      	lsls	r0, r4, #6
    2224:	9005      	str	r0, [sp, #20]
    2226:	9805      	ldr	r0, [sp, #20]
    2228:	ea40 6093 	orr.w	r0, r0, r3, lsr #26
    222c:	9005      	str	r0, [sp, #20]
    222e:	0198      	lsls	r0, r3, #6
    2230:	9004      	str	r0, [sp, #16]
    2232:	e9dd 5604 	ldrd	r5, r6, [sp, #16]
    2236:	1aed      	subs	r5, r5, r3
    2238:	eb66 0604 	sbc.w	r6, r6, r4
    223c:	462b      	mov	r3, r5
    223e:	4634      	mov	r4, r6
    2240:	185b      	adds	r3, r3, r1
    2242:	eb44 0402 	adc.w	r4, r4, r2
    2246:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38
        elapsed_us = us_x_ticks >> queue->frequency_shifts;
    224a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    224c:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
    2250:	461a      	mov	r2, r3
    2252:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
    2256:	f1c2 0020 	rsb	r0, r2, #32
    225a:	f1a2 0120 	sub.w	r1, r2, #32
    225e:	fa23 f902 	lsr.w	r9, r3, r2
    2262:	fa04 f000 	lsl.w	r0, r4, r0
    2266:	ea49 0900 	orr.w	r9, r9, r0
    226a:	fa24 f101 	lsr.w	r1, r4, r1
    226e:	ea49 0901 	orr.w	r9, r9, r1
    2272:	fa24 fa02 	lsr.w	sl, r4, r2
    2276:	e9cd 9a14 	strd	r9, sl, [sp, #80]	; 0x50

        // Update remainder
        queue->tick_remainder += us_x_ticks - (elapsed_us << queue->frequency_shifts);
    227a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    227c:	e9d3 560a 	ldrd	r5, r6, [r3, #40]	; 0x28
    2280:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2282:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
    2286:	461a      	mov	r2, r3
    2288:	e9dd 3414 	ldrd	r3, r4, [sp, #80]	; 0x50
    228c:	f1a2 0020 	sub.w	r0, r2, #32
    2290:	f1c2 0120 	rsb	r1, r2, #32
    2294:	fa04 f802 	lsl.w	r8, r4, r2
    2298:	fa03 f000 	lsl.w	r0, r3, r0
    229c:	ea48 0800 	orr.w	r8, r8, r0
    22a0:	fa23 f101 	lsr.w	r1, r3, r1
    22a4:	ea48 0801 	orr.w	r8, r8, r1
    22a8:	fa03 f702 	lsl.w	r7, r3, r2
    22ac:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
    22b0:	1bdb      	subs	r3, r3, r7
    22b2:	eb64 0408 	sbc.w	r4, r4, r8
    22b6:	195b      	adds	r3, r3, r5
    22b8:	eb44 0406 	adc.w	r4, r4, r6
    22bc:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    22be:	e9c2 340a 	strd	r3, r4, [r2, #40]	; 0x28
        if (queue->tick_remainder >= queue->frequency) {
    22c2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    22c4:	e9d3 120a 	ldrd	r1, r2, [r3, #40]	; 0x28
    22c8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    22ca:	689b      	ldr	r3, [r3, #8]
    22cc:	f04f 0400 	mov.w	r4, #0
    22d0:	42a2      	cmp	r2, r4
    22d2:	bf08      	it	eq
    22d4:	4299      	cmpeq	r1, r3
    22d6:	f0c0 808a 	bcc.w	23ee <update_present_time+0x26a>
            elapsed_us += 1;
    22da:	e9dd 3414 	ldrd	r3, r4, [sp, #80]	; 0x50
    22de:	3301      	adds	r3, #1
    22e0:	f144 0400 	adc.w	r4, r4, #0
    22e4:	e9cd 3414 	strd	r3, r4, [sp, #80]	; 0x50
            queue->tick_remainder -= queue->frequency;
    22e8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    22ea:	e9d3 120a 	ldrd	r1, r2, [r3, #40]	; 0x28
    22ee:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    22f0:	689b      	ldr	r3, [r3, #8]
    22f2:	f04f 0400 	mov.w	r4, #0
    22f6:	1acb      	subs	r3, r1, r3
    22f8:	eb62 0404 	sbc.w	r4, r2, r4
    22fc:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    22fe:	e9c2 340a 	strd	r3, r4, [r2, #40]	; 0x28
    2302:	e074      	b.n	23ee <update_present_time+0x26a>
        }
    } else {
        // General case

        uint64_t us_x_ticks = elapsed_ticks * 1000000;
    2304:	e9dd 1210 	ldrd	r1, r2, [sp, #64]	; 0x40
    2308:	460b      	mov	r3, r1
    230a:	4614      	mov	r4, r2
    230c:	0160      	lsls	r0, r4, #5
    230e:	9007      	str	r0, [sp, #28]
    2310:	9807      	ldr	r0, [sp, #28]
    2312:	ea40 60d3 	orr.w	r0, r0, r3, lsr #27
    2316:	9007      	str	r0, [sp, #28]
    2318:	015b      	lsls	r3, r3, #5
    231a:	9306      	str	r3, [sp, #24]
    231c:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
    2320:	1a5b      	subs	r3, r3, r1
    2322:	eb64 0402 	sbc.w	r4, r4, r2
    2326:	0260      	lsls	r0, r4, #9
    2328:	9009      	str	r0, [sp, #36]	; 0x24
    232a:	9809      	ldr	r0, [sp, #36]	; 0x24
    232c:	ea40 50d3 	orr.w	r0, r0, r3, lsr #23
    2330:	9009      	str	r0, [sp, #36]	; 0x24
    2332:	025b      	lsls	r3, r3, #9
    2334:	9308      	str	r3, [sp, #32]
    2336:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
    233a:	185b      	adds	r3, r3, r1
    233c:	eb44 0402 	adc.w	r4, r4, r2
    2340:	01a6      	lsls	r6, r4, #6
    2342:	ea46 6693 	orr.w	r6, r6, r3, lsr #26
    2346:	019d      	lsls	r5, r3, #6
    2348:	1aed      	subs	r5, r5, r3
    234a:	eb66 0604 	sbc.w	r6, r6, r4
    234e:	186b      	adds	r3, r5, r1
    2350:	eb46 0402 	adc.w	r4, r6, r2
    2354:	e9cd 340c 	strd	r3, r4, [sp, #48]	; 0x30
        elapsed_us = us_x_ticks / queue->frequency;
    2358:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    235a:	689b      	ldr	r3, [r3, #8]
    235c:	f04f 0400 	mov.w	r4, #0
    2360:	461a      	mov	r2, r3
    2362:	4623      	mov	r3, r4
    2364:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    2368:	f7ff f888 	bl	147c <__aeabi_uldivmod>
    236c:	4603      	mov	r3, r0
    236e:	460c      	mov	r4, r1
    2370:	e9cd 3414 	strd	r3, r4, [sp, #80]	; 0x50

        // Update remainder
        queue->tick_remainder += us_x_ticks - elapsed_us * queue->frequency;
    2374:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2376:	e9d3 120a 	ldrd	r1, r2, [r3, #40]	; 0x28
    237a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    237c:	689b      	ldr	r3, [r3, #8]
    237e:	f04f 0400 	mov.w	r4, #0
    2382:	9814      	ldr	r0, [sp, #80]	; 0x50
    2384:	fb04 f500 	mul.w	r5, r4, r0
    2388:	9815      	ldr	r0, [sp, #84]	; 0x54
    238a:	fb03 f000 	mul.w	r0, r3, r0
    238e:	4428      	add	r0, r5
    2390:	9d14      	ldr	r5, [sp, #80]	; 0x50
    2392:	fba5 3403 	umull	r3, r4, r5, r3
    2396:	4420      	add	r0, r4
    2398:	4604      	mov	r4, r0
    239a:	e9dd 560c 	ldrd	r5, r6, [sp, #48]	; 0x30
    239e:	1aeb      	subs	r3, r5, r3
    23a0:	eb66 0404 	sbc.w	r4, r6, r4
    23a4:	185b      	adds	r3, r3, r1
    23a6:	eb44 0402 	adc.w	r4, r4, r2
    23aa:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    23ac:	e9c2 340a 	strd	r3, r4, [r2, #40]	; 0x28
        if (queue->tick_remainder >= queue->frequency) {
    23b0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    23b2:	e9d3 120a 	ldrd	r1, r2, [r3, #40]	; 0x28
    23b6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    23b8:	689b      	ldr	r3, [r3, #8]
    23ba:	f04f 0400 	mov.w	r4, #0
    23be:	42a2      	cmp	r2, r4
    23c0:	bf08      	it	eq
    23c2:	4299      	cmpeq	r1, r3
    23c4:	d313      	bcc.n	23ee <update_present_time+0x26a>
            elapsed_us += 1;
    23c6:	e9dd 3414 	ldrd	r3, r4, [sp, #80]	; 0x50
    23ca:	3301      	adds	r3, #1
    23cc:	f144 0400 	adc.w	r4, r4, #0
    23d0:	e9cd 3414 	strd	r3, r4, [sp, #80]	; 0x50
            queue->tick_remainder -= queue->frequency;
    23d4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    23d6:	e9d3 120a 	ldrd	r1, r2, [r3, #40]	; 0x28
    23da:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    23dc:	689b      	ldr	r3, [r3, #8]
    23de:	f04f 0400 	mov.w	r4, #0
    23e2:	1acb      	subs	r3, r1, r3
    23e4:	eb62 0404 	sbc.w	r4, r2, r4
    23e8:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    23ea:	e9c2 340a 	strd	r3, r4, [r2, #40]	; 0x28
        }
    }

    // Update current time
    queue->present_time += elapsed_us;
    23ee:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    23f0:	e9d3 120c 	ldrd	r1, r2, [r3, #48]	; 0x30
    23f4:	e9dd 3414 	ldrd	r3, r4, [sp, #80]	; 0x50
    23f8:	185b      	adds	r3, r3, r1
    23fa:	eb44 0402 	adc.w	r4, r4, r2
    23fe:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    2400:	e9c2 340c 	strd	r3, r4, [r2, #48]	; 0x30
    2404:	e000      	b.n	2408 <update_present_time+0x284>
        return;
    2406:	bf00      	nop
}
    2408:	b016      	add	sp, #88	; 0x58
    240a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    240e:	bf00      	nop
    2410:	000f4240 	.word	0x000f4240

00002414 <compute_tick>:

/**
 * Given the absolute timestamp compute the hal tick timestamp.
 */
static timestamp_t compute_tick(const ticker_data_t *const ticker, us_timestamp_t timestamp)
{
    2414:	b570      	push	{r4, r5, r6, lr}
    2416:	b088      	sub	sp, #32
    2418:	9003      	str	r0, [sp, #12]
    241a:	e9cd 2300 	strd	r2, r3, [sp]
    ticker_event_queue_t *queue = ticker->queue;
    241e:	9b03      	ldr	r3, [sp, #12]
    2420:	685b      	ldr	r3, [r3, #4]
    2422:	9306      	str	r3, [sp, #24]
    us_timestamp_t delta_us = timestamp - queue->present_time;
    2424:	9b06      	ldr	r3, [sp, #24]
    2426:	e9d3 230c 	ldrd	r2, r3, [r3, #48]	; 0x30
    242a:	e9dd 0100 	ldrd	r0, r1, [sp]
    242e:	1a82      	subs	r2, r0, r2
    2430:	eb61 0303 	sbc.w	r3, r1, r3
    2434:	e9cd 2304 	strd	r2, r3, [sp, #16]

    timestamp_t delta = ticker->queue->max_delta;
    2438:	9b03      	ldr	r3, [sp, #12]
    243a:	685b      	ldr	r3, [r3, #4]
    243c:	691b      	ldr	r3, [r3, #16]
    243e:	9307      	str	r3, [sp, #28]
    if (delta_us <=  ticker->queue->max_delta_us) {
    2440:	9b03      	ldr	r3, [sp, #12]
    2442:	685b      	ldr	r3, [r3, #4]
    2444:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
    2448:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    244c:	4299      	cmp	r1, r3
    244e:	bf08      	it	eq
    2450:	4290      	cmpeq	r0, r2
    2452:	d362      	bcc.n	251a <compute_tick+0x106>
        // Checking max_delta_us ensures the operation will not overflow

        if (1000000 == queue->frequency) {
    2454:	9b06      	ldr	r3, [sp, #24]
    2456:	689b      	ldr	r3, [r3, #8]
    2458:	4a35      	ldr	r2, [pc, #212]	; (2530 <compute_tick+0x11c>)
    245a:	4293      	cmp	r3, r2
    245c:	d10c      	bne.n	2478 <compute_tick+0x64>
            // Optimized for 1MHz

            delta = delta_us;
    245e:	9b04      	ldr	r3, [sp, #16]
    2460:	9307      	str	r3, [sp, #28]
            if (delta > ticker->queue->max_delta) {
    2462:	9b03      	ldr	r3, [sp, #12]
    2464:	685b      	ldr	r3, [r3, #4]
    2466:	691a      	ldr	r2, [r3, #16]
    2468:	9b07      	ldr	r3, [sp, #28]
    246a:	429a      	cmp	r2, r3
    246c:	d255      	bcs.n	251a <compute_tick+0x106>
                delta = ticker->queue->max_delta;
    246e:	9b03      	ldr	r3, [sp, #12]
    2470:	685b      	ldr	r3, [r3, #4]
    2472:	691b      	ldr	r3, [r3, #16]
    2474:	9307      	str	r3, [sp, #28]
    2476:	e050      	b.n	251a <compute_tick+0x106>
            }
        } else if (0 != queue->frequency_shifts) {
    2478:	9b06      	ldr	r3, [sp, #24]
    247a:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
    247e:	2b00      	cmp	r3, #0
    2480:	d029      	beq.n	24d6 <compute_tick+0xc2>
            // Optimized frequencies divisible by 2

            delta = (delta_us << ticker->queue->frequency_shifts) / 1000000;
    2482:	9b03      	ldr	r3, [sp, #12]
    2484:	685b      	ldr	r3, [r3, #4]
    2486:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
    248a:	4619      	mov	r1, r3
    248c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    2490:	f1a1 0620 	sub.w	r6, r1, #32
    2494:	f1c1 0020 	rsb	r0, r1, #32
    2498:	fa03 f501 	lsl.w	r5, r3, r1
    249c:	fa02 f606 	lsl.w	r6, r2, r6
    24a0:	4335      	orrs	r5, r6
    24a2:	fa22 f000 	lsr.w	r0, r2, r0
    24a6:	4305      	orrs	r5, r0
    24a8:	fa02 f401 	lsl.w	r4, r2, r1
    24ac:	4a20      	ldr	r2, [pc, #128]	; (2530 <compute_tick+0x11c>)
    24ae:	f04f 0300 	mov.w	r3, #0
    24b2:	4620      	mov	r0, r4
    24b4:	4629      	mov	r1, r5
    24b6:	f7fe ffe1 	bl	147c <__aeabi_uldivmod>
    24ba:	4603      	mov	r3, r0
    24bc:	460c      	mov	r4, r1
    24be:	9307      	str	r3, [sp, #28]
            if (delta > ticker->queue->max_delta) {
    24c0:	9b03      	ldr	r3, [sp, #12]
    24c2:	685b      	ldr	r3, [r3, #4]
    24c4:	691a      	ldr	r2, [r3, #16]
    24c6:	9b07      	ldr	r3, [sp, #28]
    24c8:	429a      	cmp	r2, r3
    24ca:	d226      	bcs.n	251a <compute_tick+0x106>
                delta = ticker->queue->max_delta;
    24cc:	9b03      	ldr	r3, [sp, #12]
    24ce:	685b      	ldr	r3, [r3, #4]
    24d0:	691b      	ldr	r3, [r3, #16]
    24d2:	9307      	str	r3, [sp, #28]
    24d4:	e021      	b.n	251a <compute_tick+0x106>
            }
        } else {
            // General case

            delta = delta_us * queue->frequency / 1000000;
    24d6:	9b06      	ldr	r3, [sp, #24]
    24d8:	689b      	ldr	r3, [r3, #8]
    24da:	f04f 0400 	mov.w	r4, #0
    24de:	9a04      	ldr	r2, [sp, #16]
    24e0:	fb04 f102 	mul.w	r1, r4, r2
    24e4:	9a05      	ldr	r2, [sp, #20]
    24e6:	fb03 f202 	mul.w	r2, r3, r2
    24ea:	440a      	add	r2, r1
    24ec:	9904      	ldr	r1, [sp, #16]
    24ee:	fba1 0103 	umull	r0, r1, r1, r3
    24f2:	1853      	adds	r3, r2, r1
    24f4:	4619      	mov	r1, r3
    24f6:	4a0e      	ldr	r2, [pc, #56]	; (2530 <compute_tick+0x11c>)
    24f8:	f04f 0300 	mov.w	r3, #0
    24fc:	f7fe ffbe 	bl	147c <__aeabi_uldivmod>
    2500:	4603      	mov	r3, r0
    2502:	460c      	mov	r4, r1
    2504:	9307      	str	r3, [sp, #28]
            if (delta > ticker->queue->max_delta) {
    2506:	9b03      	ldr	r3, [sp, #12]
    2508:	685b      	ldr	r3, [r3, #4]
    250a:	691a      	ldr	r2, [r3, #16]
    250c:	9b07      	ldr	r3, [sp, #28]
    250e:	429a      	cmp	r2, r3
    2510:	d203      	bcs.n	251a <compute_tick+0x106>
                delta = ticker->queue->max_delta;
    2512:	9b03      	ldr	r3, [sp, #12]
    2514:	685b      	ldr	r3, [r3, #4]
    2516:	691b      	ldr	r3, [r3, #16]
    2518:	9307      	str	r3, [sp, #28]
            }
        }
    }
    return (queue->tick_last_read + delta) & queue->bitmask;
    251a:	9b06      	ldr	r3, [sp, #24]
    251c:	6a1a      	ldr	r2, [r3, #32]
    251e:	9b07      	ldr	r3, [sp, #28]
    2520:	441a      	add	r2, r3
    2522:	9b06      	ldr	r3, [sp, #24]
    2524:	68db      	ldr	r3, [r3, #12]
    2526:	4013      	ands	r3, r2
}
    2528:	4618      	mov	r0, r3
    252a:	b008      	add	sp, #32
    252c:	bd70      	pop	{r4, r5, r6, pc}
    252e:	bf00      	nop
    2530:	000f4240 	.word	0x000f4240

00002534 <_ticker_match_interval_passed>:

/**
 * Return 1 if the tick has incremented to or past match_tick, otherwise 0.
 */
int _ticker_match_interval_passed(timestamp_t prev_tick, timestamp_t cur_tick, timestamp_t match_tick)
{
    2534:	b084      	sub	sp, #16
    2536:	9003      	str	r0, [sp, #12]
    2538:	9102      	str	r1, [sp, #8]
    253a:	9201      	str	r2, [sp, #4]
    if (match_tick > prev_tick) {
    253c:	9a01      	ldr	r2, [sp, #4]
    253e:	9b03      	ldr	r3, [sp, #12]
    2540:	429a      	cmp	r2, r3
    2542:	d90b      	bls.n	255c <_ticker_match_interval_passed+0x28>
        return (cur_tick >= match_tick) || (cur_tick < prev_tick);
    2544:	9a02      	ldr	r2, [sp, #8]
    2546:	9b01      	ldr	r3, [sp, #4]
    2548:	429a      	cmp	r2, r3
    254a:	d203      	bcs.n	2554 <_ticker_match_interval_passed+0x20>
    254c:	9a02      	ldr	r2, [sp, #8]
    254e:	9b03      	ldr	r3, [sp, #12]
    2550:	429a      	cmp	r2, r3
    2552:	d201      	bcs.n	2558 <_ticker_match_interval_passed+0x24>
    2554:	2301      	movs	r3, #1
    2556:	e00c      	b.n	2572 <_ticker_match_interval_passed+0x3e>
    2558:	2300      	movs	r3, #0
    255a:	e00a      	b.n	2572 <_ticker_match_interval_passed+0x3e>
    } else {
        return (cur_tick < prev_tick) && (cur_tick >= match_tick);
    255c:	9a02      	ldr	r2, [sp, #8]
    255e:	9b03      	ldr	r3, [sp, #12]
    2560:	429a      	cmp	r2, r3
    2562:	d205      	bcs.n	2570 <_ticker_match_interval_passed+0x3c>
    2564:	9a02      	ldr	r2, [sp, #8]
    2566:	9b01      	ldr	r3, [sp, #4]
    2568:	429a      	cmp	r2, r3
    256a:	d301      	bcc.n	2570 <_ticker_match_interval_passed+0x3c>
    256c:	2301      	movs	r3, #1
    256e:	e000      	b.n	2572 <_ticker_match_interval_passed+0x3e>
    2570:	2300      	movs	r3, #0
    }
}
    2572:	4618      	mov	r0, r3
    2574:	b004      	add	sp, #16
    2576:	4770      	bx	lr

00002578 <schedule_interrupt>:
 * @note If there is no event in the queue then the interrupt is scheduled to
 * in ticker.queue.max_delta. This is necessary to keep track
 * of the timer overflow.
 */
static void schedule_interrupt(const ticker_data_t *const ticker)
{
    2578:	b510      	push	{r4, lr}
    257a:	b08c      	sub	sp, #48	; 0x30
    257c:	9001      	str	r0, [sp, #4]
    ticker_event_queue_t *queue = ticker->queue;
    257e:	9b01      	ldr	r3, [sp, #4]
    2580:	685b      	ldr	r3, [r3, #4]
    2582:	930b      	str	r3, [sp, #44]	; 0x2c
    update_present_time(ticker);
    2584:	9801      	ldr	r0, [sp, #4]
    2586:	f7ff fdfd 	bl	2184 <update_present_time>

    if (ticker->queue->head) {
    258a:	9b01      	ldr	r3, [sp, #4]
    258c:	685b      	ldr	r3, [r3, #4]
    258e:	685b      	ldr	r3, [r3, #4]
    2590:	2b00      	cmp	r3, #0
    2592:	d042      	beq.n	261a <schedule_interrupt+0xa2>
        us_timestamp_t present = ticker->queue->present_time;
    2594:	9b01      	ldr	r3, [sp, #4]
    2596:	685b      	ldr	r3, [r3, #4]
    2598:	e9d3 340c 	ldrd	r3, r4, [r3, #48]	; 0x30
    259c:	e9cd 3408 	strd	r3, r4, [sp, #32]
        us_timestamp_t match_time = ticker->queue->head->timestamp;
    25a0:	9b01      	ldr	r3, [sp, #4]
    25a2:	685b      	ldr	r3, [r3, #4]
    25a4:	685b      	ldr	r3, [r3, #4]
    25a6:	e9d3 3400 	ldrd	r3, r4, [r3]
    25aa:	e9cd 3406 	strd	r3, r4, [sp, #24]

        // if the event at the head of the queue is in the past then schedule
        // it immediately.
        if (match_time <= present) {
    25ae:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
    25b2:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
    25b6:	42a2      	cmp	r2, r4
    25b8:	bf08      	it	eq
    25ba:	4299      	cmpeq	r1, r3
    25bc:	d304      	bcc.n	25c8 <schedule_interrupt+0x50>
            ticker->interface->fire_interrupt();
    25be:	9b01      	ldr	r3, [sp, #4]
    25c0:	681b      	ldr	r3, [r3, #0]
    25c2:	695b      	ldr	r3, [r3, #20]
    25c4:	4798      	blx	r3
            return;
    25c6:	e036      	b.n	2636 <schedule_interrupt+0xbe>
        }

        timestamp_t match_tick = compute_tick(ticker, match_time);
    25c8:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    25cc:	9801      	ldr	r0, [sp, #4]
    25ce:	f7ff ff21 	bl	2414 <compute_tick>
    25d2:	9005      	str	r0, [sp, #20]
        // The time has been checked to be future, but it could still round
        // to the last tick as a result of us to ticks conversion
        if (match_tick == queue->tick_last_read) {
    25d4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    25d6:	6a1a      	ldr	r2, [r3, #32]
    25d8:	9b05      	ldr	r3, [sp, #20]
    25da:	429a      	cmp	r2, r3
    25dc:	d104      	bne.n	25e8 <schedule_interrupt+0x70>
            // Match time has already expired so fire immediately
            ticker->interface->fire_interrupt();
    25de:	9b01      	ldr	r3, [sp, #4]
    25e0:	681b      	ldr	r3, [r3, #0]
    25e2:	695b      	ldr	r3, [r3, #20]
    25e4:	4798      	blx	r3
            return;
    25e6:	e026      	b.n	2636 <schedule_interrupt+0xbe>
        }

        ticker->interface->set_interrupt(match_tick);
    25e8:	9b01      	ldr	r3, [sp, #4]
    25ea:	681b      	ldr	r3, [r3, #0]
    25ec:	691b      	ldr	r3, [r3, #16]
    25ee:	9805      	ldr	r0, [sp, #20]
    25f0:	4798      	blx	r3
        timestamp_t cur_tick = ticker->interface->read();
    25f2:	9b01      	ldr	r3, [sp, #4]
    25f4:	681b      	ldr	r3, [r3, #0]
    25f6:	685b      	ldr	r3, [r3, #4]
    25f8:	4798      	blx	r3
    25fa:	9004      	str	r0, [sp, #16]

        if (_ticker_match_interval_passed(queue->tick_last_read, cur_tick, match_tick)) {
    25fc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    25fe:	6a1b      	ldr	r3, [r3, #32]
    2600:	9a05      	ldr	r2, [sp, #20]
    2602:	9904      	ldr	r1, [sp, #16]
    2604:	4618      	mov	r0, r3
    2606:	f7ff ff95 	bl	2534 <_ticker_match_interval_passed>
    260a:	4603      	mov	r3, r0
    260c:	2b00      	cmp	r3, #0
    260e:	d012      	beq.n	2636 <schedule_interrupt+0xbe>
            ticker->interface->fire_interrupt();
    2610:	9b01      	ldr	r3, [sp, #4]
    2612:	681b      	ldr	r3, [r3, #0]
    2614:	695b      	ldr	r3, [r3, #20]
    2616:	4798      	blx	r3
    2618:	e00d      	b.n	2636 <schedule_interrupt+0xbe>
        }
    } else {
        uint32_t match_tick =
            (queue->tick_last_read + queue->max_delta) & queue->bitmask;
    261a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    261c:	6a1a      	ldr	r2, [r3, #32]
    261e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2620:	691b      	ldr	r3, [r3, #16]
    2622:	441a      	add	r2, r3
    2624:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2626:	68db      	ldr	r3, [r3, #12]
        uint32_t match_tick =
    2628:	4013      	ands	r3, r2
    262a:	9303      	str	r3, [sp, #12]
        ticker->interface->set_interrupt(match_tick);
    262c:	9b01      	ldr	r3, [sp, #4]
    262e:	681b      	ldr	r3, [r3, #0]
    2630:	691b      	ldr	r3, [r3, #16]
    2632:	9803      	ldr	r0, [sp, #12]
    2634:	4798      	blx	r3
    }
}
    2636:	b00c      	add	sp, #48	; 0x30
    2638:	bd10      	pop	{r4, pc}

0000263a <ticker_irq_handler>:
    set_handler(ticker, handler);
    core_util_critical_section_exit();
}

void ticker_irq_handler(const ticker_data_t *const ticker)
{
    263a:	b510      	push	{r4, lr}
    263c:	b084      	sub	sp, #16
    263e:	9001      	str	r0, [sp, #4]
    core_util_critical_section_enter();
    2640:	f000 fab6 	bl	2bb0 <core_util_critical_section_enter>

    ticker->interface->clear_interrupt();
    2644:	9b01      	ldr	r3, [sp, #4]
    2646:	681b      	ldr	r3, [r3, #0]
    2648:	68db      	ldr	r3, [r3, #12]
    264a:	4798      	blx	r3

    /* Go through all the pending TimerEvents */
    while (1) {
        if (ticker->queue->head == NULL) {
    264c:	9b01      	ldr	r3, [sp, #4]
    264e:	685b      	ldr	r3, [r3, #4]
    2650:	685b      	ldr	r3, [r3, #4]
    2652:	2b00      	cmp	r3, #0
    2654:	d027      	beq.n	26a6 <ticker_irq_handler+0x6c>
            break;
        }

        // update the current timestamp used by the queue
        update_present_time(ticker);
    2656:	9801      	ldr	r0, [sp, #4]
    2658:	f7ff fd94 	bl	2184 <update_present_time>

        if (ticker->queue->head->timestamp <= ticker->queue->present_time) {
    265c:	9b01      	ldr	r3, [sp, #4]
    265e:	685b      	ldr	r3, [r3, #4]
    2660:	685b      	ldr	r3, [r3, #4]
    2662:	e9d3 3400 	ldrd	r3, r4, [r3]
    2666:	9a01      	ldr	r2, [sp, #4]
    2668:	6852      	ldr	r2, [r2, #4]
    266a:	e9d2 120c 	ldrd	r1, r2, [r2, #48]	; 0x30
    266e:	42a2      	cmp	r2, r4
    2670:	bf08      	it	eq
    2672:	4299      	cmpeq	r1, r3
    2674:	d319      	bcc.n	26aa <ticker_irq_handler+0x70>
            // This event was in the past:
            //      point to the following one and execute its handler
            ticker_event_t *p = ticker->queue->head;
    2676:	9b01      	ldr	r3, [sp, #4]
    2678:	685b      	ldr	r3, [r3, #4]
    267a:	685b      	ldr	r3, [r3, #4]
    267c:	9303      	str	r3, [sp, #12]
            ticker->queue->head = ticker->queue->head->next;
    267e:	9b01      	ldr	r3, [sp, #4]
    2680:	685b      	ldr	r3, [r3, #4]
    2682:	9a01      	ldr	r2, [sp, #4]
    2684:	6852      	ldr	r2, [r2, #4]
    2686:	6852      	ldr	r2, [r2, #4]
    2688:	68d2      	ldr	r2, [r2, #12]
    268a:	605a      	str	r2, [r3, #4]
            if (ticker->queue->event_handler != NULL) {
    268c:	9b01      	ldr	r3, [sp, #4]
    268e:	685b      	ldr	r3, [r3, #4]
    2690:	681b      	ldr	r3, [r3, #0]
    2692:	2b00      	cmp	r3, #0
    2694:	d0da      	beq.n	264c <ticker_irq_handler+0x12>
                (*ticker->queue->event_handler)(p->id); // NOTE: the handler can set new events
    2696:	9b01      	ldr	r3, [sp, #4]
    2698:	685b      	ldr	r3, [r3, #4]
    269a:	681b      	ldr	r3, [r3, #0]
    269c:	9a03      	ldr	r2, [sp, #12]
    269e:	6892      	ldr	r2, [r2, #8]
    26a0:	4610      	mov	r0, r2
    26a2:	4798      	blx	r3
        if (ticker->queue->head == NULL) {
    26a4:	e7d2      	b.n	264c <ticker_irq_handler+0x12>
            break;
    26a6:	bf00      	nop
    26a8:	e000      	b.n	26ac <ticker_irq_handler+0x72>
            }
            /* Note: We continue back to examining the head because calling the
             * event handler may have altered the chain of pending events. */
        } else {
            break;
    26aa:	bf00      	nop
        }
    }

    schedule_interrupt(ticker);
    26ac:	9801      	ldr	r0, [sp, #4]
    26ae:	f7ff ff63 	bl	2578 <schedule_interrupt>

    core_util_critical_section_exit();
    26b2:	f000 fa97 	bl	2be4 <core_util_critical_section_exit>
}
    26b6:	bf00      	nop
    26b8:	b004      	add	sp, #16
    26ba:	bd10      	pop	{r4, pc}

000026bc <ticker_read>:

    core_util_critical_section_exit();
}

timestamp_t ticker_read(const ticker_data_t *const ticker)
{
    26bc:	b510      	push	{r4, lr}
    26be:	b082      	sub	sp, #8
    26c0:	9001      	str	r0, [sp, #4]
    return ticker_read_us(ticker);
    26c2:	9801      	ldr	r0, [sp, #4]
    26c4:	f000 f805 	bl	26d2 <ticker_read_us>
    26c8:	4603      	mov	r3, r0
    26ca:	460c      	mov	r4, r1
}
    26cc:	4618      	mov	r0, r3
    26ce:	b002      	add	sp, #8
    26d0:	bd10      	pop	{r4, pc}

000026d2 <ticker_read_us>:

us_timestamp_t ticker_read_us(const ticker_data_t *const ticker)
{
    26d2:	b510      	push	{r4, lr}
    26d4:	b082      	sub	sp, #8
    26d6:	9001      	str	r0, [sp, #4]
    initialize(ticker);
    26d8:	9801      	ldr	r0, [sp, #4]
    26da:	f7ff fc59 	bl	1f90 <initialize>

    core_util_critical_section_enter();
    26de:	f000 fa67 	bl	2bb0 <core_util_critical_section_enter>
    update_present_time(ticker);
    26e2:	9801      	ldr	r0, [sp, #4]
    26e4:	f7ff fd4e 	bl	2184 <update_present_time>
    core_util_critical_section_exit();
    26e8:	f000 fa7c 	bl	2be4 <core_util_critical_section_exit>

    return ticker->queue->present_time;
    26ec:	9b01      	ldr	r3, [sp, #4]
    26ee:	685b      	ldr	r3, [r3, #4]
    26f0:	e9d3 340c 	ldrd	r3, r4, [r3, #48]	; 0x30
}
    26f4:	4618      	mov	r0, r3
    26f6:	4621      	mov	r1, r4
    26f8:	b002      	add	sp, #8
    26fa:	bd10      	pop	{r4, pc}

000026fc <get_us_ticker_data>:
    .queue = &events
};

const ticker_data_t *get_us_ticker_data(void)
{
    return &us_data;
    26fc:	4b01      	ldr	r3, [pc, #4]	; (2704 <get_us_ticker_data+0x8>)
}
    26fe:	4618      	mov	r0, r3
    2700:	4770      	bx	lr
    2702:	bf00      	nop
    2704:	00012524 	.word	0x00012524

00002708 <us_ticker_irq_handler>:

    return prev_irq_handler;
}

void us_ticker_irq_handler(void)
{
    2708:	b508      	push	{r3, lr}
    if (irq_handler) {
    270a:	4b05      	ldr	r3, [pc, #20]	; (2720 <us_ticker_irq_handler+0x18>)
    270c:	681b      	ldr	r3, [r3, #0]
    270e:	2b00      	cmp	r3, #0
    2710:	d003      	beq.n	271a <us_ticker_irq_handler+0x12>
        irq_handler(&us_data);
    2712:	4b03      	ldr	r3, [pc, #12]	; (2720 <us_ticker_irq_handler+0x18>)
    2714:	681b      	ldr	r3, [r3, #0]
    2716:	4803      	ldr	r0, [pc, #12]	; (2724 <us_ticker_irq_handler+0x1c>)
    2718:	4798      	blx	r3
    }
}
    271a:	bf00      	nop
    271c:	bd08      	pop	{r3, pc}
    271e:	bf00      	nop
    2720:	20000004 	.word	0x20000004
    2724:	00012524 	.word	0x00012524

00002728 <_ZN4mbed10FileHandle4syncEv>:
    virtual int sync()
    2728:	b082      	sub	sp, #8
    272a:	9001      	str	r0, [sp, #4]
        return 0;
    272c:	2300      	movs	r3, #0
    }
    272e:	4618      	mov	r0, r3
    2730:	b002      	add	sp, #8
    2732:	4770      	bx	lr

00002734 <_ZN4mbed10FileHandle6isattyEv>:
    virtual int isatty()
    2734:	b082      	sub	sp, #8
    2736:	9001      	str	r0, [sp, #4]
        return false;
    2738:	2300      	movs	r3, #0
    }
    273a:	4618      	mov	r0, r3
    273c:	b002      	add	sp, #8
    273e:	4770      	bx	lr

00002740 <_ZN4mbed10FileHandle4sizeEv>:
#include "platform/mbed_critical.h"

namespace mbed {

off_t FileHandle::size()
{
    2740:	b500      	push	{lr}
    2742:	b085      	sub	sp, #20
    2744:	9001      	str	r0, [sp, #4]
    /* remember our current position */
    off_t off = seek(0, SEEK_CUR);
    2746:	9b01      	ldr	r3, [sp, #4]
    2748:	681b      	ldr	r3, [r3, #0]
    274a:	3310      	adds	r3, #16
    274c:	681b      	ldr	r3, [r3, #0]
    274e:	2201      	movs	r2, #1
    2750:	2100      	movs	r1, #0
    2752:	9801      	ldr	r0, [sp, #4]
    2754:	4798      	blx	r3
    2756:	9003      	str	r0, [sp, #12]
    if (off < 0) {
    2758:	9b03      	ldr	r3, [sp, #12]
    275a:	2b00      	cmp	r3, #0
    275c:	da01      	bge.n	2762 <_ZN4mbed10FileHandle4sizeEv+0x22>
        return off;
    275e:	9b03      	ldr	r3, [sp, #12]
    2760:	e011      	b.n	2786 <_ZN4mbed10FileHandle4sizeEv+0x46>
    }
    /* seek to the end to get the file length */
    off_t size = seek(0, SEEK_END);
    2762:	9b01      	ldr	r3, [sp, #4]
    2764:	681b      	ldr	r3, [r3, #0]
    2766:	3310      	adds	r3, #16
    2768:	681b      	ldr	r3, [r3, #0]
    276a:	2202      	movs	r2, #2
    276c:	2100      	movs	r1, #0
    276e:	9801      	ldr	r0, [sp, #4]
    2770:	4798      	blx	r3
    2772:	9002      	str	r0, [sp, #8]
    /* return to our old position */
    seek(off, SEEK_SET);
    2774:	9b01      	ldr	r3, [sp, #4]
    2776:	681b      	ldr	r3, [r3, #0]
    2778:	3310      	adds	r3, #16
    277a:	681b      	ldr	r3, [r3, #0]
    277c:	2200      	movs	r2, #0
    277e:	9903      	ldr	r1, [sp, #12]
    2780:	9801      	ldr	r0, [sp, #4]
    2782:	4798      	blx	r3
    return size;
    2784:	9b02      	ldr	r3, [sp, #8]
}
    2786:	4618      	mov	r0, r3
    2788:	b005      	add	sp, #20
    278a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00002790 <mbed_stats_heap_get>:
static SingletonPtr<PlatformMutex> malloc_stats_mutex;
static mbed_stats_heap_t heap_stats = {0, 0, 0, 0, 0};
#endif

void mbed_stats_heap_get(mbed_stats_heap_t *stats)
{
    2790:	b500      	push	{lr}
    2792:	b083      	sub	sp, #12
    2794:	9001      	str	r0, [sp, #4]
#ifdef MBED_HEAP_STATS_ENABLED
    extern uint32_t mbed_heap_size;
    heap_stats.reserved_size = mbed_heap_size;
    2796:	4b0e      	ldr	r3, [pc, #56]	; (27d0 <mbed_stats_heap_get+0x40>)
    2798:	681b      	ldr	r3, [r3, #0]
    279a:	4a0e      	ldr	r2, [pc, #56]	; (27d4 <mbed_stats_heap_get+0x44>)
    279c:	60d3      	str	r3, [r2, #12]

    malloc_stats_mutex->lock();
    279e:	480e      	ldr	r0, [pc, #56]	; (27d8 <mbed_stats_heap_get+0x48>)
    27a0:	f7ff f8cc 	bl	193c <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    27a4:	4603      	mov	r3, r0
    27a6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    27aa:	4618      	mov	r0, r3
    27ac:	f001 fb6e 	bl	3e8c <_ZN4rtos5Mutex4lockEm>
    memcpy(stats, &heap_stats, sizeof(mbed_stats_heap_t));
    27b0:	2218      	movs	r2, #24
    27b2:	4908      	ldr	r1, [pc, #32]	; (27d4 <mbed_stats_heap_get+0x44>)
    27b4:	9801      	ldr	r0, [sp, #4]
    27b6:	f7fe f8b3 	bl	920 <memcpy>
    malloc_stats_mutex->unlock();
    27ba:	4807      	ldr	r0, [pc, #28]	; (27d8 <mbed_stats_heap_get+0x48>)
    27bc:	f7ff f8be 	bl	193c <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    27c0:	4603      	mov	r3, r0
    27c2:	4618      	mov	r0, r3
    27c4:	f001 fb7a 	bl	3ebc <_ZN4rtos5Mutex6unlockEv>
#else
    memset(stats, 0, sizeof(mbed_stats_heap_t));
#endif
}
    27c8:	bf00      	nop
    27ca:	b003      	add	sp, #12
    27cc:	f85d fb04 	ldr.w	pc, [sp], #4
    27d0:	20000d9c 	.word	0x20000d9c
    27d4:	20000cd8 	.word	0x20000cd8
    27d8:	20000cb0 	.word	0x20000cb0

000027dc <__wrap__malloc_r>:

// TODO: memory tracing doesn't work with uVisor enabled.
#if !defined(FEATURE_UVISOR)

extern "C" void *__wrap__malloc_r(struct _reent *r, size_t size)
{
    27dc:	b500      	push	{lr}
    27de:	b083      	sub	sp, #12
    27e0:	4673      	mov	r3, lr
    27e2:	9001      	str	r0, [sp, #4]
    27e4:	9100      	str	r1, [sp, #0]
    return malloc_wrapper(r, size, MBED_CALLER_ADDR());
    27e6:	461a      	mov	r2, r3
    27e8:	9900      	ldr	r1, [sp, #0]
    27ea:	9801      	ldr	r0, [sp, #4]
    27ec:	f000 f806 	bl	27fc <malloc_wrapper>
    27f0:	4603      	mov	r3, r0
}
    27f2:	4618      	mov	r0, r3
    27f4:	b003      	add	sp, #12
    27f6:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000027fc <malloc_wrapper>:

extern "C" void *malloc_wrapper(struct _reent *r, size_t size, void *caller)
{
    27fc:	b500      	push	{lr}
    27fe:	b087      	sub	sp, #28
    2800:	9003      	str	r0, [sp, #12]
    2802:	9102      	str	r1, [sp, #8]
    2804:	9201      	str	r2, [sp, #4]
    void *ptr = NULL;
    2806:	2300      	movs	r3, #0
    2808:	9305      	str	r3, [sp, #20]
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_lock();
    280a:	f000 fbc1 	bl	2f90 <mbed_mem_trace_lock>
#endif
#ifdef MBED_HEAP_STATS_ENABLED
    malloc_stats_mutex->lock();
    280e:	4826      	ldr	r0, [pc, #152]	; (28a8 <malloc_wrapper+0xac>)
    2810:	f7ff f894 	bl	193c <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    2814:	4603      	mov	r3, r0
    2816:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    281a:	4618      	mov	r0, r3
    281c:	f001 fb36 	bl	3e8c <_ZN4rtos5Mutex4lockEm>
    alloc_info_t *alloc_info = (alloc_info_t *)__real__malloc_r(r, size + sizeof(alloc_info_t));
    2820:	9b02      	ldr	r3, [sp, #8]
    2822:	3308      	adds	r3, #8
    2824:	4619      	mov	r1, r3
    2826:	9803      	ldr	r0, [sp, #12]
    2828:	f008 fb12 	bl	ae50 <_malloc_r>
    282c:	9004      	str	r0, [sp, #16]
    if (alloc_info != NULL) {
    282e:	9b04      	ldr	r3, [sp, #16]
    2830:	2b00      	cmp	r3, #0
    2832:	d021      	beq.n	2878 <malloc_wrapper+0x7c>
        alloc_info->size = size;
    2834:	9b04      	ldr	r3, [sp, #16]
    2836:	9a02      	ldr	r2, [sp, #8]
    2838:	601a      	str	r2, [r3, #0]
        ptr = (void *)(alloc_info + 1);
    283a:	9b04      	ldr	r3, [sp, #16]
    283c:	3308      	adds	r3, #8
    283e:	9305      	str	r3, [sp, #20]
        heap_stats.current_size += size;
    2840:	4b1a      	ldr	r3, [pc, #104]	; (28ac <malloc_wrapper+0xb0>)
    2842:	681a      	ldr	r2, [r3, #0]
    2844:	9b02      	ldr	r3, [sp, #8]
    2846:	4413      	add	r3, r2
    2848:	4a18      	ldr	r2, [pc, #96]	; (28ac <malloc_wrapper+0xb0>)
    284a:	6013      	str	r3, [r2, #0]
        heap_stats.total_size += size;
    284c:	4b17      	ldr	r3, [pc, #92]	; (28ac <malloc_wrapper+0xb0>)
    284e:	689a      	ldr	r2, [r3, #8]
    2850:	9b02      	ldr	r3, [sp, #8]
    2852:	4413      	add	r3, r2
    2854:	4a15      	ldr	r2, [pc, #84]	; (28ac <malloc_wrapper+0xb0>)
    2856:	6093      	str	r3, [r2, #8]
        heap_stats.alloc_cnt += 1;
    2858:	4b14      	ldr	r3, [pc, #80]	; (28ac <malloc_wrapper+0xb0>)
    285a:	691b      	ldr	r3, [r3, #16]
    285c:	3301      	adds	r3, #1
    285e:	4a13      	ldr	r2, [pc, #76]	; (28ac <malloc_wrapper+0xb0>)
    2860:	6113      	str	r3, [r2, #16]
        if (heap_stats.current_size > heap_stats.max_size) {
    2862:	4b12      	ldr	r3, [pc, #72]	; (28ac <malloc_wrapper+0xb0>)
    2864:	681a      	ldr	r2, [r3, #0]
    2866:	4b11      	ldr	r3, [pc, #68]	; (28ac <malloc_wrapper+0xb0>)
    2868:	685b      	ldr	r3, [r3, #4]
    286a:	429a      	cmp	r2, r3
    286c:	d909      	bls.n	2882 <malloc_wrapper+0x86>
            heap_stats.max_size = heap_stats.current_size;
    286e:	4b0f      	ldr	r3, [pc, #60]	; (28ac <malloc_wrapper+0xb0>)
    2870:	681b      	ldr	r3, [r3, #0]
    2872:	4a0e      	ldr	r2, [pc, #56]	; (28ac <malloc_wrapper+0xb0>)
    2874:	6053      	str	r3, [r2, #4]
    2876:	e004      	b.n	2882 <malloc_wrapper+0x86>
        }
    } else {
        heap_stats.alloc_fail_cnt += 1;
    2878:	4b0c      	ldr	r3, [pc, #48]	; (28ac <malloc_wrapper+0xb0>)
    287a:	695b      	ldr	r3, [r3, #20]
    287c:	3301      	adds	r3, #1
    287e:	4a0b      	ldr	r2, [pc, #44]	; (28ac <malloc_wrapper+0xb0>)
    2880:	6153      	str	r3, [r2, #20]
    }
    malloc_stats_mutex->unlock();
    2882:	4809      	ldr	r0, [pc, #36]	; (28a8 <malloc_wrapper+0xac>)
    2884:	f7ff f85a 	bl	193c <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    2888:	4603      	mov	r3, r0
    288a:	4618      	mov	r0, r3
    288c:	f001 fb16 	bl	3ebc <_ZN4rtos5Mutex6unlockEv>
#else // #ifdef MBED_HEAP_STATS_ENABLED
    ptr = __real__malloc_r(r, size);
#endif // #ifdef MBED_HEAP_STATS_ENABLED
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_malloc(ptr, size, caller);
    2890:	9a01      	ldr	r2, [sp, #4]
    2892:	9902      	ldr	r1, [sp, #8]
    2894:	9805      	ldr	r0, [sp, #20]
    2896:	f000 fba5 	bl	2fe4 <mbed_mem_trace_malloc>
    mbed_mem_trace_unlock();
    289a:	f000 fb8f 	bl	2fbc <mbed_mem_trace_unlock>
#endif // #ifdef MBED_MEM_TRACING_ENABLED
    return ptr;
    289e:	9b05      	ldr	r3, [sp, #20]
}
    28a0:	4618      	mov	r0, r3
    28a2:	b007      	add	sp, #28
    28a4:	f85d fb04 	ldr.w	pc, [sp], #4
    28a8:	20000cb0 	.word	0x20000cb0
    28ac:	20000cd8 	.word	0x20000cd8

000028b0 <__wrap__realloc_r>:

extern "C" void *__wrap__realloc_r(struct _reent *r, void *ptr, size_t size)
{
    28b0:	b510      	push	{r4, lr}
    28b2:	b088      	sub	sp, #32
    28b4:	4674      	mov	r4, lr
    28b6:	9003      	str	r0, [sp, #12]
    28b8:	9102      	str	r1, [sp, #8]
    28ba:	9201      	str	r2, [sp, #4]
    void *new_ptr = NULL;
    28bc:	2300      	movs	r3, #0
    28be:	9307      	str	r3, [sp, #28]
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_lock();
    28c0:	f000 fb66 	bl	2f90 <mbed_mem_trace_lock>
    // resize memory directly (returns ptr + 0).

    // Note - no lock needed since malloc and free are thread safe

    // Get old size
    uint32_t old_size = 0;
    28c4:	2300      	movs	r3, #0
    28c6:	9306      	str	r3, [sp, #24]
    if (ptr != NULL) {
    28c8:	9b02      	ldr	r3, [sp, #8]
    28ca:	2b00      	cmp	r3, #0
    28cc:	d005      	beq.n	28da <__wrap__realloc_r+0x2a>
        alloc_info_t *alloc_info = ((alloc_info_t *)ptr) - 1;
    28ce:	9b02      	ldr	r3, [sp, #8]
    28d0:	3b08      	subs	r3, #8
    28d2:	9305      	str	r3, [sp, #20]
        old_size = alloc_info->size;
    28d4:	9b05      	ldr	r3, [sp, #20]
    28d6:	681b      	ldr	r3, [r3, #0]
    28d8:	9306      	str	r3, [sp, #24]
    }

    // Allocate space
    if (size != 0) {
    28da:	9b01      	ldr	r3, [sp, #4]
    28dc:	2b00      	cmp	r3, #0
    28de:	d003      	beq.n	28e8 <__wrap__realloc_r+0x38>
        new_ptr = malloc(size);
    28e0:	9801      	ldr	r0, [sp, #4]
    28e2:	f008 faa5 	bl	ae30 <malloc>
    28e6:	9007      	str	r0, [sp, #28]
    }

    // If the new buffer has been allocated copy the data to it
    // and free the old buffer
    if (new_ptr != NULL) {
    28e8:	9b07      	ldr	r3, [sp, #28]
    28ea:	2b00      	cmp	r3, #0
    28ec:	d00f      	beq.n	290e <__wrap__realloc_r+0x5e>
        uint32_t copy_size = (old_size < size) ? old_size : size;
    28ee:	9a06      	ldr	r2, [sp, #24]
    28f0:	9b01      	ldr	r3, [sp, #4]
    28f2:	429a      	cmp	r2, r3
    28f4:	d201      	bcs.n	28fa <__wrap__realloc_r+0x4a>
    28f6:	9b06      	ldr	r3, [sp, #24]
    28f8:	e000      	b.n	28fc <__wrap__realloc_r+0x4c>
    28fa:	9b01      	ldr	r3, [sp, #4]
    28fc:	9304      	str	r3, [sp, #16]
        memcpy(new_ptr, (void *)ptr, copy_size);
    28fe:	9a04      	ldr	r2, [sp, #16]
    2900:	9902      	ldr	r1, [sp, #8]
    2902:	9807      	ldr	r0, [sp, #28]
    2904:	f7fe f80c 	bl	920 <memcpy>
        free(ptr);
    2908:	9802      	ldr	r0, [sp, #8]
    290a:	f008 fa99 	bl	ae40 <free>
    }
#else // #ifdef MBED_HEAP_STATS_ENABLED
    new_ptr = __real__realloc_r(r, ptr, size);
#endif // #ifdef MBED_HEAP_STATS_ENABLED
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_realloc(new_ptr, ptr, size, MBED_CALLER_ADDR());
    290e:	4623      	mov	r3, r4
    2910:	9a01      	ldr	r2, [sp, #4]
    2912:	9902      	ldr	r1, [sp, #8]
    2914:	9807      	ldr	r0, [sp, #28]
    2916:	f000 fb81 	bl	301c <mbed_mem_trace_realloc>
    mbed_mem_trace_unlock();
    291a:	f000 fb4f 	bl	2fbc <mbed_mem_trace_unlock>
#endif // #ifdef MBED_MEM_TRACING_ENABLED
    return new_ptr;
    291e:	9b07      	ldr	r3, [sp, #28]
}
    2920:	4618      	mov	r0, r3
    2922:	b008      	add	sp, #32
    2924:	bd10      	pop	{r4, pc}

00002926 <__wrap__free_r>:

extern "C" void __wrap__free_r(struct _reent *r, void *ptr)
{
    2926:	b500      	push	{lr}
    2928:	b083      	sub	sp, #12
    292a:	4673      	mov	r3, lr
    292c:	9001      	str	r0, [sp, #4]
    292e:	9100      	str	r1, [sp, #0]
    free_wrapper(r, ptr, MBED_CALLER_ADDR());
    2930:	461a      	mov	r2, r3
    2932:	9900      	ldr	r1, [sp, #0]
    2934:	9801      	ldr	r0, [sp, #4]
    2936:	f000 f805 	bl	2944 <free_wrapper>
}
    293a:	bf00      	nop
    293c:	b003      	add	sp, #12
    293e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00002944 <free_wrapper>:

extern "C" void free_wrapper(struct _reent *r, void *ptr, void *caller)
{
    2944:	b500      	push	{lr}
    2946:	b087      	sub	sp, #28
    2948:	9003      	str	r0, [sp, #12]
    294a:	9102      	str	r1, [sp, #8]
    294c:	9201      	str	r2, [sp, #4]
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_lock();
    294e:	f000 fb1f 	bl	2f90 <mbed_mem_trace_lock>
#endif
#ifdef MBED_HEAP_STATS_ENABLED
    malloc_stats_mutex->lock();
    2952:	4819      	ldr	r0, [pc, #100]	; (29b8 <free_wrapper+0x74>)
    2954:	f7fe fff2 	bl	193c <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    2958:	4603      	mov	r3, r0
    295a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    295e:	4618      	mov	r0, r3
    2960:	f001 fa94 	bl	3e8c <_ZN4rtos5Mutex4lockEm>
    alloc_info_t *alloc_info = NULL;
    2964:	2300      	movs	r3, #0
    2966:	9305      	str	r3, [sp, #20]
    if (ptr != NULL) {
    2968:	9b02      	ldr	r3, [sp, #8]
    296a:	2b00      	cmp	r3, #0
    296c:	d00e      	beq.n	298c <free_wrapper+0x48>
        alloc_info = ((alloc_info_t *)ptr) - 1;
    296e:	9b02      	ldr	r3, [sp, #8]
    2970:	3b08      	subs	r3, #8
    2972:	9305      	str	r3, [sp, #20]
        heap_stats.current_size -= alloc_info->size;
    2974:	4b11      	ldr	r3, [pc, #68]	; (29bc <free_wrapper+0x78>)
    2976:	681a      	ldr	r2, [r3, #0]
    2978:	9b05      	ldr	r3, [sp, #20]
    297a:	681b      	ldr	r3, [r3, #0]
    297c:	1ad3      	subs	r3, r2, r3
    297e:	4a0f      	ldr	r2, [pc, #60]	; (29bc <free_wrapper+0x78>)
    2980:	6013      	str	r3, [r2, #0]
        heap_stats.alloc_cnt -= 1;
    2982:	4b0e      	ldr	r3, [pc, #56]	; (29bc <free_wrapper+0x78>)
    2984:	691b      	ldr	r3, [r3, #16]
    2986:	3b01      	subs	r3, #1
    2988:	4a0c      	ldr	r2, [pc, #48]	; (29bc <free_wrapper+0x78>)
    298a:	6113      	str	r3, [r2, #16]
    }
    __real__free_r(r, (void *)alloc_info);
    298c:	9905      	ldr	r1, [sp, #20]
    298e:	9803      	ldr	r0, [sp, #12]
    2990:	f007 fefc 	bl	a78c <_free_r>
    malloc_stats_mutex->unlock();
    2994:	4808      	ldr	r0, [pc, #32]	; (29b8 <free_wrapper+0x74>)
    2996:	f7fe ffd1 	bl	193c <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    299a:	4603      	mov	r3, r0
    299c:	4618      	mov	r0, r3
    299e:	f001 fa8d 	bl	3ebc <_ZN4rtos5Mutex6unlockEv>
#else // #ifdef MBED_HEAP_STATS_ENABLED
    __real__free_r(r, ptr);
#endif // #ifdef MBED_HEAP_STATS_ENABLED
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_free(ptr, caller);
    29a2:	9901      	ldr	r1, [sp, #4]
    29a4:	9802      	ldr	r0, [sp, #8]
    29a6:	f000 fb79 	bl	309c <mbed_mem_trace_free>
    mbed_mem_trace_unlock();
    29aa:	f000 fb07 	bl	2fbc <mbed_mem_trace_unlock>
#endif // #ifdef MBED_MEM_TRACING_ENABLED
}
    29ae:	bf00      	nop
    29b0:	b007      	add	sp, #28
    29b2:	f85d fb04 	ldr.w	pc, [sp], #4
    29b6:	bf00      	nop
    29b8:	20000cb0 	.word	0x20000cb0
    29bc:	20000cd8 	.word	0x20000cd8

000029c0 <__wrap__calloc_r>:

extern "C" void *__wrap__calloc_r(struct _reent *r, size_t nmemb, size_t size)
{
    29c0:	b510      	push	{r4, lr}
    29c2:	b086      	sub	sp, #24
    29c4:	4674      	mov	r4, lr
    29c6:	9003      	str	r0, [sp, #12]
    29c8:	9102      	str	r1, [sp, #8]
    29ca:	9201      	str	r2, [sp, #4]
    void *ptr = NULL;
    29cc:	2300      	movs	r3, #0
    29ce:	9305      	str	r3, [sp, #20]
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_lock();
    29d0:	f000 fade 	bl	2f90 <mbed_mem_trace_lock>
#endif
#ifdef MBED_HEAP_STATS_ENABLED
    // Note - no lock needed since malloc is thread safe

    ptr = malloc(nmemb * size);
    29d4:	9b02      	ldr	r3, [sp, #8]
    29d6:	9a01      	ldr	r2, [sp, #4]
    29d8:	fb02 f303 	mul.w	r3, r2, r3
    29dc:	4618      	mov	r0, r3
    29de:	f008 fa27 	bl	ae30 <malloc>
    29e2:	9005      	str	r0, [sp, #20]
    if (ptr != NULL) {
    29e4:	9b05      	ldr	r3, [sp, #20]
    29e6:	2b00      	cmp	r3, #0
    29e8:	d008      	beq.n	29fc <__wrap__calloc_r+0x3c>
        memset(ptr, 0, nmemb * size);
    29ea:	9b02      	ldr	r3, [sp, #8]
    29ec:	9a01      	ldr	r2, [sp, #4]
    29ee:	fb02 f303 	mul.w	r3, r2, r3
    29f2:	461a      	mov	r2, r3
    29f4:	2100      	movs	r1, #0
    29f6:	9805      	ldr	r0, [sp, #20]
    29f8:	f008 fd54 	bl	b4a4 <memset>
    }
#else // #ifdef MBED_HEAP_STATS_ENABLED
    ptr = __real__calloc_r(r, nmemb, size);
#endif // #ifdef MBED_HEAP_STATS_ENABLED
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_calloc(ptr, nmemb, size, MBED_CALLER_ADDR());
    29fc:	4623      	mov	r3, r4
    29fe:	9a01      	ldr	r2, [sp, #4]
    2a00:	9902      	ldr	r1, [sp, #8]
    2a02:	9805      	ldr	r0, [sp, #20]
    2a04:	f000 fb2a 	bl	305c <mbed_mem_trace_calloc>
    mbed_mem_trace_unlock();
    2a08:	f000 fad8 	bl	2fbc <mbed_mem_trace_unlock>
#endif // #ifdef MBED_MEM_TRACING_ENABLED
    return ptr;
    2a0c:	9b05      	ldr	r3, [sp, #20]
}
    2a0e:	4618      	mov	r0, r3
    2a10:	b006      	add	sp, #24
    2a12:	bd10      	pop	{r4, pc}

00002a14 <mbed_assert_internal>:

#include "platform/mbed_interface.h"
#include "platform/mbed_critical.h"

void mbed_assert_internal(const char *expr, const char *file, int line)
{
    2a14:	b500      	push	{lr}
    2a16:	b085      	sub	sp, #20
    2a18:	9003      	str	r0, [sp, #12]
    2a1a:	9102      	str	r1, [sp, #8]
    2a1c:	9201      	str	r2, [sp, #4]
    core_util_critical_section_enter();
    2a1e:	f000 f8c7 	bl	2bb0 <core_util_critical_section_enter>
    mbed_error_printf("mbed assertation failed: %s, file: %s, line %d \n", expr, file, line);
    2a22:	9b01      	ldr	r3, [sp, #4]
    2a24:	9a02      	ldr	r2, [sp, #8]
    2a26:	9903      	ldr	r1, [sp, #12]
    2a28:	4804      	ldr	r0, [pc, #16]	; (2a3c <mbed_assert_internal+0x28>)
    2a2a:	f000 f848 	bl	2abe <mbed_error_printf>
    mbed_die();
    2a2e:	f000 f807 	bl	2a40 <mbed_die>
}
    2a32:	bf00      	nop
    2a34:	b005      	add	sp, #20
    2a36:	f85d fb04 	ldr.w	pc, [sp], #4
    2a3a:	bf00      	nop
    2a3c:	00010ba0 	.word	0x00010ba0

00002a40 <mbed_die>:
extern int stdio_uart_inited;
extern serial_t stdio_uart;
#endif

WEAK void mbed_die(void)
{
    2a40:	b500      	push	{lr}
    2a42:	b085      	sub	sp, #20
#if !defined (NRF51_H) && !defined(TARGET_EFM32)
    core_util_critical_section_enter();
    2a44:	f000 f8b4 	bl	2bb0 <core_util_critical_section_enter>
#endif
    gpio_t led_err;
    gpio_init_out(&led_err, LED1);
    2a48:	ab01      	add	r3, sp, #4
    2a4a:	f241 0116 	movw	r1, #4118	; 0x1016
    2a4e:	4618      	mov	r0, r3
    2a50:	f7ff f952 	bl	1cf8 <gpio_init_out>

    while (1) {
        for (int i = 0; i < 4; ++i) {
    2a54:	2300      	movs	r3, #0
    2a56:	9303      	str	r3, [sp, #12]
    2a58:	e012      	b.n	2a80 <mbed_die+0x40>
            gpio_write(&led_err, 1);
    2a5a:	ab01      	add	r3, sp, #4
    2a5c:	2101      	movs	r1, #1
    2a5e:	4618      	mov	r0, r3
    2a60:	f007 fb66 	bl	a130 <gpio_write>
            wait_ms(150);
    2a64:	2096      	movs	r0, #150	; 0x96
    2a66:	f001 f979 	bl	3d5c <wait_ms>
            gpio_write(&led_err, 0);
    2a6a:	ab01      	add	r3, sp, #4
    2a6c:	2100      	movs	r1, #0
    2a6e:	4618      	mov	r0, r3
    2a70:	f007 fb5e 	bl	a130 <gpio_write>
            wait_ms(150);
    2a74:	2096      	movs	r0, #150	; 0x96
    2a76:	f001 f971 	bl	3d5c <wait_ms>
        for (int i = 0; i < 4; ++i) {
    2a7a:	9b03      	ldr	r3, [sp, #12]
    2a7c:	3301      	adds	r3, #1
    2a7e:	9303      	str	r3, [sp, #12]
    2a80:	9b03      	ldr	r3, [sp, #12]
    2a82:	2b03      	cmp	r3, #3
    2a84:	dde9      	ble.n	2a5a <mbed_die+0x1a>
        }

        for (int i = 0; i < 4; ++i) {
    2a86:	2300      	movs	r3, #0
    2a88:	9302      	str	r3, [sp, #8]
    2a8a:	e014      	b.n	2ab6 <mbed_die+0x76>
            gpio_write(&led_err, 1);
    2a8c:	ab01      	add	r3, sp, #4
    2a8e:	2101      	movs	r1, #1
    2a90:	4618      	mov	r0, r3
    2a92:	f007 fb4d 	bl	a130 <gpio_write>
            wait_ms(400);
    2a96:	f44f 70c8 	mov.w	r0, #400	; 0x190
    2a9a:	f001 f95f 	bl	3d5c <wait_ms>
            gpio_write(&led_err, 0);
    2a9e:	ab01      	add	r3, sp, #4
    2aa0:	2100      	movs	r1, #0
    2aa2:	4618      	mov	r0, r3
    2aa4:	f007 fb44 	bl	a130 <gpio_write>
            wait_ms(400);
    2aa8:	f44f 70c8 	mov.w	r0, #400	; 0x190
    2aac:	f001 f956 	bl	3d5c <wait_ms>
        for (int i = 0; i < 4; ++i) {
    2ab0:	9b02      	ldr	r3, [sp, #8]
    2ab2:	3301      	adds	r3, #1
    2ab4:	9302      	str	r3, [sp, #8]
    2ab6:	9b02      	ldr	r3, [sp, #8]
    2ab8:	2b03      	cmp	r3, #3
    2aba:	dde7      	ble.n	2a8c <mbed_die+0x4c>
        for (int i = 0; i < 4; ++i) {
    2abc:	e7ca      	b.n	2a54 <mbed_die+0x14>

00002abe <mbed_error_printf>:
        }
    }
}

void mbed_error_printf(const char *format, ...)
{
    2abe:	b40f      	push	{r0, r1, r2, r3}
    2ac0:	b500      	push	{lr}
    2ac2:	b083      	sub	sp, #12
    va_list arg;
    va_start(arg, format);
    2ac4:	ab05      	add	r3, sp, #20
    2ac6:	9301      	str	r3, [sp, #4]
    mbed_error_vfprintf(format, arg);
    2ac8:	9901      	ldr	r1, [sp, #4]
    2aca:	9804      	ldr	r0, [sp, #16]
    2acc:	f000 f806 	bl	2adc <mbed_error_vfprintf>
    va_end(arg);
}
    2ad0:	bf00      	nop
    2ad2:	b003      	add	sp, #12
    2ad4:	f85d eb04 	ldr.w	lr, [sp], #4
    2ad8:	b004      	add	sp, #16
    2ada:	4770      	bx	lr

00002adc <mbed_error_vfprintf>:

void mbed_error_vfprintf(const char *format, va_list arg)
{
    2adc:	b500      	push	{lr}
    2ade:	b0a7      	sub	sp, #156	; 0x9c
    2ae0:	9001      	str	r0, [sp, #4]
    2ae2:	9100      	str	r1, [sp, #0]
#if DEVICE_SERIAL
#define ERROR_BUF_SIZE      (128)
    core_util_critical_section_enter();
    2ae4:	f000 f864 	bl	2bb0 <core_util_critical_section_enter>
    char buffer[ERROR_BUF_SIZE];
    int size = vsnprintf(buffer, ERROR_BUF_SIZE, format, arg);
    2ae8:	a803      	add	r0, sp, #12
    2aea:	9b00      	ldr	r3, [sp, #0]
    2aec:	9a01      	ldr	r2, [sp, #4]
    2aee:	2180      	movs	r1, #128	; 0x80
    2af0:	f00c fa00 	bl	eef4 <vsnprintf>
    2af4:	9023      	str	r0, [sp, #140]	; 0x8c
    if (size > 0) {
    2af6:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    2af8:	2b00      	cmp	r3, #0
    2afa:	dd33      	ble.n	2b64 <mbed_error_vfprintf+0x88>
        if (!stdio_uart_inited) {
    2afc:	4b1c      	ldr	r3, [pc, #112]	; (2b70 <mbed_error_vfprintf+0x94>)
    2afe:	681b      	ldr	r3, [r3, #0]
    2b00:	2b00      	cmp	r3, #0
    2b02:	d106      	bne.n	2b12 <mbed_error_vfprintf+0x36>
            serial_init(&stdio_uart, STDIO_UART_TX, STDIO_UART_RX);
    2b04:	f241 0210 	movw	r2, #4112	; 0x1010
    2b08:	f241 0111 	movw	r1, #4113	; 0x1011
    2b0c:	4819      	ldr	r0, [pc, #100]	; (2b74 <mbed_error_vfprintf+0x98>)
    2b0e:	f006 ff35 	bl	997c <serial_init>
        }
#if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES
        char stdio_out_prev = '\0';
    2b12:	2300      	movs	r3, #0
    2b14:	f88d 3097 	strb.w	r3, [sp, #151]	; 0x97
        for (int i = 0; i < size; i++) {
    2b18:	2300      	movs	r3, #0
    2b1a:	9324      	str	r3, [sp, #144]	; 0x90
    2b1c:	e01e      	b.n	2b5c <mbed_error_vfprintf+0x80>
            if (buffer[i] == '\n' && stdio_out_prev != '\r') {
    2b1e:	aa03      	add	r2, sp, #12
    2b20:	9b24      	ldr	r3, [sp, #144]	; 0x90
    2b22:	4413      	add	r3, r2
    2b24:	781b      	ldrb	r3, [r3, #0]
    2b26:	2b0a      	cmp	r3, #10
    2b28:	d107      	bne.n	2b3a <mbed_error_vfprintf+0x5e>
    2b2a:	f89d 3097 	ldrb.w	r3, [sp, #151]	; 0x97
    2b2e:	2b0d      	cmp	r3, #13
    2b30:	d003      	beq.n	2b3a <mbed_error_vfprintf+0x5e>
                serial_putc(&stdio_uart, '\r');
    2b32:	210d      	movs	r1, #13
    2b34:	480f      	ldr	r0, [pc, #60]	; (2b74 <mbed_error_vfprintf+0x98>)
    2b36:	f006 fff7 	bl	9b28 <serial_putc>
            }
            serial_putc(&stdio_uart, buffer[i]);
    2b3a:	aa03      	add	r2, sp, #12
    2b3c:	9b24      	ldr	r3, [sp, #144]	; 0x90
    2b3e:	4413      	add	r3, r2
    2b40:	781b      	ldrb	r3, [r3, #0]
    2b42:	4619      	mov	r1, r3
    2b44:	480b      	ldr	r0, [pc, #44]	; (2b74 <mbed_error_vfprintf+0x98>)
    2b46:	f006 ffef 	bl	9b28 <serial_putc>
            stdio_out_prev = buffer[i];
    2b4a:	aa03      	add	r2, sp, #12
    2b4c:	9b24      	ldr	r3, [sp, #144]	; 0x90
    2b4e:	4413      	add	r3, r2
    2b50:	781b      	ldrb	r3, [r3, #0]
    2b52:	f88d 3097 	strb.w	r3, [sp, #151]	; 0x97
        for (int i = 0; i < size; i++) {
    2b56:	9b24      	ldr	r3, [sp, #144]	; 0x90
    2b58:	3301      	adds	r3, #1
    2b5a:	9324      	str	r3, [sp, #144]	; 0x90
    2b5c:	9a24      	ldr	r2, [sp, #144]	; 0x90
    2b5e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    2b60:	429a      	cmp	r2, r3
    2b62:	dbdc      	blt.n	2b1e <mbed_error_vfprintf+0x42>
        for (int i = 0; i < size; i++) {
            serial_putc(&stdio_uart, buffer[i]);
        }
#endif
    }
    core_util_critical_section_exit();
    2b64:	f000 f83e 	bl	2be4 <core_util_critical_section_exit>
#endif
}
    2b68:	bf00      	nop
    2b6a:	b027      	add	sp, #156	; 0x9c
    2b6c:	f85d fb04 	ldr.w	pc, [sp], #4
    2b70:	20001538 	.word	0x20001538
    2b74:	20002f6c 	.word	0x20002f6c

00002b78 <core_util_are_interrupts_enabled>:
#endif

static volatile uint32_t critical_section_reentrancy_counter = 0;

bool core_util_are_interrupts_enabled(void)
{
    2b78:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    2b7a:	f3ef 8310 	mrs	r3, PRIMASK
    2b7e:	9301      	str	r3, [sp, #4]
  return(result);
    2b80:	9b01      	ldr	r3, [sp, #4]
#if defined(__CORTEX_A9)
    return ((__get_CPSR() & 0x80) == 0);
#else
    return ((__get_PRIMASK() & 0x1) == 0);
    2b82:	f003 0301 	and.w	r3, r3, #1
    2b86:	2b00      	cmp	r3, #0
    2b88:	bf0c      	ite	eq
    2b8a:	2301      	moveq	r3, #1
    2b8c:	2300      	movne	r3, #0
    2b8e:	b2db      	uxtb	r3, r3
#endif
}
    2b90:	4618      	mov	r0, r3
    2b92:	b002      	add	sp, #8
    2b94:	4770      	bx	lr

00002b96 <core_util_is_isr_active>:

bool core_util_is_isr_active(void)
{
    2b96:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    2b98:	f3ef 8305 	mrs	r3, IPSR
    2b9c:	9301      	str	r3, [sp, #4]
  return(result);
    2b9e:	9b01      	ldr	r3, [sp, #4]
        case CPSR_M_SVC:
        default:
            return true;
    }
#else
    return (__get_IPSR() != 0U);
    2ba0:	2b00      	cmp	r3, #0
    2ba2:	bf14      	ite	ne
    2ba4:	2301      	movne	r3, #1
    2ba6:	2300      	moveq	r3, #0
    2ba8:	b2db      	uxtb	r3, r3
#endif
}
    2baa:	4618      	mov	r0, r3
    2bac:	b002      	add	sp, #8
    2bae:	4770      	bx	lr

00002bb0 <core_util_critical_section_enter>:
{
    return hal_in_critical_section();
}

void core_util_critical_section_enter(void)
{
    2bb0:	b508      	push	{r3, lr}
// FIXME
#ifdef FEATURE_UVISOR
#warning "core_util_critical_section_enter needs fixing to work from unprivileged code"
#else
    // If the reentrancy counter overflows something has gone badly wrong.
    MBED_ASSERT(critical_section_reentrancy_counter < UINT32_MAX);
    2bb2:	4b09      	ldr	r3, [pc, #36]	; (2bd8 <core_util_critical_section_enter+0x28>)
    2bb4:	681b      	ldr	r3, [r3, #0]
    2bb6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    2bba:	d104      	bne.n	2bc6 <core_util_critical_section_enter+0x16>
    2bbc:	2255      	movs	r2, #85	; 0x55
    2bbe:	4907      	ldr	r1, [pc, #28]	; (2bdc <core_util_critical_section_enter+0x2c>)
    2bc0:	4807      	ldr	r0, [pc, #28]	; (2be0 <core_util_critical_section_enter+0x30>)
    2bc2:	f7ff ff27 	bl	2a14 <mbed_assert_internal>
#endif /* FEATURE_UVISOR */

    hal_critical_section_enter();
    2bc6:	f7fe fffd 	bl	1bc4 <hal_critical_section_enter>

    ++critical_section_reentrancy_counter;
    2bca:	4b03      	ldr	r3, [pc, #12]	; (2bd8 <core_util_critical_section_enter+0x28>)
    2bcc:	681b      	ldr	r3, [r3, #0]
    2bce:	3301      	adds	r3, #1
    2bd0:	4a01      	ldr	r2, [pc, #4]	; (2bd8 <core_util_critical_section_enter+0x28>)
    2bd2:	6013      	str	r3, [r2, #0]
}
    2bd4:	bf00      	nop
    2bd6:	bd08      	pop	{r3, pc}
    2bd8:	20000cf0 	.word	0x20000cf0
    2bdc:	00010bd4 	.word	0x00010bd4
    2be0:	00010bf8 	.word	0x00010bf8

00002be4 <core_util_critical_section_exit>:

void core_util_critical_section_exit(void)
{
    2be4:	b508      	push	{r3, lr}
#ifdef FEATURE_UVISOR
#warning "core_util_critical_section_exit needs fixing to work from unprivileged code"
#endif /* FEATURE_UVISOR */

    // If critical_section_enter has not previously been called, do nothing
    if (critical_section_reentrancy_counter == 0) {
    2be6:	4b09      	ldr	r3, [pc, #36]	; (2c0c <core_util_critical_section_exit+0x28>)
    2be8:	681b      	ldr	r3, [r3, #0]
    2bea:	2b00      	cmp	r3, #0
    2bec:	d00b      	beq.n	2c06 <core_util_critical_section_exit+0x22>
        return;
    }

    --critical_section_reentrancy_counter;
    2bee:	4b07      	ldr	r3, [pc, #28]	; (2c0c <core_util_critical_section_exit+0x28>)
    2bf0:	681b      	ldr	r3, [r3, #0]
    2bf2:	3b01      	subs	r3, #1
    2bf4:	4a05      	ldr	r2, [pc, #20]	; (2c0c <core_util_critical_section_exit+0x28>)
    2bf6:	6013      	str	r3, [r2, #0]

    if (critical_section_reentrancy_counter == 0) {
    2bf8:	4b04      	ldr	r3, [pc, #16]	; (2c0c <core_util_critical_section_exit+0x28>)
    2bfa:	681b      	ldr	r3, [r3, #0]
    2bfc:	2b00      	cmp	r3, #0
    2bfe:	d103      	bne.n	2c08 <core_util_critical_section_exit+0x24>
        hal_critical_section_exit();
    2c00:	f7fe fffe 	bl	1c00 <hal_critical_section_exit>
    2c04:	e000      	b.n	2c08 <core_util_critical_section_exit+0x24>
        return;
    2c06:	bf00      	nop
    }
}
    2c08:	bd08      	pop	{r3, pc}
    2c0a:	bf00      	nop
    2c0c:	20000cf0 	.word	0x20000cf0

00002c10 <core_util_atomic_incr_u16>:
    } while (__STREXB(newValue, valuePtr));
    return newValue;
}

uint16_t core_util_atomic_incr_u16(volatile uint16_t *valuePtr, uint16_t delta)
{
    2c10:	b088      	sub	sp, #32
    2c12:	9001      	str	r0, [sp, #4]
    2c14:	460b      	mov	r3, r1
    2c16:	f8ad 3002 	strh.w	r3, [sp, #2]
    2c1a:	9b01      	ldr	r3, [sp, #4]
    2c1c:	9304      	str	r3, [sp, #16]
__STATIC_FORCEINLINE uint16_t __LDREXH(volatile uint16_t *addr)
{
    uint32_t result;

#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
    2c1e:	9b04      	ldr	r3, [sp, #16]
    2c20:	e8d3 3f5f 	ldrexh	r3, [r3]
    2c24:	9303      	str	r3, [sp, #12]
    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
       accepted by assembler. So has to use following less efficient pattern.
    */
   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
#endif
   return ((uint16_t) result);    /* Add explicit type cast here */
    2c26:	9b03      	ldr	r3, [sp, #12]
    2c28:	b29a      	uxth	r2, r3
    uint16_t newValue;
    do {
        newValue = __LDREXH(valuePtr) + delta;
    2c2a:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    2c2e:	4413      	add	r3, r2
    2c30:	f8ad 301e 	strh.w	r3, [sp, #30]
    2c34:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    2c38:	f8ad 301c 	strh.w	r3, [sp, #28]
    2c3c:	9b01      	ldr	r3, [sp, #4]
    2c3e:	9306      	str	r3, [sp, #24]
 */
__STATIC_FORCEINLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
{
   uint32_t result;

   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
    2c40:	f8bd 201c 	ldrh.w	r2, [sp, #28]
    2c44:	9906      	ldr	r1, [sp, #24]
    2c46:	e8c1 2f53 	strexh	r3, r2, [r1]
    2c4a:	9305      	str	r3, [sp, #20]
   return(result);
    2c4c:	9b05      	ldr	r3, [sp, #20]
    } while (__STREXH(newValue, valuePtr));
    2c4e:	2b00      	cmp	r3, #0
    2c50:	d1e3      	bne.n	2c1a <core_util_atomic_incr_u16+0xa>
    return newValue;
    2c52:	f8bd 301e 	ldrh.w	r3, [sp, #30]
}
    2c56:	4618      	mov	r0, r3
    2c58:	b008      	add	sp, #32
    2c5a:	4770      	bx	lr

00002c5c <core_util_atomic_decr_u16>:
    } while (__STREXB(newValue, valuePtr));
    return newValue;
}

uint16_t core_util_atomic_decr_u16(volatile uint16_t *valuePtr, uint16_t delta)
{
    2c5c:	b088      	sub	sp, #32
    2c5e:	9001      	str	r0, [sp, #4]
    2c60:	460b      	mov	r3, r1
    2c62:	f8ad 3002 	strh.w	r3, [sp, #2]
    2c66:	9b01      	ldr	r3, [sp, #4]
    2c68:	9304      	str	r3, [sp, #16]
   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
    2c6a:	9b04      	ldr	r3, [sp, #16]
    2c6c:	e8d3 3f5f 	ldrexh	r3, [r3]
    2c70:	9303      	str	r3, [sp, #12]
   return ((uint16_t) result);    /* Add explicit type cast here */
    2c72:	9b03      	ldr	r3, [sp, #12]
    2c74:	b29a      	uxth	r2, r3
    uint16_t newValue;
    do {
        newValue = __LDREXH(valuePtr) - delta;
    2c76:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    2c7a:	1ad3      	subs	r3, r2, r3
    2c7c:	f8ad 301e 	strh.w	r3, [sp, #30]
    2c80:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    2c84:	f8ad 301c 	strh.w	r3, [sp, #28]
    2c88:	9b01      	ldr	r3, [sp, #4]
    2c8a:	9306      	str	r3, [sp, #24]
   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
    2c8c:	f8bd 201c 	ldrh.w	r2, [sp, #28]
    2c90:	9906      	ldr	r1, [sp, #24]
    2c92:	e8c1 2f53 	strexh	r3, r2, [r1]
    2c96:	9305      	str	r3, [sp, #20]
   return(result);
    2c98:	9b05      	ldr	r3, [sp, #20]
    } while (__STREXH(newValue, valuePtr));
    2c9a:	2b00      	cmp	r3, #0
    2c9c:	d1e3      	bne.n	2c66 <core_util_atomic_decr_u16+0xa>
    return newValue;
    2c9e:	f8bd 301e 	ldrh.w	r3, [sp, #30]
}
    2ca2:	4618      	mov	r0, r3
    2ca4:	b008      	add	sp, #32
    2ca6:	4770      	bx	lr

00002ca8 <mbed_halt_system>:
static void print_error_report(mbed_error_ctx *ctx, const char *);
static mbed_error_status_t handle_error(mbed_error_status_t error_status, unsigned int error_value, const char *filename, int line_number);

//Helper function to halt the system
static void mbed_halt_system(void)
{
    2ca8:	b508      	push	{r3, lr}
    //If not in ISR context exit, otherwise spin on WFI
    if (core_util_is_isr_active() || !core_util_are_interrupts_enabled()) {
    2caa:	f7ff ff74 	bl	2b96 <core_util_is_isr_active>
    2cae:	4603      	mov	r3, r0
    2cb0:	2b00      	cmp	r3, #0
    2cb2:	d107      	bne.n	2cc4 <mbed_halt_system+0x1c>
    2cb4:	f7ff ff60 	bl	2b78 <core_util_are_interrupts_enabled>
    2cb8:	4603      	mov	r3, r0
    2cba:	f083 0301 	eor.w	r3, r3, #1
    2cbe:	b2db      	uxtb	r3, r3
    2cc0:	2b00      	cmp	r3, #0
    2cc2:	d001      	beq.n	2cc8 <mbed_halt_system+0x20>
        for (;;) {
            __WFI();
    2cc4:	bf30      	wfi
    2cc6:	e7fd      	b.n	2cc4 <mbed_halt_system+0x1c>
        }
    } else {
        //exit eventually calls mbed_die
        exit(1);
    2cc8:	2001      	movs	r0, #1
    2cca:	f000 feeb 	bl	3aa4 <__wrap_exit>
	...

00002cd0 <handle_error>:
    exit(1);
}

//Set an error status with the error handling system
static mbed_error_status_t handle_error(mbed_error_status_t error_status, unsigned int error_value, const char *filename, int line_number)
{
    2cd0:	b510      	push	{r4, lr}
    2cd2:	b094      	sub	sp, #80	; 0x50
    2cd4:	4674      	mov	r4, lr
    2cd6:	9003      	str	r0, [sp, #12]
    2cd8:	9102      	str	r1, [sp, #8]
    2cda:	9201      	str	r2, [sp, #4]
    2cdc:	9300      	str	r3, [sp, #0]
    mbed_error_ctx current_error_ctx;

    //Error status should always be < 0
    if (error_status >= 0) {
    2cde:	9b03      	ldr	r3, [sp, #12]
    2ce0:	2b00      	cmp	r3, #0
    2ce2:	db01      	blt.n	2ce8 <handle_error+0x18>
        //This is a weird situation, someone called mbed_error with invalid error code.
        //We will still handle the situation but change the error code to ERROR_INVALID_ARGUMENT, atleast the context will have info on who called it
        error_status = MBED_ERROR_INVALID_ARGUMENT;
    2ce4:	4b35      	ldr	r3, [pc, #212]	; (2dbc <handle_error+0xec>)
    2ce6:	9303      	str	r3, [sp, #12]
    }

    //Prevent corruption by holding out other callers
    //and we also need this until we remove the "error" call completely
    while (error_in_progress == 1);
    2ce8:	bf00      	nop
    2cea:	4b35      	ldr	r3, [pc, #212]	; (2dc0 <handle_error+0xf0>)
    2cec:	781b      	ldrb	r3, [r3, #0]
    2cee:	2b01      	cmp	r3, #1
    2cf0:	d0fb      	beq.n	2cea <handle_error+0x1a>

    //Use critsect here, as we don't want inadvertant modification of this global variable
    core_util_critical_section_enter();
    2cf2:	f7ff ff5d 	bl	2bb0 <core_util_critical_section_enter>
    error_in_progress = 1;
    2cf6:	4b32      	ldr	r3, [pc, #200]	; (2dc0 <handle_error+0xf0>)
    2cf8:	2201      	movs	r2, #1
    2cfa:	701a      	strb	r2, [r3, #0]
    core_util_critical_section_exit();
    2cfc:	f7ff ff72 	bl	2be4 <core_util_critical_section_exit>

    //Increment error count
    error_count++;
    2d00:	4b30      	ldr	r3, [pc, #192]	; (2dc4 <handle_error+0xf4>)
    2d02:	681b      	ldr	r3, [r3, #0]
    2d04:	3301      	adds	r3, #1
    2d06:	4a2f      	ldr	r2, [pc, #188]	; (2dc4 <handle_error+0xf4>)
    2d08:	6013      	str	r3, [r2, #0]

    //Clear the context capturing buffer
    memset(&current_error_ctx, sizeof(mbed_error_ctx), 0);
    2d0a:	ab04      	add	r3, sp, #16
    2d0c:	2200      	movs	r2, #0
    2d0e:	2134      	movs	r1, #52	; 0x34
    2d10:	4618      	mov	r0, r3
    2d12:	f008 fbc7 	bl	b4a4 <memset>
    //Capture error information
    current_error_ctx.error_status = error_status;
    2d16:	9b03      	ldr	r3, [sp, #12]
    2d18:	9304      	str	r3, [sp, #16]
    current_error_ctx.error_address = (uint32_t)MBED_CALLER_ADDR();
    2d1a:	4623      	mov	r3, r4
    2d1c:	9305      	str	r3, [sp, #20]
    current_error_ctx.error_value = error_value;
    2d1e:	9b02      	ldr	r3, [sp, #8]
    2d20:	9306      	str	r3, [sp, #24]
#ifdef MBED_CONF_RTOS_PRESENT
    //Capture thread info
    osRtxThread_t *current_thread = osRtxInfo.thread.run.curr;
    2d22:	4b29      	ldr	r3, [pc, #164]	; (2dc8 <handle_error+0xf8>)
    2d24:	695b      	ldr	r3, [r3, #20]
    2d26:	9313      	str	r3, [sp, #76]	; 0x4c
    current_error_ctx.thread_id = (uint32_t)current_thread;
    2d28:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2d2a:	9307      	str	r3, [sp, #28]
    current_error_ctx.thread_entry_address = (uint32_t)current_thread->thread_addr;
    2d2c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2d2e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    2d30:	9308      	str	r3, [sp, #32]
    current_error_ctx.thread_stack_size = current_thread->stack_size;
    2d32:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2d34:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    2d36:	9309      	str	r3, [sp, #36]	; 0x24
    current_error_ctx.thread_stack_mem = (uint32_t)current_thread->stack_mem;
    2d38:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2d3a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    2d3c:	930a      	str	r3, [sp, #40]	; 0x28
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    2d3e:	f3ef 8305 	mrs	r3, IPSR
    2d42:	9312      	str	r3, [sp, #72]	; 0x48
  return(result);
    2d44:	9b12      	ldr	r3, [sp, #72]	; 0x48
#ifdef TARGET_CORTEX_M
    GET_CURRENT_SP(current_error_ctx.thread_current_sp);
    2d46:	2b00      	cmp	r3, #0
    2d48:	d005      	beq.n	2d56 <handle_error+0x86>
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
    2d4a:	f3ef 8308 	mrs	r3, MSP
    2d4e:	461c      	mov	r4, r3
  return(result);
    2d50:	4623      	mov	r3, r4
    2d52:	930b      	str	r3, [sp, #44]	; 0x2c
    2d54:	e012      	b.n	2d7c <handle_error+0xac>
  __ASM volatile ("MRS %0, control" : "=r" (result) );
    2d56:	f3ef 8314 	mrs	r3, CONTROL
    2d5a:	9311      	str	r3, [sp, #68]	; 0x44
  return(result);
    2d5c:	9b11      	ldr	r3, [sp, #68]	; 0x44
    2d5e:	f003 0302 	and.w	r3, r3, #2
    2d62:	2b00      	cmp	r3, #0
    2d64:	d105      	bne.n	2d72 <handle_error+0xa2>
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
    2d66:	f3ef 8308 	mrs	r3, MSP
    2d6a:	461c      	mov	r4, r3
  return(result);
    2d6c:	4623      	mov	r3, r4
    2d6e:	930b      	str	r3, [sp, #44]	; 0x2c
    2d70:	e004      	b.n	2d7c <handle_error+0xac>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
    2d72:	f3ef 8309 	mrs	r3, PSP
    2d76:	461c      	mov	r4, r3
  return(result);
    2d78:	4623      	mov	r3, r4
    2d7a:	930b      	str	r3, [sp, #44]	; 0x2c
    strncpy(current_error_ctx.error_filename, filename, MBED_CONF_PLATFORM_MAX_ERROR_FILENAME_LEN);
    current_error_ctx.error_line_number = line_number;
#endif

    //Capture the fist system error and store it
    if (error_count == 1) { //first error
    2d7c:	4b11      	ldr	r3, [pc, #68]	; (2dc4 <handle_error+0xf4>)
    2d7e:	681b      	ldr	r3, [r3, #0]
    2d80:	2b01      	cmp	r3, #1
    2d82:	d105      	bne.n	2d90 <handle_error+0xc0>
        memcpy(&first_error_ctx, &current_error_ctx, sizeof(mbed_error_ctx));
    2d84:	ab04      	add	r3, sp, #16
    2d86:	2234      	movs	r2, #52	; 0x34
    2d88:	4619      	mov	r1, r3
    2d8a:	4810      	ldr	r0, [pc, #64]	; (2dcc <handle_error+0xfc>)
    2d8c:	f7fd fdc8 	bl	920 <memcpy>
    }

    //copy this error to last error
    memcpy(&last_error_ctx, &current_error_ctx, sizeof(mbed_error_ctx));
    2d90:	ab04      	add	r3, sp, #16
    2d92:	2234      	movs	r2, #52	; 0x34
    2d94:	4619      	mov	r1, r3
    2d96:	480e      	ldr	r0, [pc, #56]	; (2dd0 <handle_error+0x100>)
    2d98:	f7fd fdc2 	bl	920 <memcpy>
    //Log the error with error log
    mbed_error_hist_put(&current_error_ctx);
#endif

    //Call the error hook if available
    if (error_hook != NULL) {
    2d9c:	4b0d      	ldr	r3, [pc, #52]	; (2dd4 <handle_error+0x104>)
    2d9e:	681b      	ldr	r3, [r3, #0]
    2da0:	2b00      	cmp	r3, #0
    2da2:	d003      	beq.n	2dac <handle_error+0xdc>
        error_hook(&last_error_ctx);
    2da4:	4b0b      	ldr	r3, [pc, #44]	; (2dd4 <handle_error+0x104>)
    2da6:	681b      	ldr	r3, [r3, #0]
    2da8:	4809      	ldr	r0, [pc, #36]	; (2dd0 <handle_error+0x100>)
    2daa:	4798      	blx	r3
    }

    error_in_progress = 0;
    2dac:	4b04      	ldr	r3, [pc, #16]	; (2dc0 <handle_error+0xf0>)
    2dae:	2200      	movs	r2, #0
    2db0:	701a      	strb	r2, [r3, #0]

    return MBED_SUCCESS;
    2db2:	2300      	movs	r3, #0
}
    2db4:	4618      	mov	r0, r3
    2db6:	b014      	add	sp, #80	; 0x50
    2db8:	bd10      	pop	{r4, pc}
    2dba:	bf00      	nop
    2dbc:	80ff0101 	.word	0x80ff0101
    2dc0:	20000cf4 	.word	0x20000cf4
    2dc4:	20000cf8 	.word	0x20000cf8
    2dc8:	20000110 	.word	0x20000110
    2dcc:	20000cfc 	.word	0x20000cfc
    2dd0:	20000d30 	.word	0x20000d30
    2dd4:	20000d64 	.word	0x20000d64

00002dd8 <mbed_error>:
    return handle_error(error_status, error_value, filename, line_number);
}

//Sets a fatal error, this function is marked WEAK to be able to override this for some tests
WEAK mbed_error_status_t mbed_error(mbed_error_status_t error_status, const char *error_msg, unsigned int error_value, const char *filename, int line_number)
{
    2dd8:	b500      	push	{lr}
    2dda:	b085      	sub	sp, #20
    2ddc:	9003      	str	r0, [sp, #12]
    2dde:	9102      	str	r1, [sp, #8]
    2de0:	9201      	str	r2, [sp, #4]
    2de2:	9300      	str	r3, [sp, #0]
    //set the error reported and then halt the system
    if (MBED_SUCCESS != handle_error(error_status, error_value, filename, line_number)) {
    2de4:	9b06      	ldr	r3, [sp, #24]
    2de6:	9a00      	ldr	r2, [sp, #0]
    2de8:	9901      	ldr	r1, [sp, #4]
    2dea:	9803      	ldr	r0, [sp, #12]
    2dec:	f7ff ff70 	bl	2cd0 <handle_error>
    2df0:	4603      	mov	r3, r0
    2df2:	2b00      	cmp	r3, #0
    2df4:	d001      	beq.n	2dfa <mbed_error+0x22>
        return MBED_ERROR_FAILED_OPERATION;
    2df6:	4b06      	ldr	r3, [pc, #24]	; (2e10 <mbed_error+0x38>)
    2df8:	e006      	b.n	2e08 <mbed_error+0x30>
    }

    //On fatal errors print the error context/report
    ERROR_REPORT(&last_error_ctx, error_msg);
    2dfa:	9902      	ldr	r1, [sp, #8]
    2dfc:	4805      	ldr	r0, [pc, #20]	; (2e14 <mbed_error+0x3c>)
    2dfe:	f000 f80b 	bl	2e18 <print_error_report>
    mbed_halt_system();
    2e02:	f7ff ff51 	bl	2ca8 <mbed_halt_system>

    return MBED_ERROR_FAILED_OPERATION;
    2e06:	4b02      	ldr	r3, [pc, #8]	; (2e10 <mbed_error+0x38>)
}
    2e08:	4618      	mov	r0, r3
    2e0a:	b005      	add	sp, #20
    2e0c:	f85d fb04 	ldr.w	pc, [sp], #4
    2e10:	80ff010f 	.word	0x80ff010f
    2e14:	20000d30 	.word	0x20000d30

00002e18 <print_error_report>:
}
#endif

#ifndef NDEBUG
static void print_error_report(mbed_error_ctx *ctx, const char *error_msg)
{
    2e18:	b510      	push	{r4, lr}
    2e1a:	b086      	sub	sp, #24
    2e1c:	9003      	str	r0, [sp, #12]
    2e1e:	9102      	str	r1, [sp, #8]
    uint32_t error_code = MBED_GET_ERROR_CODE(ctx->error_status);
    2e20:	9b03      	ldr	r3, [sp, #12]
    2e22:	681b      	ldr	r3, [r3, #0]
    2e24:	175b      	asrs	r3, r3, #29
    2e26:	f003 0303 	and.w	r3, r3, #3
    2e2a:	2b03      	cmp	r3, #3
    2e2c:	d103      	bne.n	2e36 <print_error_report+0x1e>
    2e2e:	9b03      	ldr	r3, [sp, #12]
    2e30:	681b      	ldr	r3, [r3, #0]
    2e32:	425b      	negs	r3, r3
    2e34:	e002      	b.n	2e3c <print_error_report+0x24>
    2e36:	9b03      	ldr	r3, [sp, #12]
    2e38:	681b      	ldr	r3, [r3, #0]
    2e3a:	b29b      	uxth	r3, r3
    2e3c:	9305      	str	r3, [sp, #20]
    uint32_t error_module = MBED_GET_ERROR_MODULE(ctx->error_status);
    2e3e:	9b03      	ldr	r3, [sp, #12]
    2e40:	681b      	ldr	r3, [r3, #0]
    2e42:	141b      	asrs	r3, r3, #16
    2e44:	b2db      	uxtb	r3, r3
    2e46:	9304      	str	r3, [sp, #16]

    mbed_error_printf("\n\n++ MbedOS Error Info ++\nError Status: 0x%X Code: %d Module: %d\nError Message: ", ctx->error_status, error_code, error_module);
    2e48:	9b03      	ldr	r3, [sp, #12]
    2e4a:	6819      	ldr	r1, [r3, #0]
    2e4c:	9b04      	ldr	r3, [sp, #16]
    2e4e:	9a05      	ldr	r2, [sp, #20]
    2e50:	483d      	ldr	r0, [pc, #244]	; (2f48 <print_error_report+0x130>)
    2e52:	f7ff fe34 	bl	2abe <mbed_error_printf>

    switch (error_code) {
    2e56:	9b05      	ldr	r3, [sp, #20]
    2e58:	f2a3 1331 	subw	r3, r3, #305	; 0x131
    2e5c:	2b07      	cmp	r3, #7
    2e5e:	d84b      	bhi.n	2ef8 <print_error_report+0xe0>
    2e60:	a201      	add	r2, pc, #4	; (adr r2, 2e68 <print_error_report+0x50>)
    2e62:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    2e66:	bf00      	nop
    2e68:	00002e89 	.word	0x00002e89
    2e6c:	00002e97 	.word	0x00002e97
    2e70:	00002ea5 	.word	0x00002ea5
    2e74:	00002eb3 	.word	0x00002eb3
    2e78:	00002ec1 	.word	0x00002ec1
    2e7c:	00002edd 	.word	0x00002edd
    2e80:	00002ecf 	.word	0x00002ecf
    2e84:	00002eeb 	.word	0x00002eeb
        //These are errors reported by kernel handled from mbed_rtx_handlers
        case MBED_ERROR_CODE_RTOS_EVENT:
            mbed_error_printf("Kernel Error: 0x%X, ", ctx->error_value);
    2e88:	9b03      	ldr	r3, [sp, #12]
    2e8a:	689b      	ldr	r3, [r3, #8]
    2e8c:	4619      	mov	r1, r3
    2e8e:	482f      	ldr	r0, [pc, #188]	; (2f4c <print_error_report+0x134>)
    2e90:	f7ff fe15 	bl	2abe <mbed_error_printf>
            break;
    2e94:	e031      	b.n	2efa <print_error_report+0xe2>

        case MBED_ERROR_CODE_RTOS_THREAD_EVENT:
            mbed_error_printf("Thread: 0x%X, ", ctx->error_value);
    2e96:	9b03      	ldr	r3, [sp, #12]
    2e98:	689b      	ldr	r3, [r3, #8]
    2e9a:	4619      	mov	r1, r3
    2e9c:	482c      	ldr	r0, [pc, #176]	; (2f50 <print_error_report+0x138>)
    2e9e:	f7ff fe0e 	bl	2abe <mbed_error_printf>
            break;
    2ea2:	e02a      	b.n	2efa <print_error_report+0xe2>

        case MBED_ERROR_CODE_RTOS_MUTEX_EVENT:
            mbed_error_printf("Mutex: 0x%X, ", ctx->error_value);
    2ea4:	9b03      	ldr	r3, [sp, #12]
    2ea6:	689b      	ldr	r3, [r3, #8]
    2ea8:	4619      	mov	r1, r3
    2eaa:	482a      	ldr	r0, [pc, #168]	; (2f54 <print_error_report+0x13c>)
    2eac:	f7ff fe07 	bl	2abe <mbed_error_printf>
            break;
    2eb0:	e023      	b.n	2efa <print_error_report+0xe2>

        case MBED_ERROR_CODE_RTOS_SEMAPHORE_EVENT:
            mbed_error_printf("Semaphore: 0x%X, ", ctx->error_value);
    2eb2:	9b03      	ldr	r3, [sp, #12]
    2eb4:	689b      	ldr	r3, [r3, #8]
    2eb6:	4619      	mov	r1, r3
    2eb8:	4827      	ldr	r0, [pc, #156]	; (2f58 <print_error_report+0x140>)
    2eba:	f7ff fe00 	bl	2abe <mbed_error_printf>
            break;
    2ebe:	e01c      	b.n	2efa <print_error_report+0xe2>

        case MBED_ERROR_CODE_RTOS_MEMORY_POOL_EVENT:
            mbed_error_printf("MemoryPool: 0x%X, ", ctx->error_value);
    2ec0:	9b03      	ldr	r3, [sp, #12]
    2ec2:	689b      	ldr	r3, [r3, #8]
    2ec4:	4619      	mov	r1, r3
    2ec6:	4825      	ldr	r0, [pc, #148]	; (2f5c <print_error_report+0x144>)
    2ec8:	f7ff fdf9 	bl	2abe <mbed_error_printf>
            break;
    2ecc:	e015      	b.n	2efa <print_error_report+0xe2>

        case MBED_ERROR_CODE_RTOS_EVENT_FLAGS_EVENT:
            mbed_error_printf("EventFlags: 0x%X, ", ctx->error_value);
    2ece:	9b03      	ldr	r3, [sp, #12]
    2ed0:	689b      	ldr	r3, [r3, #8]
    2ed2:	4619      	mov	r1, r3
    2ed4:	4822      	ldr	r0, [pc, #136]	; (2f60 <print_error_report+0x148>)
    2ed6:	f7ff fdf2 	bl	2abe <mbed_error_printf>
            break;
    2eda:	e00e      	b.n	2efa <print_error_report+0xe2>

        case MBED_ERROR_CODE_RTOS_TIMER_EVENT:
            mbed_error_printf("Timer: 0x%X, ", ctx->error_value);
    2edc:	9b03      	ldr	r3, [sp, #12]
    2ede:	689b      	ldr	r3, [r3, #8]
    2ee0:	4619      	mov	r1, r3
    2ee2:	4820      	ldr	r0, [pc, #128]	; (2f64 <print_error_report+0x14c>)
    2ee4:	f7ff fdeb 	bl	2abe <mbed_error_printf>
            break;
    2ee8:	e007      	b.n	2efa <print_error_report+0xe2>

        case MBED_ERROR_CODE_RTOS_MESSAGE_QUEUE_EVENT:
            mbed_error_printf("MessageQueue: 0x%X, ", ctx->error_value);
    2eea:	9b03      	ldr	r3, [sp, #12]
    2eec:	689b      	ldr	r3, [r3, #8]
    2eee:	4619      	mov	r1, r3
    2ef0:	481d      	ldr	r0, [pc, #116]	; (2f68 <print_error_report+0x150>)
    2ef2:	f7ff fde4 	bl	2abe <mbed_error_printf>
            break;
    2ef6:	e000      	b.n	2efa <print_error_report+0xe2>

        default:
            //Nothing to do here, just print the error info down
            break;
    2ef8:	bf00      	nop
    }
    mbed_error_printf(error_msg);
    2efa:	9802      	ldr	r0, [sp, #8]
    2efc:	f7ff fddf 	bl	2abe <mbed_error_printf>
    mbed_error_printf("\nLocation: 0x%X", ctx->error_address);
    2f00:	9b03      	ldr	r3, [sp, #12]
    2f02:	685b      	ldr	r3, [r3, #4]
    2f04:	4619      	mov	r1, r3
    2f06:	4819      	ldr	r0, [pc, #100]	; (2f6c <print_error_report+0x154>)
    2f08:	f7ff fdd9 	bl	2abe <mbed_error_printf>
        //for string, we must pass address of a ptr which has the address of the string
        mbed_error_printf("\nFile:%s+%d", ctx->error_filename, ctx->error_line_number);
    }
#endif

    mbed_error_printf("\nError Value: 0x%X", ctx->error_value);
    2f0c:	9b03      	ldr	r3, [sp, #12]
    2f0e:	689b      	ldr	r3, [r3, #8]
    2f10:	4619      	mov	r1, r3
    2f12:	4817      	ldr	r0, [pc, #92]	; (2f70 <print_error_report+0x158>)
    2f14:	f7ff fdd3 	bl	2abe <mbed_error_printf>
#ifdef TARGET_CORTEX_M
    mbed_error_printf("\nCurrent Thread: Id: 0x%X Entry: 0x%X StackSize: 0x%X StackMem: 0x%X SP: 0x%X ",
    2f18:	9b03      	ldr	r3, [sp, #12]
    2f1a:	68d9      	ldr	r1, [r3, #12]
    2f1c:	9b03      	ldr	r3, [sp, #12]
    2f1e:	6918      	ldr	r0, [r3, #16]
    2f20:	9b03      	ldr	r3, [sp, #12]
    2f22:	695c      	ldr	r4, [r3, #20]
    2f24:	9b03      	ldr	r3, [sp, #12]
    2f26:	699b      	ldr	r3, [r3, #24]
    2f28:	9a03      	ldr	r2, [sp, #12]
    2f2a:	69d2      	ldr	r2, [r2, #28]
    2f2c:	9201      	str	r2, [sp, #4]
    2f2e:	9300      	str	r3, [sp, #0]
    2f30:	4623      	mov	r3, r4
    2f32:	4602      	mov	r2, r0
    2f34:	480f      	ldr	r0, [pc, #60]	; (2f74 <print_error_report+0x15c>)
    2f36:	f7ff fdc2 	bl	2abe <mbed_error_printf>
    mbed_error_printf("\nIdle:");
    threads = (osRtxThread_t *)&osRtxInfo.thread.idle;
    print_threads_info(threads);
#endif

    mbed_error_printf("\n-- MbedOS Error Info --\n");
    2f3a:	480f      	ldr	r0, [pc, #60]	; (2f78 <print_error_report+0x160>)
    2f3c:	f7ff fdbf 	bl	2abe <mbed_error_printf>
}
    2f40:	bf00      	nop
    2f42:	b006      	add	sp, #24
    2f44:	bd10      	pop	{r4, pc}
    2f46:	bf00      	nop
    2f48:	00010c44 	.word	0x00010c44
    2f4c:	00010c98 	.word	0x00010c98
    2f50:	00010cb0 	.word	0x00010cb0
    2f54:	00010cc0 	.word	0x00010cc0
    2f58:	00010cd0 	.word	0x00010cd0
    2f5c:	00010ce4 	.word	0x00010ce4
    2f60:	00010cf8 	.word	0x00010cf8
    2f64:	00010d0c 	.word	0x00010d0c
    2f68:	00010d1c 	.word	0x00010d1c
    2f6c:	00010d34 	.word	0x00010d34
    2f70:	00010d44 	.word	0x00010d44
    2f74:	00010d58 	.word	0x00010d58
    2f78:	00010da8 	.word	0x00010da8

00002f7c <mbed_mem_trace_set_callback>:
/******************************************************************************
 * Public interface
 *****************************************************************************/

void mbed_mem_trace_set_callback(mbed_mem_trace_cb_t cb)
{
    2f7c:	b082      	sub	sp, #8
    2f7e:	9001      	str	r0, [sp, #4]
    mem_trace_cb = cb;
    2f80:	4a02      	ldr	r2, [pc, #8]	; (2f8c <mbed_mem_trace_set_callback+0x10>)
    2f82:	9b01      	ldr	r3, [sp, #4]
    2f84:	6013      	str	r3, [r2, #0]
}
    2f86:	bf00      	nop
    2f88:	b002      	add	sp, #8
    2f8a:	4770      	bx	lr
    2f8c:	20000d68 	.word	0x20000d68

00002f90 <mbed_mem_trace_lock>:

void mbed_mem_trace_lock()
{
    2f90:	b508      	push	{r3, lr}
    mem_trace_mutex->lock();
    2f92:	4808      	ldr	r0, [pc, #32]	; (2fb4 <mbed_mem_trace_lock+0x24>)
    2f94:	f7fe fcd2 	bl	193c <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    2f98:	4603      	mov	r3, r0
    2f9a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2f9e:	4618      	mov	r0, r3
    2fa0:	f000 ff74 	bl	3e8c <_ZN4rtos5Mutex4lockEm>
    trace_lock_count++;
    2fa4:	4b04      	ldr	r3, [pc, #16]	; (2fb8 <mbed_mem_trace_lock+0x28>)
    2fa6:	781b      	ldrb	r3, [r3, #0]
    2fa8:	3301      	adds	r3, #1
    2faa:	b2da      	uxtb	r2, r3
    2fac:	4b02      	ldr	r3, [pc, #8]	; (2fb8 <mbed_mem_trace_lock+0x28>)
    2fae:	701a      	strb	r2, [r3, #0]
}
    2fb0:	bf00      	nop
    2fb2:	bd08      	pop	{r3, pc}
    2fb4:	20000d70 	.word	0x20000d70
    2fb8:	20000d6c 	.word	0x20000d6c

00002fbc <mbed_mem_trace_unlock>:

void mbed_mem_trace_unlock()
{
    2fbc:	b508      	push	{r3, lr}
    trace_lock_count--;
    2fbe:	4b07      	ldr	r3, [pc, #28]	; (2fdc <mbed_mem_trace_unlock+0x20>)
    2fc0:	781b      	ldrb	r3, [r3, #0]
    2fc2:	3b01      	subs	r3, #1
    2fc4:	b2da      	uxtb	r2, r3
    2fc6:	4b05      	ldr	r3, [pc, #20]	; (2fdc <mbed_mem_trace_unlock+0x20>)
    2fc8:	701a      	strb	r2, [r3, #0]
    mem_trace_mutex->unlock();
    2fca:	4805      	ldr	r0, [pc, #20]	; (2fe0 <mbed_mem_trace_unlock+0x24>)
    2fcc:	f7fe fcb6 	bl	193c <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    2fd0:	4603      	mov	r3, r0
    2fd2:	4618      	mov	r0, r3
    2fd4:	f000 ff72 	bl	3ebc <_ZN4rtos5Mutex6unlockEv>
}
    2fd8:	bf00      	nop
    2fda:	bd08      	pop	{r3, pc}
    2fdc:	20000d6c 	.word	0x20000d6c
    2fe0:	20000d70 	.word	0x20000d70

00002fe4 <mbed_mem_trace_malloc>:

void *mbed_mem_trace_malloc(void *res, size_t size, void *caller)
{
    2fe4:	b510      	push	{r4, lr}
    2fe6:	b084      	sub	sp, #16
    2fe8:	9003      	str	r0, [sp, #12]
    2fea:	9102      	str	r1, [sp, #8]
    2fec:	9201      	str	r2, [sp, #4]
    if (mem_trace_cb) {
    2fee:	4b09      	ldr	r3, [pc, #36]	; (3014 <mbed_mem_trace_malloc+0x30>)
    2ff0:	681b      	ldr	r3, [r3, #0]
    2ff2:	2b00      	cmp	r3, #0
    2ff4:	d00a      	beq.n	300c <mbed_mem_trace_malloc+0x28>
        if (TRACE_FIRST_LOCK()) {
    2ff6:	4b08      	ldr	r3, [pc, #32]	; (3018 <mbed_mem_trace_malloc+0x34>)
    2ff8:	781b      	ldrb	r3, [r3, #0]
    2ffa:	2b01      	cmp	r3, #1
    2ffc:	dc06      	bgt.n	300c <mbed_mem_trace_malloc+0x28>
            mem_trace_cb(MBED_MEM_TRACE_MALLOC, res, caller, size);
    2ffe:	4b05      	ldr	r3, [pc, #20]	; (3014 <mbed_mem_trace_malloc+0x30>)
    3000:	681c      	ldr	r4, [r3, #0]
    3002:	9b02      	ldr	r3, [sp, #8]
    3004:	9a01      	ldr	r2, [sp, #4]
    3006:	9903      	ldr	r1, [sp, #12]
    3008:	2000      	movs	r0, #0
    300a:	47a0      	blx	r4
        }
    }
    return res;
    300c:	9b03      	ldr	r3, [sp, #12]
}
    300e:	4618      	mov	r0, r3
    3010:	b004      	add	sp, #16
    3012:	bd10      	pop	{r4, pc}
    3014:	20000d68 	.word	0x20000d68
    3018:	20000d6c 	.word	0x20000d6c

0000301c <mbed_mem_trace_realloc>:

void *mbed_mem_trace_realloc(void *res, void *ptr, size_t size, void *caller)
{
    301c:	b510      	push	{r4, lr}
    301e:	b086      	sub	sp, #24
    3020:	9005      	str	r0, [sp, #20]
    3022:	9104      	str	r1, [sp, #16]
    3024:	9203      	str	r2, [sp, #12]
    3026:	9302      	str	r3, [sp, #8]
    if (mem_trace_cb) {
    3028:	4b0a      	ldr	r3, [pc, #40]	; (3054 <mbed_mem_trace_realloc+0x38>)
    302a:	681b      	ldr	r3, [r3, #0]
    302c:	2b00      	cmp	r3, #0
    302e:	d00c      	beq.n	304a <mbed_mem_trace_realloc+0x2e>
        if (TRACE_FIRST_LOCK()) {
    3030:	4b09      	ldr	r3, [pc, #36]	; (3058 <mbed_mem_trace_realloc+0x3c>)
    3032:	781b      	ldrb	r3, [r3, #0]
    3034:	2b01      	cmp	r3, #1
    3036:	dc08      	bgt.n	304a <mbed_mem_trace_realloc+0x2e>
            mem_trace_cb(MBED_MEM_TRACE_REALLOC, res, caller, ptr, size);
    3038:	4b06      	ldr	r3, [pc, #24]	; (3054 <mbed_mem_trace_realloc+0x38>)
    303a:	681c      	ldr	r4, [r3, #0]
    303c:	9b03      	ldr	r3, [sp, #12]
    303e:	9300      	str	r3, [sp, #0]
    3040:	9b04      	ldr	r3, [sp, #16]
    3042:	9a02      	ldr	r2, [sp, #8]
    3044:	9905      	ldr	r1, [sp, #20]
    3046:	2001      	movs	r0, #1
    3048:	47a0      	blx	r4
        }
    }
    return res;
    304a:	9b05      	ldr	r3, [sp, #20]
}
    304c:	4618      	mov	r0, r3
    304e:	b006      	add	sp, #24
    3050:	bd10      	pop	{r4, pc}
    3052:	bf00      	nop
    3054:	20000d68 	.word	0x20000d68
    3058:	20000d6c 	.word	0x20000d6c

0000305c <mbed_mem_trace_calloc>:

void *mbed_mem_trace_calloc(void *res, size_t num, size_t size, void *caller)
{
    305c:	b510      	push	{r4, lr}
    305e:	b086      	sub	sp, #24
    3060:	9005      	str	r0, [sp, #20]
    3062:	9104      	str	r1, [sp, #16]
    3064:	9203      	str	r2, [sp, #12]
    3066:	9302      	str	r3, [sp, #8]
    if (mem_trace_cb) {
    3068:	4b0a      	ldr	r3, [pc, #40]	; (3094 <mbed_mem_trace_calloc+0x38>)
    306a:	681b      	ldr	r3, [r3, #0]
    306c:	2b00      	cmp	r3, #0
    306e:	d00c      	beq.n	308a <mbed_mem_trace_calloc+0x2e>
        if (TRACE_FIRST_LOCK()) {
    3070:	4b09      	ldr	r3, [pc, #36]	; (3098 <mbed_mem_trace_calloc+0x3c>)
    3072:	781b      	ldrb	r3, [r3, #0]
    3074:	2b01      	cmp	r3, #1
    3076:	dc08      	bgt.n	308a <mbed_mem_trace_calloc+0x2e>
            mem_trace_cb(MBED_MEM_TRACE_CALLOC, res, caller, num, size);
    3078:	4b06      	ldr	r3, [pc, #24]	; (3094 <mbed_mem_trace_calloc+0x38>)
    307a:	681c      	ldr	r4, [r3, #0]
    307c:	9b03      	ldr	r3, [sp, #12]
    307e:	9300      	str	r3, [sp, #0]
    3080:	9b04      	ldr	r3, [sp, #16]
    3082:	9a02      	ldr	r2, [sp, #8]
    3084:	9905      	ldr	r1, [sp, #20]
    3086:	2002      	movs	r0, #2
    3088:	47a0      	blx	r4
        }
    }
    return res;
    308a:	9b05      	ldr	r3, [sp, #20]
}
    308c:	4618      	mov	r0, r3
    308e:	b006      	add	sp, #24
    3090:	bd10      	pop	{r4, pc}
    3092:	bf00      	nop
    3094:	20000d68 	.word	0x20000d68
    3098:	20000d6c 	.word	0x20000d6c

0000309c <mbed_mem_trace_free>:

void mbed_mem_trace_free(void *ptr, void *caller)
{
    309c:	b510      	push	{r4, lr}
    309e:	b082      	sub	sp, #8
    30a0:	9001      	str	r0, [sp, #4]
    30a2:	9100      	str	r1, [sp, #0]
    if (mem_trace_cb) {
    30a4:	4b08      	ldr	r3, [pc, #32]	; (30c8 <mbed_mem_trace_free+0x2c>)
    30a6:	681b      	ldr	r3, [r3, #0]
    30a8:	2b00      	cmp	r3, #0
    30aa:	d00a      	beq.n	30c2 <mbed_mem_trace_free+0x26>
        if (TRACE_FIRST_LOCK()) {
    30ac:	4b07      	ldr	r3, [pc, #28]	; (30cc <mbed_mem_trace_free+0x30>)
    30ae:	781b      	ldrb	r3, [r3, #0]
    30b0:	2b01      	cmp	r3, #1
    30b2:	dc06      	bgt.n	30c2 <mbed_mem_trace_free+0x26>
            mem_trace_cb(MBED_MEM_TRACE_FREE, NULL, caller, ptr);
    30b4:	4b04      	ldr	r3, [pc, #16]	; (30c8 <mbed_mem_trace_free+0x2c>)
    30b6:	681c      	ldr	r4, [r3, #0]
    30b8:	9b01      	ldr	r3, [sp, #4]
    30ba:	9a00      	ldr	r2, [sp, #0]
    30bc:	2100      	movs	r1, #0
    30be:	2003      	movs	r0, #3
    30c0:	47a0      	blx	r4
        }
    }
}
    30c2:	bf00      	nop
    30c4:	b002      	add	sp, #8
    30c6:	bd10      	pop	{r4, pc}
    30c8:	20000d68 	.word	0x20000d68
    30cc:	20000d6c 	.word	0x20000d6c

000030d0 <mbed_mem_trace_default_callback>:

void mbed_mem_trace_default_callback(uint8_t op, void *res, void *caller, ...)
{
    30d0:	b40c      	push	{r2, r3}
    30d2:	b500      	push	{lr}
    30d4:	b089      	sub	sp, #36	; 0x24
    30d6:	4603      	mov	r3, r0
    30d8:	9102      	str	r1, [sp, #8]
    30da:	f88d 300f 	strb.w	r3, [sp, #15]
    va_list va;
    size_t temp_s1, temp_s2;
    void *temp_ptr;

    va_start(va, caller);
    30de:	ab0b      	add	r3, sp, #44	; 0x2c
    30e0:	9304      	str	r3, [sp, #16]
    switch (op) {
    30e2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    30e6:	2b03      	cmp	r3, #3
    30e8:	d848      	bhi.n	317c <mbed_mem_trace_default_callback+0xac>
    30ea:	a201      	add	r2, pc, #4	; (adr r2, 30f0 <mbed_mem_trace_default_callback+0x20>)
    30ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    30f0:	00003101 	.word	0x00003101
    30f4:	00003119 	.word	0x00003119
    30f8:	0000313f 	.word	0x0000313f
    30fc:	00003165 	.word	0x00003165
        case MBED_MEM_TRACE_MALLOC:
            temp_s1 = va_arg(va, size_t);
    3100:	9b04      	ldr	r3, [sp, #16]
    3102:	1d1a      	adds	r2, r3, #4
    3104:	9204      	str	r2, [sp, #16]
    3106:	681b      	ldr	r3, [r3, #0]
    3108:	9307      	str	r3, [sp, #28]
            printf(MBED_MEM_DEFAULT_TRACER_PREFIX "m:%p;%p-%u\n", res, caller, temp_s1);
    310a:	9b07      	ldr	r3, [sp, #28]
    310c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    310e:	9902      	ldr	r1, [sp, #8]
    3110:	481f      	ldr	r0, [pc, #124]	; (3190 <mbed_mem_trace_default_callback+0xc0>)
    3112:	f008 fa15 	bl	b540 <printf>
            break;
    3116:	e034      	b.n	3182 <mbed_mem_trace_default_callback+0xb2>

        case MBED_MEM_TRACE_REALLOC:
            temp_ptr = va_arg(va, void *);
    3118:	9b04      	ldr	r3, [sp, #16]
    311a:	1d1a      	adds	r2, r3, #4
    311c:	9204      	str	r2, [sp, #16]
    311e:	681b      	ldr	r3, [r3, #0]
    3120:	9306      	str	r3, [sp, #24]
            temp_s1 = va_arg(va, size_t);
    3122:	9b04      	ldr	r3, [sp, #16]
    3124:	1d1a      	adds	r2, r3, #4
    3126:	9204      	str	r2, [sp, #16]
    3128:	681b      	ldr	r3, [r3, #0]
    312a:	9307      	str	r3, [sp, #28]
            printf(MBED_MEM_DEFAULT_TRACER_PREFIX "r:%p;%p-%p;%u\n", res, caller, temp_ptr, temp_s1);
    312c:	9b07      	ldr	r3, [sp, #28]
    312e:	9300      	str	r3, [sp, #0]
    3130:	9b06      	ldr	r3, [sp, #24]
    3132:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    3134:	9902      	ldr	r1, [sp, #8]
    3136:	4817      	ldr	r0, [pc, #92]	; (3194 <mbed_mem_trace_default_callback+0xc4>)
    3138:	f008 fa02 	bl	b540 <printf>
            break;
    313c:	e021      	b.n	3182 <mbed_mem_trace_default_callback+0xb2>

        case MBED_MEM_TRACE_CALLOC:
            temp_s1 = va_arg(va, size_t);
    313e:	9b04      	ldr	r3, [sp, #16]
    3140:	1d1a      	adds	r2, r3, #4
    3142:	9204      	str	r2, [sp, #16]
    3144:	681b      	ldr	r3, [r3, #0]
    3146:	9307      	str	r3, [sp, #28]
            temp_s2 = va_arg(va, size_t);
    3148:	9b04      	ldr	r3, [sp, #16]
    314a:	1d1a      	adds	r2, r3, #4
    314c:	9204      	str	r2, [sp, #16]
    314e:	681b      	ldr	r3, [r3, #0]
    3150:	9305      	str	r3, [sp, #20]
            printf(MBED_MEM_DEFAULT_TRACER_PREFIX "c:%p;%p-%u;%u\n", res, caller, temp_s1, temp_s2);
    3152:	9b05      	ldr	r3, [sp, #20]
    3154:	9300      	str	r3, [sp, #0]
    3156:	9b07      	ldr	r3, [sp, #28]
    3158:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    315a:	9902      	ldr	r1, [sp, #8]
    315c:	480e      	ldr	r0, [pc, #56]	; (3198 <mbed_mem_trace_default_callback+0xc8>)
    315e:	f008 f9ef 	bl	b540 <printf>
            break;
    3162:	e00e      	b.n	3182 <mbed_mem_trace_default_callback+0xb2>

        case MBED_MEM_TRACE_FREE:
            temp_ptr = va_arg(va, void *);
    3164:	9b04      	ldr	r3, [sp, #16]
    3166:	1d1a      	adds	r2, r3, #4
    3168:	9204      	str	r2, [sp, #16]
    316a:	681b      	ldr	r3, [r3, #0]
    316c:	9306      	str	r3, [sp, #24]
            printf(MBED_MEM_DEFAULT_TRACER_PREFIX "f:%p;%p-%p\n", res, caller, temp_ptr);
    316e:	9b06      	ldr	r3, [sp, #24]
    3170:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    3172:	9902      	ldr	r1, [sp, #8]
    3174:	4809      	ldr	r0, [pc, #36]	; (319c <mbed_mem_trace_default_callback+0xcc>)
    3176:	f008 f9e3 	bl	b540 <printf>
            break;
    317a:	e002      	b.n	3182 <mbed_mem_trace_default_callback+0xb2>

        default:
            printf("?\n");
    317c:	4808      	ldr	r0, [pc, #32]	; (31a0 <mbed_mem_trace_default_callback+0xd0>)
    317e:	f008 f9df 	bl	b540 <printf>
    }
    va_end(va);
}
    3182:	bf00      	nop
    3184:	b009      	add	sp, #36	; 0x24
    3186:	f85d eb04 	ldr.w	lr, [sp], #4
    318a:	b002      	add	sp, #8
    318c:	4770      	bx	lr
    318e:	bf00      	nop
    3190:	00010dc4 	.word	0x00010dc4
    3194:	00010dd4 	.word	0x00010dd4
    3198:	00010de4 	.word	0x00010de4
    319c:	00010df4 	.word	0x00010df4
    31a0:	00010e04 	.word	0x00010e04

000031a4 <_ZL14singleton_lockv>:
{
    31a4:	b508      	push	{r3, lr}
    osMutexAcquire(singleton_mutex_id, osWaitForever);
    31a6:	4b04      	ldr	r3, [pc, #16]	; (31b8 <_ZL14singleton_lockv+0x14>)
    31a8:	681b      	ldr	r3, [r3, #0]
    31aa:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    31ae:	4618      	mov	r0, r3
    31b0:	f003 f9ee 	bl	6590 <osMutexAcquire>
}
    31b4:	bf00      	nop
    31b6:	bd08      	pop	{r3, pc}
    31b8:	20001ed0 	.word	0x20001ed0

000031bc <_ZL16singleton_unlockv>:
{
    31bc:	b508      	push	{r3, lr}
    osMutexRelease(singleton_mutex_id);
    31be:	4b03      	ldr	r3, [pc, #12]	; (31cc <_ZL16singleton_unlockv+0x10>)
    31c0:	681b      	ldr	r3, [r3, #0]
    31c2:	4618      	mov	r0, r3
    31c4:	f003 fa12 	bl	65ec <osMutexRelease>
}
    31c8:	bf00      	nop
    31ca:	bd08      	pop	{r3, pc}
    31cc:	20001ed0 	.word	0x20001ed0

000031d0 <_ZN12DirectSerial4seekEli>:
class DirectSerial : public FileHandle {
public:
    DirectSerial(PinName tx, PinName rx, int baud);
    virtual ssize_t write(const void *buffer, size_t size);
    virtual ssize_t read(void *buffer, size_t size);
    virtual off_t seek(off_t offset, int whence = SEEK_SET)
    31d0:	b084      	sub	sp, #16
    31d2:	9003      	str	r0, [sp, #12]
    31d4:	9102      	str	r1, [sp, #8]
    31d6:	9201      	str	r2, [sp, #4]
    {
        return -ESPIPE;
    31d8:	f06f 031c 	mvn.w	r3, #28
    }
    31dc:	4618      	mov	r0, r3
    31de:	b004      	add	sp, #16
    31e0:	4770      	bx	lr

000031e2 <_ZN12DirectSerial4sizeEv>:
    virtual off_t size()
    31e2:	b082      	sub	sp, #8
    31e4:	9001      	str	r0, [sp, #4]
    {
        return -EINVAL;
    31e6:	f06f 0315 	mvn.w	r3, #21
    }
    31ea:	4618      	mov	r0, r3
    31ec:	b002      	add	sp, #8
    31ee:	4770      	bx	lr

000031f0 <_ZN12DirectSerial6isattyEv>:
    virtual int isatty()
    31f0:	b082      	sub	sp, #8
    31f2:	9001      	str	r0, [sp, #4]
    {
        return true;
    31f4:	2301      	movs	r3, #1
    }
    31f6:	4618      	mov	r0, r3
    31f8:	b002      	add	sp, #8
    31fa:	4770      	bx	lr

000031fc <_ZN12DirectSerial5closeEv>:
    virtual int close()
    31fc:	b082      	sub	sp, #8
    31fe:	9001      	str	r0, [sp, #4]
    {
        return 0;
    3200:	2300      	movs	r3, #0
    }
    3202:	4618      	mov	r0, r3
    3204:	b002      	add	sp, #8
    3206:	4770      	bx	lr

00003208 <_ZN12DirectSerialC1E7PinNameS0_i>:
    virtual short poll(short events) const;
};

DirectSerial::DirectSerial(PinName tx, PinName rx, int baud)
    3208:	b500      	push	{lr}
    320a:	b085      	sub	sp, #20
    320c:	9003      	str	r0, [sp, #12]
    320e:	9102      	str	r1, [sp, #8]
    3210:	9201      	str	r2, [sp, #4]
    3212:	9300      	str	r3, [sp, #0]
    3214:	9b03      	ldr	r3, [sp, #12]
    3216:	4618      	mov	r0, r3
    3218:	f7fe fc62 	bl	1ae0 <_ZN4mbed10FileHandleC1Ev>
    321c:	4a0b      	ldr	r2, [pc, #44]	; (324c <_ZN12DirectSerialC1E7PinNameS0_i+0x44>)
    321e:	9b03      	ldr	r3, [sp, #12]
    3220:	601a      	str	r2, [r3, #0]
{
    if (stdio_uart_inited) {
    3222:	4b0b      	ldr	r3, [pc, #44]	; (3250 <_ZN12DirectSerialC1E7PinNameS0_i+0x48>)
    3224:	681b      	ldr	r3, [r3, #0]
    3226:	2b00      	cmp	r3, #0
    3228:	d109      	bne.n	323e <_ZN12DirectSerialC1E7PinNameS0_i+0x36>
        return;
    }
    serial_init(&stdio_uart, tx, rx);
    322a:	9a01      	ldr	r2, [sp, #4]
    322c:	9902      	ldr	r1, [sp, #8]
    322e:	4809      	ldr	r0, [pc, #36]	; (3254 <_ZN12DirectSerialC1E7PinNameS0_i+0x4c>)
    3230:	f006 fba4 	bl	997c <serial_init>
    serial_baud(&stdio_uart, baud);
    3234:	9900      	ldr	r1, [sp, #0]
    3236:	4807      	ldr	r0, [pc, #28]	; (3254 <_ZN12DirectSerialC1E7PinNameS0_i+0x4c>)
    3238:	f006 fc3a 	bl	9ab0 <serial_baud>
    323c:	e000      	b.n	3240 <_ZN12DirectSerialC1E7PinNameS0_i+0x38>
        return;
    323e:	bf00      	nop
#elif CONSOLE_FLOWCONTROL == CONSOLE_FLOWCONTROL_CTS
    serial_set_flow_control(&stdio_uart, FlowControlCTS, NC, STDIO_UART_CTS);
#elif CONSOLE_FLOWCONTROL == CONSOLE_FLOWCONTROL_RTSCTS
    serial_set_flow_control(&stdio_uart, FlowControlRTSCTS, STDIO_UART_RTS, STDIO_UART_CTS);
#endif
}
    3240:	9b03      	ldr	r3, [sp, #12]
    3242:	4618      	mov	r0, r3
    3244:	b005      	add	sp, #20
    3246:	f85d fb04 	ldr.w	pc, [sp], #4
    324a:	bf00      	nop
    324c:	00012584 	.word	0x00012584
    3250:	20001538 	.word	0x20001538
    3254:	20002f6c 	.word	0x20002f6c

00003258 <_ZN12DirectSerial5writeEPKvj>:

ssize_t DirectSerial::write(const void *buffer, size_t size)
{
    3258:	b500      	push	{lr}
    325a:	b087      	sub	sp, #28
    325c:	9003      	str	r0, [sp, #12]
    325e:	9102      	str	r1, [sp, #8]
    3260:	9201      	str	r2, [sp, #4]
    const unsigned char *buf = static_cast<const unsigned char *>(buffer);
    3262:	9b02      	ldr	r3, [sp, #8]
    3264:	9304      	str	r3, [sp, #16]
    for (size_t i = 0; i < size; i++) {
    3266:	2300      	movs	r3, #0
    3268:	9305      	str	r3, [sp, #20]
    326a:	9a05      	ldr	r2, [sp, #20]
    326c:	9b01      	ldr	r3, [sp, #4]
    326e:	429a      	cmp	r2, r3
    3270:	d20b      	bcs.n	328a <_ZN12DirectSerial5writeEPKvj+0x32>
        serial_putc(&stdio_uart, buf[i]);
    3272:	9a04      	ldr	r2, [sp, #16]
    3274:	9b05      	ldr	r3, [sp, #20]
    3276:	4413      	add	r3, r2
    3278:	781b      	ldrb	r3, [r3, #0]
    327a:	4619      	mov	r1, r3
    327c:	4805      	ldr	r0, [pc, #20]	; (3294 <_ZN12DirectSerial5writeEPKvj+0x3c>)
    327e:	f006 fc53 	bl	9b28 <serial_putc>
    for (size_t i = 0; i < size; i++) {
    3282:	9b05      	ldr	r3, [sp, #20]
    3284:	3301      	adds	r3, #1
    3286:	9305      	str	r3, [sp, #20]
    3288:	e7ef      	b.n	326a <_ZN12DirectSerial5writeEPKvj+0x12>
    }
    return size;
    328a:	9b01      	ldr	r3, [sp, #4]
}
    328c:	4618      	mov	r0, r3
    328e:	b007      	add	sp, #28
    3290:	f85d fb04 	ldr.w	pc, [sp], #4
    3294:	20002f6c 	.word	0x20002f6c

00003298 <_ZN12DirectSerial4readEPvj>:

ssize_t DirectSerial::read(void *buffer, size_t size)
{
    3298:	b500      	push	{lr}
    329a:	b087      	sub	sp, #28
    329c:	9003      	str	r0, [sp, #12]
    329e:	9102      	str	r1, [sp, #8]
    32a0:	9201      	str	r2, [sp, #4]
    unsigned char *buf = static_cast<unsigned char *>(buffer);
    32a2:	9b02      	ldr	r3, [sp, #8]
    32a4:	9305      	str	r3, [sp, #20]
    if (size == 0) {
    32a6:	9b01      	ldr	r3, [sp, #4]
    32a8:	2b00      	cmp	r3, #0
    32aa:	d101      	bne.n	32b0 <_ZN12DirectSerial4readEPvj+0x18>
        return 0;
    32ac:	2300      	movs	r3, #0
    32ae:	e007      	b.n	32c0 <_ZN12DirectSerial4readEPvj+0x28>
    }
    buf[0] = serial_getc(&stdio_uart);
    32b0:	4805      	ldr	r0, [pc, #20]	; (32c8 <_ZN12DirectSerial4readEPvj+0x30>)
    32b2:	f006 fc1b 	bl	9aec <serial_getc>
    32b6:	4603      	mov	r3, r0
    32b8:	b2da      	uxtb	r2, r3
    32ba:	9b05      	ldr	r3, [sp, #20]
    32bc:	701a      	strb	r2, [r3, #0]
    return 1;
    32be:	2301      	movs	r3, #1
}
    32c0:	4618      	mov	r0, r3
    32c2:	b007      	add	sp, #28
    32c4:	f85d fb04 	ldr.w	pc, [sp], #4
    32c8:	20002f6c 	.word	0x20002f6c

000032cc <_ZNK12DirectSerial4pollEs>:

short DirectSerial::poll(short events) const
{
    32cc:	b500      	push	{lr}
    32ce:	b085      	sub	sp, #20
    32d0:	9001      	str	r0, [sp, #4]
    32d2:	460b      	mov	r3, r1
    32d4:	f8ad 3002 	strh.w	r3, [sp, #2]
    short revents = 0;
    32d8:	2300      	movs	r3, #0
    32da:	f8ad 300e 	strh.w	r3, [sp, #14]
    if ((events & POLLIN) && serial_readable(&stdio_uart)) {
    32de:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    32e2:	f003 0301 	and.w	r3, r3, #1
    32e6:	2b00      	cmp	r3, #0
    32e8:	d007      	beq.n	32fa <_ZNK12DirectSerial4pollEs+0x2e>
    32ea:	4817      	ldr	r0, [pc, #92]	; (3348 <_ZNK12DirectSerial4pollEs+0x7c>)
    32ec:	f006 fc38 	bl	9b60 <serial_readable>
    32f0:	4603      	mov	r3, r0
    32f2:	2b00      	cmp	r3, #0
    32f4:	d001      	beq.n	32fa <_ZNK12DirectSerial4pollEs+0x2e>
    32f6:	2301      	movs	r3, #1
    32f8:	e000      	b.n	32fc <_ZNK12DirectSerial4pollEs+0x30>
    32fa:	2300      	movs	r3, #0
    32fc:	2b00      	cmp	r3, #0
    32fe:	d005      	beq.n	330c <_ZNK12DirectSerial4pollEs+0x40>
        revents |= POLLIN;
    3300:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    3304:	f043 0301 	orr.w	r3, r3, #1
    3308:	f8ad 300e 	strh.w	r3, [sp, #14]
    }
    if ((events & POLLOUT) && serial_writable(&stdio_uart)) {
    330c:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    3310:	f003 0310 	and.w	r3, r3, #16
    3314:	2b00      	cmp	r3, #0
    3316:	d007      	beq.n	3328 <_ZNK12DirectSerial4pollEs+0x5c>
    3318:	480b      	ldr	r0, [pc, #44]	; (3348 <_ZNK12DirectSerial4pollEs+0x7c>)
    331a:	f006 fc45 	bl	9ba8 <serial_writable>
    331e:	4603      	mov	r3, r0
    3320:	2b00      	cmp	r3, #0
    3322:	d001      	beq.n	3328 <_ZNK12DirectSerial4pollEs+0x5c>
    3324:	2301      	movs	r3, #1
    3326:	e000      	b.n	332a <_ZNK12DirectSerial4pollEs+0x5e>
    3328:	2300      	movs	r3, #0
    332a:	2b00      	cmp	r3, #0
    332c:	d005      	beq.n	333a <_ZNK12DirectSerial4pollEs+0x6e>
        revents |= POLLOUT;
    332e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    3332:	f043 0310 	orr.w	r3, r3, #16
    3336:	f8ad 300e 	strh.w	r3, [sp, #14]
    }
    return revents;
    333a:	f9bd 300e 	ldrsh.w	r3, [sp, #14]
}
    333e:	4618      	mov	r0, r3
    3340:	b005      	add	sp, #20
    3342:	f85d fb04 	ldr.w	pc, [sp], #4
    3346:	bf00      	nop
    3348:	20002f6c 	.word	0x20002f6c

0000334c <_ZN4mbed28mbed_target_override_consoleEi>:
    return 1;
}


MBED_WEAK FileHandle *mbed::mbed_target_override_console(int fd)
{
    334c:	b082      	sub	sp, #8
    334e:	9001      	str	r0, [sp, #4]
    return NULL;
    3350:	2300      	movs	r3, #0
}
    3352:	4618      	mov	r0, r3
    3354:	b002      	add	sp, #8
    3356:	4770      	bx	lr

00003358 <_ZN4mbed21mbed_override_consoleEi>:

MBED_WEAK FileHandle *mbed::mbed_override_console(int fd)
{
    3358:	b082      	sub	sp, #8
    335a:	9001      	str	r0, [sp, #4]
    return NULL;
    335c:	2300      	movs	r3, #0
}
    335e:	4618      	mov	r0, r3
    3360:	b002      	add	sp, #8
    3362:	4770      	bx	lr

00003364 <_ZL15default_consolev>:

static FileHandle *default_console()
{
    3364:	b508      	push	{r3, lr}
    console.set_flow_control(SerialBase::CTS, NC, STDIO_UART_CTS);
#   elif CONSOLE_FLOWCONTROL == CONSOLE_FLOWCONTROL_RTSCTS
    console.set_flow_control(SerialBase::RTSCTS, STDIO_UART_RTS, STDIO_UART_CTS);
#   endif
#  else
    static DirectSerial console(STDIO_UART_TX, STDIO_UART_RX, MBED_CONF_PLATFORM_STDIO_BAUD_RATE);
    3366:	4b16      	ldr	r3, [pc, #88]	; (33c0 <_ZL15default_consolev+0x5c>)
    3368:	781b      	ldrb	r3, [r3, #0]
    336a:	f3bf 8f5b 	dmb	ish
    336e:	b2db      	uxtb	r3, r3
    3370:	f003 0301 	and.w	r3, r3, #1
    3374:	2b00      	cmp	r3, #0
    3376:	bf0c      	ite	eq
    3378:	2301      	moveq	r3, #1
    337a:	2300      	movne	r3, #0
    337c:	b2db      	uxtb	r3, r3
    337e:	2b00      	cmp	r3, #0
    3380:	d01b      	beq.n	33ba <_ZL15default_consolev+0x56>
    3382:	480f      	ldr	r0, [pc, #60]	; (33c0 <_ZL15default_consolev+0x5c>)
    3384:	f000 fbb2 	bl	3aec <__cxa_guard_acquire>
    3388:	4603      	mov	r3, r0
    338a:	2b00      	cmp	r3, #0
    338c:	bf14      	ite	ne
    338e:	2301      	movne	r3, #1
    3390:	2300      	moveq	r3, #0
    3392:	b2db      	uxtb	r3, r3
    3394:	2b00      	cmp	r3, #0
    3396:	d010      	beq.n	33ba <_ZL15default_consolev+0x56>
    3398:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
    339c:	f241 0210 	movw	r2, #4112	; 0x1010
    33a0:	f241 0111 	movw	r1, #4113	; 0x1011
    33a4:	4807      	ldr	r0, [pc, #28]	; (33c4 <_ZL15default_consolev+0x60>)
    33a6:	f7ff ff2f 	bl	3208 <_ZN12DirectSerialC1E7PinNameS0_i>
    33aa:	4805      	ldr	r0, [pc, #20]	; (33c0 <_ZL15default_consolev+0x5c>)
    33ac:	f000 fbd4 	bl	3b58 <__cxa_guard_release>
    33b0:	4a05      	ldr	r2, [pc, #20]	; (33c8 <_ZL15default_consolev+0x64>)
    33b2:	4906      	ldr	r1, [pc, #24]	; (33cc <_ZL15default_consolev+0x68>)
    33b4:	4803      	ldr	r0, [pc, #12]	; (33c4 <_ZL15default_consolev+0x60>)
    33b6:	f000 fb6d 	bl	3a94 <__aeabi_atexit>
#  endif
#else // DEVICE_SERIAL
    static Sink console;
#endif
    return &console;
    33ba:	4b02      	ldr	r3, [pc, #8]	; (33c4 <_ZL15default_consolev+0x60>)
}
    33bc:	4618      	mov	r0, r3
    33be:	bd08      	pop	{r3, pc}
    33c0:	20000e24 	.word	0x20000e24
    33c4:	20000e20 	.word	0x20000e20
    33c8:	20000000 	.word	0x20000000
    33cc:	00003c0d 	.word	0x00003c0d

000033d0 <_ZL11get_consolei>:

/* Locate the default console for stdout, stdin, stderr */
static FileHandle *get_console(int fd)
{
    33d0:	b500      	push	{lr}
    33d2:	b085      	sub	sp, #20
    33d4:	9001      	str	r0, [sp, #4]
    FileHandle *fh = mbed_override_console(fd);
    33d6:	9801      	ldr	r0, [sp, #4]
    33d8:	f7ff ffbe 	bl	3358 <_ZN4mbed21mbed_override_consoleEi>
    33dc:	9003      	str	r0, [sp, #12]
    if (fh) {
    33de:	9b03      	ldr	r3, [sp, #12]
    33e0:	2b00      	cmp	r3, #0
    33e2:	d001      	beq.n	33e8 <_ZL11get_consolei+0x18>
        return fh;
    33e4:	9b03      	ldr	r3, [sp, #12]
    33e6:	e00b      	b.n	3400 <_ZL11get_consolei+0x30>
    }
    fh = mbed_target_override_console(fd);
    33e8:	9801      	ldr	r0, [sp, #4]
    33ea:	f7ff ffaf 	bl	334c <_ZN4mbed28mbed_target_override_consoleEi>
    33ee:	9003      	str	r0, [sp, #12]
    if (fh) {
    33f0:	9b03      	ldr	r3, [sp, #12]
    33f2:	2b00      	cmp	r3, #0
    33f4:	d001      	beq.n	33fa <_ZL11get_consolei+0x2a>
        return fh;
    33f6:	9b03      	ldr	r3, [sp, #12]
    33f8:	e002      	b.n	3400 <_ZL11get_consolei+0x30>
    }
    return default_console();
    33fa:	f7ff ffb3 	bl	3364 <_ZL15default_consolev>
    33fe:	4603      	mov	r3, r0
}
    3400:	4618      	mov	r0, r3
    3402:	b005      	add	sp, #20
    3404:	f85d fb04 	ldr.w	pc, [sp], #4

00003408 <_ZL7get_fhci>:

/* Deal with the fact C library may not _open descriptors 0, 1, 2 - auto bind */
static FileHandle *get_fhc(int fd)
{
    3408:	b500      	push	{lr}
    340a:	b085      	sub	sp, #20
    340c:	9001      	str	r0, [sp, #4]
    if (fd >= OPEN_MAX) {
    340e:	9b01      	ldr	r3, [sp, #4]
    3410:	2b3f      	cmp	r3, #63	; 0x3f
    3412:	dd01      	ble.n	3418 <_ZL7get_fhci+0x10>
        return NULL;
    3414:	2300      	movs	r3, #0
    3416:	e015      	b.n	3444 <_ZL7get_fhci+0x3c>
    }
    FileHandle *fh = filehandles[fd];
    3418:	4a0c      	ldr	r2, [pc, #48]	; (344c <_ZL7get_fhci+0x44>)
    341a:	9b01      	ldr	r3, [sp, #4]
    341c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3420:	9303      	str	r3, [sp, #12]
    if (fh == FILE_HANDLE_RESERVED && fd < 3) {
    3422:	9b03      	ldr	r3, [sp, #12]
    3424:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    3428:	d10b      	bne.n	3442 <_ZL7get_fhci+0x3a>
    342a:	9b01      	ldr	r3, [sp, #4]
    342c:	2b02      	cmp	r3, #2
    342e:	dc08      	bgt.n	3442 <_ZL7get_fhci+0x3a>
        filehandles[fd] = fh = get_console(fd);
    3430:	9801      	ldr	r0, [sp, #4]
    3432:	f7ff ffcd 	bl	33d0 <_ZL11get_consolei>
    3436:	9003      	str	r0, [sp, #12]
    3438:	4904      	ldr	r1, [pc, #16]	; (344c <_ZL7get_fhci+0x44>)
    343a:	9b01      	ldr	r3, [sp, #4]
    343c:	9a03      	ldr	r2, [sp, #12]
    343e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    return fh;
    3442:	9b03      	ldr	r3, [sp, #12]
}
    3444:	4618      	mov	r0, r3
    3446:	b005      	add	sp, #20
    3448:	f85d fb04 	ldr.w	pc, [sp], #4
    344c:	20000008 	.word	0x20000008

00003450 <_close>:

    return fildes;
}

extern "C" int PREFIX(_close)(FILEHANDLE fh)
{
    3450:	b500      	push	{lr}
    3452:	b083      	sub	sp, #12
    3454:	9001      	str	r0, [sp, #4]
    return close(fh);
    3456:	9801      	ldr	r0, [sp, #4]
    3458:	f000 f806 	bl	3468 <close>
    345c:	4603      	mov	r3, r0
}
    345e:	4618      	mov	r0, r3
    3460:	b003      	add	sp, #12
    3462:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00003468 <close>:

extern "C" int close(int fildes)
{
    3468:	b500      	push	{lr}
    346a:	b085      	sub	sp, #20
    346c:	9001      	str	r0, [sp, #4]
    FileHandle *fhc = get_fhc(fildes);
    346e:	9801      	ldr	r0, [sp, #4]
    3470:	f7ff ffca 	bl	3408 <_ZL7get_fhci>
    3474:	9003      	str	r0, [sp, #12]
    filehandles[fildes] = NULL;
    3476:	4a14      	ldr	r2, [pc, #80]	; (34c8 <close+0x60>)
    3478:	9b01      	ldr	r3, [sp, #4]
    347a:	2100      	movs	r1, #0
    347c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    if (fhc == NULL) {
    3480:	9b03      	ldr	r3, [sp, #12]
    3482:	2b00      	cmp	r3, #0
    3484:	d107      	bne.n	3496 <close+0x2e>
        errno = EBADF;
    3486:	f006 ff73 	bl	a370 <__errno>
    348a:	4602      	mov	r2, r0
    348c:	2309      	movs	r3, #9
    348e:	6013      	str	r3, [r2, #0]
        return -1;
    3490:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3494:	e013      	b.n	34be <close+0x56>
    }

    int err = fhc->close();
    3496:	9b03      	ldr	r3, [sp, #12]
    3498:	681b      	ldr	r3, [r3, #0]
    349a:	3314      	adds	r3, #20
    349c:	681b      	ldr	r3, [r3, #0]
    349e:	9803      	ldr	r0, [sp, #12]
    34a0:	4798      	blx	r3
    34a2:	9002      	str	r0, [sp, #8]
    if (err < 0) {
    34a4:	9b02      	ldr	r3, [sp, #8]
    34a6:	2b00      	cmp	r3, #0
    34a8:	da08      	bge.n	34bc <close+0x54>
        errno = -err;
    34aa:	f006 ff61 	bl	a370 <__errno>
    34ae:	4602      	mov	r2, r0
    34b0:	9b02      	ldr	r3, [sp, #8]
    34b2:	425b      	negs	r3, r3
    34b4:	6013      	str	r3, [r2, #0]
        return -1;
    34b6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    34ba:	e000      	b.n	34be <close+0x56>
    } else {
        return 0;
    34bc:	2300      	movs	r3, #0
    }
}
    34be:	4618      	mov	r0, r3
    34c0:	b005      	add	sp, #20
    34c2:	f85d fb04 	ldr.w	pc, [sp], #4
    34c6:	bf00      	nop
    34c8:	20000008 	.word	0x20000008

000034cc <_ZL12convert_crlfi>:

static bool convert_crlf(int fd)
{
    34cc:	b500      	push	{lr}
    34ce:	b083      	sub	sp, #12
    34d0:	9001      	str	r0, [sp, #4]
#if MBED_CONF_PLATFORM_STDIO_CONVERT_TTY_NEWLINES
    return isatty(fd);
#elif MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES
    return fd < 3 && isatty(fd);
    34d2:	9b01      	ldr	r3, [sp, #4]
    34d4:	2b02      	cmp	r3, #2
    34d6:	dc07      	bgt.n	34e8 <_ZL12convert_crlfi+0x1c>
    34d8:	9801      	ldr	r0, [sp, #4]
    34da:	f000 f9d8 	bl	388e <isatty>
    34de:	4603      	mov	r3, r0
    34e0:	2b00      	cmp	r3, #0
    34e2:	d001      	beq.n	34e8 <_ZL12convert_crlfi+0x1c>
    34e4:	2301      	movs	r3, #1
    34e6:	e000      	b.n	34ea <_ZL12convert_crlfi+0x1e>
    34e8:	2300      	movs	r3, #0
#else
    return false;
#endif
}
    34ea:	4618      	mov	r0, r3
    34ec:	b003      	add	sp, #12
    34ee:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000034f4 <_write>:
#if defined(__ICCARM__)
extern "C" size_t    __write(int        fh, const unsigned char *buffer, size_t length)
{
#else
extern "C" int PREFIX(_write)(FILEHANDLE fh, const unsigned char *buffer, unsigned int length, int mode)
{
    34f4:	b500      	push	{lr}
    34f6:	b08d      	sub	sp, #52	; 0x34
    34f8:	9005      	str	r0, [sp, #20]
    34fa:	9104      	str	r1, [sp, #16]
    34fc:	9203      	str	r2, [sp, #12]
    34fe:	9302      	str	r3, [sp, #8]
#endif

#if defined(MBED_TRAP_ERRORS_ENABLED) && MBED_TRAP_ERRORS_ENABLED && defined(MBED_CONF_RTOS_PRESENT)
    if (core_util_is_isr_active() || !core_util_are_interrupts_enabled()) {
    3500:	f7ff fb49 	bl	2b96 <core_util_is_isr_active>
    3504:	4603      	mov	r3, r0
    3506:	2b00      	cmp	r3, #0
    3508:	d107      	bne.n	351a <_write+0x26>
    350a:	f7ff fb35 	bl	2b78 <core_util_are_interrupts_enabled>
    350e:	4603      	mov	r3, r0
    3510:	f083 0301 	eor.w	r3, r3, #1
    3514:	b2db      	uxtb	r3, r3
    3516:	2b00      	cmp	r3, #0
    3518:	d001      	beq.n	351e <_write+0x2a>
    351a:	2301      	movs	r3, #1
    351c:	e000      	b.n	3520 <_write+0x2c>
    351e:	2300      	movs	r3, #0
    3520:	2b00      	cmp	r3, #0
    3522:	d007      	beq.n	3534 <_write+0x40>
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_PROHIBITED_IN_ISR_CONTEXT), "Error - writing to a file in an ISR or critical section\r\n", fh);
    3524:	9a05      	ldr	r2, [sp, #20]
    3526:	2300      	movs	r3, #0
    3528:	9300      	str	r3, [sp, #0]
    352a:	2300      	movs	r3, #0
    352c:	494f      	ldr	r1, [pc, #316]	; (366c <_write+0x178>)
    352e:	4850      	ldr	r0, [pc, #320]	; (3670 <_write+0x17c>)
    3530:	f7ff fc52 	bl	2dd8 <mbed_error>
    }
#endif

    if (length > SSIZE_MAX) {
    3534:	9b03      	ldr	r3, [sp, #12]
    3536:	2b00      	cmp	r3, #0
    3538:	da07      	bge.n	354a <_write+0x56>
        errno = EINVAL;
    353a:	f006 ff19 	bl	a370 <__errno>
    353e:	4602      	mov	r2, r0
    3540:	2316      	movs	r3, #22
    3542:	6013      	str	r3, [r2, #0]
        return -1;
    3544:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3548:	e08b      	b.n	3662 <_write+0x16e>
    }

    ssize_t slength = length;
    354a:	9b03      	ldr	r3, [sp, #12]
    354c:	9308      	str	r3, [sp, #32]
    ssize_t written = 0;
    354e:	2300      	movs	r3, #0
    3550:	930b      	str	r3, [sp, #44]	; 0x2c

    if (convert_crlf(fh)) {
    3552:	9805      	ldr	r0, [sp, #20]
    3554:	f7ff ffba 	bl	34cc <_ZL12convert_crlfi>
    3558:	4603      	mov	r3, r0
    355a:	2b00      	cmp	r3, #0
    355c:	d056      	beq.n	360c <_write+0x118>
        // local prev is previous in buffer during seek
        // stdio_out_prev[fh] is last thing actually written
        char prev = stdio_out_prev[fh];
    355e:	4a45      	ldr	r2, [pc, #276]	; (3674 <_write+0x180>)
    3560:	9b05      	ldr	r3, [sp, #20]
    3562:	4413      	add	r3, r2
    3564:	781b      	ldrb	r3, [r3, #0]
    3566:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
        // Seek for '\n' without preceding '\r'; if found flush
        // preceding and insert '\r'. Continue until end of input.
        for (ssize_t cur = 0; cur < slength; cur++) {
    356a:	2300      	movs	r3, #0
    356c:	9309      	str	r3, [sp, #36]	; 0x24
    356e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    3570:	9b08      	ldr	r3, [sp, #32]
    3572:	429a      	cmp	r2, r3
    3574:	da4a      	bge.n	360c <_write+0x118>
            if (buffer[cur] == '\n' && prev != '\r') {
    3576:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3578:	9a04      	ldr	r2, [sp, #16]
    357a:	4413      	add	r3, r2
    357c:	781b      	ldrb	r3, [r3, #0]
    357e:	2b0a      	cmp	r3, #10
    3580:	d13a      	bne.n	35f8 <_write+0x104>
    3582:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    3586:	2b0d      	cmp	r3, #13
    3588:	d036      	beq.n	35f8 <_write+0x104>
                ssize_t r;
                // flush stuff preceding the \n
                if (cur > written) {
    358a:	9a09      	ldr	r2, [sp, #36]	; 0x24
    358c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    358e:	429a      	cmp	r2, r3
    3590:	dd1e      	ble.n	35d0 <_write+0xdc>
                    r = write(fh, buffer + written, cur - written);
    3592:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3594:	9a04      	ldr	r2, [sp, #16]
    3596:	18d1      	adds	r1, r2, r3
    3598:	9a09      	ldr	r2, [sp, #36]	; 0x24
    359a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    359c:	1ad3      	subs	r3, r2, r3
    359e:	461a      	mov	r2, r3
    35a0:	9805      	ldr	r0, [sp, #20]
    35a2:	f000 f86b 	bl	367c <write>
    35a6:	9007      	str	r0, [sp, #28]
                    if (r < 0) {
    35a8:	9b07      	ldr	r3, [sp, #28]
    35aa:	2b00      	cmp	r3, #0
    35ac:	da02      	bge.n	35b4 <_write+0xc0>
                        return -1;
    35ae:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    35b2:	e056      	b.n	3662 <_write+0x16e>
                    }
                    written += r;
    35b4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    35b6:	9b07      	ldr	r3, [sp, #28]
    35b8:	4413      	add	r3, r2
    35ba:	930b      	str	r3, [sp, #44]	; 0x2c
                    if (written < cur) {
    35bc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    35be:	9b09      	ldr	r3, [sp, #36]	; 0x24
    35c0:	429a      	cmp	r2, r3
    35c2:	db4a      	blt.n	365a <_write+0x166>
                        // For some reason, didn't write all - give up now
                        goto finish;
                    }
                    stdio_out_prev[fh] = prev;
    35c4:	4a2b      	ldr	r2, [pc, #172]	; (3674 <_write+0x180>)
    35c6:	9b05      	ldr	r3, [sp, #20]
    35c8:	4413      	add	r3, r2
    35ca:	f89d 202b 	ldrb.w	r2, [sp, #43]	; 0x2b
    35ce:	701a      	strb	r2, [r3, #0]
                }
                // insert a \r now, leaving the \n still to be written
                r = write(fh, "\r", 1);
    35d0:	2201      	movs	r2, #1
    35d2:	4929      	ldr	r1, [pc, #164]	; (3678 <_write+0x184>)
    35d4:	9805      	ldr	r0, [sp, #20]
    35d6:	f000 f851 	bl	367c <write>
    35da:	9007      	str	r0, [sp, #28]
                if (r < 0) {
    35dc:	9b07      	ldr	r3, [sp, #28]
    35de:	2b00      	cmp	r3, #0
    35e0:	da02      	bge.n	35e8 <_write+0xf4>
                    return -1;
    35e2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    35e6:	e03c      	b.n	3662 <_write+0x16e>
                }
                if (r < 1) {
    35e8:	9b07      	ldr	r3, [sp, #28]
    35ea:	2b00      	cmp	r3, #0
    35ec:	dd37      	ble.n	365e <_write+0x16a>
                    goto finish;
                }
                stdio_out_prev[fh] = '\r';
    35ee:	4a21      	ldr	r2, [pc, #132]	; (3674 <_write+0x180>)
    35f0:	9b05      	ldr	r3, [sp, #20]
    35f2:	4413      	add	r3, r2
    35f4:	220d      	movs	r2, #13
    35f6:	701a      	strb	r2, [r3, #0]
            }
            prev = buffer[cur];
    35f8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    35fa:	9a04      	ldr	r2, [sp, #16]
    35fc:	4413      	add	r3, r2
    35fe:	781b      	ldrb	r3, [r3, #0]
    3600:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
        for (ssize_t cur = 0; cur < slength; cur++) {
    3604:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3606:	3301      	adds	r3, #1
    3608:	9309      	str	r3, [sp, #36]	; 0x24
    360a:	e7b0      	b.n	356e <_write+0x7a>
        }
    }

    // Flush remaining from conversion, or the whole thing if no conversion
    if (written < slength) {
    360c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    360e:	9b08      	ldr	r3, [sp, #32]
    3610:	429a      	cmp	r2, r3
    3612:	da25      	bge.n	3660 <_write+0x16c>
        ssize_t r = write(fh, buffer + written, slength - written);
    3614:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3616:	9a04      	ldr	r2, [sp, #16]
    3618:	18d1      	adds	r1, r2, r3
    361a:	9a08      	ldr	r2, [sp, #32]
    361c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    361e:	1ad3      	subs	r3, r2, r3
    3620:	461a      	mov	r2, r3
    3622:	9805      	ldr	r0, [sp, #20]
    3624:	f000 f82a 	bl	367c <write>
    3628:	9006      	str	r0, [sp, #24]
        if (r < 0) {
    362a:	9b06      	ldr	r3, [sp, #24]
    362c:	2b00      	cmp	r3, #0
    362e:	da02      	bge.n	3636 <_write+0x142>
            return -1;
    3630:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3634:	e015      	b.n	3662 <_write+0x16e>
        }
        written += r;
    3636:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    3638:	9b06      	ldr	r3, [sp, #24]
    363a:	4413      	add	r3, r2
    363c:	930b      	str	r3, [sp, #44]	; 0x2c
        if (written > 0) {
    363e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3640:	2b00      	cmp	r3, #0
    3642:	dd0d      	ble.n	3660 <_write+0x16c>
            stdio_out_prev[fh] = buffer[written - 1];
    3644:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3646:	3b01      	subs	r3, #1
    3648:	9a04      	ldr	r2, [sp, #16]
    364a:	4413      	add	r3, r2
    364c:	7819      	ldrb	r1, [r3, #0]
    364e:	4a09      	ldr	r2, [pc, #36]	; (3674 <_write+0x180>)
    3650:	9b05      	ldr	r3, [sp, #20]
    3652:	4413      	add	r3, r2
    3654:	460a      	mov	r2, r1
    3656:	701a      	strb	r2, [r3, #0]
    3658:	e002      	b.n	3660 <_write+0x16c>
                        goto finish;
    365a:	bf00      	nop
    365c:	e000      	b.n	3660 <_write+0x16c>
                    goto finish;
    365e:	bf00      	nop
        return slength - written;
    } else {
        return written;
    }
#else
    return written;
    3660:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
#endif
}
    3662:	4618      	mov	r0, r3
    3664:	b00d      	add	sp, #52	; 0x34
    3666:	f85d fb04 	ldr.w	pc, [sp], #4
    366a:	bf00      	nop
    366c:	00010e40 	.word	0x00010e40
    3670:	8001012f 	.word	0x8001012f
    3674:	20000de0 	.word	0x20000de0
    3678:	00010e7c 	.word	0x00010e7c

0000367c <write>:

extern "C" ssize_t write(int fildes, const void *buf, size_t length)
{
    367c:	b500      	push	{lr}
    367e:	b087      	sub	sp, #28
    3680:	9003      	str	r0, [sp, #12]
    3682:	9102      	str	r1, [sp, #8]
    3684:	9201      	str	r2, [sp, #4]

    FileHandle *fhc = get_fhc(fildes);
    3686:	9803      	ldr	r0, [sp, #12]
    3688:	f7ff febe 	bl	3408 <_ZL7get_fhci>
    368c:	9005      	str	r0, [sp, #20]
    if (fhc == NULL) {
    368e:	9b05      	ldr	r3, [sp, #20]
    3690:	2b00      	cmp	r3, #0
    3692:	d107      	bne.n	36a4 <write+0x28>
        errno = EBADF;
    3694:	f006 fe6c 	bl	a370 <__errno>
    3698:	4602      	mov	r2, r0
    369a:	2309      	movs	r3, #9
    369c:	6013      	str	r3, [r2, #0]
        return -1;
    369e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    36a2:	e015      	b.n	36d0 <write+0x54>
    }

    ssize_t ret = fhc->write(buf, length);
    36a4:	9b05      	ldr	r3, [sp, #20]
    36a6:	681b      	ldr	r3, [r3, #0]
    36a8:	330c      	adds	r3, #12
    36aa:	681b      	ldr	r3, [r3, #0]
    36ac:	9a01      	ldr	r2, [sp, #4]
    36ae:	9902      	ldr	r1, [sp, #8]
    36b0:	9805      	ldr	r0, [sp, #20]
    36b2:	4798      	blx	r3
    36b4:	9004      	str	r0, [sp, #16]
    if (ret < 0) {
    36b6:	9b04      	ldr	r3, [sp, #16]
    36b8:	2b00      	cmp	r3, #0
    36ba:	da08      	bge.n	36ce <write+0x52>
        errno = -ret;
    36bc:	f006 fe58 	bl	a370 <__errno>
    36c0:	4602      	mov	r2, r0
    36c2:	9b04      	ldr	r3, [sp, #16]
    36c4:	425b      	negs	r3, r3
    36c6:	6013      	str	r3, [r2, #0]
        return -1;
    36c8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    36cc:	e000      	b.n	36d0 <write+0x54>
    } else {
        return ret;
    36ce:	9b04      	ldr	r3, [sp, #16]
    }
}
    36d0:	4618      	mov	r0, r3
    36d2:	b007      	add	sp, #28
    36d4:	f85d fb04 	ldr.w	pc, [sp], #4

000036d8 <_read>:
#if defined(__ICCARM__)
extern "C" size_t    __read(int        fh, unsigned char *buffer, size_t       length)
{
#else
extern "C" int PREFIX(_read)(FILEHANDLE fh, unsigned char *buffer, unsigned int length, int mode)
{
    36d8:	b500      	push	{lr}
    36da:	b08b      	sub	sp, #44	; 0x2c
    36dc:	9005      	str	r0, [sp, #20]
    36de:	9104      	str	r1, [sp, #16]
    36e0:	9203      	str	r2, [sp, #12]
    36e2:	9302      	str	r3, [sp, #8]
#endif

#if defined(MBED_TRAP_ERRORS_ENABLED) && MBED_TRAP_ERRORS_ENABLED && defined(MBED_CONF_RTOS_PRESENT)
    if (core_util_is_isr_active() || !core_util_are_interrupts_enabled()) {
    36e4:	f7ff fa57 	bl	2b96 <core_util_is_isr_active>
    36e8:	4603      	mov	r3, r0
    36ea:	2b00      	cmp	r3, #0
    36ec:	d107      	bne.n	36fe <_read+0x26>
    36ee:	f7ff fa43 	bl	2b78 <core_util_are_interrupts_enabled>
    36f2:	4603      	mov	r3, r0
    36f4:	f083 0301 	eor.w	r3, r3, #1
    36f8:	b2db      	uxtb	r3, r3
    36fa:	2b00      	cmp	r3, #0
    36fc:	d001      	beq.n	3702 <_read+0x2a>
    36fe:	2301      	movs	r3, #1
    3700:	e000      	b.n	3704 <_read+0x2c>
    3702:	2300      	movs	r3, #0
    3704:	2b00      	cmp	r3, #0
    3706:	d007      	beq.n	3718 <_read+0x40>
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_PROHIBITED_IN_ISR_CONTEXT), "Error - reading from a file in an ISR or critical section\r\n", fh);
    3708:	9a05      	ldr	r2, [sp, #20]
    370a:	2300      	movs	r3, #0
    370c:	9300      	str	r3, [sp, #0]
    370e:	2300      	movs	r3, #0
    3710:	493f      	ldr	r1, [pc, #252]	; (3810 <_read+0x138>)
    3712:	4840      	ldr	r0, [pc, #256]	; (3814 <_read+0x13c>)
    3714:	f7ff fb60 	bl	2dd8 <mbed_error>
    }
#endif

    if (length > SSIZE_MAX) {
    3718:	9b03      	ldr	r3, [sp, #12]
    371a:	2b00      	cmp	r3, #0
    371c:	da07      	bge.n	372e <_read+0x56>
        errno = EINVAL;
    371e:	f006 fe27 	bl	a370 <__errno>
    3722:	4602      	mov	r2, r0
    3724:	2316      	movs	r3, #22
    3726:	6013      	str	r3, [r2, #0]
        return -1;
    3728:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    372c:	e06b      	b.n	3806 <_read+0x12e>
    }

    ssize_t bytes_read = 0;
    372e:	2300      	movs	r3, #0
    3730:	9309      	str	r3, [sp, #36]	; 0x24

    if (convert_crlf(fh)) {
    3732:	9805      	ldr	r0, [sp, #20]
    3734:	f7ff feca 	bl	34cc <_ZL12convert_crlfi>
    3738:	4603      	mov	r3, r0
    373a:	2b00      	cmp	r3, #0
    373c:	d05c      	beq.n	37f8 <_read+0x120>
        while (true) {
            char c;
            ssize_t r = read(fh, &c, 1);
    373e:	f10d 031f 	add.w	r3, sp, #31
    3742:	2201      	movs	r2, #1
    3744:	4619      	mov	r1, r3
    3746:	9805      	ldr	r0, [sp, #20]
    3748:	f000 f868 	bl	381c <read>
    374c:	9008      	str	r0, [sp, #32]
            if (r < 0) {
    374e:	9b08      	ldr	r3, [sp, #32]
    3750:	2b00      	cmp	r3, #0
    3752:	da02      	bge.n	375a <_read+0x82>
                return -1;
    3754:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3758:	e055      	b.n	3806 <_read+0x12e>
            }
            if (r == 0) {
    375a:	9b08      	ldr	r3, [sp, #32]
    375c:	2b00      	cmp	r3, #0
    375e:	d101      	bne.n	3764 <_read+0x8c>
                return bytes_read;
    3760:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3762:	e050      	b.n	3806 <_read+0x12e>
            }
            if ((c == '\r' && stdio_in_prev[fh] != '\n') ||
    3764:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3768:	2b0d      	cmp	r3, #13
    376a:	d105      	bne.n	3778 <_read+0xa0>
    376c:	4a2a      	ldr	r2, [pc, #168]	; (3818 <_read+0x140>)
    376e:	9b05      	ldr	r3, [sp, #20]
    3770:	4413      	add	r3, r2
    3772:	781b      	ldrb	r3, [r3, #0]
    3774:	2b0a      	cmp	r3, #10
    3776:	d109      	bne.n	378c <_read+0xb4>
                    (c == '\n' && stdio_in_prev[fh] != '\r')) {
    3778:	f89d 301f 	ldrb.w	r3, [sp, #31]
            if ((c == '\r' && stdio_in_prev[fh] != '\n') ||
    377c:	2b0a      	cmp	r3, #10
    377e:	d110      	bne.n	37a2 <_read+0xca>
                    (c == '\n' && stdio_in_prev[fh] != '\r')) {
    3780:	4a25      	ldr	r2, [pc, #148]	; (3818 <_read+0x140>)
    3782:	9b05      	ldr	r3, [sp, #20]
    3784:	4413      	add	r3, r2
    3786:	781b      	ldrb	r3, [r3, #0]
    3788:	2b0d      	cmp	r3, #13
    378a:	d00a      	beq.n	37a2 <_read+0xca>
                stdio_in_prev[fh] = c;
    378c:	f89d 101f 	ldrb.w	r1, [sp, #31]
    3790:	4a21      	ldr	r2, [pc, #132]	; (3818 <_read+0x140>)
    3792:	9b05      	ldr	r3, [sp, #20]
    3794:	4413      	add	r3, r2
    3796:	460a      	mov	r2, r1
    3798:	701a      	strb	r2, [r3, #0]
                *buffer = '\n';
    379a:	9b04      	ldr	r3, [sp, #16]
    379c:	220a      	movs	r2, #10
    379e:	701a      	strb	r2, [r3, #0]
                break;
    37a0:	e027      	b.n	37f2 <_read+0x11a>
            } else if ((c == '\r' && stdio_in_prev[fh] == '\n') ||
    37a2:	f89d 301f 	ldrb.w	r3, [sp, #31]
    37a6:	2b0d      	cmp	r3, #13
    37a8:	d105      	bne.n	37b6 <_read+0xde>
    37aa:	4a1b      	ldr	r2, [pc, #108]	; (3818 <_read+0x140>)
    37ac:	9b05      	ldr	r3, [sp, #20]
    37ae:	4413      	add	r3, r2
    37b0:	781b      	ldrb	r3, [r3, #0]
    37b2:	2b0a      	cmp	r3, #10
    37b4:	d009      	beq.n	37ca <_read+0xf2>
                       (c == '\n' && stdio_in_prev[fh] == '\r')) {
    37b6:	f89d 301f 	ldrb.w	r3, [sp, #31]
            } else if ((c == '\r' && stdio_in_prev[fh] == '\n') ||
    37ba:	2b0a      	cmp	r3, #10
    37bc:	d10d      	bne.n	37da <_read+0x102>
                       (c == '\n' && stdio_in_prev[fh] == '\r')) {
    37be:	4a16      	ldr	r2, [pc, #88]	; (3818 <_read+0x140>)
    37c0:	9b05      	ldr	r3, [sp, #20]
    37c2:	4413      	add	r3, r2
    37c4:	781b      	ldrb	r3, [r3, #0]
    37c6:	2b0d      	cmp	r3, #13
    37c8:	d107      	bne.n	37da <_read+0x102>
                stdio_in_prev[fh] = c;
    37ca:	f89d 101f 	ldrb.w	r1, [sp, #31]
    37ce:	4a12      	ldr	r2, [pc, #72]	; (3818 <_read+0x140>)
    37d0:	9b05      	ldr	r3, [sp, #20]
    37d2:	4413      	add	r3, r2
    37d4:	460a      	mov	r2, r1
    37d6:	701a      	strb	r2, [r3, #0]
            } else {
                stdio_in_prev[fh] = c;
                *buffer = c;
                break;
            }
        }
    37d8:	e7b1      	b.n	373e <_read+0x66>
                stdio_in_prev[fh] = c;
    37da:	f89d 101f 	ldrb.w	r1, [sp, #31]
    37de:	4a0e      	ldr	r2, [pc, #56]	; (3818 <_read+0x140>)
    37e0:	9b05      	ldr	r3, [sp, #20]
    37e2:	4413      	add	r3, r2
    37e4:	460a      	mov	r2, r1
    37e6:	701a      	strb	r2, [r3, #0]
                *buffer = c;
    37e8:	f89d 201f 	ldrb.w	r2, [sp, #31]
    37ec:	9b04      	ldr	r3, [sp, #16]
    37ee:	701a      	strb	r2, [r3, #0]
                break;
    37f0:	bf00      	nop
        bytes_read = 1;
    37f2:	2301      	movs	r3, #1
    37f4:	9309      	str	r3, [sp, #36]	; 0x24
    37f6:	e005      	b.n	3804 <_read+0x12c>
    } else {
        bytes_read = read(fh, buffer, length);
    37f8:	9a03      	ldr	r2, [sp, #12]
    37fa:	9904      	ldr	r1, [sp, #16]
    37fc:	9805      	ldr	r0, [sp, #20]
    37fe:	f000 f80d 	bl	381c <read>
    3802:	9009      	str	r0, [sp, #36]	; 0x24
        return 0x80000000 | length; // weird EOF indication
    } else {
        return (ssize_t)length - bytes_read;
    }
#else
    return bytes_read;
    3804:	9b09      	ldr	r3, [sp, #36]	; 0x24
#endif
}
    3806:	4618      	mov	r0, r3
    3808:	b00b      	add	sp, #44	; 0x2c
    380a:	f85d fb04 	ldr.w	pc, [sp], #4
    380e:	bf00      	nop
    3810:	00010e80 	.word	0x00010e80
    3814:	8001012f 	.word	0x8001012f
    3818:	20000da0 	.word	0x20000da0

0000381c <read>:

extern "C" ssize_t read(int fildes, void *buf, size_t length)
{
    381c:	b500      	push	{lr}
    381e:	b087      	sub	sp, #28
    3820:	9003      	str	r0, [sp, #12]
    3822:	9102      	str	r1, [sp, #8]
    3824:	9201      	str	r2, [sp, #4]

    FileHandle *fhc = get_fhc(fildes);
    3826:	9803      	ldr	r0, [sp, #12]
    3828:	f7ff fdee 	bl	3408 <_ZL7get_fhci>
    382c:	9005      	str	r0, [sp, #20]
    if (fhc == NULL) {
    382e:	9b05      	ldr	r3, [sp, #20]
    3830:	2b00      	cmp	r3, #0
    3832:	d107      	bne.n	3844 <read+0x28>
        errno = EBADF;
    3834:	f006 fd9c 	bl	a370 <__errno>
    3838:	4602      	mov	r2, r0
    383a:	2309      	movs	r3, #9
    383c:	6013      	str	r3, [r2, #0]
        return -1;
    383e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3842:	e015      	b.n	3870 <read+0x54>
    }

    ssize_t ret = fhc->read(buf, length);
    3844:	9b05      	ldr	r3, [sp, #20]
    3846:	681b      	ldr	r3, [r3, #0]
    3848:	3308      	adds	r3, #8
    384a:	681b      	ldr	r3, [r3, #0]
    384c:	9a01      	ldr	r2, [sp, #4]
    384e:	9902      	ldr	r1, [sp, #8]
    3850:	9805      	ldr	r0, [sp, #20]
    3852:	4798      	blx	r3
    3854:	9004      	str	r0, [sp, #16]
    if (ret < 0) {
    3856:	9b04      	ldr	r3, [sp, #16]
    3858:	2b00      	cmp	r3, #0
    385a:	da08      	bge.n	386e <read+0x52>
        errno = -ret;
    385c:	f006 fd88 	bl	a370 <__errno>
    3860:	4602      	mov	r2, r0
    3862:	9b04      	ldr	r3, [sp, #16]
    3864:	425b      	negs	r3, r3
    3866:	6013      	str	r3, [r2, #0]
        return -1;
    3868:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    386c:	e000      	b.n	3870 <read+0x54>
    } else {
        return ret;
    386e:	9b04      	ldr	r3, [sp, #16]
    }
}
    3870:	4618      	mov	r0, r3
    3872:	b007      	add	sp, #28
    3874:	f85d fb04 	ldr.w	pc, [sp], #4

00003878 <_isatty>:
#ifdef __ARMCC_VERSION
extern "C" int PREFIX(_istty)(FILEHANDLE fh)
#else
extern "C" int _isatty(FILEHANDLE fh)
#endif
{
    3878:	b500      	push	{lr}
    387a:	b083      	sub	sp, #12
    387c:	9001      	str	r0, [sp, #4]
    return isatty(fh);
    387e:	9801      	ldr	r0, [sp, #4]
    3880:	f000 f805 	bl	388e <isatty>
    3884:	4603      	mov	r3, r0
}
    3886:	4618      	mov	r0, r3
    3888:	b003      	add	sp, #12
    388a:	f85d fb04 	ldr.w	pc, [sp], #4

0000388e <isatty>:

extern "C" int isatty(int fildes)
{
    388e:	b500      	push	{lr}
    3890:	b085      	sub	sp, #20
    3892:	9001      	str	r0, [sp, #4]
    FileHandle *fhc = get_fhc(fildes);
    3894:	9801      	ldr	r0, [sp, #4]
    3896:	f7ff fdb7 	bl	3408 <_ZL7get_fhci>
    389a:	9003      	str	r0, [sp, #12]
    if (fhc == NULL) {
    389c:	9b03      	ldr	r3, [sp, #12]
    389e:	2b00      	cmp	r3, #0
    38a0:	d106      	bne.n	38b0 <isatty+0x22>
        errno = EBADF;
    38a2:	f006 fd65 	bl	a370 <__errno>
    38a6:	4602      	mov	r2, r0
    38a8:	2309      	movs	r3, #9
    38aa:	6013      	str	r3, [r2, #0]
        return 0;
    38ac:	2300      	movs	r3, #0
    38ae:	e012      	b.n	38d6 <isatty+0x48>
    }

    int tty = fhc->isatty();
    38b0:	9b03      	ldr	r3, [sp, #12]
    38b2:	681b      	ldr	r3, [r3, #0]
    38b4:	331c      	adds	r3, #28
    38b6:	681b      	ldr	r3, [r3, #0]
    38b8:	9803      	ldr	r0, [sp, #12]
    38ba:	4798      	blx	r3
    38bc:	9002      	str	r0, [sp, #8]
    if (tty < 0) {
    38be:	9b02      	ldr	r3, [sp, #8]
    38c0:	2b00      	cmp	r3, #0
    38c2:	da07      	bge.n	38d4 <isatty+0x46>
        errno = -tty;
    38c4:	f006 fd54 	bl	a370 <__errno>
    38c8:	4602      	mov	r2, r0
    38ca:	9b02      	ldr	r3, [sp, #8]
    38cc:	425b      	negs	r3, r3
    38ce:	6013      	str	r3, [r2, #0]
        return 0;
    38d0:	2300      	movs	r3, #0
    38d2:	e000      	b.n	38d6 <isatty+0x48>
    } else {
        return tty;
    38d4:	9b02      	ldr	r3, [sp, #8]
    }
}
    38d6:	4618      	mov	r0, r3
    38d8:	b005      	add	sp, #20
    38da:	f85d fb04 	ldr.w	pc, [sp], #4

000038de <_lseek>:
#elif defined(__ICCARM__)
long __lseek(int fh, long offset, int whence)
#else
int _lseek(FILEHANDLE fh, int offset, int whence)
#endif
{
    38de:	b500      	push	{lr}
    38e0:	b087      	sub	sp, #28
    38e2:	9003      	str	r0, [sp, #12]
    38e4:	9102      	str	r1, [sp, #8]
    38e6:	9201      	str	r2, [sp, #4]
#if defined(__ARMCC_VERSION)
    int whence = SEEK_SET;
#endif

    off_t off = lseek(fh, offset, whence);
    38e8:	9a01      	ldr	r2, [sp, #4]
    38ea:	9902      	ldr	r1, [sp, #8]
    38ec:	9803      	ldr	r0, [sp, #12]
    38ee:	f000 f806 	bl	38fe <lseek>
    38f2:	9005      	str	r0, [sp, #20]
    // Assuming INT_MAX = LONG_MAX, so we don't care about prototype difference
    if (off > INT_MAX) {
        errno = EOVERFLOW;
        return -1;
    }
    return off;
    38f4:	9b05      	ldr	r3, [sp, #20]
}
    38f6:	4618      	mov	r0, r3
    38f8:	b007      	add	sp, #28
    38fa:	f85d fb04 	ldr.w	pc, [sp], #4

000038fe <lseek>:

extern "C" off_t lseek(int fildes, off_t offset, int whence)
{
    38fe:	b500      	push	{lr}
    3900:	b087      	sub	sp, #28
    3902:	9003      	str	r0, [sp, #12]
    3904:	9102      	str	r1, [sp, #8]
    3906:	9201      	str	r2, [sp, #4]
    FileHandle *fhc = get_fhc(fildes);
    3908:	9803      	ldr	r0, [sp, #12]
    390a:	f7ff fd7d 	bl	3408 <_ZL7get_fhci>
    390e:	9005      	str	r0, [sp, #20]
    if (fhc == NULL) {
    3910:	9b05      	ldr	r3, [sp, #20]
    3912:	2b00      	cmp	r3, #0
    3914:	d107      	bne.n	3926 <lseek+0x28>
        errno = EBADF;
    3916:	f006 fd2b 	bl	a370 <__errno>
    391a:	4602      	mov	r2, r0
    391c:	2309      	movs	r3, #9
    391e:	6013      	str	r3, [r2, #0]
        return -1;
    3920:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3924:	e015      	b.n	3952 <lseek+0x54>
    }

    off_t off = fhc->seek(offset, whence);
    3926:	9b05      	ldr	r3, [sp, #20]
    3928:	681b      	ldr	r3, [r3, #0]
    392a:	3310      	adds	r3, #16
    392c:	681b      	ldr	r3, [r3, #0]
    392e:	9a01      	ldr	r2, [sp, #4]
    3930:	9902      	ldr	r1, [sp, #8]
    3932:	9805      	ldr	r0, [sp, #20]
    3934:	4798      	blx	r3
    3936:	9004      	str	r0, [sp, #16]
    if (off < 0) {
    3938:	9b04      	ldr	r3, [sp, #16]
    393a:	2b00      	cmp	r3, #0
    393c:	da08      	bge.n	3950 <lseek+0x52>
        errno = -off;
    393e:	f006 fd17 	bl	a370 <__errno>
    3942:	4602      	mov	r2, r0
    3944:	9b04      	ldr	r3, [sp, #16]
    3946:	425b      	negs	r3, r3
    3948:	6013      	str	r3, [r2, #0]
        return -1;
    394a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    394e:	e000      	b.n	3952 <lseek+0x54>
    }
    return off;
    3950:	9b04      	ldr	r3, [sp, #16]
}
    3952:	4618      	mov	r0, r3
    3954:	b007      	add	sp, #28
    3956:	f85d fb04 	ldr.w	pc, [sp], #4

0000395a <_fstat>:
#endif


#if !defined(__ARMCC_VERSION) && !defined(__ICCARM__)
extern "C" int _fstat(int fh, struct stat *st)
{
    395a:	b500      	push	{lr}
    395c:	b083      	sub	sp, #12
    395e:	9001      	str	r0, [sp, #4]
    3960:	9100      	str	r1, [sp, #0]
    return fstat(fh, st);
    3962:	9900      	ldr	r1, [sp, #0]
    3964:	9801      	ldr	r0, [sp, #4]
    3966:	f000 f805 	bl	3974 <fstat>
    396a:	4603      	mov	r3, r0
}
    396c:	4618      	mov	r0, r3
    396e:	b003      	add	sp, #12
    3970:	f85d fb04 	ldr.w	pc, [sp], #4

00003974 <fstat>:
#endif

extern "C" int fstat(int fildes, struct stat *st)
{
    3974:	b500      	push	{lr}
    3976:	b085      	sub	sp, #20
    3978:	9001      	str	r0, [sp, #4]
    397a:	9100      	str	r1, [sp, #0]
    FileHandle *fhc = get_fhc(fildes);
    397c:	9801      	ldr	r0, [sp, #4]
    397e:	f7ff fd43 	bl	3408 <_ZL7get_fhci>
    3982:	9003      	str	r0, [sp, #12]
    if (fhc == NULL) {
    3984:	9b03      	ldr	r3, [sp, #12]
    3986:	2b00      	cmp	r3, #0
    3988:	d107      	bne.n	399a <fstat+0x26>
        errno = EBADF;
    398a:	f006 fcf1 	bl	a370 <__errno>
    398e:	4602      	mov	r2, r0
    3990:	2309      	movs	r3, #9
    3992:	6013      	str	r3, [r2, #0]
        return -1;
    3994:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3998:	e019      	b.n	39ce <fstat+0x5a>
    }

    st->st_mode = fhc->isatty() ? S_IFCHR : S_IFREG;
    399a:	9b03      	ldr	r3, [sp, #12]
    399c:	681b      	ldr	r3, [r3, #0]
    399e:	331c      	adds	r3, #28
    39a0:	681b      	ldr	r3, [r3, #0]
    39a2:	9803      	ldr	r0, [sp, #12]
    39a4:	4798      	blx	r3
    39a6:	4603      	mov	r3, r0
    39a8:	2b00      	cmp	r3, #0
    39aa:	d002      	beq.n	39b2 <fstat+0x3e>
    39ac:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    39b0:	e001      	b.n	39b6 <fstat+0x42>
    39b2:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    39b6:	9b00      	ldr	r3, [sp, #0]
    39b8:	605a      	str	r2, [r3, #4]
    st->st_size = fhc->size();
    39ba:	9b03      	ldr	r3, [sp, #12]
    39bc:	681b      	ldr	r3, [r3, #0]
    39be:	3328      	adds	r3, #40	; 0x28
    39c0:	681b      	ldr	r3, [r3, #0]
    39c2:	9803      	ldr	r0, [sp, #12]
    39c4:	4798      	blx	r3
    39c6:	4602      	mov	r2, r0
    39c8:	9b00      	ldr	r3, [sp, #0]
    39ca:	611a      	str	r2, [r3, #16]
    return 0;
    39cc:	2300      	movs	r3, #0
}
    39ce:	4618      	mov	r0, r3
    39d0:	b005      	add	sp, #20
    39d2:	f85d fb04 	ldr.w	pc, [sp], #4

000039d6 <__cxa_pure_virtual>:
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_CLIB_EXCEPTION), "Exception", 0);
}
}
extern "C" WEAK void __cxa_pure_virtual(void);
extern "C" WEAK void __cxa_pure_virtual(void)
{
    39d6:	b508      	push	{r3, lr}
    exit(1);
    39d8:	2001      	movs	r0, #1
    39da:	f000 f863 	bl	3aa4 <__wrap_exit>
	...

000039e0 <_sbrk>:
#else
// Linker defined symbol used by _sbrk to indicate where heap should start.
extern "C" uint32_t __end__;
// Weak attribute allows user to override, e.g. to use external RAM for dynamic memory.
extern "C" WEAK caddr_t _sbrk(int incr)
{
    39e0:	b410      	push	{r4}
    39e2:	b085      	sub	sp, #20
    39e4:	9001      	str	r0, [sp, #4]
    static unsigned char *heap = (unsigned char *)&__end__;
    unsigned char        *prev_heap = heap;
    39e6:	4b1b      	ldr	r3, [pc, #108]	; (3a54 <_sbrk+0x74>)
    39e8:	681b      	ldr	r3, [r3, #0]
    39ea:	9303      	str	r3, [sp, #12]
    unsigned char        *new_heap = heap + incr;
    39ec:	4b19      	ldr	r3, [pc, #100]	; (3a54 <_sbrk+0x74>)
    39ee:	681a      	ldr	r2, [r3, #0]
    39f0:	9b01      	ldr	r3, [sp, #4]
    39f2:	4413      	add	r3, r2
    39f4:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
    39f6:	f3ef 8308 	mrs	r3, MSP
    39fa:	461c      	mov	r4, r3
  return(result);
    39fc:	4623      	mov	r3, r4

#if defined(TARGET_CORTEX_A)
    if (new_heap >= (unsigned char *)&__HeapLimit) {    /* __HeapLimit is end of heap section */
#else
    if (new_heap >= (unsigned char *)__get_MSP()) {
    39fe:	461a      	mov	r2, r3
    3a00:	9b02      	ldr	r3, [sp, #8]
    3a02:	429a      	cmp	r2, r3
    3a04:	bf94      	ite	ls
    3a06:	2301      	movls	r3, #1
    3a08:	2300      	movhi	r3, #0
    3a0a:	b2db      	uxtb	r3, r3
    3a0c:	2b00      	cmp	r3, #0
    3a0e:	d005      	beq.n	3a1c <_sbrk+0x3c>
#endif
        errno = ENOMEM;
    3a10:	4b11      	ldr	r3, [pc, #68]	; (3a58 <_sbrk+0x78>)
    3a12:	220c      	movs	r2, #12
    3a14:	601a      	str	r2, [r3, #0]
        return (caddr_t) -1;
    3a16:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3a1a:	e015      	b.n	3a48 <_sbrk+0x68>
    }

    // Additional heap checking if set
    if (mbed_heap_size && (new_heap >= mbed_heap_start + mbed_heap_size)) {
    3a1c:	4b0f      	ldr	r3, [pc, #60]	; (3a5c <_sbrk+0x7c>)
    3a1e:	681b      	ldr	r3, [r3, #0]
    3a20:	2b00      	cmp	r3, #0
    3a22:	d00d      	beq.n	3a40 <_sbrk+0x60>
    3a24:	4b0e      	ldr	r3, [pc, #56]	; (3a60 <_sbrk+0x80>)
    3a26:	681a      	ldr	r2, [r3, #0]
    3a28:	4b0c      	ldr	r3, [pc, #48]	; (3a5c <_sbrk+0x7c>)
    3a2a:	681b      	ldr	r3, [r3, #0]
    3a2c:	441a      	add	r2, r3
    3a2e:	9b02      	ldr	r3, [sp, #8]
    3a30:	429a      	cmp	r2, r3
    3a32:	d805      	bhi.n	3a40 <_sbrk+0x60>
        errno = ENOMEM;
    3a34:	4b08      	ldr	r3, [pc, #32]	; (3a58 <_sbrk+0x78>)
    3a36:	220c      	movs	r2, #12
    3a38:	601a      	str	r2, [r3, #0]
        return (caddr_t) -1;
    3a3a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3a3e:	e003      	b.n	3a48 <_sbrk+0x68>
    }

    heap = new_heap;
    3a40:	4a04      	ldr	r2, [pc, #16]	; (3a54 <_sbrk+0x74>)
    3a42:	9b02      	ldr	r3, [sp, #8]
    3a44:	6013      	str	r3, [r2, #0]
    return (caddr_t) prev_heap;
    3a46:	9b03      	ldr	r3, [sp, #12]
}
    3a48:	4618      	mov	r0, r3
    3a4a:	b005      	add	sp, #20
    3a4c:	f85d 4b04 	ldr.w	r4, [sp], #4
    3a50:	4770      	bx	lr
    3a52:	bf00      	nop
    3a54:	20000108 	.word	0x20000108
    3a58:	2000304c 	.word	0x2000304c
    3a5c:	20000d9c 	.word	0x20000d9c
    3a60:	20000d98 	.word	0x20000d98

00003a64 <_exit>:
#endif
#endif

#if defined(TOOLCHAIN_GCC_ARM) || defined(TOOLCHAIN_GCC_CR)
extern "C" void _exit(int return_code)
{
    3a64:	b500      	push	{lr}
    3a66:	b083      	sub	sp, #12
    3a68:	9001      	str	r0, [sp, #4]
{
#endif

#if DEVICE_STDIO_MESSAGES
#if MBED_CONF_PLATFORM_STDIO_FLUSH_AT_EXIT
    fflush(stdout);
    3a6a:	4b09      	ldr	r3, [pc, #36]	; (3a90 <_exit+0x2c>)
    3a6c:	681b      	ldr	r3, [r3, #0]
    3a6e:	689b      	ldr	r3, [r3, #8]
    3a70:	4618      	mov	r0, r3
    3a72:	f006 fdaf 	bl	a5d4 <fflush>
    fflush(stderr);
    3a76:	4b06      	ldr	r3, [pc, #24]	; (3a90 <_exit+0x2c>)
    3a78:	681b      	ldr	r3, [r3, #0]
    3a7a:	68db      	ldr	r3, [r3, #12]
    3a7c:	4618      	mov	r0, r3
    3a7e:	f006 fda9 	bl	a5d4 <fflush>
#if DEVICE_SEMIHOST
    if (mbed_interface_connected()) {
        semihost_exit();
    }
#endif
    if (return_code) {
    3a82:	9b01      	ldr	r3, [sp, #4]
    3a84:	2b00      	cmp	r3, #0
    3a86:	d001      	beq.n	3a8c <_exit+0x28>
        mbed_die();
    3a88:	f7fe ffda 	bl	2a40 <mbed_die>
    }

    while (1);
    3a8c:	e7fe      	b.n	3a8c <_exit+0x28>
    3a8e:	bf00      	nop
    3a90:	200001c0 	.word	0x200001c0

00003a94 <__aeabi_atexit>:
// In mbed, program never exit properly, it dies.
// More informations about this topic for ARMCC here:
// http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/6449.html
extern "C" {
    int __aeabi_atexit(void *object, void (*dtor)(void * /*this*/), void *handle)
    {
    3a94:	b084      	sub	sp, #16
    3a96:	9003      	str	r0, [sp, #12]
    3a98:	9102      	str	r1, [sp, #8]
    3a9a:	9201      	str	r2, [sp, #4]
        return 1;
    3a9c:	2301      	movs	r3, #1
    }
    3a9e:	4618      	mov	r0, r3
    3aa0:	b004      	add	sp, #16
    3aa2:	4770      	bx	lr

00003aa4 <__wrap_exit>:
     * @brief Retarget of exit for GCC.
     * @details Unlike the standard version, this function doesn't call any function
     * registered with atexit before calling _exit.
     */
    void __wrap_exit(int return_code)
    {
    3aa4:	b500      	push	{lr}
    3aa6:	b083      	sub	sp, #12
    3aa8:	9001      	str	r0, [sp, #4]
        _exit(return_code);
    3aaa:	9801      	ldr	r0, [sp, #4]
    3aac:	f7ff ffda 	bl	3a64 <_exit>
    }
    3ab0:	bf00      	nop
    3ab2:	b003      	add	sp, #12
    3ab4:	f85d fb04 	ldr.w	pc, [sp], #4

00003ab8 <__wrap_atexit>:
     * @brief Retarget atexit from GCC.
     * @details This function will always fail and never register any handler to be
     * called at exit.
     */
    int __wrap_atexit(void (*func)())
    {
    3ab8:	b082      	sub	sp, #8
    3aba:	9001      	str	r0, [sp, #4]
        return 1;
    3abc:	2301      	movs	r3, #1
    }
    3abe:	4618      	mov	r0, r3
    3ac0:	b002      	add	sp, #8
    3ac2:	4770      	bx	lr

00003ac4 <__malloc_lock>:
extern "C" WEAK void __rtos_malloc_unlock(struct _reent *_r) {}
extern "C" WEAK void __rtos_env_lock(struct _reent *_r) {}
extern "C" WEAK void __rtos_env_unlock(struct _reent *_r) {}

extern "C" void __malloc_lock(struct _reent *_r)
{
    3ac4:	b500      	push	{lr}
    3ac6:	b083      	sub	sp, #12
    3ac8:	9001      	str	r0, [sp, #4]
    __rtos_malloc_lock(_r);
    3aca:	9801      	ldr	r0, [sp, #4]
    3acc:	f000 fc12 	bl	42f4 <__rtos_malloc_lock>
}
    3ad0:	bf00      	nop
    3ad2:	b003      	add	sp, #12
    3ad4:	f85d fb04 	ldr.w	pc, [sp], #4

00003ad8 <__malloc_unlock>:

extern "C" void __malloc_unlock(struct _reent *_r)
{
    3ad8:	b500      	push	{lr}
    3ada:	b083      	sub	sp, #12
    3adc:	9001      	str	r0, [sp, #4]
    __rtos_malloc_unlock(_r);
    3ade:	9801      	ldr	r0, [sp, #4]
    3ae0:	f000 fc18 	bl	4314 <__rtos_malloc_unlock>
}
    3ae4:	bf00      	nop
    3ae6:	b003      	add	sp, #12
    3ae8:	f85d fb04 	ldr.w	pc, [sp], #4

00003aec <__cxa_guard_acquire>:
#define CXA_GUARD_INIT_DONE             (1 << 0)
#define CXA_GUARD_INIT_IN_PROGRESS      (1 << 1)
#define CXA_GUARD_MASK                  (CXA_GUARD_INIT_DONE | CXA_GUARD_INIT_IN_PROGRESS)

extern "C" int __cxa_guard_acquire(int *guard_object_p)
{
    3aec:	b500      	push	{lr}
    3aee:	b085      	sub	sp, #20
    3af0:	9001      	str	r0, [sp, #4]
    uint8_t *guard_object = (uint8_t *)guard_object_p;
    3af2:	9b01      	ldr	r3, [sp, #4]
    3af4:	9303      	str	r3, [sp, #12]
    if (CXA_GUARD_INIT_DONE == (*guard_object & CXA_GUARD_MASK)) {
    3af6:	9b03      	ldr	r3, [sp, #12]
    3af8:	781b      	ldrb	r3, [r3, #0]
    3afa:	f003 0303 	and.w	r3, r3, #3
    3afe:	2b01      	cmp	r3, #1
    3b00:	d101      	bne.n	3b06 <__cxa_guard_acquire+0x1a>
        return 0;
    3b02:	2300      	movs	r3, #0
    3b04:	e01f      	b.n	3b46 <__cxa_guard_acquire+0x5a>
    }
    singleton_lock();
    3b06:	f7ff fb4d 	bl	31a4 <_ZL14singleton_lockv>
    if (CXA_GUARD_INIT_DONE == (*guard_object & CXA_GUARD_MASK)) {
    3b0a:	9b03      	ldr	r3, [sp, #12]
    3b0c:	781b      	ldrb	r3, [r3, #0]
    3b0e:	f003 0303 	and.w	r3, r3, #3
    3b12:	2b01      	cmp	r3, #1
    3b14:	d103      	bne.n	3b1e <__cxa_guard_acquire+0x32>
        singleton_unlock();
    3b16:	f7ff fb51 	bl	31bc <_ZL16singleton_unlockv>
        return 0;
    3b1a:	2300      	movs	r3, #0
    3b1c:	e013      	b.n	3b46 <__cxa_guard_acquire+0x5a>
    }
    MBED_ASSERT(0 == (*guard_object & CXA_GUARD_MASK));
    3b1e:	9b03      	ldr	r3, [sp, #12]
    3b20:	781b      	ldrb	r3, [r3, #0]
    3b22:	f003 0303 	and.w	r3, r3, #3
    3b26:	2b00      	cmp	r3, #0
    3b28:	d005      	beq.n	3b36 <__cxa_guard_acquire+0x4a>
    3b2a:	f240 52ab 	movw	r2, #1451	; 0x5ab
    3b2e:	4908      	ldr	r1, [pc, #32]	; (3b50 <__cxa_guard_acquire+0x64>)
    3b30:	4808      	ldr	r0, [pc, #32]	; (3b54 <__cxa_guard_acquire+0x68>)
    3b32:	f7fe ff6f 	bl	2a14 <mbed_assert_internal>
    *guard_object = *guard_object | CXA_GUARD_INIT_IN_PROGRESS;
    3b36:	9b03      	ldr	r3, [sp, #12]
    3b38:	781b      	ldrb	r3, [r3, #0]
    3b3a:	f043 0302 	orr.w	r3, r3, #2
    3b3e:	b2da      	uxtb	r2, r3
    3b40:	9b03      	ldr	r3, [sp, #12]
    3b42:	701a      	strb	r2, [r3, #0]
    return 1;
    3b44:	2301      	movs	r3, #1
}
    3b46:	4618      	mov	r0, r3
    3b48:	b005      	add	sp, #20
    3b4a:	f85d fb04 	ldr.w	pc, [sp], #4
    3b4e:	bf00      	nop
    3b50:	00010ec8 	.word	0x00010ec8
    3b54:	00010ef0 	.word	0x00010ef0

00003b58 <__cxa_guard_release>:

extern "C" void __cxa_guard_release(int *guard_object_p)
{
    3b58:	b500      	push	{lr}
    3b5a:	b085      	sub	sp, #20
    3b5c:	9001      	str	r0, [sp, #4]
    uint8_t *guard_object = (uint8_t *)guard_object_p;
    3b5e:	9b01      	ldr	r3, [sp, #4]
    3b60:	9303      	str	r3, [sp, #12]
    MBED_ASSERT(CXA_GUARD_INIT_IN_PROGRESS == (*guard_object & CXA_GUARD_MASK));
    3b62:	9b03      	ldr	r3, [sp, #12]
    3b64:	781b      	ldrb	r3, [r3, #0]
    3b66:	f003 0303 	and.w	r3, r3, #3
    3b6a:	2b02      	cmp	r3, #2
    3b6c:	d005      	beq.n	3b7a <__cxa_guard_release+0x22>
    3b6e:	f240 52b3 	movw	r2, #1459	; 0x5b3
    3b72:	490b      	ldr	r1, [pc, #44]	; (3ba0 <__cxa_guard_release+0x48>)
    3b74:	480b      	ldr	r0, [pc, #44]	; (3ba4 <__cxa_guard_release+0x4c>)
    3b76:	f7fe ff4d 	bl	2a14 <mbed_assert_internal>
    *guard_object = (*guard_object & ~CXA_GUARD_MASK) | CXA_GUARD_INIT_DONE;
    3b7a:	9b03      	ldr	r3, [sp, #12]
    3b7c:	781b      	ldrb	r3, [r3, #0]
    3b7e:	b25b      	sxtb	r3, r3
    3b80:	f023 0303 	bic.w	r3, r3, #3
    3b84:	b25b      	sxtb	r3, r3
    3b86:	f043 0301 	orr.w	r3, r3, #1
    3b8a:	b25b      	sxtb	r3, r3
    3b8c:	b2da      	uxtb	r2, r3
    3b8e:	9b03      	ldr	r3, [sp, #12]
    3b90:	701a      	strb	r2, [r3, #0]
    singleton_unlock();
    3b92:	f7ff fb13 	bl	31bc <_ZL16singleton_unlockv>
}
    3b96:	bf00      	nop
    3b98:	b005      	add	sp, #20
    3b9a:	f85d fb04 	ldr.w	pc, [sp], #4
    3b9e:	bf00      	nop
    3ba0:	00010ec8 	.word	0x00010ec8
    3ba4:	00010f18 	.word	0x00010f18

00003ba8 <_Znwj>:

extern "C" void *malloc_wrapper(struct _reent *r, size_t size, void *caller);
extern "C" void free_wrapper(struct _reent *r, void *ptr, void *caller);

void *operator new (std::size_t count)
{
    3ba8:	b500      	push	{lr}
    3baa:	b087      	sub	sp, #28
    3bac:	4672      	mov	r2, lr
    3bae:	9003      	str	r0, [sp, #12]
    void *buffer = malloc_wrapper(_REENT, count, MBED_CALLER_ADDR());
    3bb0:	4b0b      	ldr	r3, [pc, #44]	; (3be0 <_Znwj+0x38>)
    3bb2:	681b      	ldr	r3, [r3, #0]
    3bb4:	9903      	ldr	r1, [sp, #12]
    3bb6:	4618      	mov	r0, r3
    3bb8:	f7fe fe20 	bl	27fc <malloc_wrapper>
    3bbc:	9005      	str	r0, [sp, #20]
    if (NULL == buffer) {
    3bbe:	9b05      	ldr	r3, [sp, #20]
    3bc0:	2b00      	cmp	r3, #0
    3bc2:	d107      	bne.n	3bd4 <_Znwj+0x2c>
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_OUT_OF_MEMORY), "Operator new out of memory\r\n", count);
    3bc4:	2300      	movs	r3, #0
    3bc6:	9300      	str	r3, [sp, #0]
    3bc8:	2300      	movs	r3, #0
    3bca:	9a03      	ldr	r2, [sp, #12]
    3bcc:	4905      	ldr	r1, [pc, #20]	; (3be4 <_Znwj+0x3c>)
    3bce:	4806      	ldr	r0, [pc, #24]	; (3be8 <_Znwj+0x40>)
    3bd0:	f7ff f902 	bl	2dd8 <mbed_error>
    }
    return buffer;
    3bd4:	9b05      	ldr	r3, [sp, #20]
}
    3bd6:	4618      	mov	r0, r3
    3bd8:	b007      	add	sp, #28
    3bda:	f85d fb04 	ldr.w	pc, [sp], #4
    3bde:	bf00      	nop
    3be0:	200001c0 	.word	0x200001c0
    3be4:	00010f58 	.word	0x00010f58
    3be8:	8001011f 	.word	0x8001011f

00003bec <_ZdlPv>:
{
    return malloc_wrapper(_REENT, count, MBED_CALLER_ADDR());
}

void operator delete (void *ptr)
{
    3bec:	b500      	push	{lr}
    3bee:	b083      	sub	sp, #12
    3bf0:	4672      	mov	r2, lr
    3bf2:	9001      	str	r0, [sp, #4]
    free_wrapper(_REENT, ptr, MBED_CALLER_ADDR());
    3bf4:	4b04      	ldr	r3, [pc, #16]	; (3c08 <_ZdlPv+0x1c>)
    3bf6:	681b      	ldr	r3, [r3, #0]
    3bf8:	9901      	ldr	r1, [sp, #4]
    3bfa:	4618      	mov	r0, r3
    3bfc:	f7fe fea2 	bl	2944 <free_wrapper>
}
    3c00:	bf00      	nop
    3c02:	b003      	add	sp, #12
    3c04:	f85d fb04 	ldr.w	pc, [sp], #4
    3c08:	200001c0 	.word	0x200001c0

00003c0c <_ZN12DirectSerialD1Ev>:
class DirectSerial : public FileHandle {
    3c0c:	b500      	push	{lr}
    3c0e:	b083      	sub	sp, #12
    3c10:	9001      	str	r0, [sp, #4]
    3c12:	4a06      	ldr	r2, [pc, #24]	; (3c2c <_ZN12DirectSerialD1Ev+0x20>)
    3c14:	9b01      	ldr	r3, [sp, #4]
    3c16:	601a      	str	r2, [r3, #0]
    3c18:	9b01      	ldr	r3, [sp, #4]
    3c1a:	4618      	mov	r0, r3
    3c1c:	f7fd ff22 	bl	1a64 <_ZN4mbed10FileHandleD1Ev>
    3c20:	9b01      	ldr	r3, [sp, #4]
    3c22:	4618      	mov	r0, r3
    3c24:	b003      	add	sp, #12
    3c26:	f85d fb04 	ldr.w	pc, [sp], #4
    3c2a:	bf00      	nop
    3c2c:	00012584 	.word	0x00012584

00003c30 <_ZN12DirectSerialD0Ev>:
    3c30:	b500      	push	{lr}
    3c32:	b083      	sub	sp, #12
    3c34:	9001      	str	r0, [sp, #4]
    3c36:	9801      	ldr	r0, [sp, #4]
    3c38:	f7ff ffe8 	bl	3c0c <_ZN12DirectSerialD1Ev>
    3c3c:	9801      	ldr	r0, [sp, #4]
    3c3e:	f7ff ffd5 	bl	3bec <_ZdlPv>
    3c42:	9b01      	ldr	r3, [sp, #4]
    3c44:	4618      	mov	r0, r3
    3c46:	b003      	add	sp, #12
    3c48:	f85d fb04 	ldr.w	pc, [sp], #4

00003c4c <mbed_stats_stack_get_each>:
    free(threads);
#endif
}

size_t mbed_stats_stack_get_each(mbed_stats_stack_t *stats, size_t count)
{
    3c4c:	b510      	push	{r4, lr}
    3c4e:	b086      	sub	sp, #24
    3c50:	9001      	str	r0, [sp, #4]
    3c52:	9100      	str	r1, [sp, #0]
    MBED_ASSERT(stats != NULL);
    3c54:	9b01      	ldr	r3, [sp, #4]
    3c56:	2b00      	cmp	r3, #0
    3c58:	d104      	bne.n	3c64 <mbed_stats_stack_get_each+0x18>
    3c5a:	223f      	movs	r2, #63	; 0x3f
    3c5c:	4931      	ldr	r1, [pc, #196]	; (3d24 <mbed_stats_stack_get_each+0xd8>)
    3c5e:	4832      	ldr	r0, [pc, #200]	; (3d28 <mbed_stats_stack_get_each+0xdc>)
    3c60:	f7fe fed8 	bl	2a14 <mbed_assert_internal>
    memset(stats, 0, count * sizeof(mbed_stats_stack_t));
    3c64:	9b00      	ldr	r3, [sp, #0]
    3c66:	011b      	lsls	r3, r3, #4
    3c68:	461a      	mov	r2, r3
    3c6a:	2100      	movs	r1, #0
    3c6c:	9801      	ldr	r0, [sp, #4]
    3c6e:	f007 fc19 	bl	b4a4 <memset>

    size_t i = 0;
    3c72:	2300      	movs	r3, #0
    3c74:	9305      	str	r3, [sp, #20]

#if defined(MBED_STACK_STATS_ENABLED) && defined(MBED_CONF_RTOS_PRESENT)
    osThreadId_t *threads;

    threads = malloc(sizeof(osThreadId_t) * count);
    3c76:	9b00      	ldr	r3, [sp, #0]
    3c78:	009b      	lsls	r3, r3, #2
    3c7a:	4618      	mov	r0, r3
    3c7c:	f007 f8d8 	bl	ae30 <malloc>
    3c80:	9004      	str	r0, [sp, #16]
    MBED_ASSERT(threads != NULL);
    3c82:	9b04      	ldr	r3, [sp, #16]
    3c84:	2b00      	cmp	r3, #0
    3c86:	d104      	bne.n	3c92 <mbed_stats_stack_get_each+0x46>
    3c88:	2248      	movs	r2, #72	; 0x48
    3c8a:	4926      	ldr	r1, [pc, #152]	; (3d24 <mbed_stats_stack_get_each+0xd8>)
    3c8c:	4827      	ldr	r0, [pc, #156]	; (3d2c <mbed_stats_stack_get_each+0xe0>)
    3c8e:	f7fe fec1 	bl	2a14 <mbed_assert_internal>

    osKernelLock();
    3c92:	f001 f921 	bl	4ed8 <osKernelLock>
    count = osThreadEnumerate(threads, count);
    3c96:	9900      	ldr	r1, [sp, #0]
    3c98:	9804      	ldr	r0, [sp, #16]
    3c9a:	f003 ffd3 	bl	7c44 <osThreadEnumerate>
    3c9e:	9000      	str	r0, [sp, #0]

    for (i = 0; i < count; i++) {
    3ca0:	2300      	movs	r3, #0
    3ca2:	9305      	str	r3, [sp, #20]
    3ca4:	e031      	b.n	3d0a <mbed_stats_stack_get_each+0xbe>
        uint32_t stack_size = osThreadGetStackSize(threads[i]);
    3ca6:	9b05      	ldr	r3, [sp, #20]
    3ca8:	009b      	lsls	r3, r3, #2
    3caa:	9a04      	ldr	r2, [sp, #16]
    3cac:	4413      	add	r3, r2
    3cae:	681b      	ldr	r3, [r3, #0]
    3cb0:	4618      	mov	r0, r3
    3cb2:	f003 ff53 	bl	7b5c <osThreadGetStackSize>
    3cb6:	9003      	str	r0, [sp, #12]
        stats[i].max_size = stack_size - osThreadGetStackSpace(threads[i]);
    3cb8:	9b05      	ldr	r3, [sp, #20]
    3cba:	011b      	lsls	r3, r3, #4
    3cbc:	9a01      	ldr	r2, [sp, #4]
    3cbe:	18d4      	adds	r4, r2, r3
    3cc0:	9b05      	ldr	r3, [sp, #20]
    3cc2:	009b      	lsls	r3, r3, #2
    3cc4:	9a04      	ldr	r2, [sp, #16]
    3cc6:	4413      	add	r3, r2
    3cc8:	681b      	ldr	r3, [r3, #0]
    3cca:	4618      	mov	r0, r3
    3ccc:	f003 ff6a 	bl	7ba4 <osThreadGetStackSpace>
    3cd0:	4602      	mov	r2, r0
    3cd2:	9b03      	ldr	r3, [sp, #12]
    3cd4:	1a9b      	subs	r3, r3, r2
    3cd6:	6063      	str	r3, [r4, #4]
        stats[i].reserved_size = stack_size;
    3cd8:	9b05      	ldr	r3, [sp, #20]
    3cda:	011b      	lsls	r3, r3, #4
    3cdc:	9a01      	ldr	r2, [sp, #4]
    3cde:	4413      	add	r3, r2
    3ce0:	9a03      	ldr	r2, [sp, #12]
    3ce2:	609a      	str	r2, [r3, #8]
        stats[i].thread_id = (uint32_t)threads[i];
    3ce4:	9b05      	ldr	r3, [sp, #20]
    3ce6:	011b      	lsls	r3, r3, #4
    3ce8:	9a01      	ldr	r2, [sp, #4]
    3cea:	4413      	add	r3, r2
    3cec:	9a05      	ldr	r2, [sp, #20]
    3cee:	0092      	lsls	r2, r2, #2
    3cf0:	9904      	ldr	r1, [sp, #16]
    3cf2:	440a      	add	r2, r1
    3cf4:	6812      	ldr	r2, [r2, #0]
    3cf6:	601a      	str	r2, [r3, #0]
        stats[i].stack_cnt = 1;
    3cf8:	9b05      	ldr	r3, [sp, #20]
    3cfa:	011b      	lsls	r3, r3, #4
    3cfc:	9a01      	ldr	r2, [sp, #4]
    3cfe:	4413      	add	r3, r2
    3d00:	2201      	movs	r2, #1
    3d02:	60da      	str	r2, [r3, #12]
    for (i = 0; i < count; i++) {
    3d04:	9b05      	ldr	r3, [sp, #20]
    3d06:	3301      	adds	r3, #1
    3d08:	9305      	str	r3, [sp, #20]
    3d0a:	9a05      	ldr	r2, [sp, #20]
    3d0c:	9b00      	ldr	r3, [sp, #0]
    3d0e:	429a      	cmp	r2, r3
    3d10:	d3c9      	bcc.n	3ca6 <mbed_stats_stack_get_each+0x5a>
    }
    osKernelUnlock();
    3d12:	f001 f903 	bl	4f1c <osKernelUnlock>

    free(threads);
    3d16:	9804      	ldr	r0, [sp, #16]
    3d18:	f007 f892 	bl	ae40 <free>
#endif

    return i;
    3d1c:	9b05      	ldr	r3, [sp, #20]
}
    3d1e:	4618      	mov	r0, r3
    3d20:	b006      	add	sp, #24
    3d22:	bd10      	pop	{r4, pc}
    3d24:	00010fb0 	.word	0x00010fb0
    3d28:	00010fd0 	.word	0x00010fd0
    3d2c:	00010fe0 	.word	0x00010fe0

00003d30 <wait>:
#include "rtos/rtos.h"
#include "platform/mbed_critical.h"
#include "platform/mbed_power_mgmt.h"

void wait(float s)
{
    3d30:	b500      	push	{lr}
    3d32:	b083      	sub	sp, #12
    3d34:	9001      	str	r0, [sp, #4]
    wait_us(s * 1000000.0f);
    3d36:	eddd 7a01 	vldr	s15, [sp, #4]
    3d3a:	ed9f 7a07 	vldr	s14, [pc, #28]	; 3d58 <wait+0x28>
    3d3e:	ee67 7a87 	vmul.f32	s15, s15, s14
    3d42:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    3d46:	ee17 0a90 	vmov	r0, s15
    3d4a:	f000 f817 	bl	3d7c <wait_us>
}
    3d4e:	bf00      	nop
    3d50:	b003      	add	sp, #12
    3d52:	f85d fb04 	ldr.w	pc, [sp], #4
    3d56:	bf00      	nop
    3d58:	49742400 	.word	0x49742400

00003d5c <wait_ms>:

void wait_ms(int ms)
{
    3d5c:	b500      	push	{lr}
    3d5e:	b083      	sub	sp, #12
    3d60:	9001      	str	r0, [sp, #4]
    wait_us(ms * 1000);
    3d62:	9b01      	ldr	r3, [sp, #4]
    3d64:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    3d68:	fb02 f303 	mul.w	r3, r2, r3
    3d6c:	4618      	mov	r0, r3
    3d6e:	f000 f805 	bl	3d7c <wait_us>
}
    3d72:	bf00      	nop
    3d74:	b003      	add	sp, #12
    3d76:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00003d7c <wait_us>:

void wait_us(int us)
{
    3d7c:	b500      	push	{lr}
    3d7e:	b087      	sub	sp, #28
    3d80:	9001      	str	r0, [sp, #4]
    const ticker_data_t *const ticker = get_us_ticker_data();
    3d82:	f7fe fcbb 	bl	26fc <get_us_ticker_data>
    3d86:	9005      	str	r0, [sp, #20]

    uint32_t start = ticker_read(ticker);
    3d88:	9805      	ldr	r0, [sp, #20]
    3d8a:	f7fe fc97 	bl	26bc <ticker_read>
    3d8e:	9004      	str	r0, [sp, #16]
    // Use the RTOS to wait for millisecond delays if possible
    int ms = us / 1000;
    3d90:	9b01      	ldr	r3, [sp, #4]
    3d92:	4a17      	ldr	r2, [pc, #92]	; (3df0 <wait_us+0x74>)
    3d94:	fb82 1203 	smull	r1, r2, r2, r3
    3d98:	1192      	asrs	r2, r2, #6
    3d9a:	17db      	asrs	r3, r3, #31
    3d9c:	1ad3      	subs	r3, r2, r3
    3d9e:	9303      	str	r3, [sp, #12]
    if ((ms > 0) && core_util_are_interrupts_enabled()) {
    3da0:	9b03      	ldr	r3, [sp, #12]
    3da2:	2b00      	cmp	r3, #0
    3da4:	dd06      	ble.n	3db4 <wait_us+0x38>
    3da6:	f7fe fee7 	bl	2b78 <core_util_are_interrupts_enabled>
    3daa:	4603      	mov	r3, r0
    3dac:	2b00      	cmp	r3, #0
    3dae:	d001      	beq.n	3db4 <wait_us+0x38>
    3db0:	2301      	movs	r3, #1
    3db2:	e000      	b.n	3db6 <wait_us+0x3a>
    3db4:	2300      	movs	r3, #0
    3db6:	2b00      	cmp	r3, #0
    3db8:	d007      	beq.n	3dca <wait_us+0x4e>
        sleep_manager_lock_deep_sleep();
    3dba:	f7fe f85f 	bl	1e7c <sleep_manager_lock_deep_sleep_internal>
        Thread::wait((uint32_t)ms);
    3dbe:	9b03      	ldr	r3, [sp, #12]
    3dc0:	4618      	mov	r0, r3
    3dc2:	f004 f8a9 	bl	7f18 <_ZN4rtos6Thread4waitEm>
        sleep_manager_unlock_deep_sleep();
    3dc6:	f7fe f87f 	bl	1ec8 <sleep_manager_unlock_deep_sleep_internal>
    }
    // Use busy waiting for sub-millisecond delays, or for the whole
    // interval if interrupts are not enabled
    while ((ticker_read(ticker) - start) < (uint32_t)us);
    3dca:	9805      	ldr	r0, [sp, #20]
    3dcc:	f7fe fc76 	bl	26bc <ticker_read>
    3dd0:	4602      	mov	r2, r0
    3dd2:	9b04      	ldr	r3, [sp, #16]
    3dd4:	1ad2      	subs	r2, r2, r3
    3dd6:	9b01      	ldr	r3, [sp, #4]
    3dd8:	429a      	cmp	r2, r3
    3dda:	bf34      	ite	cc
    3ddc:	2301      	movcc	r3, #1
    3dde:	2300      	movcs	r3, #0
    3de0:	b2db      	uxtb	r3, r3
    3de2:	2b00      	cmp	r3, #0
    3de4:	d000      	beq.n	3de8 <wait_us+0x6c>
    3de6:	e7f0      	b.n	3dca <wait_us+0x4e>
}
    3de8:	bf00      	nop
    3dea:	b007      	add	sp, #28
    3dec:	f85d fb04 	ldr.w	pc, [sp], #4
    3df0:	10624dd3 	.word	0x10624dd3

00003df4 <_ZN4rtos5MutexC1Ev>:
#include "mbed_error.h"
#include "mbed_assert.h"

namespace rtos {

Mutex::Mutex(): _count(0)
    3df4:	b500      	push	{lr}
    3df6:	b083      	sub	sp, #12
    3df8:	9001      	str	r0, [sp, #4]
    3dfa:	9801      	ldr	r0, [sp, #4]
    3dfc:	f000 f870 	bl	3ee0 <_ZN4mbed11NonCopyableIN4rtos5MutexEEC1Ev>
    3e00:	9b01      	ldr	r3, [sp, #4]
    3e02:	2200      	movs	r2, #0
    3e04:	621a      	str	r2, [r3, #32]
{
    constructor();
    3e06:	2100      	movs	r1, #0
    3e08:	9801      	ldr	r0, [sp, #4]
    3e0a:	f000 f805 	bl	3e18 <_ZN4rtos5Mutex11constructorEPKc>
}
    3e0e:	9b01      	ldr	r3, [sp, #4]
    3e10:	4618      	mov	r0, r3
    3e12:	b003      	add	sp, #12
    3e14:	f85d fb04 	ldr.w	pc, [sp], #4

00003e18 <_ZN4rtos5Mutex11constructorEPKc>:
{
    constructor(name);
}

void Mutex::constructor(const char *name)
{
    3e18:	b500      	push	{lr}
    3e1a:	b087      	sub	sp, #28
    3e1c:	9001      	str	r0, [sp, #4]
    3e1e:	9100      	str	r1, [sp, #0]
    memset(&_obj_mem, 0, sizeof(_obj_mem));
    3e20:	9b01      	ldr	r3, [sp, #4]
    3e22:	3304      	adds	r3, #4
    3e24:	221c      	movs	r2, #28
    3e26:	2100      	movs	r1, #0
    3e28:	4618      	mov	r0, r3
    3e2a:	f007 fb3b 	bl	b4a4 <memset>
    osMutexAttr_t attr = { 0 };
    3e2e:	ab02      	add	r3, sp, #8
    3e30:	2200      	movs	r2, #0
    3e32:	601a      	str	r2, [r3, #0]
    3e34:	605a      	str	r2, [r3, #4]
    3e36:	609a      	str	r2, [r3, #8]
    3e38:	60da      	str	r2, [r3, #12]
    attr.name = name ? name : "aplication_unnamed_mutex";
    3e3a:	9b00      	ldr	r3, [sp, #0]
    3e3c:	2b00      	cmp	r3, #0
    3e3e:	d001      	beq.n	3e44 <_ZN4rtos5Mutex11constructorEPKc+0x2c>
    3e40:	9b00      	ldr	r3, [sp, #0]
    3e42:	e000      	b.n	3e46 <_ZN4rtos5Mutex11constructorEPKc+0x2e>
    3e44:	4b0e      	ldr	r3, [pc, #56]	; (3e80 <_ZN4rtos5Mutex11constructorEPKc+0x68>)
    3e46:	9302      	str	r3, [sp, #8]
    attr.cb_mem = &_obj_mem;
    3e48:	9b01      	ldr	r3, [sp, #4]
    3e4a:	3304      	adds	r3, #4
    3e4c:	9304      	str	r3, [sp, #16]
    attr.cb_size = sizeof(_obj_mem);
    3e4e:	231c      	movs	r3, #28
    3e50:	9305      	str	r3, [sp, #20]
    attr.attr_bits = osMutexRecursive | osMutexPrioInherit | osMutexRobust;
    3e52:	230b      	movs	r3, #11
    3e54:	9303      	str	r3, [sp, #12]
    _id = osMutexNew(&attr);
    3e56:	ab02      	add	r3, sp, #8
    3e58:	4618      	mov	r0, r3
    3e5a:	f002 fb71 	bl	6540 <osMutexNew>
    3e5e:	4602      	mov	r2, r0
    3e60:	9b01      	ldr	r3, [sp, #4]
    3e62:	601a      	str	r2, [r3, #0]
    MBED_ASSERT(_id);
    3e64:	9b01      	ldr	r3, [sp, #4]
    3e66:	681b      	ldr	r3, [r3, #0]
    3e68:	2b00      	cmp	r3, #0
    3e6a:	d104      	bne.n	3e76 <_ZN4rtos5Mutex11constructorEPKc+0x5e>
    3e6c:	2232      	movs	r2, #50	; 0x32
    3e6e:	4905      	ldr	r1, [pc, #20]	; (3e84 <_ZN4rtos5Mutex11constructorEPKc+0x6c>)
    3e70:	4805      	ldr	r0, [pc, #20]	; (3e88 <_ZN4rtos5Mutex11constructorEPKc+0x70>)
    3e72:	f7fe fdcf 	bl	2a14 <mbed_assert_internal>
}
    3e76:	bf00      	nop
    3e78:	b007      	add	sp, #28
    3e7a:	f85d fb04 	ldr.w	pc, [sp], #4
    3e7e:	bf00      	nop
    3e80:	00010ff0 	.word	0x00010ff0
    3e84:	0001100c 	.word	0x0001100c
    3e88:	00011028 	.word	0x00011028

00003e8c <_ZN4rtos5Mutex4lockEm>:

osStatus Mutex::lock(uint32_t millisec) {
    3e8c:	b500      	push	{lr}
    3e8e:	b085      	sub	sp, #20
    3e90:	9001      	str	r0, [sp, #4]
    3e92:	9100      	str	r1, [sp, #0]
    osStatus status = osMutexAcquire(_id, millisec);
    3e94:	9b01      	ldr	r3, [sp, #4]
    3e96:	681b      	ldr	r3, [r3, #0]
    3e98:	9900      	ldr	r1, [sp, #0]
    3e9a:	4618      	mov	r0, r3
    3e9c:	f002 fb78 	bl	6590 <osMutexAcquire>
    3ea0:	9003      	str	r0, [sp, #12]
    if (osOK == status) {
    3ea2:	9b03      	ldr	r3, [sp, #12]
    3ea4:	2b00      	cmp	r3, #0
    3ea6:	d104      	bne.n	3eb2 <_ZN4rtos5Mutex4lockEm+0x26>
        _count++;
    3ea8:	9b01      	ldr	r3, [sp, #4]
    3eaa:	6a1b      	ldr	r3, [r3, #32]
    3eac:	1c5a      	adds	r2, r3, #1
    3eae:	9b01      	ldr	r3, [sp, #4]
    3eb0:	621a      	str	r2, [r3, #32]
    }
    return status;
    3eb2:	9b03      	ldr	r3, [sp, #12]
}
    3eb4:	4618      	mov	r0, r3
    3eb6:	b005      	add	sp, #20
    3eb8:	f85d fb04 	ldr.w	pc, [sp], #4

00003ebc <_ZN4rtos5Mutex6unlockEv>:
    } else {
        return trylock_for(millisec - now);
    }
}

osStatus Mutex::unlock() {
    3ebc:	b500      	push	{lr}
    3ebe:	b083      	sub	sp, #12
    3ec0:	9001      	str	r0, [sp, #4]
    _count--;
    3ec2:	9b01      	ldr	r3, [sp, #4]
    3ec4:	6a1b      	ldr	r3, [r3, #32]
    3ec6:	1e5a      	subs	r2, r3, #1
    3ec8:	9b01      	ldr	r3, [sp, #4]
    3eca:	621a      	str	r2, [r3, #32]
    return osMutexRelease(_id);
    3ecc:	9b01      	ldr	r3, [sp, #4]
    3ece:	681b      	ldr	r3, [r3, #0]
    3ed0:	4618      	mov	r0, r3
    3ed2:	f002 fb8b 	bl	65ec <osMutexRelease>
    3ed6:	4603      	mov	r3, r0
}
    3ed8:	4618      	mov	r0, r3
    3eda:	b003      	add	sp, #12
    3edc:	f85d fb04 	ldr.w	pc, [sp], #4

00003ee0 <_ZN4mbed11NonCopyableIN4rtos5MutexEEC1Ev>:
    3ee0:	b082      	sub	sp, #8
    3ee2:	9001      	str	r0, [sp, #4]
    3ee4:	9b01      	ldr	r3, [sp, #4]
    3ee6:	4618      	mov	r0, r3
    3ee8:	b002      	add	sp, #8
    3eea:	4770      	bx	lr

00003eec <mbed_fault_handler>:
mbed_fault_context_t mbed_fault_context;

//This is a handler function called from Fault handler to print the error information out.
//This runs in fault context and uses special functions(defined in mbed_rtx_fault_handler.c) to print the information without using C-lib support.
void mbed_fault_handler (uint32_t fault_type, void *mbed_fault_context_in, void *osRtxInfoIn)
{
    3eec:	b500      	push	{lr}
    3eee:	b089      	sub	sp, #36	; 0x24
    3ef0:	9005      	str	r0, [sp, #20]
    3ef2:	9104      	str	r1, [sp, #16]
    3ef4:	9203      	str	r2, [sp, #12]
    mbed_error_status_t faultStatus = MBED_SUCCESS;
    3ef6:	2300      	movs	r3, #0
    3ef8:	9307      	str	r3, [sp, #28]
    
    mbed_error_printf("\n++ MbedOS Fault Handler ++\n\nFaultType: ");
    3efa:	481b      	ldr	r0, [pc, #108]	; (3f68 <mbed_fault_handler+0x7c>)
    3efc:	f7fe fddf 	bl	2abe <mbed_error_printf>
        
    switch( fault_type ) {
    3f00:	9b05      	ldr	r3, [sp, #20]
    3f02:	2b30      	cmp	r3, #48	; 0x30
    3f04:	d009      	beq.n	3f1a <mbed_fault_handler+0x2e>
    3f06:	2b40      	cmp	r3, #64	; 0x40
    3f08:	d00d      	beq.n	3f26 <mbed_fault_handler+0x3a>
    3f0a:	2b20      	cmp	r3, #32
    3f0c:	d111      	bne.n	3f32 <mbed_fault_handler+0x46>
      case MEMMANAGE_FAULT_EXCEPTION: 
        mbed_error_printf("MemManageFault"); 
    3f0e:	4817      	ldr	r0, [pc, #92]	; (3f6c <mbed_fault_handler+0x80>)
    3f10:	f7fe fdd5 	bl	2abe <mbed_error_printf>
        faultStatus = MBED_ERROR_MEMMANAGE_EXCEPTION;
    3f14:	4b16      	ldr	r3, [pc, #88]	; (3f70 <mbed_fault_handler+0x84>)
    3f16:	9307      	str	r3, [sp, #28]
        break;
    3f18:	e011      	b.n	3f3e <mbed_fault_handler+0x52>
      
      case BUS_FAULT_EXCEPTION: 
        mbed_error_printf("BusFault"); 
    3f1a:	4816      	ldr	r0, [pc, #88]	; (3f74 <mbed_fault_handler+0x88>)
    3f1c:	f7fe fdcf 	bl	2abe <mbed_error_printf>
        faultStatus = MBED_ERROR_BUSFAULT_EXCEPTION;
    3f20:	4b15      	ldr	r3, [pc, #84]	; (3f78 <mbed_fault_handler+0x8c>)
    3f22:	9307      	str	r3, [sp, #28]
        break;
    3f24:	e00b      	b.n	3f3e <mbed_fault_handler+0x52>
      
      case USAGE_FAULT_EXCEPTION: 
        mbed_error_printf("UsageFault"); 
    3f26:	4815      	ldr	r0, [pc, #84]	; (3f7c <mbed_fault_handler+0x90>)
    3f28:	f7fe fdc9 	bl	2abe <mbed_error_printf>
        faultStatus = MBED_ERROR_USAGEFAULT_EXCEPTION;
    3f2c:	4b14      	ldr	r3, [pc, #80]	; (3f80 <mbed_fault_handler+0x94>)
    3f2e:	9307      	str	r3, [sp, #28]
        break;
    3f30:	e005      	b.n	3f3e <mbed_fault_handler+0x52>
      
      //There is no way we can hit this code without getting an exception, so we have the default treated like hardfault
      case HARD_FAULT_EXCEPTION: 
      default:    
        mbed_error_printf("HardFault");
    3f32:	4814      	ldr	r0, [pc, #80]	; (3f84 <mbed_fault_handler+0x98>)
    3f34:	f7fe fdc3 	bl	2abe <mbed_error_printf>
        faultStatus = MBED_ERROR_HARDFAULT_EXCEPTION;      
    3f38:	4b13      	ldr	r3, [pc, #76]	; (3f88 <mbed_fault_handler+0x9c>)
    3f3a:	9307      	str	r3, [sp, #28]
        break;
    3f3c:	bf00      	nop
    }
    mbed_error_printf("\n\nContext:");
    3f3e:	4813      	ldr	r0, [pc, #76]	; (3f8c <mbed_fault_handler+0xa0>)
    3f40:	f7fe fdbd 	bl	2abe <mbed_error_printf>
    print_context_info();
    3f44:	f000 f82a 	bl	3f9c <print_context_info>
    
    mbed_error_printf("\n\n-- MbedOS Fault Handler --\n\n");
    3f48:	4811      	ldr	r0, [pc, #68]	; (3f90 <mbed_fault_handler+0xa4>)
    3f4a:	f7fe fdb8 	bl	2abe <mbed_error_printf>
    
    //Now call mbed_error, to log the error and halt the system
    mbed_error( faultStatus, "Unrecoverable fault excaption.", mbed_fault_context.PC_reg, NULL, 0 );
    3f4e:	4b11      	ldr	r3, [pc, #68]	; (3f94 <mbed_fault_handler+0xa8>)
    3f50:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    3f52:	2300      	movs	r3, #0
    3f54:	9300      	str	r3, [sp, #0]
    3f56:	2300      	movs	r3, #0
    3f58:	490f      	ldr	r1, [pc, #60]	; (3f98 <mbed_fault_handler+0xac>)
    3f5a:	9807      	ldr	r0, [sp, #28]
    3f5c:	f7fe ff3c 	bl	2dd8 <mbed_error>
    
}
    3f60:	bf00      	nop
    3f62:	b009      	add	sp, #36	; 0x24
    3f64:	f85d fb04 	ldr.w	pc, [sp], #4
    3f68:	00011064 	.word	0x00011064
    3f6c:	00011090 	.word	0x00011090
    3f70:	80ff013e 	.word	0x80ff013e
    3f74:	000110a0 	.word	0x000110a0
    3f78:	80ff013f 	.word	0x80ff013f
    3f7c:	000110ac 	.word	0x000110ac
    3f80:	80ff0140 	.word	0x80ff0140
    3f84:	000110b8 	.word	0x000110b8
    3f88:	80ff013d 	.word	0x80ff013d
    3f8c:	000110c4 	.word	0x000110c4
    3f90:	000110d0 	.word	0x000110d0
    3f94:	20001e00 	.word	0x20001e00
    3f98:	000110f0 	.word	0x000110f0

00003f9c <print_context_info>:

MBED_NOINLINE void print_context_info(void)
{
    3f9c:	b530      	push	{r4, r5, lr}
    3f9e:	b087      	sub	sp, #28
    //Context Regs
    for(int i=0;i<13;i++) {
    3fa0:	2300      	movs	r3, #0
    3fa2:	9305      	str	r3, [sp, #20]
    3fa4:	e00c      	b.n	3fc0 <print_context_info+0x24>
        mbed_error_printf("\nR%-4d: %08X", i, ((uint32_t *)&mbed_fault_context)[i]);  
    3fa6:	9b05      	ldr	r3, [sp, #20]
    3fa8:	009b      	lsls	r3, r3, #2
    3faa:	4a44      	ldr	r2, [pc, #272]	; (40bc <print_context_info+0x120>)
    3fac:	4413      	add	r3, r2
    3fae:	681b      	ldr	r3, [r3, #0]
    3fb0:	461a      	mov	r2, r3
    3fb2:	9905      	ldr	r1, [sp, #20]
    3fb4:	4842      	ldr	r0, [pc, #264]	; (40c0 <print_context_info+0x124>)
    3fb6:	f7fe fd82 	bl	2abe <mbed_error_printf>
    for(int i=0;i<13;i++) {
    3fba:	9b05      	ldr	r3, [sp, #20]
    3fbc:	3301      	adds	r3, #1
    3fbe:	9305      	str	r3, [sp, #20]
    3fc0:	9b05      	ldr	r3, [sp, #20]
    3fc2:	2b0c      	cmp	r3, #12
    3fc4:	ddef      	ble.n	3fa6 <print_context_info+0xa>
    }
        
    mbed_error_printf("\nSP   : %08X" 
    3fc6:	4b3d      	ldr	r3, [pc, #244]	; (40bc <print_context_info+0x120>)
    3fc8:	6b58      	ldr	r0, [r3, #52]	; 0x34
    3fca:	4b3c      	ldr	r3, [pc, #240]	; (40bc <print_context_info+0x120>)
    3fcc:	6b9c      	ldr	r4, [r3, #56]	; 0x38
    3fce:	4b3b      	ldr	r3, [pc, #236]	; (40bc <print_context_info+0x120>)
    3fd0:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
    3fd2:	4b3a      	ldr	r3, [pc, #232]	; (40bc <print_context_info+0x120>)
    3fd4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3fd6:	4a39      	ldr	r2, [pc, #228]	; (40bc <print_context_info+0x120>)
    3fd8:	6c52      	ldr	r2, [r2, #68]	; 0x44
    3fda:	4938      	ldr	r1, [pc, #224]	; (40bc <print_context_info+0x120>)
    3fdc:	6c89      	ldr	r1, [r1, #72]	; 0x48
    3fde:	9102      	str	r1, [sp, #8]
    3fe0:	9201      	str	r2, [sp, #4]
    3fe2:	9300      	str	r3, [sp, #0]
    3fe4:	462b      	mov	r3, r5
    3fe6:	4622      	mov	r2, r4
    3fe8:	4601      	mov	r1, r0
    3fea:	4836      	ldr	r0, [pc, #216]	; (40c4 <print_context_info+0x128>)
    3fec:	f7fe fd67 	bl	2abe <mbed_error_printf>
                      "\nPSP  : %08X" 
                      "\nMSP  : %08X", mbed_fault_context.SP_reg, mbed_fault_context.LR_reg, mbed_fault_context.PC_reg, 
                                     mbed_fault_context.xPSR, mbed_fault_context.PSP, mbed_fault_context.MSP );
                       
    //Capture CPUID to get core/cpu info
    mbed_error_printf("\nCPUID: %08X", SCB->CPUID);
    3ff0:	4b35      	ldr	r3, [pc, #212]	; (40c8 <print_context_info+0x12c>)
    3ff2:	681b      	ldr	r3, [r3, #0]
    3ff4:	4619      	mov	r1, r3
    3ff6:	4835      	ldr	r0, [pc, #212]	; (40cc <print_context_info+0x130>)
    3ff8:	f7fe fd61 	bl	2abe <mbed_error_printf>
                    "\nMMFSR: %08X"
                    "\nBFSR : %08X"
                    "\nUFSR : %08X"
                    "\nDFSR : %08X"
                    "\nAFSR : %08X"  ////Split/Capture CFSR into MMFSR, BFSR, UFSR
                    ,SCB->HFSR, (0xFF & SCB->CFSR), ((0xFF00 & SCB->CFSR) >> 8), ((0xFFFF0000 & SCB->CFSR) >> 16), SCB->DFSR, SCB->AFSR ); 
    3ffc:	4b32      	ldr	r3, [pc, #200]	; (40c8 <print_context_info+0x12c>)
    mbed_error_printf("\nHFSR : %08X"
    3ffe:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
                    ,SCB->HFSR, (0xFF & SCB->CFSR), ((0xFF00 & SCB->CFSR) >> 8), ((0xFFFF0000 & SCB->CFSR) >> 16), SCB->DFSR, SCB->AFSR ); 
    4000:	4b31      	ldr	r3, [pc, #196]	; (40c8 <print_context_info+0x12c>)
    4002:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    mbed_error_printf("\nHFSR : %08X"
    4004:	b2dc      	uxtb	r4, r3
                    ,SCB->HFSR, (0xFF & SCB->CFSR), ((0xFF00 & SCB->CFSR) >> 8), ((0xFFFF0000 & SCB->CFSR) >> 16), SCB->DFSR, SCB->AFSR ); 
    4006:	4b30      	ldr	r3, [pc, #192]	; (40c8 <print_context_info+0x12c>)
    4008:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    400a:	0a1b      	lsrs	r3, r3, #8
    mbed_error_printf("\nHFSR : %08X"
    400c:	b2dd      	uxtb	r5, r3
                    ,SCB->HFSR, (0xFF & SCB->CFSR), ((0xFF00 & SCB->CFSR) >> 8), ((0xFFFF0000 & SCB->CFSR) >> 16), SCB->DFSR, SCB->AFSR ); 
    400e:	4b2e      	ldr	r3, [pc, #184]	; (40c8 <print_context_info+0x12c>)
    4010:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4012:	0c1b      	lsrs	r3, r3, #16
    mbed_error_printf("\nHFSR : %08X"
    4014:	b29b      	uxth	r3, r3
                    ,SCB->HFSR, (0xFF & SCB->CFSR), ((0xFF00 & SCB->CFSR) >> 8), ((0xFFFF0000 & SCB->CFSR) >> 16), SCB->DFSR, SCB->AFSR ); 
    4016:	4a2c      	ldr	r2, [pc, #176]	; (40c8 <print_context_info+0x12c>)
    mbed_error_printf("\nHFSR : %08X"
    4018:	6b12      	ldr	r2, [r2, #48]	; 0x30
                    ,SCB->HFSR, (0xFF & SCB->CFSR), ((0xFF00 & SCB->CFSR) >> 8), ((0xFFFF0000 & SCB->CFSR) >> 16), SCB->DFSR, SCB->AFSR ); 
    401a:	492b      	ldr	r1, [pc, #172]	; (40c8 <print_context_info+0x12c>)
    mbed_error_printf("\nHFSR : %08X"
    401c:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
    401e:	9102      	str	r1, [sp, #8]
    4020:	9201      	str	r2, [sp, #4]
    4022:	9300      	str	r3, [sp, #0]
    4024:	462b      	mov	r3, r5
    4026:	4622      	mov	r2, r4
    4028:	4601      	mov	r1, r0
    402a:	4829      	ldr	r0, [pc, #164]	; (40d0 <print_context_info+0x134>)
    402c:	f7fe fd47 	bl	2abe <mbed_error_printf>
    
    //Print MMFAR only if its valid as indicated by MMFSR
    if ((0xFF & SCB->CFSR) & 0x80) {
    4030:	4b25      	ldr	r3, [pc, #148]	; (40c8 <print_context_info+0x12c>)
    4032:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4034:	f003 0380 	and.w	r3, r3, #128	; 0x80
    4038:	2b00      	cmp	r3, #0
    403a:	d005      	beq.n	4048 <print_context_info+0xac>
        mbed_error_printf("\nMMFAR: %08X",SCB->MMFAR); 
    403c:	4b22      	ldr	r3, [pc, #136]	; (40c8 <print_context_info+0x12c>)
    403e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    4040:	4619      	mov	r1, r3
    4042:	4824      	ldr	r0, [pc, #144]	; (40d4 <print_context_info+0x138>)
    4044:	f7fe fd3b 	bl	2abe <mbed_error_printf>
    }
    //Print BFAR only if its valid as indicated by BFSR
    if (((0xFF00 & SCB->CFSR) >> 8) & 0x80) {
    4048:	4b1f      	ldr	r3, [pc, #124]	; (40c8 <print_context_info+0x12c>)
    404a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    404c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
    4050:	2b00      	cmp	r3, #0
    4052:	d005      	beq.n	4060 <print_context_info+0xc4>
        mbed_error_printf("\nBFAR : %08X",SCB->BFAR); 
    4054:	4b1c      	ldr	r3, [pc, #112]	; (40c8 <print_context_info+0x12c>)
    4056:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    4058:	4619      	mov	r1, r3
    405a:	481f      	ldr	r0, [pc, #124]	; (40d8 <print_context_info+0x13c>)
    405c:	f7fe fd2f 	bl	2abe <mbed_error_printf>
    }
#endif
    
    //Print Mode
    if (mbed_fault_context.EXC_RETURN & 0x8) {
    4060:	4b16      	ldr	r3, [pc, #88]	; (40bc <print_context_info+0x120>)
    4062:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    4064:	f003 0308 	and.w	r3, r3, #8
    4068:	2b00      	cmp	r3, #0
    406a:	d010      	beq.n	408e <print_context_info+0xf2>
        mbed_error_printf("\nMode : Thread");
    406c:	481b      	ldr	r0, [pc, #108]	; (40dc <print_context_info+0x140>)
    406e:	f7fe fd26 	bl	2abe <mbed_error_printf>
        //Print Priv level in Thread mode - We capture CONTROL reg which reflects the privilege.
        //Note that the CONTROL register captured still reflects the privilege status of the 
        //thread mode eventhough we are in Handler mode by the time we capture it.
        if(mbed_fault_context.CONTROL & 0x1) {
    4072:	4b12      	ldr	r3, [pc, #72]	; (40bc <print_context_info+0x120>)
    4074:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    4076:	f003 0301 	and.w	r3, r3, #1
    407a:	2b00      	cmp	r3, #0
    407c:	d003      	beq.n	4086 <print_context_info+0xea>
            mbed_error_printf("\nPriv : User"); 
    407e:	4818      	ldr	r0, [pc, #96]	; (40e0 <print_context_info+0x144>)
    4080:	f7fe fd1d 	bl	2abe <mbed_error_printf>
    4084:	e009      	b.n	409a <print_context_info+0xfe>
        } else {
            mbed_error_printf("\nPriv : Privileged"); 
    4086:	4817      	ldr	r0, [pc, #92]	; (40e4 <print_context_info+0x148>)
    4088:	f7fe fd19 	bl	2abe <mbed_error_printf>
    408c:	e005      	b.n	409a <print_context_info+0xfe>
        }        
    } else {
        mbed_error_printf("\nMode : Handler"); 
    408e:	4816      	ldr	r0, [pc, #88]	; (40e8 <print_context_info+0x14c>)
    4090:	f7fe fd15 	bl	2abe <mbed_error_printf>
        mbed_error_printf("\nPriv : Privileged"); 
    4094:	4813      	ldr	r0, [pc, #76]	; (40e4 <print_context_info+0x148>)
    4096:	f7fe fd12 	bl	2abe <mbed_error_printf>
    }
    //Print Return Stack
    if (mbed_fault_context.EXC_RETURN & 0x4) {
    409a:	4b08      	ldr	r3, [pc, #32]	; (40bc <print_context_info+0x120>)
    409c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    409e:	f003 0304 	and.w	r3, r3, #4
    40a2:	2b00      	cmp	r3, #0
    40a4:	d003      	beq.n	40ae <print_context_info+0x112>
        mbed_error_printf("\nStack: PSP"); 
    40a6:	4811      	ldr	r0, [pc, #68]	; (40ec <print_context_info+0x150>)
    40a8:	f7fe fd09 	bl	2abe <mbed_error_printf>
    } else {
        mbed_error_printf("\nStack: MSP"); 
    }
}
    40ac:	e002      	b.n	40b4 <print_context_info+0x118>
        mbed_error_printf("\nStack: MSP"); 
    40ae:	4810      	ldr	r0, [pc, #64]	; (40f0 <print_context_info+0x154>)
    40b0:	f7fe fd05 	bl	2abe <mbed_error_printf>
}
    40b4:	bf00      	nop
    40b6:	b007      	add	sp, #28
    40b8:	bd30      	pop	{r4, r5, pc}
    40ba:	bf00      	nop
    40bc:	20001e00 	.word	0x20001e00
    40c0:	00011110 	.word	0x00011110
    40c4:	00011120 	.word	0x00011120
    40c8:	e000ed00 	.word	0xe000ed00
    40cc:	0001116c 	.word	0x0001116c
    40d0:	0001117c 	.word	0x0001117c
    40d4:	000111c8 	.word	0x000111c8
    40d8:	000111d8 	.word	0x000111d8
    40dc:	000111e8 	.word	0x000111e8
    40e0:	000111f8 	.word	0x000111f8
    40e4:	00011208 	.word	0x00011208
    40e8:	0001121c 	.word	0x0001121c
    40ec:	0001122c 	.word	0x0001122c
    40f0:	00011238 	.word	0x00011238

000040f4 <mbed_set_stack_heap>:
 * -mbed_heap_start
 * -mbed_heap_size
 * -mbed_stack_isr_start
 * -mbed_stack_isr_size
 */
void mbed_set_stack_heap(void) {
    40f4:	b082      	sub	sp, #8

    unsigned char *free_start = HEAP_START;
    40f6:	4b13      	ldr	r3, [pc, #76]	; (4144 <mbed_set_stack_heap+0x50>)
    40f8:	9301      	str	r3, [sp, #4]
    uint32_t free_size = HEAP_SIZE;
    40fa:	4b12      	ldr	r3, [pc, #72]	; (4144 <mbed_set_stack_heap+0x50>)
    40fc:	f1c3 5300 	rsb	r3, r3, #536870912	; 0x20000000
    4100:	f503 3340 	add.w	r3, r3, #196608	; 0x30000
    4104:	9300      	str	r3, [sp, #0]
    /* Interrupt stack explicitly specified */
    mbed_stack_isr_size = ISR_STACK_SIZE;
    mbed_stack_isr_start = ISR_STACK_START;
#else
    /* Interrupt stack -  reserve space at the end of the free block */
    mbed_stack_isr_size = ISR_STACK_SIZE < free_size ? ISR_STACK_SIZE : free_size;
    4106:	9b00      	ldr	r3, [sp, #0]
    4108:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    410c:	bf28      	it	cs
    410e:	f44f 6380 	movcs.w	r3, #1024	; 0x400
    4112:	4a0d      	ldr	r2, [pc, #52]	; (4148 <mbed_set_stack_heap+0x54>)
    4114:	6013      	str	r3, [r2, #0]
    mbed_stack_isr_start = free_start + free_size - mbed_stack_isr_size;
    4116:	4b0c      	ldr	r3, [pc, #48]	; (4148 <mbed_set_stack_heap+0x54>)
    4118:	681b      	ldr	r3, [r3, #0]
    411a:	9a00      	ldr	r2, [sp, #0]
    411c:	1ad3      	subs	r3, r2, r3
    411e:	9a01      	ldr	r2, [sp, #4]
    4120:	4413      	add	r3, r2
    4122:	4a0a      	ldr	r2, [pc, #40]	; (414c <mbed_set_stack_heap+0x58>)
    4124:	6013      	str	r3, [r2, #0]
    free_size -= mbed_stack_isr_size;
    4126:	4b08      	ldr	r3, [pc, #32]	; (4148 <mbed_set_stack_heap+0x54>)
    4128:	681b      	ldr	r3, [r3, #0]
    412a:	9a00      	ldr	r2, [sp, #0]
    412c:	1ad3      	subs	r3, r2, r3
    412e:	9300      	str	r3, [sp, #0]
#endif

    /* Heap - everything else */
    mbed_heap_size = free_size;
    4130:	4a07      	ldr	r2, [pc, #28]	; (4150 <mbed_set_stack_heap+0x5c>)
    4132:	9b00      	ldr	r3, [sp, #0]
    4134:	6013      	str	r3, [r2, #0]
    mbed_heap_start = free_start;
    4136:	4a07      	ldr	r2, [pc, #28]	; (4154 <mbed_set_stack_heap+0x60>)
    4138:	9b01      	ldr	r3, [sp, #4]
    413a:	6013      	str	r3, [r2, #0]
}
    413c:	bf00      	nop
    413e:	b002      	add	sp, #8
    4140:	4770      	bx	lr
    4142:	bf00      	nop
    4144:	20003050 	.word	0x20003050
    4148:	20000e2c 	.word	0x20000e2c
    414c:	20000e28 	.word	0x20000e28
    4150:	20000d9c 	.word	0x20000d9c
    4154:	20000d98 	.word	0x20000d98

00004158 <mbed_cpy_nvic>:

static void mbed_cpy_nvic(void)
{
    4158:	b084      	sub	sp, #16
    VTOR register and for A9 for which CMSIS doesn't define NVIC_SetVector; in both cases target code is
    responsible for correctly handling the vectors.
    */
#if !defined(__CORTEX_M0) && !defined(__CORTEX_A9)
#ifdef NVIC_RAM_VECTOR_ADDRESS
    uint32_t *old_vectors = (uint32_t *)SCB->VTOR;
    415a:	4b0f      	ldr	r3, [pc, #60]	; (4198 <mbed_cpy_nvic+0x40>)
    415c:	689b      	ldr	r3, [r3, #8]
    415e:	9302      	str	r3, [sp, #8]
    uint32_t *vectors = (uint32_t*)NVIC_RAM_VECTOR_ADDRESS;
    4160:	4b0e      	ldr	r3, [pc, #56]	; (419c <mbed_cpy_nvic+0x44>)
    4162:	9301      	str	r3, [sp, #4]
    for (int i = 0; i < NVIC_NUM_VECTORS; i++) {
    4164:	2300      	movs	r3, #0
    4166:	9303      	str	r3, [sp, #12]
    4168:	e00c      	b.n	4184 <mbed_cpy_nvic+0x2c>
        vectors[i] = old_vectors[i];
    416a:	9b03      	ldr	r3, [sp, #12]
    416c:	009b      	lsls	r3, r3, #2
    416e:	9a01      	ldr	r2, [sp, #4]
    4170:	4413      	add	r3, r2
    4172:	9a03      	ldr	r2, [sp, #12]
    4174:	0092      	lsls	r2, r2, #2
    4176:	9902      	ldr	r1, [sp, #8]
    4178:	440a      	add	r2, r1
    417a:	6812      	ldr	r2, [r2, #0]
    417c:	601a      	str	r2, [r3, #0]
    for (int i = 0; i < NVIC_NUM_VECTORS; i++) {
    417e:	9b03      	ldr	r3, [sp, #12]
    4180:	3301      	adds	r3, #1
    4182:	9303      	str	r3, [sp, #12]
    4184:	9b03      	ldr	r3, [sp, #12]
    4186:	2b65      	cmp	r3, #101	; 0x65
    4188:	ddef      	ble.n	416a <mbed_cpy_nvic+0x12>
    }
    SCB->VTOR = (uint32_t)NVIC_RAM_VECTOR_ADDRESS;
    418a:	4b03      	ldr	r3, [pc, #12]	; (4198 <mbed_cpy_nvic+0x40>)
    418c:	4a03      	ldr	r2, [pc, #12]	; (419c <mbed_cpy_nvic+0x44>)
    418e:	609a      	str	r2, [r3, #8]
#endif /* NVIC_RAM_VECTOR_ADDRESS */
#endif /* !defined(__CORTEX_M0) && !defined(__CORTEX_A9) */
}
    4190:	bf00      	nop
    4192:	b004      	add	sp, #16
    4194:	4770      	bx	lr
    4196:	bf00      	nop
    4198:	e000ed00 	.word	0xe000ed00
    419c:	1fff0000 	.word	0x1fff0000

000041a0 <mbed_main>:
 * mbed_main(), it is not meant for user code, but for the SDK itself to perform
 * initializations before main() is called.
 */
WEAK void mbed_main(void) {

}
    41a0:	bf00      	nop
    41a2:	4770      	bx	lr

000041a4 <mbed_start_main>:
void mbed_sdk_init(void);
WEAK void mbed_sdk_init(void) {
}

void mbed_start_main(void)
{
    41a4:	b500      	push	{lr}
    41a6:	b085      	sub	sp, #20
    _main_thread_attr.stack_mem = _main_stack;
    41a8:	4b14      	ldr	r3, [pc, #80]	; (41fc <mbed_start_main+0x58>)
    41aa:	4a15      	ldr	r2, [pc, #84]	; (4200 <mbed_start_main+0x5c>)
    41ac:	611a      	str	r2, [r3, #16]
    _main_thread_attr.stack_size = sizeof(_main_stack);
    41ae:	4b13      	ldr	r3, [pc, #76]	; (41fc <mbed_start_main+0x58>)
    41b0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    41b4:	615a      	str	r2, [r3, #20]
    _main_thread_attr.cb_size = sizeof(_main_obj);
    41b6:	4b11      	ldr	r3, [pc, #68]	; (41fc <mbed_start_main+0x58>)
    41b8:	2248      	movs	r2, #72	; 0x48
    41ba:	60da      	str	r2, [r3, #12]
    _main_thread_attr.cb_mem = &_main_obj;
    41bc:	4b0f      	ldr	r3, [pc, #60]	; (41fc <mbed_start_main+0x58>)
    41be:	4a11      	ldr	r2, [pc, #68]	; (4204 <mbed_start_main+0x60>)
    41c0:	609a      	str	r2, [r3, #8]
    _main_thread_attr.priority = osPriorityNormal;
    41c2:	4b0e      	ldr	r3, [pc, #56]	; (41fc <mbed_start_main+0x58>)
    41c4:	2218      	movs	r2, #24
    41c6:	619a      	str	r2, [r3, #24]
    _main_thread_attr.name = "main_thread";
    41c8:	4b0c      	ldr	r3, [pc, #48]	; (41fc <mbed_start_main+0x58>)
    41ca:	4a0f      	ldr	r2, [pc, #60]	; (4208 <mbed_start_main+0x64>)
    41cc:	601a      	str	r2, [r3, #0]
    osThreadId_t result = osThreadNew((osThreadFunc_t)pre_main, NULL, &_main_thread_attr);
    41ce:	4a0b      	ldr	r2, [pc, #44]	; (41fc <mbed_start_main+0x58>)
    41d0:	2100      	movs	r1, #0
    41d2:	480e      	ldr	r0, [pc, #56]	; (420c <mbed_start_main+0x68>)
    41d4:	f003 fc5c 	bl	7a90 <osThreadNew>
    41d8:	9003      	str	r0, [sp, #12]
    if ((void *)result == NULL) {
    41da:	9b03      	ldr	r3, [sp, #12]
    41dc:	2b00      	cmp	r3, #0
    41de:	d107      	bne.n	41f0 <mbed_start_main+0x4c>
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_INITIALIZATION_FAILED), "Pre main thread not created", &_main_thread_attr);
    41e0:	4a06      	ldr	r2, [pc, #24]	; (41fc <mbed_start_main+0x58>)
    41e2:	2300      	movs	r3, #0
    41e4:	9300      	str	r3, [sp, #0]
    41e6:	2300      	movs	r3, #0
    41e8:	4909      	ldr	r1, [pc, #36]	; (4210 <mbed_start_main+0x6c>)
    41ea:	480a      	ldr	r0, [pc, #40]	; (4214 <mbed_start_main+0x70>)
    41ec:	f7fe fdf4 	bl	2dd8 <mbed_error>
    }

    osKernelStart();
    41f0:	f000 fe3c 	bl	4e6c <osKernelStart>
}
    41f4:	bf00      	nop
    41f6:	b005      	add	sp, #20
    41f8:	f85d fb04 	ldr.w	pc, [sp], #4
    41fc:	20001ea8 	.word	0x20001ea8
    4200:	20001f58 	.word	0x20001f58
    4204:	20001f0c 	.word	0x20001f0c
    4208:	00011244 	.word	0x00011244
    420c:	00004229 	.word	0x00004229
    4210:	00011250 	.word	0x00011250
    4214:	8001011d 	.word	0x8001011d

00004218 <__wrap_main>:

#ifdef  FEATURE_UVISOR
#include "uvisor-lib/uvisor-lib.h"
#endif/* FEATURE_UVISOR */

int __wrap_main(void) {
    4218:	b508      	push	{r3, lr}
    mbed_main();
    421a:	f7ff ffc1 	bl	41a0 <mbed_main>
    return __real_main();
    421e:	f7fd fb0d 	bl	183c <main>
    4222:	4603      	mov	r3, r0
}
    4224:	4618      	mov	r0, r3
    4226:	bd08      	pop	{r3, pc}

00004228 <pre_main>:

void pre_main(void)
{
    4228:	b508      	push	{r3, lr}
    singleton_mutex_attr.name = "singleton_mutex";
    422a:	4b1f      	ldr	r3, [pc, #124]	; (42a8 <pre_main+0x80>)
    422c:	4a1f      	ldr	r2, [pc, #124]	; (42ac <pre_main+0x84>)
    422e:	601a      	str	r2, [r3, #0]
    singleton_mutex_attr.attr_bits = osMutexRecursive | osMutexPrioInherit | osMutexRobust;
    4230:	4b1d      	ldr	r3, [pc, #116]	; (42a8 <pre_main+0x80>)
    4232:	220b      	movs	r2, #11
    4234:	605a      	str	r2, [r3, #4]
    singleton_mutex_attr.cb_size = sizeof(singleton_mutex_obj);
    4236:	4b1c      	ldr	r3, [pc, #112]	; (42a8 <pre_main+0x80>)
    4238:	221c      	movs	r2, #28
    423a:	60da      	str	r2, [r3, #12]
    singleton_mutex_attr.cb_mem = &singleton_mutex_obj;
    423c:	4b1a      	ldr	r3, [pc, #104]	; (42a8 <pre_main+0x80>)
    423e:	4a1c      	ldr	r2, [pc, #112]	; (42b0 <pre_main+0x88>)
    4240:	609a      	str	r2, [r3, #8]
    singleton_mutex_id = osMutexNew(&singleton_mutex_attr);
    4242:	4819      	ldr	r0, [pc, #100]	; (42a8 <pre_main+0x80>)
    4244:	f002 f97c 	bl	6540 <osMutexNew>
    4248:	4602      	mov	r2, r0
    424a:	4b1a      	ldr	r3, [pc, #104]	; (42b4 <pre_main+0x8c>)
    424c:	601a      	str	r2, [r3, #0]

    malloc_mutex_attr.name = "malloc_mutex";
    424e:	4b1a      	ldr	r3, [pc, #104]	; (42b8 <pre_main+0x90>)
    4250:	4a1a      	ldr	r2, [pc, #104]	; (42bc <pre_main+0x94>)
    4252:	601a      	str	r2, [r3, #0]
    malloc_mutex_attr.attr_bits = osMutexRecursive | osMutexPrioInherit | osMutexRobust;
    4254:	4b18      	ldr	r3, [pc, #96]	; (42b8 <pre_main+0x90>)
    4256:	220b      	movs	r2, #11
    4258:	605a      	str	r2, [r3, #4]
    malloc_mutex_attr.cb_size = sizeof(malloc_mutex_obj);
    425a:	4b17      	ldr	r3, [pc, #92]	; (42b8 <pre_main+0x90>)
    425c:	221c      	movs	r2, #28
    425e:	60da      	str	r2, [r3, #12]
    malloc_mutex_attr.cb_mem = &malloc_mutex_obj;
    4260:	4b15      	ldr	r3, [pc, #84]	; (42b8 <pre_main+0x90>)
    4262:	4a17      	ldr	r2, [pc, #92]	; (42c0 <pre_main+0x98>)
    4264:	609a      	str	r2, [r3, #8]
    malloc_mutex_id = osMutexNew(&malloc_mutex_attr);
    4266:	4814      	ldr	r0, [pc, #80]	; (42b8 <pre_main+0x90>)
    4268:	f002 f96a 	bl	6540 <osMutexNew>
    426c:	4602      	mov	r2, r0
    426e:	4b15      	ldr	r3, [pc, #84]	; (42c4 <pre_main+0x9c>)
    4270:	601a      	str	r2, [r3, #0]

    env_mutex_attr.name = "env_mutex";
    4272:	4b15      	ldr	r3, [pc, #84]	; (42c8 <pre_main+0xa0>)
    4274:	4a15      	ldr	r2, [pc, #84]	; (42cc <pre_main+0xa4>)
    4276:	601a      	str	r2, [r3, #0]
    env_mutex_attr.attr_bits = osMutexRecursive | osMutexPrioInherit | osMutexRobust;
    4278:	4b13      	ldr	r3, [pc, #76]	; (42c8 <pre_main+0xa0>)
    427a:	220b      	movs	r2, #11
    427c:	605a      	str	r2, [r3, #4]
    env_mutex_attr.cb_size = sizeof(env_mutex_obj);
    427e:	4b12      	ldr	r3, [pc, #72]	; (42c8 <pre_main+0xa0>)
    4280:	221c      	movs	r2, #28
    4282:	60da      	str	r2, [r3, #12]
    env_mutex_attr.cb_mem = &env_mutex_obj;
    4284:	4b10      	ldr	r3, [pc, #64]	; (42c8 <pre_main+0xa0>)
    4286:	4a12      	ldr	r2, [pc, #72]	; (42d0 <pre_main+0xa8>)
    4288:	609a      	str	r2, [r3, #8]
    env_mutex_id = osMutexNew(&env_mutex_attr);
    428a:	480f      	ldr	r0, [pc, #60]	; (42c8 <pre_main+0xa0>)
    428c:	f002 f958 	bl	6540 <osMutexNew>
    4290:	4602      	mov	r2, r0
    4292:	4b10      	ldr	r3, [pc, #64]	; (42d4 <pre_main+0xac>)
    4294:	601a      	str	r2, [r3, #0]

    __libc_init_array();
    4296:	f006 fd15 	bl	acc4 <__libc_init_array>

    main(0, NULL);
    429a:	2100      	movs	r1, #0
    429c:	2000      	movs	r0, #0
    429e:	f7ff ffbb 	bl	4218 <__wrap_main>
}
    42a2:	bf00      	nop
    42a4:	bd08      	pop	{r3, pc}
    42a6:	bf00      	nop
    42a8:	20001e84 	.word	0x20001e84
    42ac:	0001126c 	.word	0x0001126c
    42b0:	20001e58 	.word	0x20001e58
    42b4:	20001ed0 	.word	0x20001ed0
    42b8:	20001e74 	.word	0x20001e74
    42bc:	0001127c 	.word	0x0001127c
    42c0:	20001ed4 	.word	0x20001ed4
    42c4:	20001ecc 	.word	0x20001ecc
    42c8:	20001e94 	.word	0x20001e94
    42cc:	0001128c 	.word	0x0001128c
    42d0:	20001ef0 	.word	0x20001ef0
    42d4:	20001ea4 	.word	0x20001ea4

000042d8 <software_init_hook>:

void software_init_hook(void)
{
    42d8:	b508      	push	{r3, lr}
    mbed_set_stack_heap();
    42da:	f7ff ff0b 	bl	40f4 <mbed_set_stack_heap>
    /* Copy the vector table to RAM only if uVisor is not in use. */
#if !(defined(FEATURE_UVISOR) && defined(TARGET_UVISOR_SUPPORTED))
    mbed_cpy_nvic();
    42de:	f7ff ff3b 	bl	4158 <mbed_cpy_nvic>
#endif
    mbed_sdk_init();
    42e2:	f003 fe61 	bl	7fa8 <mbed_sdk_init>
    osKernelInitialize();
    42e6:	f000 fd7d 	bl	4de4 <osKernelInitialize>
    return_code = uvisor_lib_init();
    if (return_code) {
        mbed_die();
    }
#endif/* FEATURE_UVISOR */
    mbed_start_main();
    42ea:	f7ff ff5b 	bl	41a4 <mbed_start_main>
}
    42ee:	bf00      	nop
    42f0:	bd08      	pop	{r3, pc}
	...

000042f4 <__rtos_malloc_lock>:

/* Opaque declaration of _reent structure */
struct _reent;

void __rtos_malloc_lock( struct _reent *_r )
{
    42f4:	b500      	push	{lr}
    42f6:	b083      	sub	sp, #12
    42f8:	9001      	str	r0, [sp, #4]
    osMutexAcquire(malloc_mutex_id, osWaitForever);
    42fa:	4b05      	ldr	r3, [pc, #20]	; (4310 <__rtos_malloc_lock+0x1c>)
    42fc:	681b      	ldr	r3, [r3, #0]
    42fe:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    4302:	4618      	mov	r0, r3
    4304:	f002 f944 	bl	6590 <osMutexAcquire>
}
    4308:	bf00      	nop
    430a:	b003      	add	sp, #12
    430c:	f85d fb04 	ldr.w	pc, [sp], #4
    4310:	20001ecc 	.word	0x20001ecc

00004314 <__rtos_malloc_unlock>:

void __rtos_malloc_unlock( struct _reent *_r )
{
    4314:	b500      	push	{lr}
    4316:	b083      	sub	sp, #12
    4318:	9001      	str	r0, [sp, #4]
    osMutexRelease(malloc_mutex_id);
    431a:	4b04      	ldr	r3, [pc, #16]	; (432c <__rtos_malloc_unlock+0x18>)
    431c:	681b      	ldr	r3, [r3, #0]
    431e:	4618      	mov	r0, r3
    4320:	f002 f964 	bl	65ec <osMutexRelease>
}
    4324:	bf00      	nop
    4326:	b003      	add	sp, #12
    4328:	f85d fb04 	ldr.w	pc, [sp], #4
    432c:	20001ecc 	.word	0x20001ecc

00004330 <osRtxIdleThread>:

extern void rtos_idle_loop(void);
extern void thread_terminate_hook(osThreadId_t id);

__NO_RETURN void osRtxIdleThread (void *argument)
{
    4330:	b500      	push	{lr}
    4332:	b083      	sub	sp, #12
    4334:	9001      	str	r0, [sp, #4]
    for (;;) {
      rtos_idle_loop();
    4336:	f000 f911 	bl	455c <rtos_idle_loop>
    433a:	e7fc      	b.n	4336 <osRtxIdleThread+0x6>

0000433c <osRtxErrorNotify>:
    }
}

__NO_RETURN uint32_t osRtxErrorNotify (uint32_t code, void *object_id)
{
    433c:	b500      	push	{lr}
    433e:	b087      	sub	sp, #28
    4340:	9003      	str	r0, [sp, #12]
    4342:	9102      	str	r1, [sp, #8]
    osThreadId_t tid = osThreadGetId();
    4344:	f003 fbec 	bl	7b20 <osThreadGetId>
    4348:	9005      	str	r0, [sp, #20]

    switch (code) {
    434a:	9b03      	ldr	r3, [sp, #12]
    434c:	3b01      	subs	r3, #1
    434e:	2b04      	cmp	r3, #4
    4350:	d839      	bhi.n	43c6 <osRtxErrorNotify+0x8a>
    4352:	a201      	add	r2, pc, #4	; (adr r2, 4358 <osRtxErrorNotify+0x1c>)
    4354:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    4358:	0000436d 	.word	0x0000436d
    435c:	0000437f 	.word	0x0000437f
    4360:	00004391 	.word	0x00004391
    4364:	000043a3 	.word	0x000043a3
    4368:	000043b5 	.word	0x000043b5
      case osRtxErrorStackUnderflow:
        // Stack underflow detected for thread (thread_id=object_id)
        // Note: "overflow" is printed instead of "underflow" due to end user familiarity with overflow errors
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_KERNEL, MBED_ERROR_CODE_STACK_OVERFLOW), "CMSIS-RTOS error: Stack overflow", code);
    436c:	2300      	movs	r3, #0
    436e:	9300      	str	r3, [sp, #0]
    4370:	2300      	movs	r3, #0
    4372:	9a03      	ldr	r2, [sp, #12]
    4374:	4919      	ldr	r1, [pc, #100]	; (43dc <osRtxErrorNotify+0xa0>)
    4376:	481a      	ldr	r0, [pc, #104]	; (43e0 <osRtxErrorNotify+0xa4>)
    4378:	f7fe fd2e 	bl	2dd8 <mbed_error>
        break;
    437c:	e02c      	b.n	43d8 <osRtxErrorNotify+0x9c>
      case osRtxErrorISRQueueOverflow:
        // ISR Queue overflow detected when inserting object (object_id)
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_KERNEL, MBED_ERROR_CODE_ISR_QUEUE_OVERFLOW), "CMSIS-RTOS error: ISR Queue overflow", code);
    437e:	2300      	movs	r3, #0
    4380:	9300      	str	r3, [sp, #0]
    4382:	2300      	movs	r3, #0
    4384:	9a03      	ldr	r2, [sp, #12]
    4386:	4917      	ldr	r1, [pc, #92]	; (43e4 <osRtxErrorNotify+0xa8>)
    4388:	4817      	ldr	r0, [pc, #92]	; (43e8 <osRtxErrorNotify+0xac>)
    438a:	f7fe fd25 	bl	2dd8 <mbed_error>
        break;
    438e:	e023      	b.n	43d8 <osRtxErrorNotify+0x9c>
      case osRtxErrorTimerQueueOverflow:
        // User Timer Callback Queue overflow detected for timer (timer_id=object_id)
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_KERNEL, MBED_ERROR_CODE_TIMER_QUEUE_OVERFLOW), "CMSIS-RTOS error: User Timer Callback Queue overflow", code);
    4390:	2300      	movs	r3, #0
    4392:	9300      	str	r3, [sp, #0]
    4394:	2300      	movs	r3, #0
    4396:	9a03      	ldr	r2, [sp, #12]
    4398:	4914      	ldr	r1, [pc, #80]	; (43ec <osRtxErrorNotify+0xb0>)
    439a:	4815      	ldr	r0, [pc, #84]	; (43f0 <osRtxErrorNotify+0xb4>)
    439c:	f7fe fd1c 	bl	2dd8 <mbed_error>
        break;
    43a0:	e01a      	b.n	43d8 <osRtxErrorNotify+0x9c>
      case osRtxErrorClibSpace:
        // Standard C/C++ library libspace not available: increase OS_THREAD_LIBSPACE_NUM
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_KERNEL, MBED_ERROR_CODE_CLIB_SPACE_UNAVAILABLE), "CMSIS-RTOS error: STD C/C++ library libspace not available", code);
    43a2:	2300      	movs	r3, #0
    43a4:	9300      	str	r3, [sp, #0]
    43a6:	2300      	movs	r3, #0
    43a8:	9a03      	ldr	r2, [sp, #12]
    43aa:	4912      	ldr	r1, [pc, #72]	; (43f4 <osRtxErrorNotify+0xb8>)
    43ac:	4812      	ldr	r0, [pc, #72]	; (43f8 <osRtxErrorNotify+0xbc>)
    43ae:	f7fe fd13 	bl	2dd8 <mbed_error>
        break;
    43b2:	e011      	b.n	43d8 <osRtxErrorNotify+0x9c>
      case osRtxErrorClibMutex:
        // Standard C/C++ library mutex initialization failed
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_KERNEL, MBED_ERROR_CODE_CLIB_MUTEX_INIT_FAILURE), "CMSIS-RTOS error: STD C/C++ library mutex initialization failed", code);
    43b4:	2300      	movs	r3, #0
    43b6:	9300      	str	r3, [sp, #0]
    43b8:	2300      	movs	r3, #0
    43ba:	9a03      	ldr	r2, [sp, #12]
    43bc:	490f      	ldr	r1, [pc, #60]	; (43fc <osRtxErrorNotify+0xc0>)
    43be:	4810      	ldr	r0, [pc, #64]	; (4400 <osRtxErrorNotify+0xc4>)
    43c0:	f7fe fd0a 	bl	2dd8 <mbed_error>
        break;
    43c4:	e008      	b.n	43d8 <osRtxErrorNotify+0x9c>
      default:
        //Unknown error flagged from kernel  
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_KERNEL, MBED_ERROR_CODE_UNKNOWN), "CMSIS-RTOS error: Unknown", code);
    43c6:	2300      	movs	r3, #0
    43c8:	9300      	str	r3, [sp, #0]
    43ca:	2300      	movs	r3, #0
    43cc:	9a03      	ldr	r2, [sp, #12]
    43ce:	490d      	ldr	r1, [pc, #52]	; (4404 <osRtxErrorNotify+0xc8>)
    43d0:	480d      	ldr	r0, [pc, #52]	; (4408 <osRtxErrorNotify+0xcc>)
    43d2:	f7fe fd01 	bl	2dd8 <mbed_error>
        break;
    43d6:	bf00      	nop
    }

    /* That shouldn't be reached */
    for (;;) {}
    43d8:	e7fe      	b.n	43d8 <osRtxErrorNotify+0x9c>
    43da:	bf00      	nop
    43dc:	00011298 	.word	0x00011298
    43e0:	80020125 	.word	0x80020125
    43e4:	000112bc 	.word	0x000112bc
    43e8:	80020126 	.word	0x80020126
    43ec:	000112e4 	.word	0x000112e4
    43f0:	80020127 	.word	0x80020127
    43f4:	0001131c 	.word	0x0001131c
    43f8:	80020128 	.word	0x80020128
    43fc:	00011358 	.word	0x00011358
    4400:	8002012a 	.word	0x8002012a
    4404:	00011398 	.word	0x00011398
    4408:	80020100 	.word	0x80020100

0000440c <error_msg>:
}

#if defined(MBED_TRAP_ERRORS_ENABLED) && MBED_TRAP_ERRORS_ENABLED

static const char* error_msg(int32_t status)
{
    440c:	b082      	sub	sp, #8
    440e:	9001      	str	r0, [sp, #4]
    switch (status) {
    4410:	9b01      	ldr	r3, [sp, #4]
    4412:	3306      	adds	r3, #6
    4414:	2b05      	cmp	r3, #5
    4416:	d81b      	bhi.n	4450 <error_msg+0x44>
    4418:	a201      	add	r2, pc, #4	; (adr r2, 4420 <error_msg+0x14>)
    441a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    441e:	bf00      	nop
    4420:	0000444d 	.word	0x0000444d
    4424:	00004449 	.word	0x00004449
    4428:	00004445 	.word	0x00004445
    442c:	00004441 	.word	0x00004441
    4430:	0000443d 	.word	0x0000443d
    4434:	00004439 	.word	0x00004439
    case osError:
        return "Unspecified RTOS error";
    4438:	4b07      	ldr	r3, [pc, #28]	; (4458 <error_msg+0x4c>)
    443a:	e00a      	b.n	4452 <error_msg+0x46>
    case osErrorTimeout:
        return "Operation not completed within the timeout period";
    443c:	4b07      	ldr	r3, [pc, #28]	; (445c <error_msg+0x50>)
    443e:	e008      	b.n	4452 <error_msg+0x46>
    case osErrorResource:
        return "Resource not available";
    4440:	4b07      	ldr	r3, [pc, #28]	; (4460 <error_msg+0x54>)
    4442:	e006      	b.n	4452 <error_msg+0x46>
    case osErrorParameter:
        return "Parameter error";
    4444:	4b07      	ldr	r3, [pc, #28]	; (4464 <error_msg+0x58>)
    4446:	e004      	b.n	4452 <error_msg+0x46>
    case osErrorNoMemory:
        return "System is out of memory";
    4448:	4b07      	ldr	r3, [pc, #28]	; (4468 <error_msg+0x5c>)
    444a:	e002      	b.n	4452 <error_msg+0x46>
    case osErrorISR:
        return "Not allowed in ISR context";
    444c:	4b07      	ldr	r3, [pc, #28]	; (446c <error_msg+0x60>)
    444e:	e000      	b.n	4452 <error_msg+0x46>
    default:
        return "Unknown";
    4450:	4b07      	ldr	r3, [pc, #28]	; (4470 <error_msg+0x64>)
    }
}
    4452:	4618      	mov	r0, r3
    4454:	b002      	add	sp, #8
    4456:	4770      	bx	lr
    4458:	000113b4 	.word	0x000113b4
    445c:	000113cc 	.word	0x000113cc
    4460:	00011400 	.word	0x00011400
    4464:	00011418 	.word	0x00011418
    4468:	00011428 	.word	0x00011428
    446c:	00011440 	.word	0x00011440
    4470:	0001145c 	.word	0x0001145c

00004474 <EvrRtxKernelError>:

void EvrRtxKernelError (int32_t status)
{
    4474:	b500      	push	{lr}
    4476:	b085      	sub	sp, #20
    4478:	9003      	str	r0, [sp, #12]
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_RTOS_EVENT), error_msg(status), status);
    447a:	9803      	ldr	r0, [sp, #12]
    447c:	f7ff ffc6 	bl	440c <error_msg>
    4480:	4601      	mov	r1, r0
    4482:	9a03      	ldr	r2, [sp, #12]
    4484:	2300      	movs	r3, #0
    4486:	9300      	str	r3, [sp, #0]
    4488:	2300      	movs	r3, #0
    448a:	4803      	ldr	r0, [pc, #12]	; (4498 <EvrRtxKernelError+0x24>)
    448c:	f7fe fca4 	bl	2dd8 <mbed_error>
}
    4490:	bf00      	nop
    4492:	b005      	add	sp, #20
    4494:	f85d fb04 	ldr.w	pc, [sp], #4
    4498:	80010131 	.word	0x80010131

0000449c <EvrRtxThreadError>:

void EvrRtxThreadError (osThreadId_t thread_id, int32_t status)
{
    449c:	b500      	push	{lr}
    449e:	b085      	sub	sp, #20
    44a0:	9003      	str	r0, [sp, #12]
    44a2:	9102      	str	r1, [sp, #8]
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_RTOS_THREAD_EVENT), error_msg(status), thread_id);
    44a4:	9802      	ldr	r0, [sp, #8]
    44a6:	f7ff ffb1 	bl	440c <error_msg>
    44aa:	4601      	mov	r1, r0
    44ac:	9a03      	ldr	r2, [sp, #12]
    44ae:	2300      	movs	r3, #0
    44b0:	9300      	str	r3, [sp, #0]
    44b2:	2300      	movs	r3, #0
    44b4:	4803      	ldr	r0, [pc, #12]	; (44c4 <EvrRtxThreadError+0x28>)
    44b6:	f7fe fc8f 	bl	2dd8 <mbed_error>
}
    44ba:	bf00      	nop
    44bc:	b005      	add	sp, #20
    44be:	f85d fb04 	ldr.w	pc, [sp], #4
    44c2:	bf00      	nop
    44c4:	80010132 	.word	0x80010132

000044c8 <EvrRtxMutexError>:
{
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_RTOS_EVENT_FLAGS_EVENT), error_msg(status), ef_id);
}

void EvrRtxMutexError (osMutexId_t mutex_id, int32_t status)
{
    44c8:	b500      	push	{lr}
    44ca:	b085      	sub	sp, #20
    44cc:	9003      	str	r0, [sp, #12]
    44ce:	9102      	str	r1, [sp, #8]
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_RTOS_MUTEX_EVENT), error_msg(status), mutex_id);
    44d0:	9802      	ldr	r0, [sp, #8]
    44d2:	f7ff ff9b 	bl	440c <error_msg>
    44d6:	4601      	mov	r1, r0
    44d8:	9a03      	ldr	r2, [sp, #12]
    44da:	2300      	movs	r3, #0
    44dc:	9300      	str	r3, [sp, #0]
    44de:	2300      	movs	r3, #0
    44e0:	4803      	ldr	r0, [pc, #12]	; (44f0 <EvrRtxMutexError+0x28>)
    44e2:	f7fe fc79 	bl	2dd8 <mbed_error>
}
    44e6:	bf00      	nop
    44e8:	b005      	add	sp, #20
    44ea:	f85d fb04 	ldr.w	pc, [sp], #4
    44ee:	bf00      	nop
    44f0:	80010133 	.word	0x80010133

000044f4 <EvrRtxMessageQueueError>:
{
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_RTOS_MEMORY_POOL_EVENT), error_msg(status), mp_id);
}

void EvrRtxMessageQueueError (osMessageQueueId_t mq_id, int32_t status)
{
    44f4:	b500      	push	{lr}
    44f6:	b085      	sub	sp, #20
    44f8:	9003      	str	r0, [sp, #12]
    44fa:	9102      	str	r1, [sp, #8]
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_RTOS_MESSAGE_QUEUE_EVENT), error_msg(status), mq_id);
    44fc:	9802      	ldr	r0, [sp, #8]
    44fe:	f7ff ff85 	bl	440c <error_msg>
    4502:	4601      	mov	r1, r0
    4504:	9a03      	ldr	r2, [sp, #12]
    4506:	2300      	movs	r3, #0
    4508:	9300      	str	r3, [sp, #0]
    450a:	2300      	movs	r3, #0
    450c:	4803      	ldr	r0, [pc, #12]	; (451c <EvrRtxMessageQueueError+0x28>)
    450e:	f7fe fc63 	bl	2dd8 <mbed_error>
}
    4512:	bf00      	nop
    4514:	b005      	add	sp, #20
    4516:	f85d fb04 	ldr.w	pc, [sp], #4
    451a:	bf00      	nop
    451c:	80010138 	.word	0x80010138

00004520 <EvrRtxThreadExit>:

#endif

// RTX hook which gets called when a thread terminates, using the event function to call hook
void EvrRtxThreadExit (void)
{
    4520:	b500      	push	{lr}
    4522:	b083      	sub	sp, #12
    osThreadId_t thread_id = osThreadGetId();
    4524:	f003 fafc 	bl	7b20 <osThreadGetId>
    4528:	9001      	str	r0, [sp, #4]
    thread_terminate_hook(thread_id);
    452a:	9801      	ldr	r0, [sp, #4]
    452c:	f003 fce2 	bl	7ef4 <thread_terminate_hook>
#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_EXIT_DISABLE) && defined(RTE_Compiler_EventRecorder))
    EventRecord2(EvtRtxThreadExit, 0U, 0U);
#endif
}
    4530:	bf00      	nop
    4532:	b003      	add	sp, #12
    4534:	f85d fb04 	ldr.w	pc, [sp], #4

00004538 <sleep>:
 *  The mbed interface semihosting is disconnected as part of going to sleep, and can not be restored.
 * Flash re-programming and the USB serial port will remain active, but the mbed program will no longer be
 * able to access the LocalFileSystem
 */
static inline void sleep(void)
{
    4538:	b508      	push	{r3, lr}
#if !(defined(FEATURE_UVISOR) && defined(TARGET_UVISOR_SUPPORTED))
#if DEVICE_SLEEP
#if (MBED_CONF_RTOS_PRESENT == 0) || (DEVICE_STCLK_OFF_DURING_SLEEP == 0) || defined(MBED_TICKLESS)
    sleep_manager_sleep_auto();
    453a:	f7fd fce9 	bl	1f10 <sleep_manager_sleep_auto>
#endif /* (MBED_CONF_RTOS_PRESENT == 0) || (DEVICE_STCLK_OFF_DURING_SLEEP == 0) || defined(MBED_TICKLESS) */
#endif /* DEVICE_SLEEP */
#endif /* !(defined(FEATURE_UVISOR) && defined(TARGET_UVISOR_SUPPORTED)) */
}
    453e:	bf00      	nop
    4540:	bd08      	pop	{r3, pc}

00004542 <_ZL17default_idle_hookv>:
}

#else

static void default_idle_hook(void)
{
    4542:	b508      	push	{r3, lr}
    // critical section to complete sleep with locked deepsleep
    core_util_critical_section_enter();
    4544:	f7fe fb34 	bl	2bb0 <core_util_critical_section_enter>
    sleep_manager_lock_deep_sleep();
    4548:	f7fd fc98 	bl	1e7c <sleep_manager_lock_deep_sleep_internal>
    sleep();
    454c:	f7ff fff4 	bl	4538 <sleep>
    sleep_manager_unlock_deep_sleep();
    4550:	f7fd fcba 	bl	1ec8 <sleep_manager_unlock_deep_sleep_internal>
    core_util_critical_section_exit();
    4554:	f7fe fb46 	bl	2be4 <core_util_critical_section_exit>
}
    4558:	bf00      	nop
    455a:	bd08      	pop	{r3, pc}

0000455c <rtos_idle_loop>:
        idle_hook_fptr = default_idle_hook;
    }
}

extern "C" void rtos_idle_loop(void)
{
    455c:	b508      	push	{r3, lr}
    //Continuously call the idle hook function pointer
    while (1) {
        idle_hook_fptr();
    455e:	4b02      	ldr	r3, [pc, #8]	; (4568 <rtos_idle_loop+0xc>)
    4560:	681b      	ldr	r3, [r3, #0]
    4562:	4798      	blx	r3
    4564:	e7fb      	b.n	455e <rtos_idle_loop+0x2>
    4566:	bf00      	nop
    4568:	2000010c 	.word	0x2000010c

0000456c <IsIrqMode>:
  return ((__get_CONTROL() & 1U) == 0U);
}

/// Check if in IRQ Mode
/// \return     true=IRQ, false=thread
__STATIC_INLINE bool_t IsIrqMode (void) {
    456c:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    456e:	f3ef 8305 	mrs	r3, IPSR
    4572:	9301      	str	r3, [sp, #4]
  return(result);
    4574:	9b01      	ldr	r3, [sp, #4]
  return (__get_IPSR() != 0U);
    4576:	2b00      	cmp	r3, #0
    4578:	bf14      	ite	ne
    457a:	2301      	movne	r3, #1
    457c:	2300      	moveq	r3, #0
    457e:	b2db      	uxtb	r3, r3
}
    4580:	4618      	mov	r0, r3
    4582:	b002      	add	sp, #8
    4584:	4770      	bx	lr

00004586 <IsIrqMasked>:

/// Check if IRQ is Masked
/// \return     true=masked, false=not masked
__STATIC_INLINE bool_t IsIrqMasked (void) {
    4586:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    4588:	f3ef 8310 	mrs	r3, PRIMASK
    458c:	9301      	str	r3, [sp, #4]
  return(result);
    458e:	9b01      	ldr	r3, [sp, #4]
#if   ((defined(__ARM_ARCH_7M__)      && (__ARM_ARCH_7M__      != 0)) || \
       (defined(__ARM_ARCH_7EM__)     && (__ARM_ARCH_7EM__     != 0)) || \
       (defined(__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ != 0)))
  return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
    4590:	2b00      	cmp	r3, #0
    4592:	d105      	bne.n	45a0 <IsIrqMasked+0x1a>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
    4594:	f3ef 8311 	mrs	r3, BASEPRI
    4598:	9300      	str	r3, [sp, #0]
  return(result);
    459a:	9b00      	ldr	r3, [sp, #0]
    459c:	2b00      	cmp	r3, #0
    459e:	d001      	beq.n	45a4 <IsIrqMasked+0x1e>
    45a0:	2301      	movs	r3, #1
    45a2:	e000      	b.n	45a6 <IsIrqMasked+0x20>
    45a4:	2300      	movs	r3, #0
    45a6:	f003 0301 	and.w	r3, r3, #1
    45aa:	b2db      	uxtb	r3, r3
#else
  return  (__get_PRIMASK() != 0U);
#endif
}
    45ac:	4618      	mov	r0, r3
    45ae:	b002      	add	sp, #8
    45b0:	4770      	bx	lr

000045b2 <svcRtxDelay>:

//  ==== Service Calls ====

/// Wait for Timeout (Time Delay).
/// \note API identical to osDelay
static osStatus_t svcRtxDelay (uint32_t ticks) {
    45b2:	b500      	push	{lr}
    45b4:	b083      	sub	sp, #12
    45b6:	9001      	str	r0, [sp, #4]

  if (ticks != 0U) {
    45b8:	9b01      	ldr	r3, [sp, #4]
    45ba:	2b00      	cmp	r3, #0
    45bc:	d00b      	beq.n	45d6 <svcRtxDelay+0x24>
    if (!osRtxThreadWaitEnter(osRtxThreadWaitingDelay, ticks)) {
    45be:	9901      	ldr	r1, [sp, #4]
    45c0:	2013      	movs	r0, #19
    45c2:	f002 fdd1 	bl	7168 <osRtxThreadWaitEnter>
    45c6:	4603      	mov	r3, r0
    45c8:	f083 0301 	eor.w	r3, r3, #1
    45cc:	b2db      	uxtb	r3, r3
    45ce:	2b00      	cmp	r3, #0
    45d0:	d001      	beq.n	45d6 <svcRtxDelay+0x24>
      EvrRtxThreadDelayCompleted();
    45d2:	f000 f8cb 	bl	476c <EvrRtxThreadDelayCompleted>
    }
  }

  return osOK;
    45d6:	2300      	movs	r3, #0
}
    45d8:	4618      	mov	r0, r3
    45da:	b003      	add	sp, #12
    45dc:	f85d fb04 	ldr.w	pc, [sp], #4

000045e0 <osDelay>:


//  ==== Public API ====

/// Wait for Timeout (Time Delay).
osStatus_t osDelay (uint32_t ticks) {
    45e0:	b500      	push	{lr}
    45e2:	b085      	sub	sp, #20
    45e4:	9001      	str	r0, [sp, #4]
  osStatus_t status;

  EvrRtxThreadDelay(ticks);
    45e6:	9801      	ldr	r0, [sp, #4]
    45e8:	f000 f8bb 	bl	4762 <EvrRtxThreadDelay>
  if (IsIrqMode() || IsIrqMasked()) {
    45ec:	f7ff ffbe 	bl	456c <IsIrqMode>
    45f0:	4603      	mov	r3, r0
    45f2:	2b00      	cmp	r3, #0
    45f4:	d104      	bne.n	4600 <osDelay+0x20>
    45f6:	f7ff ffc6 	bl	4586 <IsIrqMasked>
    45fa:	4603      	mov	r3, r0
    45fc:	2b00      	cmp	r3, #0
    45fe:	d008      	beq.n	4612 <osDelay+0x32>
    EvrRtxThreadError(NULL, (int32_t)osErrorISR);
    4600:	f06f 0105 	mvn.w	r1, #5
    4604:	2000      	movs	r0, #0
    4606:	f7ff ff49 	bl	449c <EvrRtxThreadError>
    status = osErrorISR;
    460a:	f06f 0305 	mvn.w	r3, #5
    460e:	9303      	str	r3, [sp, #12]
    4610:	e007      	b.n	4622 <osDelay+0x42>
    4612:	9b01      	ldr	r3, [sp, #4]
    4614:	9302      	str	r3, [sp, #8]
SVC0_1(Delay,      osStatus_t, uint32_t)
    4616:	9802      	ldr	r0, [sp, #8]
    4618:	4b04      	ldr	r3, [pc, #16]	; (462c <osDelay+0x4c>)
    461a:	469c      	mov	ip, r3
    461c:	df00      	svc	0
    461e:	4603      	mov	r3, r0
  } else {
    status = __svcDelay(ticks);
    4620:	9303      	str	r3, [sp, #12]
  }
  return status;
    4622:	9b03      	ldr	r3, [sp, #12]
}
    4624:	4618      	mov	r0, r3
    4626:	b005      	add	sp, #20
    4628:	f85d fb04 	ldr.w	pc, [sp], #4
    462c:	000045b3 	.word	0x000045b3

00004630 <EvrRtxMemoryInit>:


//  ==== Memory Events ====

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_INIT_DISABLE))
__WEAK void EvrRtxMemoryInit (void *mem, uint32_t size, uint32_t result) {
    4630:	b084      	sub	sp, #16
    4632:	9003      	str	r0, [sp, #12]
    4634:	9102      	str	r1, [sp, #8]
    4636:	9201      	str	r2, [sp, #4]
#else
  (void)mem;
  (void)size;
  (void)result;
#endif
}
    4638:	bf00      	nop
    463a:	b004      	add	sp, #16
    463c:	4770      	bx	lr

0000463e <EvrRtxMemoryAlloc>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_ALLOC_DISABLE))
__WEAK void EvrRtxMemoryAlloc (void *mem, uint32_t size, uint32_t type, void *block) {
    463e:	b084      	sub	sp, #16
    4640:	9003      	str	r0, [sp, #12]
    4642:	9102      	str	r1, [sp, #8]
    4644:	9201      	str	r2, [sp, #4]
    4646:	9300      	str	r3, [sp, #0]
  (void)mem;
  (void)size;
  (void)type;
  (void)block;
#endif
}
    4648:	bf00      	nop
    464a:	b004      	add	sp, #16
    464c:	4770      	bx	lr

0000464e <EvrRtxMemoryFree>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_FREE_DISABLE))
__WEAK void EvrRtxMemoryFree (void *mem, void *block, uint32_t result) {
    464e:	b084      	sub	sp, #16
    4650:	9003      	str	r0, [sp, #12]
    4652:	9102      	str	r1, [sp, #8]
    4654:	9201      	str	r2, [sp, #4]
#else
  (void)mem;
  (void)block;
  (void)result;
#endif
}
    4656:	bf00      	nop
    4658:	b004      	add	sp, #16
    465a:	4770      	bx	lr

0000465c <EvrRtxMemoryBlockInit>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_BLOCK_INIT_DISABLE))
__WEAK void EvrRtxMemoryBlockInit (osRtxMpInfo_t *mp_info, uint32_t block_count, uint32_t block_size, void *block_mem) {
    465c:	b084      	sub	sp, #16
    465e:	9003      	str	r0, [sp, #12]
    4660:	9102      	str	r1, [sp, #8]
    4662:	9201      	str	r2, [sp, #4]
    4664:	9300      	str	r3, [sp, #0]
  (void)mp_info;
  (void)block_count;
  (void)block_size;
  (void)block_mem;
#endif
}
    4666:	bf00      	nop
    4668:	b004      	add	sp, #16
    466a:	4770      	bx	lr

0000466c <EvrRtxMemoryBlockAlloc>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_BLOCK_ALLOC_DISABLE))
__WEAK void EvrRtxMemoryBlockAlloc (osRtxMpInfo_t *mp_info, void *block) {
    466c:	b082      	sub	sp, #8
    466e:	9001      	str	r0, [sp, #4]
    4670:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMemoryBlockAlloc, (uint32_t)mp_info, (uint32_t)block);
#else
  (void)mp_info;
  (void)block;
#endif
}
    4672:	bf00      	nop
    4674:	b002      	add	sp, #8
    4676:	4770      	bx	lr

00004678 <EvrRtxMemoryBlockFree>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_BLOCK_FREE_DISABLE))
__WEAK void EvrRtxMemoryBlockFree (osRtxMpInfo_t *mp_info, void *block, int32_t status) {
    4678:	b084      	sub	sp, #16
    467a:	9003      	str	r0, [sp, #12]
    467c:	9102      	str	r1, [sp, #8]
    467e:	9201      	str	r2, [sp, #4]
#else
  (void)mp_info;
  (void)block;
  (void)status;
#endif
}
    4680:	bf00      	nop
    4682:	b004      	add	sp, #16
    4684:	4770      	bx	lr

00004686 <EvrRtxKernelInitialize>:
__WEAK void EvrRtxKernelInitialize (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelInitialize, 0U, 0U);
#else
#endif
}
    4686:	bf00      	nop
    4688:	4770      	bx	lr

0000468a <EvrRtxKernelInitializeCompleted>:
__WEAK void EvrRtxKernelInitializeCompleted (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelInitializeCompleted, 0U, 0U);
#else
#endif
}
    468a:	bf00      	nop
    468c:	4770      	bx	lr

0000468e <EvrRtxKernelGetState>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_GET_STATE_DISABLE))
__WEAK void EvrRtxKernelGetState (osKernelState_t state) {
    468e:	b082      	sub	sp, #8
    4690:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelGetState, (uint32_t)state, 0U);
#else
  (void)state;
#endif
}
    4692:	bf00      	nop
    4694:	b002      	add	sp, #8
    4696:	4770      	bx	lr

00004698 <EvrRtxKernelStart>:
__WEAK void EvrRtxKernelStart (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelStart, 0U, 0U);
#else
#endif
}
    4698:	bf00      	nop
    469a:	4770      	bx	lr

0000469c <EvrRtxKernelStarted>:
__WEAK void EvrRtxKernelStarted (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelStarted, 0U, 0U);
#else
#endif
}
    469c:	bf00      	nop
    469e:	4770      	bx	lr

000046a0 <EvrRtxKernelLock>:
__WEAK void EvrRtxKernelLock (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelLock, 0U, 0U);
#else
#endif
}
    46a0:	bf00      	nop
    46a2:	4770      	bx	lr

000046a4 <EvrRtxKernelLocked>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_LOCKED_DISABLE))
__WEAK void EvrRtxKernelLocked (int32_t lock) {
    46a4:	b082      	sub	sp, #8
    46a6:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelLocked, (uint32_t)lock, 0U);
#else
  (void)lock;
#endif
}
    46a8:	bf00      	nop
    46aa:	b002      	add	sp, #8
    46ac:	4770      	bx	lr

000046ae <EvrRtxKernelUnlock>:
__WEAK void EvrRtxKernelUnlock (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelUnlock, 0U, 0U);
#else
#endif
}
    46ae:	bf00      	nop
    46b0:	4770      	bx	lr

000046b2 <EvrRtxKernelUnlocked>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_UNLOCKED_DISABLE))
__WEAK void EvrRtxKernelUnlocked (int32_t lock) {
    46b2:	b082      	sub	sp, #8
    46b4:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelUnlocked, (uint32_t)lock, 0U);
#else
  (void)lock;
#endif
}
    46b6:	bf00      	nop
    46b8:	b002      	add	sp, #8
    46ba:	4770      	bx	lr

000046bc <EvrRtxThreadNew>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_NEW_DISABLE))
__WEAK void EvrRtxThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
    46bc:	b084      	sub	sp, #16
    46be:	9003      	str	r0, [sp, #12]
    46c0:	9102      	str	r1, [sp, #8]
    46c2:	9201      	str	r2, [sp, #4]
#else
  (void)func;
  (void)argument;
  (void)attr;
#endif
}
    46c4:	bf00      	nop
    46c6:	b004      	add	sp, #16
    46c8:	4770      	bx	lr

000046ca <EvrRtxThreadCreated>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_CREATED_DISABLE))
__WEAK void EvrRtxThreadCreated (osThreadId_t thread_id, uint32_t thread_addr) {
    46ca:	b082      	sub	sp, #8
    46cc:	9001      	str	r0, [sp, #4]
    46ce:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxThreadCreated, (uint32_t)thread_id, thread_addr);
#else
  (void)thread_id;
  (void)thread_addr;
#endif
}
    46d0:	bf00      	nop
    46d2:	b002      	add	sp, #8
    46d4:	4770      	bx	lr

000046d6 <EvrRtxThreadGetId>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_GET_ID_DISABLE))
__WEAK void EvrRtxThreadGetId (osThreadId_t thread_id) {
    46d6:	b082      	sub	sp, #8
    46d8:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadGetId, (uint32_t)thread_id, 0U);
#else
  (void)thread_id;
#endif
}
    46da:	bf00      	nop
    46dc:	b002      	add	sp, #8
    46de:	4770      	bx	lr

000046e0 <EvrRtxThreadGetStackSize>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_GET_STACK_SIZE_DISABLE))
__WEAK void EvrRtxThreadGetStackSize (osThreadId_t thread_id, uint32_t stack_size) {
    46e0:	b082      	sub	sp, #8
    46e2:	9001      	str	r0, [sp, #4]
    46e4:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxThreadGetStackSize, (uint32_t)thread_id, stack_size);
#else
  (void)thread_id;
  (void)stack_size;
#endif
}
    46e6:	bf00      	nop
    46e8:	b002      	add	sp, #8
    46ea:	4770      	bx	lr

000046ec <EvrRtxThreadGetStackSpace>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_GET_STACK_SPACE_DISABLE))
__WEAK void EvrRtxThreadGetStackSpace (osThreadId_t thread_id, uint32_t stack_space) {
    46ec:	b082      	sub	sp, #8
    46ee:	9001      	str	r0, [sp, #4]
    46f0:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxThreadGetStackSpace, (uint32_t)thread_id, stack_space);
#else
  (void)thread_id;
  (void)stack_space;
#endif
}
    46f2:	bf00      	nop
    46f4:	b002      	add	sp, #8
    46f6:	4770      	bx	lr

000046f8 <EvrRtxThreadJoined>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_JOINED_DISABLE))
__WEAK void EvrRtxThreadJoined (osThreadId_t thread_id) {
    46f8:	b082      	sub	sp, #8
    46fa:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadJoined, (uint32_t)thread_id, 0U);
#else
  (void)thread_id;
#endif
}
    46fc:	bf00      	nop
    46fe:	b002      	add	sp, #8
    4700:	4770      	bx	lr

00004702 <EvrRtxThreadBlocked>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_BLOCKED_DISABLE))
__WEAK void EvrRtxThreadBlocked (osThreadId_t thread_id, uint32_t timeout) {
    4702:	b082      	sub	sp, #8
    4704:	9001      	str	r0, [sp, #4]
    4706:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxThreadBlocked, (uint32_t)thread_id, timeout);
#else
  (void)thread_id;
  (void)timeout;
#endif
}
    4708:	bf00      	nop
    470a:	b002      	add	sp, #8
    470c:	4770      	bx	lr

0000470e <EvrRtxThreadUnblocked>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_UNBLOCKED_DISABLE))
__WEAK void EvrRtxThreadUnblocked (osThreadId_t thread_id, uint32_t ret_val) {
    470e:	b082      	sub	sp, #8
    4710:	9001      	str	r0, [sp, #4]
    4712:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxThreadUnblocked, (uint32_t)thread_id, ret_val);
#else
  (void)thread_id;
  (void)ret_val;
#endif
}
    4714:	bf00      	nop
    4716:	b002      	add	sp, #8
    4718:	4770      	bx	lr

0000471a <EvrRtxThreadPreempted>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_PREEMPTED_DISABLE))
__WEAK void EvrRtxThreadPreempted (osThreadId_t thread_id) {
    471a:	b082      	sub	sp, #8
    471c:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadPreempted, (uint32_t)thread_id, 0U);
#else
  (void)thread_id;
#endif
}
    471e:	bf00      	nop
    4720:	b002      	add	sp, #8
    4722:	4770      	bx	lr

00004724 <EvrRtxThreadSwitched>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_SWITCHED_DISABLE))
__WEAK void EvrRtxThreadSwitched (osThreadId_t thread_id) {
    4724:	b082      	sub	sp, #8
    4726:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadSwitched, (uint32_t)thread_id, 0U);
#else
  (void)thread_id;
#endif
}
    4728:	bf00      	nop
    472a:	b002      	add	sp, #8
    472c:	4770      	bx	lr

0000472e <EvrRtxThreadDestroyed>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_DESTROYED_DISABLE))
__WEAK void EvrRtxThreadDestroyed (osThreadId_t thread_id) {
    472e:	b082      	sub	sp, #8
    4730:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadDestroyed, (uint32_t)thread_id, 0U);
#else
  (void)thread_id;
#endif
}
    4732:	bf00      	nop
    4734:	b002      	add	sp, #8
    4736:	4770      	bx	lr

00004738 <EvrRtxThreadGetCount>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_GET_COUNT_DISABLE))
__WEAK void EvrRtxThreadGetCount (uint32_t count) {
    4738:	b082      	sub	sp, #8
    473a:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadGetCount, count, 0U);
#else
  (void)count;
#endif
}
    473c:	bf00      	nop
    473e:	b002      	add	sp, #8
    4740:	4770      	bx	lr

00004742 <EvrRtxThreadEnumerate>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_ENUMERATE_DISABLE))
__WEAK void EvrRtxThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items, uint32_t count) {
    4742:	b084      	sub	sp, #16
    4744:	9003      	str	r0, [sp, #12]
    4746:	9102      	str	r1, [sp, #8]
    4748:	9201      	str	r2, [sp, #4]
#else
  (void)thread_array;
  (void)array_items;
  (void)count;
#endif
}
    474a:	bf00      	nop
    474c:	b004      	add	sp, #16
    474e:	4770      	bx	lr

00004750 <EvrRtxThreadFlagsWaitTimeout>:
#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_FLAGS_WAIT_TIMEOUT_DISABLE))
__WEAK void EvrRtxThreadFlagsWaitTimeout (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadFlagsWaitTimeout, 0U, 0U);
#endif
}
    4750:	bf00      	nop
    4752:	4770      	bx	lr

00004754 <EvrRtxThreadFlagsWaitCompleted>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_FLAGS_WAIT_COMPLETED_DISABLE))
__WEAK void EvrRtxThreadFlagsWaitCompleted (uint32_t flags, uint32_t options, uint32_t thread_flags) {
    4754:	b084      	sub	sp, #16
    4756:	9003      	str	r0, [sp, #12]
    4758:	9102      	str	r1, [sp, #8]
    475a:	9201      	str	r2, [sp, #4]
#else
  (void)flags;
  (void)options;
  (void)thread_flags;
#endif
}
    475c:	bf00      	nop
    475e:	b004      	add	sp, #16
    4760:	4770      	bx	lr

00004762 <EvrRtxThreadDelay>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_DELAY_DISABLE))
__WEAK void EvrRtxThreadDelay (uint32_t ticks) {
    4762:	b082      	sub	sp, #8
    4764:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadDelay, ticks, 0U);
#else
  (void)ticks;
#endif
}
    4766:	bf00      	nop
    4768:	b002      	add	sp, #8
    476a:	4770      	bx	lr

0000476c <EvrRtxThreadDelayCompleted>:
#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_DELAY_COMPLETED_DISABLE))
__WEAK void EvrRtxThreadDelayCompleted (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadDelayCompleted, 0U, 0U);
#endif
}
    476c:	bf00      	nop
    476e:	4770      	bx	lr

00004770 <EvrRtxTimerCallback>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_TIMER != 0) && !defined(EVR_RTX_TIMER_CALLBACK_DISABLE))
__WEAK void EvrRtxTimerCallback (osTimerFunc_t func, void *argument) {
    4770:	b082      	sub	sp, #8
    4772:	9001      	str	r0, [sp, #4]
    4774:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxTimerCallback, (uint32_t)func, (uint32_t)argument);
#else
  (void)func;
  (void)argument;
#endif
}
    4776:	bf00      	nop
    4778:	b002      	add	sp, #8
    477a:	4770      	bx	lr

0000477c <EvrRtxEventFlagsWaitTimeout>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_WAIT_TIMEOUT_DISABLE))
__WEAK void EvrRtxEventFlagsWaitTimeout (osEventFlagsId_t ef_id) {
    477c:	b082      	sub	sp, #8
    477e:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxEventFlagsWaitTimeout, (uint32_t)ef_id, 0U);
#else
  (void)ef_id;
#endif
}
    4780:	bf00      	nop
    4782:	b002      	add	sp, #8
    4784:	4770      	bx	lr

00004786 <EvrRtxMutexNew>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_NEW_DISABLE))
__WEAK void EvrRtxMutexNew (const osMutexAttr_t *attr) {
    4786:	b082      	sub	sp, #8
    4788:	9001      	str	r0, [sp, #4]
    (void)EventRecordData(EvtRtxMutexNew_Detail, attr, sizeof (osMutexAttr_t));
  }
#else
  (void)attr;
#endif
}
    478a:	bf00      	nop
    478c:	b002      	add	sp, #8
    478e:	4770      	bx	lr

00004790 <EvrRtxMutexCreated>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_CREATED_DISABLE))
__WEAK void EvrRtxMutexCreated (osMutexId_t mutex_id, const char *name) {
    4790:	b082      	sub	sp, #8
    4792:	9001      	str	r0, [sp, #4]
    4794:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMutexCreated, (uint32_t)mutex_id, (uint32_t)name);
#else
  (void)mutex_id;
  (void)name;
#endif
}
    4796:	bf00      	nop
    4798:	b002      	add	sp, #8
    479a:	4770      	bx	lr

0000479c <EvrRtxMutexAcquire>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_ACQUIRE_DISABLE))
__WEAK void EvrRtxMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
    479c:	b082      	sub	sp, #8
    479e:	9001      	str	r0, [sp, #4]
    47a0:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMutexAcquire, (uint32_t)mutex_id, timeout);
#else
  (void)mutex_id;
  (void)timeout;
#endif
}
    47a2:	bf00      	nop
    47a4:	b002      	add	sp, #8
    47a6:	4770      	bx	lr

000047a8 <EvrRtxMutexAcquirePending>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_ACQUIRE_PENDING_DISABLE))
__WEAK void EvrRtxMutexAcquirePending (osMutexId_t mutex_id, uint32_t timeout) {
    47a8:	b082      	sub	sp, #8
    47aa:	9001      	str	r0, [sp, #4]
    47ac:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMutexAcquirePending, (uint32_t)mutex_id, timeout);
#else
  (void)mutex_id;
  (void)timeout;
#endif
}
    47ae:	bf00      	nop
    47b0:	b002      	add	sp, #8
    47b2:	4770      	bx	lr

000047b4 <EvrRtxMutexAcquireTimeout>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_ACQUIRE_TIMEOUT_DISABLE))
__WEAK void EvrRtxMutexAcquireTimeout (osMutexId_t mutex_id) {
    47b4:	b082      	sub	sp, #8
    47b6:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxMutexAcquireTimeout, (uint32_t)mutex_id, 0U);
#else
  (void)mutex_id;
#endif
}
    47b8:	bf00      	nop
    47ba:	b002      	add	sp, #8
    47bc:	4770      	bx	lr

000047be <EvrRtxMutexAcquired>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_ACQUIRED_DISABLE))
__WEAK void EvrRtxMutexAcquired (osMutexId_t mutex_id, uint32_t lock) {
    47be:	b082      	sub	sp, #8
    47c0:	9001      	str	r0, [sp, #4]
    47c2:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMutexAcquired, (uint32_t)mutex_id, lock);
#else
  (void)mutex_id;
  (void)lock;
#endif
}
    47c4:	bf00      	nop
    47c6:	b002      	add	sp, #8
    47c8:	4770      	bx	lr

000047ca <EvrRtxMutexNotAcquired>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_NOT_ACQUIRED_DISABLE))
__WEAK void EvrRtxMutexNotAcquired (osMutexId_t mutex_id) {
    47ca:	b082      	sub	sp, #8
    47cc:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxMutexNotAcquired, (uint32_t)mutex_id, 0U);
#else
  (void)mutex_id;
#endif
}
    47ce:	bf00      	nop
    47d0:	b002      	add	sp, #8
    47d2:	4770      	bx	lr

000047d4 <EvrRtxMutexRelease>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_RELEASE_DISABLE))
__WEAK void EvrRtxMutexRelease (osMutexId_t mutex_id) {
    47d4:	b082      	sub	sp, #8
    47d6:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxMutexRelease, (uint32_t)mutex_id, 0U);
#else
  (void)mutex_id;
#endif
}
    47d8:	bf00      	nop
    47da:	b002      	add	sp, #8
    47dc:	4770      	bx	lr

000047de <EvrRtxMutexReleased>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_RELEASED_DISABLE))
__WEAK void EvrRtxMutexReleased (osMutexId_t mutex_id, uint32_t lock) {
    47de:	b082      	sub	sp, #8
    47e0:	9001      	str	r0, [sp, #4]
    47e2:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMutexReleased, (uint32_t)mutex_id, lock);
#else
  (void)mutex_id;
  (void)lock;
#endif
}
    47e4:	bf00      	nop
    47e6:	b002      	add	sp, #8
    47e8:	4770      	bx	lr

000047ea <EvrRtxSemaphoreAcquireTimeout>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_ACQUIRE_TIMEOUT_DISABLE))
__WEAK void EvrRtxSemaphoreAcquireTimeout (osSemaphoreId_t semaphore_id) {
    47ea:	b082      	sub	sp, #8
    47ec:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxSemaphoreAcquireTimeout, (uint32_t)semaphore_id, 0U);
#else
  (void)semaphore_id;
#endif
}
    47ee:	bf00      	nop
    47f0:	b002      	add	sp, #8
    47f2:	4770      	bx	lr

000047f4 <EvrRtxMemoryPoolAllocTimeout>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_ALLOC_TIMEOUT_DISABLE))
__WEAK void EvrRtxMemoryPoolAllocTimeout (osMemoryPoolId_t mp_id) {
    47f4:	b082      	sub	sp, #8
    47f6:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxMemoryPoolAllocTimeout, (uint32_t)mp_id, 0U);
#else
  (void)mp_id;
#endif
}
    47f8:	bf00      	nop
    47fa:	b002      	add	sp, #8
    47fc:	4770      	bx	lr

000047fe <EvrRtxMessageQueueNew>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_NEW_DISABLE))
__WEAK void EvrRtxMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
    47fe:	b084      	sub	sp, #16
    4800:	9003      	str	r0, [sp, #12]
    4802:	9102      	str	r1, [sp, #8]
    4804:	9201      	str	r2, [sp, #4]
#else
  (void)msg_count;
  (void)msg_size;
  (void)attr;
#endif
}
    4806:	bf00      	nop
    4808:	b004      	add	sp, #16
    480a:	4770      	bx	lr

0000480c <EvrRtxMessageQueueCreated>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_CREATED_DISABLE))
__WEAK void EvrRtxMessageQueueCreated (osMessageQueueId_t mq_id, const char *name) {
    480c:	b082      	sub	sp, #8
    480e:	9001      	str	r0, [sp, #4]
    4810:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMessageQueueCreated, (uint32_t)mq_id, (uint32_t)name);
#else
  (void)mq_id;
  (void)name;
#endif
}
    4812:	bf00      	nop
    4814:	b002      	add	sp, #8
    4816:	4770      	bx	lr

00004818 <EvrRtxMessageQueuePut>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_PUT_DISABLE))
__WEAK void EvrRtxMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
    4818:	b084      	sub	sp, #16
    481a:	9003      	str	r0, [sp, #12]
    481c:	9102      	str	r1, [sp, #8]
    481e:	9300      	str	r3, [sp, #0]
    4820:	4613      	mov	r3, r2
    4822:	f88d 3007 	strb.w	r3, [sp, #7]
  (void)mq_id;
  (void)msg_ptr;
  (void)msg_prio;
  (void)timeout;
#endif
}
    4826:	bf00      	nop
    4828:	b004      	add	sp, #16
    482a:	4770      	bx	lr

0000482c <EvrRtxMessageQueuePutPending>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_PUT_PENDING_DISABLE))
__WEAK void EvrRtxMessageQueuePutPending (osMessageQueueId_t mq_id, const void *msg_ptr, uint32_t timeout) {
    482c:	b084      	sub	sp, #16
    482e:	9003      	str	r0, [sp, #12]
    4830:	9102      	str	r1, [sp, #8]
    4832:	9201      	str	r2, [sp, #4]
#else
  (void)mq_id;
  (void)msg_ptr;
  (void)timeout;
#endif
}
    4834:	bf00      	nop
    4836:	b004      	add	sp, #16
    4838:	4770      	bx	lr

0000483a <EvrRtxMessageQueuePutTimeout>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_PUT_TIMEOUT_DISABLE))
__WEAK void EvrRtxMessageQueuePutTimeout (osMessageQueueId_t mq_id) {
    483a:	b082      	sub	sp, #8
    483c:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxMessageQueuePutTimeout, (uint32_t)mq_id, 0U);
#else
  (void)mq_id;
#endif
}
    483e:	bf00      	nop
    4840:	b002      	add	sp, #8
    4842:	4770      	bx	lr

00004844 <EvrRtxMessageQueueInsertPending>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_INSERT_PENDING_DISABLE))
__WEAK void EvrRtxMessageQueueInsertPending (osMessageQueueId_t mq_id, const void *msg_ptr) {
    4844:	b082      	sub	sp, #8
    4846:	9001      	str	r0, [sp, #4]
    4848:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMessageQueueInsertPending, (uint32_t)mq_id, (uint32_t)msg_ptr);
#else
  (void)mq_id;
  (void)msg_ptr;
#endif
}
    484a:	bf00      	nop
    484c:	b002      	add	sp, #8
    484e:	4770      	bx	lr

00004850 <EvrRtxMessageQueueInserted>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_INSERTED_DISABLE))
__WEAK void EvrRtxMessageQueueInserted (osMessageQueueId_t mq_id, const void *msg_ptr) {
    4850:	b082      	sub	sp, #8
    4852:	9001      	str	r0, [sp, #4]
    4854:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMessageQueueInserted, (uint32_t)mq_id, (uint32_t)msg_ptr);
#else
  (void)mq_id;
  (void)msg_ptr;
#endif
}
    4856:	bf00      	nop
    4858:	b002      	add	sp, #8
    485a:	4770      	bx	lr

0000485c <EvrRtxMessageQueueNotInserted>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_NOT_INSERTED_DISABLE))
__WEAK void EvrRtxMessageQueueNotInserted (osMessageQueueId_t mq_id, const void *msg_ptr) {
    485c:	b082      	sub	sp, #8
    485e:	9001      	str	r0, [sp, #4]
    4860:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMessageQueueNotInserted, (uint32_t)mq_id, (uint32_t)msg_ptr);
#else
  (void)mq_id;
  (void)msg_ptr;
#endif
}
    4862:	bf00      	nop
    4864:	b002      	add	sp, #8
    4866:	4770      	bx	lr

00004868 <EvrRtxMessageQueueGet>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_GET_DISABLE))
__WEAK void EvrRtxMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
    4868:	b084      	sub	sp, #16
    486a:	9003      	str	r0, [sp, #12]
    486c:	9102      	str	r1, [sp, #8]
    486e:	9201      	str	r2, [sp, #4]
    4870:	9300      	str	r3, [sp, #0]
  (void)mq_id;
  (void)msg_ptr;
  (void)msg_prio;
  (void)timeout;
#endif
}
    4872:	bf00      	nop
    4874:	b004      	add	sp, #16
    4876:	4770      	bx	lr

00004878 <EvrRtxMessageQueueGetPending>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_GET_PENDING_DISABLE))
__WEAK void EvrRtxMessageQueueGetPending (osMessageQueueId_t mq_id, void *msg_ptr, uint32_t timeout) {
    4878:	b084      	sub	sp, #16
    487a:	9003      	str	r0, [sp, #12]
    487c:	9102      	str	r1, [sp, #8]
    487e:	9201      	str	r2, [sp, #4]
#else
  (void)mq_id;
  (void)msg_ptr;
  (void)timeout;
#endif
}
    4880:	bf00      	nop
    4882:	b004      	add	sp, #16
    4884:	4770      	bx	lr

00004886 <EvrRtxMessageQueueGetTimeout>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_GET_TIMEOUT_DISABLE))
__WEAK void EvrRtxMessageQueueGetTimeout (osMessageQueueId_t mq_id) {
    4886:	b082      	sub	sp, #8
    4888:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxMessageQueueGetTimeout, (uint32_t)mq_id, 0U);
#else
  (void)mq_id;
#endif
}
    488a:	bf00      	nop
    488c:	b002      	add	sp, #8
    488e:	4770      	bx	lr

00004890 <EvrRtxMessageQueueRetrieved>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_RETRIEVED_DISABLE))
__WEAK void EvrRtxMessageQueueRetrieved (osMessageQueueId_t mq_id, void *msg_ptr) {
    4890:	b082      	sub	sp, #8
    4892:	9001      	str	r0, [sp, #4]
    4894:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMessageQueueRetrieved, (uint32_t)mq_id, (uint32_t)msg_ptr);
#else
  (void)mq_id;
  (void)msg_ptr;
#endif
}
    4896:	bf00      	nop
    4898:	b002      	add	sp, #8
    489a:	4770      	bx	lr

0000489c <EvrRtxMessageQueueNotRetrieved>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_NOT_RETRIEVED_DISABLE))
__WEAK void EvrRtxMessageQueueNotRetrieved (osMessageQueueId_t mq_id, void *msg_ptr) {
    489c:	b082      	sub	sp, #8
    489e:	9001      	str	r0, [sp, #4]
    48a0:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMessageQueueNotRetrieved, (uint32_t)mq_id, (uint32_t)msg_ptr);
#else
  (void)mq_id;
  (void)msg_ptr;
#endif
}
    48a2:	bf00      	nop
    48a4:	b002      	add	sp, #8
    48a6:	4770      	bx	lr

000048a8 <__NVIC_GetPriorityGrouping>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
    48a8:	4b03      	ldr	r3, [pc, #12]	; (48b8 <__NVIC_GetPriorityGrouping+0x10>)
    48aa:	68db      	ldr	r3, [r3, #12]
    48ac:	0a1b      	lsrs	r3, r3, #8
    48ae:	f003 0307 	and.w	r3, r3, #7
}
    48b2:	4618      	mov	r0, r3
    48b4:	4770      	bx	lr
    48b6:	bf00      	nop
    48b8:	e000ed00 	.word	0xe000ed00

000048bc <IsPrivileged>:
__STATIC_INLINE bool_t IsPrivileged (void) {
    48bc:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, control" : "=r" (result) );
    48be:	f3ef 8314 	mrs	r3, CONTROL
    48c2:	9301      	str	r3, [sp, #4]
  return(result);
    48c4:	9b01      	ldr	r3, [sp, #4]
  return ((__get_CONTROL() & 1U) == 0U);
    48c6:	f003 0301 	and.w	r3, r3, #1
    48ca:	2b00      	cmp	r3, #0
    48cc:	bf0c      	ite	eq
    48ce:	2301      	moveq	r3, #1
    48d0:	2300      	movne	r3, #0
    48d2:	b2db      	uxtb	r3, r3
}
    48d4:	4618      	mov	r0, r3
    48d6:	b002      	add	sp, #8
    48d8:	4770      	bx	lr

000048da <IsIrqMode>:
__STATIC_INLINE bool_t IsIrqMode (void) {
    48da:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    48dc:	f3ef 8305 	mrs	r3, IPSR
    48e0:	9301      	str	r3, [sp, #4]
  return(result);
    48e2:	9b01      	ldr	r3, [sp, #4]
  return (__get_IPSR() != 0U);
    48e4:	2b00      	cmp	r3, #0
    48e6:	bf14      	ite	ne
    48e8:	2301      	movne	r3, #1
    48ea:	2300      	moveq	r3, #0
    48ec:	b2db      	uxtb	r3, r3
}
    48ee:	4618      	mov	r0, r3
    48f0:	b002      	add	sp, #8
    48f2:	4770      	bx	lr

000048f4 <IsIrqMasked>:
__STATIC_INLINE bool_t IsIrqMasked (void) {
    48f4:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    48f6:	f3ef 8310 	mrs	r3, PRIMASK
    48fa:	9301      	str	r3, [sp, #4]
  return(result);
    48fc:	9b01      	ldr	r3, [sp, #4]
  return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
    48fe:	2b00      	cmp	r3, #0
    4900:	d105      	bne.n	490e <IsIrqMasked+0x1a>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
    4902:	f3ef 8311 	mrs	r3, BASEPRI
    4906:	9300      	str	r3, [sp, #0]
  return(result);
    4908:	9b00      	ldr	r3, [sp, #0]
    490a:	2b00      	cmp	r3, #0
    490c:	d001      	beq.n	4912 <IsIrqMasked+0x1e>
    490e:	2301      	movs	r3, #1
    4910:	e000      	b.n	4914 <IsIrqMasked+0x20>
    4912:	2300      	movs	r3, #0
    4914:	f003 0301 	and.w	r3, r3, #1
    4918:	b2db      	uxtb	r3, r3
}
    491a:	4618      	mov	r0, r3
    491c:	b002      	add	sp, #8
    491e:	4770      	bx	lr

00004920 <SVC_Setup>:


//  ==== Core Peripherals functions ====

/// Setup SVC and PendSV System Service Calls
__STATIC_INLINE void SVC_Setup (void) {
    4920:	b500      	push	{lr}
    4922:	b083      	sub	sp, #12
  SCB->SHPR[0] |= (n << (8+1)) & 0xFC000000U;
#elif ((defined(__ARM_ARCH_7M__)      && (__ARM_ARCH_7M__      != 0)) || \
       (defined(__ARM_ARCH_7EM__)     && (__ARM_ARCH_7EM__     != 0)))
  uint32_t p, n;

  SCB->SHP[10] = 0xFFU;
    4924:	4b12      	ldr	r3, [pc, #72]	; (4970 <SVC_Setup+0x50>)
    4926:	22ff      	movs	r2, #255	; 0xff
    4928:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  n = 32U - (uint32_t)__CLZ(~(SCB->SHP[10] | 0xFFFFFF00U));
    492c:	4b10      	ldr	r3, [pc, #64]	; (4970 <SVC_Setup+0x50>)
    492e:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    4932:	b2db      	uxtb	r3, r3
    4934:	f063 03ff 	orn	r3, r3, #255	; 0xff
    4938:	43db      	mvns	r3, r3
    493a:	fab3 f383 	clz	r3, r3
    493e:	b2db      	uxtb	r3, r3
    4940:	f1c3 0320 	rsb	r3, r3, #32
    4944:	9301      	str	r3, [sp, #4]
  p = NVIC_GetPriorityGrouping();
    4946:	f7ff ffaf 	bl	48a8 <__NVIC_GetPriorityGrouping>
    494a:	9000      	str	r0, [sp, #0]
  if (p >= n) {
    494c:	9a00      	ldr	r2, [sp, #0]
    494e:	9b01      	ldr	r3, [sp, #4]
    4950:	429a      	cmp	r2, r3
    4952:	d302      	bcc.n	495a <SVC_Setup+0x3a>
    n = p + 1U;
    4954:	9b00      	ldr	r3, [sp, #0]
    4956:	3301      	adds	r3, #1
    4958:	9301      	str	r3, [sp, #4]
  }
  /* Only change the SVCall priority if uVisor is not present. */
  #if !(defined(FEATURE_UVISOR) && defined(TARGET_UVISOR_SUPPORTED))
  SCB->SHP[7] = (uint8_t)(0xFEU << n);
    495a:	4a05      	ldr	r2, [pc, #20]	; (4970 <SVC_Setup+0x50>)
    495c:	21fe      	movs	r1, #254	; 0xfe
    495e:	9b01      	ldr	r3, [sp, #4]
    4960:	fa01 f303 	lsl.w	r3, r1, r3
    4964:	b2db      	uxtb	r3, r3
    4966:	77d3      	strb	r3, [r2, #31]

  SCB->SHP[1] |= 0x00FF0000U;
  n = SCB->SHP[1];
  SCB->SHP[0] |= (n << (8+1)) & 0xFC000000U;
#endif
}
    4968:	bf00      	nop
    496a:	b003      	add	sp, #12
    496c:	f85d fb04 	ldr.w	pc, [sp], #4
    4970:	e000ed00 	.word	0xe000ed00

00004974 <osRtxKernelState>:
}

// Kernel State
__STATIC_INLINE osKernelState_t osRtxKernelState (void) {
  //lint -e{9030} -e{9034} "cast to enum"
  return ((osKernelState_t)(osRtxInfo.kernel.state));
    4974:	4b01      	ldr	r3, [pc, #4]	; (497c <osRtxKernelState+0x8>)
    4976:	7a1b      	ldrb	r3, [r3, #8]
}
    4978:	4618      	mov	r0, r3
    497a:	4770      	bx	lr
    497c:	20000110 	.word	0x20000110

00004980 <svcRtxKernelInitialize>:

//  ==== Service Calls ====

/// Initialize the RTOS Kernel.
/// \note API identical to osKernelInitialize
static osStatus_t svcRtxKernelInitialize (void) {
    4980:	b508      	push	{r3, lr}

  if (osRtxInfo.kernel.state == osRtxKernelReady) {
    4982:	4b44      	ldr	r3, [pc, #272]	; (4a94 <svcRtxKernelInitialize+0x114>)
    4984:	7a1b      	ldrb	r3, [r3, #8]
    4986:	2b01      	cmp	r3, #1
    4988:	d103      	bne.n	4992 <svcRtxKernelInitialize+0x12>
    EvrRtxKernelInitializeCompleted();
    498a:	f7ff fe7e 	bl	468a <EvrRtxKernelInitializeCompleted>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osOK;
    498e:	2300      	movs	r3, #0
    4990:	e159      	b.n	4c46 <svcRtxKernelInitialize+0x2c6>
  }
  if (osRtxInfo.kernel.state != osRtxKernelInactive) {
    4992:	4b40      	ldr	r3, [pc, #256]	; (4a94 <svcRtxKernelInitialize+0x114>)
    4994:	7a1b      	ldrb	r3, [r3, #8]
    4996:	2b00      	cmp	r3, #0
    4998:	d006      	beq.n	49a8 <svcRtxKernelInitialize+0x28>
    EvrRtxKernelError((int32_t)osError);
    499a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    499e:	f7ff fd69 	bl	4474 <EvrRtxKernelError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    49a2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    49a6:	e14e      	b.n	4c46 <svcRtxKernelInitialize+0x2c6>
  }

  if (osRtxConfig.thread_stack_size < (64U + 8U)) {
    49a8:	4b3b      	ldr	r3, [pc, #236]	; (4a98 <svcRtxKernelInitialize+0x118>)
    49aa:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    49ac:	2b47      	cmp	r3, #71	; 0x47
    49ae:	d806      	bhi.n	49be <svcRtxKernelInitialize+0x3e>
    EvrRtxKernelError(osRtxErrorInvalidThreadStack);
    49b0:	f06f 000a 	mvn.w	r0, #10
    49b4:	f7ff fd5e 	bl	4474 <EvrRtxKernelError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    49b8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    49bc:	e143      	b.n	4c46 <svcRtxKernelInitialize+0x2c6>
  }

  if ((osRtxConfig.isr_queue.data == NULL) || (osRtxConfig.isr_queue.max == 0U)) {
    49be:	4b36      	ldr	r3, [pc, #216]	; (4a98 <svcRtxKernelInitialize+0x118>)
    49c0:	68db      	ldr	r3, [r3, #12]
    49c2:	2b00      	cmp	r3, #0
    49c4:	d003      	beq.n	49ce <svcRtxKernelInitialize+0x4e>
    49c6:	4b34      	ldr	r3, [pc, #208]	; (4a98 <svcRtxKernelInitialize+0x118>)
    49c8:	8a1b      	ldrh	r3, [r3, #16]
    49ca:	2b00      	cmp	r3, #0
    49cc:	d106      	bne.n	49dc <svcRtxKernelInitialize+0x5c>
    EvrRtxKernelError((int32_t)osError);
    49ce:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    49d2:	f7ff fd4f 	bl	4474 <EvrRtxKernelError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    49d6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    49da:	e134      	b.n	4c46 <svcRtxKernelInitialize+0x2c6>
    return osError;
  }
#endif

  // Initialize osRtxInfo
  memset(&osRtxInfo.kernel, 0, sizeof(osRtxInfo) - offsetof(osRtxInfo_t, kernel));
    49dc:	229c      	movs	r2, #156	; 0x9c
    49de:	2100      	movs	r1, #0
    49e0:	482e      	ldr	r0, [pc, #184]	; (4a9c <svcRtxKernelInitialize+0x11c>)
    49e2:	f006 fd5f 	bl	b4a4 <memset>

  osRtxInfo.isr_queue.data = osRtxConfig.isr_queue.data;
    49e6:	4b2c      	ldr	r3, [pc, #176]	; (4a98 <svcRtxKernelInitialize+0x118>)
    49e8:	68db      	ldr	r3, [r3, #12]
    49ea:	4a2a      	ldr	r2, [pc, #168]	; (4a94 <svcRtxKernelInitialize+0x114>)
    49ec:	65d3      	str	r3, [r2, #92]	; 0x5c
  osRtxInfo.isr_queue.max  = osRtxConfig.isr_queue.max;
    49ee:	4b2a      	ldr	r3, [pc, #168]	; (4a98 <svcRtxKernelInitialize+0x118>)
    49f0:	8a1a      	ldrh	r2, [r3, #16]
    49f2:	4b28      	ldr	r3, [pc, #160]	; (4a94 <svcRtxKernelInitialize+0x114>)
    49f4:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54

  osRtxInfo.thread.robin.timeout = osRtxConfig.robin_timeout;
    49f8:	4b27      	ldr	r3, [pc, #156]	; (4a98 <svcRtxKernelInitialize+0x118>)
    49fa:	689b      	ldr	r3, [r3, #8]
    49fc:	4a25      	ldr	r2, [pc, #148]	; (4a94 <svcRtxKernelInitialize+0x114>)
    49fe:	6413      	str	r3, [r2, #64]	; 0x40

  // Initialize Memory Pools (Variable Block Size)
  if (osRtxMemoryInit(osRtxConfig.mem.common_addr, osRtxConfig.mem.common_size) != 0U) {
    4a00:	4b25      	ldr	r3, [pc, #148]	; (4a98 <svcRtxKernelInitialize+0x118>)
    4a02:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4a04:	4b24      	ldr	r3, [pc, #144]	; (4a98 <svcRtxKernelInitialize+0x118>)
    4a06:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    4a08:	4619      	mov	r1, r3
    4a0a:	4610      	mov	r0, r2
    4a0c:	f000 fabb 	bl	4f86 <osRtxMemoryInit>
    4a10:	4603      	mov	r3, r0
    4a12:	2b00      	cmp	r3, #0
    4a14:	d004      	beq.n	4a20 <svcRtxKernelInitialize+0xa0>
    osRtxInfo.mem.common = osRtxConfig.mem.common_addr;
    4a16:	4b20      	ldr	r3, [pc, #128]	; (4a98 <svcRtxKernelInitialize+0x118>)
    4a18:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4a1a:	4a1e      	ldr	r2, [pc, #120]	; (4a94 <svcRtxKernelInitialize+0x114>)
    4a1c:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  }
  if (osRtxMemoryInit(osRtxConfig.mem.stack_addr, osRtxConfig.mem.stack_size) != 0U) {
    4a20:	4b1d      	ldr	r3, [pc, #116]	; (4a98 <svcRtxKernelInitialize+0x118>)
    4a22:	695a      	ldr	r2, [r3, #20]
    4a24:	4b1c      	ldr	r3, [pc, #112]	; (4a98 <svcRtxKernelInitialize+0x118>)
    4a26:	699b      	ldr	r3, [r3, #24]
    4a28:	4619      	mov	r1, r3
    4a2a:	4610      	mov	r0, r2
    4a2c:	f000 faab 	bl	4f86 <osRtxMemoryInit>
    4a30:	4603      	mov	r3, r0
    4a32:	2b00      	cmp	r3, #0
    4a34:	d004      	beq.n	4a40 <svcRtxKernelInitialize+0xc0>
    osRtxInfo.mem.stack = osRtxConfig.mem.stack_addr;
    4a36:	4b18      	ldr	r3, [pc, #96]	; (4a98 <svcRtxKernelInitialize+0x118>)
    4a38:	695b      	ldr	r3, [r3, #20]
    4a3a:	4a16      	ldr	r2, [pc, #88]	; (4a94 <svcRtxKernelInitialize+0x114>)
    4a3c:	6753      	str	r3, [r2, #116]	; 0x74
    4a3e:	e004      	b.n	4a4a <svcRtxKernelInitialize+0xca>
  } else {
    osRtxInfo.mem.stack = osRtxInfo.mem.common;
    4a40:	4b14      	ldr	r3, [pc, #80]	; (4a94 <svcRtxKernelInitialize+0x114>)
    4a42:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    4a46:	4a13      	ldr	r2, [pc, #76]	; (4a94 <svcRtxKernelInitialize+0x114>)
    4a48:	6753      	str	r3, [r2, #116]	; 0x74
  }
  if (osRtxMemoryInit(osRtxConfig.mem.mp_data_addr, osRtxConfig.mem.mp_data_size) != 0U) {
    4a4a:	4b13      	ldr	r3, [pc, #76]	; (4a98 <svcRtxKernelInitialize+0x118>)
    4a4c:	69da      	ldr	r2, [r3, #28]
    4a4e:	4b12      	ldr	r3, [pc, #72]	; (4a98 <svcRtxKernelInitialize+0x118>)
    4a50:	6a1b      	ldr	r3, [r3, #32]
    4a52:	4619      	mov	r1, r3
    4a54:	4610      	mov	r0, r2
    4a56:	f000 fa96 	bl	4f86 <osRtxMemoryInit>
    4a5a:	4603      	mov	r3, r0
    4a5c:	2b00      	cmp	r3, #0
    4a5e:	d004      	beq.n	4a6a <svcRtxKernelInitialize+0xea>
    osRtxInfo.mem.mp_data = osRtxConfig.mem.mp_data_addr;
    4a60:	4b0d      	ldr	r3, [pc, #52]	; (4a98 <svcRtxKernelInitialize+0x118>)
    4a62:	69db      	ldr	r3, [r3, #28]
    4a64:	4a0b      	ldr	r2, [pc, #44]	; (4a94 <svcRtxKernelInitialize+0x114>)
    4a66:	6793      	str	r3, [r2, #120]	; 0x78
    4a68:	e004      	b.n	4a74 <svcRtxKernelInitialize+0xf4>
  } else {
    osRtxInfo.mem.mp_data = osRtxInfo.mem.common;
    4a6a:	4b0a      	ldr	r3, [pc, #40]	; (4a94 <svcRtxKernelInitialize+0x114>)
    4a6c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    4a70:	4a08      	ldr	r2, [pc, #32]	; (4a94 <svcRtxKernelInitialize+0x114>)
    4a72:	6793      	str	r3, [r2, #120]	; 0x78
  }
  if (osRtxMemoryInit(osRtxConfig.mem.mq_data_addr, osRtxConfig.mem.mq_data_size) != 0U) {
    4a74:	4b08      	ldr	r3, [pc, #32]	; (4a98 <svcRtxKernelInitialize+0x118>)
    4a76:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    4a78:	4b07      	ldr	r3, [pc, #28]	; (4a98 <svcRtxKernelInitialize+0x118>)
    4a7a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4a7c:	4619      	mov	r1, r3
    4a7e:	4610      	mov	r0, r2
    4a80:	f000 fa81 	bl	4f86 <osRtxMemoryInit>
    4a84:	4603      	mov	r3, r0
    4a86:	2b00      	cmp	r3, #0
    4a88:	d00a      	beq.n	4aa0 <svcRtxKernelInitialize+0x120>
    osRtxInfo.mem.mq_data = osRtxConfig.mem.mq_data_addr;
    4a8a:	4b03      	ldr	r3, [pc, #12]	; (4a98 <svcRtxKernelInitialize+0x118>)
    4a8c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    4a8e:	4a01      	ldr	r2, [pc, #4]	; (4a94 <svcRtxKernelInitialize+0x114>)
    4a90:	67d3      	str	r3, [r2, #124]	; 0x7c
    4a92:	e00a      	b.n	4aaa <svcRtxKernelInitialize+0x12a>
    4a94:	20000110 	.word	0x20000110
    4a98:	0001148c 	.word	0x0001148c
    4a9c:	20000118 	.word	0x20000118
  } else {
    osRtxInfo.mem.mq_data = osRtxInfo.mem.common;
    4aa0:	4b6a      	ldr	r3, [pc, #424]	; (4c4c <svcRtxKernelInitialize+0x2cc>)
    4aa2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    4aa6:	4a69      	ldr	r2, [pc, #420]	; (4c4c <svcRtxKernelInitialize+0x2cc>)
    4aa8:	67d3      	str	r3, [r2, #124]	; 0x7c
  }

  // Initialize Memory Pools (Fixed Block Size)
  if (osRtxConfig.mpi.stack != NULL) {
    4aaa:	4b69      	ldr	r3, [pc, #420]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4aac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    4aae:	2b00      	cmp	r3, #0
    4ab0:	d014      	beq.n	4adc <svcRtxKernelInitialize+0x15c>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.stack,
    4ab2:	4b67      	ldr	r3, [pc, #412]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4ab4:	6b58      	ldr	r0, [r3, #52]	; 0x34
                            osRtxConfig.mpi.stack->max_blocks,
    4ab6:	4b66      	ldr	r3, [pc, #408]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4ab8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.stack,
    4aba:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.stack->block_size,
    4abc:	4b64      	ldr	r3, [pc, #400]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4abe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.stack,
    4ac0:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.stack->block_base) != 0U) {
    4ac2:	4b63      	ldr	r3, [pc, #396]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4ac4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.stack,
    4ac6:	68db      	ldr	r3, [r3, #12]
    4ac8:	f000 fbf2 	bl	52b0 <osRtxMemoryPoolInit>
    4acc:	4603      	mov	r3, r0
    4ace:	2b00      	cmp	r3, #0
    4ad0:	d004      	beq.n	4adc <svcRtxKernelInitialize+0x15c>
      osRtxInfo.mpi.stack = osRtxConfig.mpi.stack;
    4ad2:	4b5f      	ldr	r3, [pc, #380]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4ad4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    4ad6:	4a5d      	ldr	r2, [pc, #372]	; (4c4c <svcRtxKernelInitialize+0x2cc>)
    4ad8:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    }
  }
  if (osRtxConfig.mpi.thread != NULL) {
    4adc:	4b5c      	ldr	r3, [pc, #368]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4ade:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    4ae0:	2b00      	cmp	r3, #0
    4ae2:	d014      	beq.n	4b0e <svcRtxKernelInitialize+0x18e>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.thread,
    4ae4:	4b5a      	ldr	r3, [pc, #360]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4ae6:	6b98      	ldr	r0, [r3, #56]	; 0x38
                            osRtxConfig.mpi.thread->max_blocks,
    4ae8:	4b59      	ldr	r3, [pc, #356]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4aea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.thread,
    4aec:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.thread->block_size,
    4aee:	4b58      	ldr	r3, [pc, #352]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4af0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.thread,
    4af2:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.thread->block_base) != 0U) {
    4af4:	4b56      	ldr	r3, [pc, #344]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4af6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.thread,
    4af8:	68db      	ldr	r3, [r3, #12]
    4afa:	f000 fbd9 	bl	52b0 <osRtxMemoryPoolInit>
    4afe:	4603      	mov	r3, r0
    4b00:	2b00      	cmp	r3, #0
    4b02:	d004      	beq.n	4b0e <svcRtxKernelInitialize+0x18e>
      osRtxInfo.mpi.thread = osRtxConfig.mpi.thread;
    4b04:	4b52      	ldr	r3, [pc, #328]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b06:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    4b08:	4a50      	ldr	r2, [pc, #320]	; (4c4c <svcRtxKernelInitialize+0x2cc>)
    4b0a:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    }
  }
  if (osRtxConfig.mpi.timer != NULL) {
    4b0e:	4b50      	ldr	r3, [pc, #320]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b10:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    4b12:	2b00      	cmp	r3, #0
    4b14:	d014      	beq.n	4b40 <svcRtxKernelInitialize+0x1c0>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.timer,
    4b16:	4b4e      	ldr	r3, [pc, #312]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b18:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
                            osRtxConfig.mpi.timer->max_blocks,
    4b1a:	4b4d      	ldr	r3, [pc, #308]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b1c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.timer,
    4b1e:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.timer->block_size,
    4b20:	4b4b      	ldr	r3, [pc, #300]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b22:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.timer,
    4b24:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.timer->block_base) != 0U) {
    4b26:	4b4a      	ldr	r3, [pc, #296]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b28:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.timer,
    4b2a:	68db      	ldr	r3, [r3, #12]
    4b2c:	f000 fbc0 	bl	52b0 <osRtxMemoryPoolInit>
    4b30:	4603      	mov	r3, r0
    4b32:	2b00      	cmp	r3, #0
    4b34:	d004      	beq.n	4b40 <svcRtxKernelInitialize+0x1c0>
      osRtxInfo.mpi.timer = osRtxConfig.mpi.timer;
    4b36:	4b46      	ldr	r3, [pc, #280]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b38:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    4b3a:	4a44      	ldr	r2, [pc, #272]	; (4c4c <svcRtxKernelInitialize+0x2cc>)
    4b3c:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    }
  }
  if (osRtxConfig.mpi.event_flags != NULL) {
    4b40:	4b43      	ldr	r3, [pc, #268]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b42:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4b44:	2b00      	cmp	r3, #0
    4b46:	d014      	beq.n	4b72 <svcRtxKernelInitialize+0x1f2>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.event_flags,
    4b48:	4b41      	ldr	r3, [pc, #260]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b4a:	6c18      	ldr	r0, [r3, #64]	; 0x40
                            osRtxConfig.mpi.event_flags->max_blocks,
    4b4c:	4b40      	ldr	r3, [pc, #256]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b4e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.event_flags,
    4b50:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.event_flags->block_size,
    4b52:	4b3f      	ldr	r3, [pc, #252]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b54:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.event_flags,
    4b56:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.event_flags->block_base) != 0U) {
    4b58:	4b3d      	ldr	r3, [pc, #244]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b5a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.event_flags,
    4b5c:	68db      	ldr	r3, [r3, #12]
    4b5e:	f000 fba7 	bl	52b0 <osRtxMemoryPoolInit>
    4b62:	4603      	mov	r3, r0
    4b64:	2b00      	cmp	r3, #0
    4b66:	d004      	beq.n	4b72 <svcRtxKernelInitialize+0x1f2>
      osRtxInfo.mpi.event_flags = osRtxConfig.mpi.event_flags;
    4b68:	4b39      	ldr	r3, [pc, #228]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b6a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4b6c:	4a37      	ldr	r2, [pc, #220]	; (4c4c <svcRtxKernelInitialize+0x2cc>)
    4b6e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
    }
  }
  if (osRtxConfig.mpi.mutex != NULL) {
    4b72:	4b37      	ldr	r3, [pc, #220]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b74:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    4b76:	2b00      	cmp	r3, #0
    4b78:	d014      	beq.n	4ba4 <svcRtxKernelInitialize+0x224>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.mutex,
    4b7a:	4b35      	ldr	r3, [pc, #212]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b7c:	6c58      	ldr	r0, [r3, #68]	; 0x44
                            osRtxConfig.mpi.mutex->max_blocks,
    4b7e:	4b34      	ldr	r3, [pc, #208]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b80:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.mutex,
    4b82:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.mutex->block_size,
    4b84:	4b32      	ldr	r3, [pc, #200]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b86:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.mutex,
    4b88:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.mutex->block_base) != 0U) {
    4b8a:	4b31      	ldr	r3, [pc, #196]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b8c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.mutex,
    4b8e:	68db      	ldr	r3, [r3, #12]
    4b90:	f000 fb8e 	bl	52b0 <osRtxMemoryPoolInit>
    4b94:	4603      	mov	r3, r0
    4b96:	2b00      	cmp	r3, #0
    4b98:	d004      	beq.n	4ba4 <svcRtxKernelInitialize+0x224>
      osRtxInfo.mpi.mutex = osRtxConfig.mpi.mutex;
    4b9a:	4b2d      	ldr	r3, [pc, #180]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4b9c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    4b9e:	4a2b      	ldr	r2, [pc, #172]	; (4c4c <svcRtxKernelInitialize+0x2cc>)
    4ba0:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    }
  }
  if (osRtxConfig.mpi.semaphore != NULL) {
    4ba4:	4b2a      	ldr	r3, [pc, #168]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4ba6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    4ba8:	2b00      	cmp	r3, #0
    4baa:	d014      	beq.n	4bd6 <svcRtxKernelInitialize+0x256>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.semaphore,
    4bac:	4b28      	ldr	r3, [pc, #160]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4bae:	6c98      	ldr	r0, [r3, #72]	; 0x48
                            osRtxConfig.mpi.semaphore->max_blocks,
    4bb0:	4b27      	ldr	r3, [pc, #156]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4bb2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.semaphore,
    4bb4:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.semaphore->block_size,
    4bb6:	4b26      	ldr	r3, [pc, #152]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4bb8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.semaphore,
    4bba:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.semaphore->block_base) != 0U) {
    4bbc:	4b24      	ldr	r3, [pc, #144]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4bbe:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.semaphore,
    4bc0:	68db      	ldr	r3, [r3, #12]
    4bc2:	f000 fb75 	bl	52b0 <osRtxMemoryPoolInit>
    4bc6:	4603      	mov	r3, r0
    4bc8:	2b00      	cmp	r3, #0
    4bca:	d004      	beq.n	4bd6 <svcRtxKernelInitialize+0x256>
      osRtxInfo.mpi.semaphore = osRtxConfig.mpi.semaphore;
    4bcc:	4b20      	ldr	r3, [pc, #128]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4bce:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    4bd0:	4a1e      	ldr	r2, [pc, #120]	; (4c4c <svcRtxKernelInitialize+0x2cc>)
    4bd2:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
    }
  }
  if (osRtxConfig.mpi.memory_pool != NULL) {
    4bd6:	4b1e      	ldr	r3, [pc, #120]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4bd8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    4bda:	2b00      	cmp	r3, #0
    4bdc:	d014      	beq.n	4c08 <svcRtxKernelInitialize+0x288>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.memory_pool,
    4bde:	4b1c      	ldr	r3, [pc, #112]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4be0:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
                            osRtxConfig.mpi.memory_pool->max_blocks,
    4be2:	4b1b      	ldr	r3, [pc, #108]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4be4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.memory_pool,
    4be6:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.memory_pool->block_size,
    4be8:	4b19      	ldr	r3, [pc, #100]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4bea:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.memory_pool,
    4bec:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.memory_pool->block_base) != 0U) {
    4bee:	4b18      	ldr	r3, [pc, #96]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4bf0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.memory_pool,
    4bf2:	68db      	ldr	r3, [r3, #12]
    4bf4:	f000 fb5c 	bl	52b0 <osRtxMemoryPoolInit>
    4bf8:	4603      	mov	r3, r0
    4bfa:	2b00      	cmp	r3, #0
    4bfc:	d004      	beq.n	4c08 <svcRtxKernelInitialize+0x288>
      osRtxInfo.mpi.memory_pool = osRtxConfig.mpi.memory_pool;
    4bfe:	4b14      	ldr	r3, [pc, #80]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4c00:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    4c02:	4a12      	ldr	r2, [pc, #72]	; (4c4c <svcRtxKernelInitialize+0x2cc>)
    4c04:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
    }
  }
  if (osRtxConfig.mpi.message_queue != NULL) {
    4c08:	4b11      	ldr	r3, [pc, #68]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4c0a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    4c0c:	2b00      	cmp	r3, #0
    4c0e:	d014      	beq.n	4c3a <svcRtxKernelInitialize+0x2ba>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.message_queue,
    4c10:	4b0f      	ldr	r3, [pc, #60]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4c12:	6d18      	ldr	r0, [r3, #80]	; 0x50
                            osRtxConfig.mpi.message_queue->max_blocks,
    4c14:	4b0e      	ldr	r3, [pc, #56]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4c16:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.message_queue,
    4c18:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.message_queue->block_size,
    4c1a:	4b0d      	ldr	r3, [pc, #52]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4c1c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.message_queue,
    4c1e:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.message_queue->block_base) != 0U) {
    4c20:	4b0b      	ldr	r3, [pc, #44]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4c22:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.message_queue,
    4c24:	68db      	ldr	r3, [r3, #12]
    4c26:	f000 fb43 	bl	52b0 <osRtxMemoryPoolInit>
    4c2a:	4603      	mov	r3, r0
    4c2c:	2b00      	cmp	r3, #0
    4c2e:	d004      	beq.n	4c3a <svcRtxKernelInitialize+0x2ba>
      osRtxInfo.mpi.message_queue = osRtxConfig.mpi.message_queue;
    4c30:	4b07      	ldr	r3, [pc, #28]	; (4c50 <svcRtxKernelInitialize+0x2d0>)
    4c32:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    4c34:	4a05      	ldr	r2, [pc, #20]	; (4c4c <svcRtxKernelInitialize+0x2cc>)
    4c36:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
    }
  }

  osRtxInfo.kernel.state = osRtxKernelReady;
    4c3a:	4b04      	ldr	r3, [pc, #16]	; (4c4c <svcRtxKernelInitialize+0x2cc>)
    4c3c:	2201      	movs	r2, #1
    4c3e:	721a      	strb	r2, [r3, #8]

  EvrRtxKernelInitializeCompleted();
    4c40:	f7ff fd23 	bl	468a <EvrRtxKernelInitializeCompleted>

  return osOK;
    4c44:	2300      	movs	r3, #0
}
    4c46:	4618      	mov	r0, r3
    4c48:	bd08      	pop	{r3, pc}
    4c4a:	bf00      	nop
    4c4c:	20000110 	.word	0x20000110
    4c50:	0001148c 	.word	0x0001148c

00004c54 <svcRtxKernelGetState>:
  return osOK;
}

/// Get the current RTOS Kernel state.
/// \note API identical to osKernelGetState
static osKernelState_t svcRtxKernelGetState (void) {
    4c54:	b500      	push	{lr}
    4c56:	b083      	sub	sp, #12
  osKernelState_t state = osRtxKernelState();
    4c58:	f7ff fe8c 	bl	4974 <osRtxKernelState>
    4c5c:	9001      	str	r0, [sp, #4]
  EvrRtxKernelGetState(state);
    4c5e:	9801      	ldr	r0, [sp, #4]
    4c60:	f7ff fd15 	bl	468e <EvrRtxKernelGetState>
  return state;
    4c64:	9b01      	ldr	r3, [sp, #4]
}
    4c66:	4618      	mov	r0, r3
    4c68:	b003      	add	sp, #12
    4c6a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00004c70 <svcRtxKernelStart>:

/// Start the RTOS Kernel scheduler.
/// \note API identical to osKernelStart
static osStatus_t svcRtxKernelStart (void) {
    4c70:	b500      	push	{lr}
    4c72:	b085      	sub	sp, #20
  os_thread_t *thread;

  if (osRtxInfo.kernel.state != osRtxKernelReady) {
    4c74:	4b2f      	ldr	r3, [pc, #188]	; (4d34 <svcRtxKernelStart+0xc4>)
    4c76:	7a1b      	ldrb	r3, [r3, #8]
    4c78:	2b01      	cmp	r3, #1
    4c7a:	d006      	beq.n	4c8a <svcRtxKernelStart+0x1a>
    EvrRtxKernelError(osRtxErrorKernelNotReady);
    4c7c:	f06f 0006 	mvn.w	r0, #6
    4c80:	f7ff fbf8 	bl	4474 <EvrRtxKernelError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    4c84:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4c88:	e04f      	b.n	4d2a <svcRtxKernelStart+0xba>
  }

  // Thread startup (Idle and Timer Thread)
  if (!osRtxThreadStartup()) {
    4c8a:	f002 feb7 	bl	79fc <osRtxThreadStartup>
    4c8e:	4603      	mov	r3, r0
    4c90:	f083 0301 	eor.w	r3, r3, #1
    4c94:	b2db      	uxtb	r3, r3
    4c96:	2b00      	cmp	r3, #0
    4c98:	d006      	beq.n	4ca8 <svcRtxKernelStart+0x38>
    EvrRtxKernelError((int32_t)osError);
    4c9a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4c9e:	f7ff fbe9 	bl	4474 <EvrRtxKernelError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    4ca2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4ca6:	e040      	b.n	4d2a <svcRtxKernelStart+0xba>
  }

  // Setup SVC and PendSV System Service Calls
  SVC_Setup();
    4ca8:	f7ff fe3a 	bl	4920 <SVC_Setup>

  // Setup RTOS Tick
  if (OS_Tick_Setup(osRtxConfig.tick_freq, OS_TICK_HANDLER) != 0) {
    4cac:	4b22      	ldr	r3, [pc, #136]	; (4d38 <svcRtxKernelStart+0xc8>)
    4cae:	685b      	ldr	r3, [r3, #4]
    4cb0:	4922      	ldr	r1, [pc, #136]	; (4d3c <svcRtxKernelStart+0xcc>)
    4cb2:	4618      	mov	r0, r3
    4cb4:	f003 f8c6 	bl	7e44 <OS_Tick_Setup>
    4cb8:	4603      	mov	r3, r0
    4cba:	2b00      	cmp	r3, #0
    4cbc:	d006      	beq.n	4ccc <svcRtxKernelStart+0x5c>
    EvrRtxKernelError((int32_t)osError);
    4cbe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4cc2:	f7ff fbd7 	bl	4474 <EvrRtxKernelError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    4cc6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4cca:	e02e      	b.n	4d2a <svcRtxKernelStart+0xba>
  }
  osRtxInfo.tick_irqn = OS_Tick_GetIRQn();
    4ccc:	f003 f90e 	bl	7eec <OS_Tick_GetIRQn>
    4cd0:	4602      	mov	r2, r0
    4cd2:	4b18      	ldr	r3, [pc, #96]	; (4d34 <svcRtxKernelStart+0xc4>)
    4cd4:	611a      	str	r2, [r3, #16]

  // Enable RTOS Tick
  OS_Tick_Enable();
    4cd6:	f003 f8e9 	bl	7eac <OS_Tick_Enable>

  // Switch to Ready Thread with highest Priority
  thread = osRtxThreadListGet(&osRtxInfo.thread.ready);
    4cda:	4819      	ldr	r0, [pc, #100]	; (4d40 <svcRtxKernelStart+0xd0>)
    4cdc:	f001 ff80 	bl	6be0 <osRtxThreadListGet>
    4ce0:	9003      	str	r0, [sp, #12]
  if (thread == NULL) {
    4ce2:	9b03      	ldr	r3, [sp, #12]
    4ce4:	2b00      	cmp	r3, #0
    4ce6:	d106      	bne.n	4cf6 <svcRtxKernelStart+0x86>
    EvrRtxKernelError((int32_t)osError);
    4ce8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4cec:	f7ff fbc2 	bl	4474 <EvrRtxKernelError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    4cf0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4cf4:	e019      	b.n	4d2a <svcRtxKernelStart+0xba>
  }
  osRtxThreadSwitch(thread);
    4cf6:	9803      	ldr	r0, [sp, #12]
    4cf8:	f002 f988 	bl	700c <osRtxThreadSwitch>

  if ((osRtxConfig.flags & osRtxConfigPrivilegedMode) != 0U) {
    4cfc:	4b0e      	ldr	r3, [pc, #56]	; (4d38 <svcRtxKernelStart+0xc8>)
    4cfe:	681b      	ldr	r3, [r3, #0]
    4d00:	f003 0301 	and.w	r3, r3, #1
    4d04:	2b00      	cmp	r3, #0
    4d06:	d005      	beq.n	4d14 <svcRtxKernelStart+0xa4>
    4d08:	2302      	movs	r3, #2
    4d0a:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
    4d0c:	9b02      	ldr	r3, [sp, #8]
    4d0e:	f383 8814 	msr	CONTROL, r3
    4d12:	e004      	b.n	4d1e <svcRtxKernelStart+0xae>
    4d14:	2303      	movs	r3, #3
    4d16:	9301      	str	r3, [sp, #4]
    4d18:	9b01      	ldr	r3, [sp, #4]
    4d1a:	f383 8814 	msr	CONTROL, r3
  } else {
    // Unprivileged Thread mode & PSP
    __set_CONTROL(0x03U);
  }

  osRtxInfo.kernel.state = osRtxKernelRunning;
    4d1e:	4b05      	ldr	r3, [pc, #20]	; (4d34 <svcRtxKernelStart+0xc4>)
    4d20:	2202      	movs	r2, #2
    4d22:	721a      	strb	r2, [r3, #8]

  EvrRtxKernelStarted();
    4d24:	f7ff fcba 	bl	469c <EvrRtxKernelStarted>

  return osOK;
    4d28:	2300      	movs	r3, #0
}
    4d2a:	4618      	mov	r0, r3
    4d2c:	b005      	add	sp, #20
    4d2e:	f85d fb04 	ldr.w	pc, [sp], #4
    4d32:	bf00      	nop
    4d34:	20000110 	.word	0x20000110
    4d38:	0001148c 	.word	0x0001148c
    4d3c:	00000677 	.word	0x00000677
    4d40:	2000012c 	.word	0x2000012c

00004d44 <svcRtxKernelLock>:

/// Lock the RTOS Kernel scheduler.
/// \note API identical to osKernelLock
int32_t svcRtxKernelLock (void) {
    4d44:	b500      	push	{lr}
    4d46:	b083      	sub	sp, #12
  int32_t lock;

  switch (osRtxInfo.kernel.state) {
    4d48:	4b11      	ldr	r3, [pc, #68]	; (4d90 <svcRtxKernelLock+0x4c>)
    4d4a:	7a1b      	ldrb	r3, [r3, #8]
    4d4c:	2b02      	cmp	r3, #2
    4d4e:	d002      	beq.n	4d56 <svcRtxKernelLock+0x12>
    4d50:	2b03      	cmp	r3, #3
    4d52:	d009      	beq.n	4d68 <svcRtxKernelLock+0x24>
    4d54:	e00e      	b.n	4d74 <svcRtxKernelLock+0x30>
    case osRtxKernelRunning:
      osRtxInfo.kernel.state = osRtxKernelLocked;
    4d56:	4b0e      	ldr	r3, [pc, #56]	; (4d90 <svcRtxKernelLock+0x4c>)
    4d58:	2203      	movs	r2, #3
    4d5a:	721a      	strb	r2, [r3, #8]
      EvrRtxKernelLocked(0);
    4d5c:	2000      	movs	r0, #0
    4d5e:	f7ff fca1 	bl	46a4 <EvrRtxKernelLocked>
      lock = 0;
    4d62:	2300      	movs	r3, #0
    4d64:	9301      	str	r3, [sp, #4]
      break;
    4d66:	e00d      	b.n	4d84 <svcRtxKernelLock+0x40>
    case osRtxKernelLocked:
      EvrRtxKernelLocked(1);
    4d68:	2001      	movs	r0, #1
    4d6a:	f7ff fc9b 	bl	46a4 <EvrRtxKernelLocked>
      lock = 1;
    4d6e:	2301      	movs	r3, #1
    4d70:	9301      	str	r3, [sp, #4]
      break;
    4d72:	e007      	b.n	4d84 <svcRtxKernelLock+0x40>
    default:
      EvrRtxKernelError((int32_t)osError);
    4d74:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4d78:	f7ff fb7c 	bl	4474 <EvrRtxKernelError>
      lock = (int32_t)osError;
    4d7c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4d80:	9301      	str	r3, [sp, #4]
      break;
    4d82:	bf00      	nop
  }
  return lock;
    4d84:	9b01      	ldr	r3, [sp, #4]
}
    4d86:	4618      	mov	r0, r3
    4d88:	b003      	add	sp, #12
    4d8a:	f85d fb04 	ldr.w	pc, [sp], #4
    4d8e:	bf00      	nop
    4d90:	20000110 	.word	0x20000110

00004d94 <svcRtxKernelUnlock>:

/// Unlock the RTOS Kernel scheduler.
/// \note API identical to osKernelUnlock
int32_t svcRtxKernelUnlock (void) {
    4d94:	b500      	push	{lr}
    4d96:	b083      	sub	sp, #12
  int32_t lock;

  switch (osRtxInfo.kernel.state) {
    4d98:	4b11      	ldr	r3, [pc, #68]	; (4de0 <svcRtxKernelUnlock+0x4c>)
    4d9a:	7a1b      	ldrb	r3, [r3, #8]
    4d9c:	2b02      	cmp	r3, #2
    4d9e:	d002      	beq.n	4da6 <svcRtxKernelUnlock+0x12>
    4da0:	2b03      	cmp	r3, #3
    4da2:	d006      	beq.n	4db2 <svcRtxKernelUnlock+0x1e>
    4da4:	e00e      	b.n	4dc4 <svcRtxKernelUnlock+0x30>
    case osRtxKernelRunning:
      EvrRtxKernelUnlocked(0);
    4da6:	2000      	movs	r0, #0
    4da8:	f7ff fc83 	bl	46b2 <EvrRtxKernelUnlocked>
      lock = 0;
    4dac:	2300      	movs	r3, #0
    4dae:	9301      	str	r3, [sp, #4]
      break;
    4db0:	e010      	b.n	4dd4 <svcRtxKernelUnlock+0x40>
    case osRtxKernelLocked:
      osRtxInfo.kernel.state = osRtxKernelRunning;
    4db2:	4b0b      	ldr	r3, [pc, #44]	; (4de0 <svcRtxKernelUnlock+0x4c>)
    4db4:	2202      	movs	r2, #2
    4db6:	721a      	strb	r2, [r3, #8]
      EvrRtxKernelUnlocked(1);
    4db8:	2001      	movs	r0, #1
    4dba:	f7ff fc7a 	bl	46b2 <EvrRtxKernelUnlocked>
      lock = 1;
    4dbe:	2301      	movs	r3, #1
    4dc0:	9301      	str	r3, [sp, #4]
      break;
    4dc2:	e007      	b.n	4dd4 <svcRtxKernelUnlock+0x40>
    default:
      EvrRtxKernelError((int32_t)osError);
    4dc4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4dc8:	f7ff fb54 	bl	4474 <EvrRtxKernelError>
      lock = (int32_t)osError;
    4dcc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4dd0:	9301      	str	r3, [sp, #4]
      break;
    4dd2:	bf00      	nop
  }
  return lock;
    4dd4:	9b01      	ldr	r3, [sp, #4]
}
    4dd6:	4618      	mov	r0, r3
    4dd8:	b003      	add	sp, #12
    4dda:	f85d fb04 	ldr.w	pc, [sp], #4
    4dde:	bf00      	nop
    4de0:	20000110 	.word	0x20000110

00004de4 <osKernelInitialize>:


//  ==== Public API ====

/// Initialize the RTOS Kernel.
osStatus_t osKernelInitialize (void) {
    4de4:	b500      	push	{lr}
    4de6:	b083      	sub	sp, #12
  osStatus_t status;

  EvrRtxKernelInitialize();
    4de8:	f7ff fc4d 	bl	4686 <EvrRtxKernelInitialize>
  if (IsIrqMode() || IsIrqMasked()) {
    4dec:	f7ff fd75 	bl	48da <IsIrqMode>
    4df0:	4603      	mov	r3, r0
    4df2:	2b00      	cmp	r3, #0
    4df4:	d104      	bne.n	4e00 <osKernelInitialize+0x1c>
    4df6:	f7ff fd7d 	bl	48f4 <IsIrqMasked>
    4dfa:	4603      	mov	r3, r0
    4dfc:	2b00      	cmp	r3, #0
    4dfe:	d007      	beq.n	4e10 <osKernelInitialize+0x2c>
    EvrRtxKernelError((int32_t)osErrorISR);
    4e00:	f06f 0005 	mvn.w	r0, #5
    4e04:	f7ff fb36 	bl	4474 <EvrRtxKernelError>
    status = osErrorISR;
    4e08:	f06f 0305 	mvn.w	r3, #5
    4e0c:	9301      	str	r3, [sp, #4]
    4e0e:	e004      	b.n	4e1a <osKernelInitialize+0x36>
SVC0_0 (KernelInitialize,       osStatus_t)
    4e10:	4b04      	ldr	r3, [pc, #16]	; (4e24 <osKernelInitialize+0x40>)
    4e12:	469c      	mov	ip, r3
    4e14:	df00      	svc	0
    4e16:	4603      	mov	r3, r0
  } else {
    status = __svcKernelInitialize();
    4e18:	9301      	str	r3, [sp, #4]
  }
  return status;
    4e1a:	9b01      	ldr	r3, [sp, #4]
}
    4e1c:	4618      	mov	r0, r3
    4e1e:	b003      	add	sp, #12
    4e20:	f85d fb04 	ldr.w	pc, [sp], #4
    4e24:	00004981 	.word	0x00004981

00004e28 <osKernelGetState>:
  }
  return status;
}

/// Get the current RTOS Kernel state.
osKernelState_t osKernelGetState (void) {
    4e28:	b500      	push	{lr}
    4e2a:	b083      	sub	sp, #12
  osKernelState_t state;

  if (IsPrivileged() || IsIrqMode() || IsIrqMasked()) {
    4e2c:	f7ff fd46 	bl	48bc <IsPrivileged>
    4e30:	4603      	mov	r3, r0
    4e32:	2b00      	cmp	r3, #0
    4e34:	d109      	bne.n	4e4a <osKernelGetState+0x22>
    4e36:	f7ff fd50 	bl	48da <IsIrqMode>
    4e3a:	4603      	mov	r3, r0
    4e3c:	2b00      	cmp	r3, #0
    4e3e:	d104      	bne.n	4e4a <osKernelGetState+0x22>
    4e40:	f7ff fd58 	bl	48f4 <IsIrqMasked>
    4e44:	4603      	mov	r3, r0
    4e46:	2b00      	cmp	r3, #0
    4e48:	d003      	beq.n	4e52 <osKernelGetState+0x2a>
    state = svcRtxKernelGetState();
    4e4a:	f7ff ff03 	bl	4c54 <svcRtxKernelGetState>
    4e4e:	9001      	str	r0, [sp, #4]
    4e50:	e004      	b.n	4e5c <osKernelGetState+0x34>
SVC0_0 (KernelGetState,         osKernelState_t)
    4e52:	4b05      	ldr	r3, [pc, #20]	; (4e68 <osKernelGetState+0x40>)
    4e54:	469c      	mov	ip, r3
    4e56:	df00      	svc	0
    4e58:	4603      	mov	r3, r0
  } else {
    state =  __svcKernelGetState();
    4e5a:	9301      	str	r3, [sp, #4]
  }
  return state;
    4e5c:	9b01      	ldr	r3, [sp, #4]
}
    4e5e:	4618      	mov	r0, r3
    4e60:	b003      	add	sp, #12
    4e62:	f85d fb04 	ldr.w	pc, [sp], #4
    4e66:	bf00      	nop
    4e68:	00004c55 	.word	0x00004c55

00004e6c <osKernelStart>:

/// Start the RTOS Kernel scheduler.
osStatus_t osKernelStart (void) {
    4e6c:	b500      	push	{lr}
    4e6e:	b083      	sub	sp, #12
  osStatus_t status;

  EvrRtxKernelStart();
    4e70:	f7ff fc12 	bl	4698 <EvrRtxKernelStart>
  if (IsIrqMode() || IsIrqMasked()) {
    4e74:	f7ff fd31 	bl	48da <IsIrqMode>
    4e78:	4603      	mov	r3, r0
    4e7a:	2b00      	cmp	r3, #0
    4e7c:	d104      	bne.n	4e88 <osKernelStart+0x1c>
    4e7e:	f7ff fd39 	bl	48f4 <IsIrqMasked>
    4e82:	4603      	mov	r3, r0
    4e84:	2b00      	cmp	r3, #0
    4e86:	d007      	beq.n	4e98 <osKernelStart+0x2c>
    EvrRtxKernelError((int32_t)osErrorISR);
    4e88:	f06f 0005 	mvn.w	r0, #5
    4e8c:	f7ff faf2 	bl	4474 <EvrRtxKernelError>
    status = osErrorISR;
    4e90:	f06f 0305 	mvn.w	r3, #5
    4e94:	9301      	str	r3, [sp, #4]
    4e96:	e016      	b.n	4ec6 <osKernelStart+0x5a>
  } else {
    /* Call the pre-start event (from unprivileged mode) if the handler exists
    * and the kernel is not running. */
    /* FIXME osEventObs needs to be readable but not writable from unprivileged
    * code. */
    if (osKernelGetState() != osKernelRunning && osEventObs && osEventObs->pre_start) {
    4e98:	f7ff ffc6 	bl	4e28 <osKernelGetState>
    4e9c:	4603      	mov	r3, r0
    4e9e:	2b02      	cmp	r3, #2
    4ea0:	d00c      	beq.n	4ebc <osKernelStart+0x50>
    4ea2:	4b0b      	ldr	r3, [pc, #44]	; (4ed0 <osKernelStart+0x64>)
    4ea4:	681b      	ldr	r3, [r3, #0]
    4ea6:	2b00      	cmp	r3, #0
    4ea8:	d008      	beq.n	4ebc <osKernelStart+0x50>
    4eaa:	4b09      	ldr	r3, [pc, #36]	; (4ed0 <osKernelStart+0x64>)
    4eac:	681b      	ldr	r3, [r3, #0]
    4eae:	685b      	ldr	r3, [r3, #4]
    4eb0:	2b00      	cmp	r3, #0
    4eb2:	d003      	beq.n	4ebc <osKernelStart+0x50>
      osEventObs->pre_start();
    4eb4:	4b06      	ldr	r3, [pc, #24]	; (4ed0 <osKernelStart+0x64>)
    4eb6:	681b      	ldr	r3, [r3, #0]
    4eb8:	685b      	ldr	r3, [r3, #4]
    4eba:	4798      	blx	r3
SVC0_0 (KernelStart,            osStatus_t)
    4ebc:	4b05      	ldr	r3, [pc, #20]	; (4ed4 <osKernelStart+0x68>)
    4ebe:	469c      	mov	ip, r3
    4ec0:	df00      	svc	0
    4ec2:	4603      	mov	r3, r0
    }
    status = __svcKernelStart();
    4ec4:	9301      	str	r3, [sp, #4]
  }
  return status;
    4ec6:	9b01      	ldr	r3, [sp, #4]
}
    4ec8:	4618      	mov	r0, r3
    4eca:	b003      	add	sp, #12
    4ecc:	f85d fb04 	ldr.w	pc, [sp], #4
    4ed0:	20002f58 	.word	0x20002f58
    4ed4:	00004c71 	.word	0x00004c71

00004ed8 <osKernelLock>:

/// Lock the RTOS Kernel scheduler.
int32_t osKernelLock (void) {
    4ed8:	b500      	push	{lr}
    4eda:	b083      	sub	sp, #12
  int32_t lock;

  EvrRtxKernelLock();
    4edc:	f7ff fbe0 	bl	46a0 <EvrRtxKernelLock>
  if (IsIrqMode() || IsIrqMasked()) {
    4ee0:	f7ff fcfb 	bl	48da <IsIrqMode>
    4ee4:	4603      	mov	r3, r0
    4ee6:	2b00      	cmp	r3, #0
    4ee8:	d104      	bne.n	4ef4 <osKernelLock+0x1c>
    4eea:	f7ff fd03 	bl	48f4 <IsIrqMasked>
    4eee:	4603      	mov	r3, r0
    4ef0:	2b00      	cmp	r3, #0
    4ef2:	d007      	beq.n	4f04 <osKernelLock+0x2c>
    EvrRtxKernelError((int32_t)osErrorISR);
    4ef4:	f06f 0005 	mvn.w	r0, #5
    4ef8:	f7ff fabc 	bl	4474 <EvrRtxKernelError>
    lock = (int32_t)osErrorISR;
    4efc:	f06f 0305 	mvn.w	r3, #5
    4f00:	9301      	str	r3, [sp, #4]
    4f02:	e004      	b.n	4f0e <osKernelLock+0x36>
SVC0_0 (KernelLock,             int32_t)
    4f04:	4b04      	ldr	r3, [pc, #16]	; (4f18 <osKernelLock+0x40>)
    4f06:	469c      	mov	ip, r3
    4f08:	df00      	svc	0
    4f0a:	4603      	mov	r3, r0
  } else {
    lock = __svcKernelLock();
    4f0c:	9301      	str	r3, [sp, #4]
  }
  return lock;
    4f0e:	9b01      	ldr	r3, [sp, #4]
}
    4f10:	4618      	mov	r0, r3
    4f12:	b003      	add	sp, #12
    4f14:	f85d fb04 	ldr.w	pc, [sp], #4
    4f18:	00004d45 	.word	0x00004d45

00004f1c <osKernelUnlock>:

/// Unlock the RTOS Kernel scheduler.
int32_t osKernelUnlock (void) {
    4f1c:	b500      	push	{lr}
    4f1e:	b083      	sub	sp, #12
  int32_t lock;

  EvrRtxKernelUnlock();
    4f20:	f7ff fbc5 	bl	46ae <EvrRtxKernelUnlock>
  if (IsIrqMode() || IsIrqMasked()) {
    4f24:	f7ff fcd9 	bl	48da <IsIrqMode>
    4f28:	4603      	mov	r3, r0
    4f2a:	2b00      	cmp	r3, #0
    4f2c:	d104      	bne.n	4f38 <osKernelUnlock+0x1c>
    4f2e:	f7ff fce1 	bl	48f4 <IsIrqMasked>
    4f32:	4603      	mov	r3, r0
    4f34:	2b00      	cmp	r3, #0
    4f36:	d007      	beq.n	4f48 <osKernelUnlock+0x2c>
    EvrRtxKernelError((int32_t)osErrorISR);
    4f38:	f06f 0005 	mvn.w	r0, #5
    4f3c:	f7ff fa9a 	bl	4474 <EvrRtxKernelError>
    lock = (int32_t)osErrorISR;
    4f40:	f06f 0305 	mvn.w	r3, #5
    4f44:	9301      	str	r3, [sp, #4]
    4f46:	e004      	b.n	4f52 <osKernelUnlock+0x36>
SVC0_0 (KernelUnlock,           int32_t)
    4f48:	4b04      	ldr	r3, [pc, #16]	; (4f5c <osKernelUnlock+0x40>)
    4f4a:	469c      	mov	ip, r3
    4f4c:	df00      	svc	0
    4f4e:	4603      	mov	r3, r0
  } else {
    lock = __svcKernelUnlock();
    4f50:	9301      	str	r3, [sp, #4]
  }
  return lock;
    4f52:	9b01      	ldr	r3, [sp, #4]
}
    4f54:	4618      	mov	r0, r3
    4f56:	b003      	add	sp, #12
    4f58:	f85d fb04 	ldr.w	pc, [sp], #4
    4f5c:	00004d95 	.word	0x00004d95

00004f60 <MemHeadPtr>:
//  Memory Block Info: Length = <31:2>:'00', Type = <1:0>
#define MB_INFO_LEN_MASK        0xFFFFFFFCU     // Length mask
#define MB_INFO_TYPE_MASK       0x00000003U     // Type mask

//  Memory Head Pointer
__STATIC_INLINE mem_head_t *MemHeadPtr (void *mem) {
    4f60:	b082      	sub	sp, #8
    4f62:	9001      	str	r0, [sp, #4]
  //lint -e{9079} -e{9087} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
  return ((mem_head_t *)mem);
    4f64:	9b01      	ldr	r3, [sp, #4]
}
    4f66:	4618      	mov	r0, r3
    4f68:	b002      	add	sp, #8
    4f6a:	4770      	bx	lr

00004f6c <MemBlockPtr>:

//  Memory Block Pointer
__STATIC_INLINE mem_block_t *MemBlockPtr (void *mem, uint32_t offset) {
    4f6c:	b084      	sub	sp, #16
    4f6e:	9001      	str	r0, [sp, #4]
    4f70:	9100      	str	r1, [sp, #0]
  uint32_t     addr;
  mem_block_t *ptr;

  //lint --e{923} --e{9078} "cast between pointer and unsigned int" [MISRA Note 8]
  addr = (uint32_t)mem + offset;
    4f72:	9a01      	ldr	r2, [sp, #4]
    4f74:	9b00      	ldr	r3, [sp, #0]
    4f76:	4413      	add	r3, r2
    4f78:	9303      	str	r3, [sp, #12]
  ptr  = (mem_block_t *)addr;
    4f7a:	9b03      	ldr	r3, [sp, #12]
    4f7c:	9302      	str	r3, [sp, #8]

  return ptr;
    4f7e:	9b02      	ldr	r3, [sp, #8]
}
    4f80:	4618      	mov	r0, r3
    4f82:	b004      	add	sp, #16
    4f84:	4770      	bx	lr

00004f86 <osRtxMemoryInit>:

/// Initialize Memory Pool with variable block size.
/// \param[in]  mem             pointer to memory pool.
/// \param[in]  size            size of a memory pool in bytes.
/// \return 1 - success, 0 - failure.
__WEAK uint32_t osRtxMemoryInit (void *mem, uint32_t size) {
    4f86:	b500      	push	{lr}
    4f88:	b085      	sub	sp, #20
    4f8a:	9001      	str	r0, [sp, #4]
    4f8c:	9100      	str	r1, [sp, #0]
  mem_head_t  *head;
  mem_block_t *ptr;

  // Check parameters
  //lint -e{923} "cast from pointer to unsigned int" [MISRA Note 7]
  if ((mem == NULL) || (((uint32_t)mem & 7U) != 0U) || ((size & 7U) != 0U) ||
    4f8e:	9b01      	ldr	r3, [sp, #4]
    4f90:	2b00      	cmp	r3, #0
    4f92:	d00c      	beq.n	4fae <osRtxMemoryInit+0x28>
    4f94:	9b01      	ldr	r3, [sp, #4]
    4f96:	f003 0307 	and.w	r3, r3, #7
    4f9a:	2b00      	cmp	r3, #0
    4f9c:	d107      	bne.n	4fae <osRtxMemoryInit+0x28>
    4f9e:	9b00      	ldr	r3, [sp, #0]
    4fa0:	f003 0307 	and.w	r3, r3, #7
    4fa4:	2b00      	cmp	r3, #0
    4fa6:	d102      	bne.n	4fae <osRtxMemoryInit+0x28>
    4fa8:	9b00      	ldr	r3, [sp, #0]
    4faa:	2b17      	cmp	r3, #23
    4fac:	d806      	bhi.n	4fbc <osRtxMemoryInit+0x36>
      (size < (sizeof(mem_head_t) + (2U*sizeof(mem_block_t))))) {
    EvrRtxMemoryInit(mem, size, 0U);
    4fae:	2200      	movs	r2, #0
    4fb0:	9900      	ldr	r1, [sp, #0]
    4fb2:	9801      	ldr	r0, [sp, #4]
    4fb4:	f7ff fb3c 	bl	4630 <EvrRtxMemoryInit>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    4fb8:	2300      	movs	r3, #0
    4fba:	e028      	b.n	500e <osRtxMemoryInit+0x88>
  }

  // Initialize memory pool header
  head = MemHeadPtr(mem);
    4fbc:	9801      	ldr	r0, [sp, #4]
    4fbe:	f7ff ffcf 	bl	4f60 <MemHeadPtr>
    4fc2:	9003      	str	r0, [sp, #12]
  head->size = size;
    4fc4:	9b03      	ldr	r3, [sp, #12]
    4fc6:	9a00      	ldr	r2, [sp, #0]
    4fc8:	601a      	str	r2, [r3, #0]
  head->used = sizeof(mem_head_t) + sizeof(mem_block_t);
    4fca:	9b03      	ldr	r3, [sp, #12]
    4fcc:	2210      	movs	r2, #16
    4fce:	605a      	str	r2, [r3, #4]

  // Initialize first and last block header
  ptr = MemBlockPtr(mem, sizeof(mem_head_t));
    4fd0:	2108      	movs	r1, #8
    4fd2:	9801      	ldr	r0, [sp, #4]
    4fd4:	f7ff ffca 	bl	4f6c <MemBlockPtr>
    4fd8:	9002      	str	r0, [sp, #8]
  ptr->next = MemBlockPtr(mem, size - sizeof(mem_block_t));
    4fda:	9b00      	ldr	r3, [sp, #0]
    4fdc:	3b08      	subs	r3, #8
    4fde:	4619      	mov	r1, r3
    4fe0:	9801      	ldr	r0, [sp, #4]
    4fe2:	f7ff ffc3 	bl	4f6c <MemBlockPtr>
    4fe6:	4602      	mov	r2, r0
    4fe8:	9b02      	ldr	r3, [sp, #8]
    4fea:	601a      	str	r2, [r3, #0]
  ptr->next->next = NULL;
    4fec:	9b02      	ldr	r3, [sp, #8]
    4fee:	681b      	ldr	r3, [r3, #0]
    4ff0:	2200      	movs	r2, #0
    4ff2:	601a      	str	r2, [r3, #0]
  ptr->next->info = sizeof(mem_head_t) + sizeof(mem_block_t);
    4ff4:	9b02      	ldr	r3, [sp, #8]
    4ff6:	681b      	ldr	r3, [r3, #0]
    4ff8:	2210      	movs	r2, #16
    4ffa:	605a      	str	r2, [r3, #4]
  ptr->info = 0U;
    4ffc:	9b02      	ldr	r3, [sp, #8]
    4ffe:	2200      	movs	r2, #0
    5000:	605a      	str	r2, [r3, #4]

  EvrRtxMemoryInit(mem, size, 1U);
    5002:	2201      	movs	r2, #1
    5004:	9900      	ldr	r1, [sp, #0]
    5006:	9801      	ldr	r0, [sp, #4]
    5008:	f7ff fb12 	bl	4630 <EvrRtxMemoryInit>

  return 1U;
    500c:	2301      	movs	r3, #1
}
    500e:	4618      	mov	r0, r3
    5010:	b005      	add	sp, #20
    5012:	f85d fb04 	ldr.w	pc, [sp], #4

00005016 <osRtxMemoryAlloc>:
/// Allocate a memory block from a Memory Pool.
/// \param[in]  mem             pointer to memory pool.
/// \param[in]  size            size of a memory block in bytes.
/// \param[in]  type            memory block type: 0 - generic, 1 - control block
/// \return allocated memory block or NULL in case of no memory is available.
__WEAK void *osRtxMemoryAlloc (void *mem, uint32_t size, uint32_t type) {
    5016:	b510      	push	{r4, lr}
    5018:	b08a      	sub	sp, #40	; 0x28
    501a:	9003      	str	r0, [sp, #12]
    501c:	9102      	str	r1, [sp, #8]
    501e:	9201      	str	r2, [sp, #4]
  mem_block_t *p, *p_new;
  uint32_t     block_size;
  uint32_t     hole_size;

  // Check parameters
  if ((mem == NULL) || (size == 0U) || ((type & ~MB_INFO_TYPE_MASK) != 0U)) {
    5020:	9b03      	ldr	r3, [sp, #12]
    5022:	2b00      	cmp	r3, #0
    5024:	d007      	beq.n	5036 <osRtxMemoryAlloc+0x20>
    5026:	9b02      	ldr	r3, [sp, #8]
    5028:	2b00      	cmp	r3, #0
    502a:	d004      	beq.n	5036 <osRtxMemoryAlloc+0x20>
    502c:	9b01      	ldr	r3, [sp, #4]
    502e:	f023 0303 	bic.w	r3, r3, #3
    5032:	2b00      	cmp	r3, #0
    5034:	d007      	beq.n	5046 <osRtxMemoryAlloc+0x30>
    EvrRtxMemoryAlloc(mem, size, type, NULL);
    5036:	2300      	movs	r3, #0
    5038:	9a01      	ldr	r2, [sp, #4]
    503a:	9902      	ldr	r1, [sp, #8]
    503c:	9803      	ldr	r0, [sp, #12]
    503e:	f7ff fafe 	bl	463e <EvrRtxMemoryAlloc>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return NULL;
    5042:	2300      	movs	r3, #0
    5044:	e080      	b.n	5148 <osRtxMemoryAlloc+0x132>
  }

  // Add block header to size
  block_size = size + sizeof(mem_block_t);
    5046:	9b02      	ldr	r3, [sp, #8]
    5048:	3308      	adds	r3, #8
    504a:	9307      	str	r3, [sp, #28]
  // Make sure that block is 8-byte aligned
  block_size = (block_size + 7U) & ~((uint32_t)7U);
    504c:	9b07      	ldr	r3, [sp, #28]
    504e:	3307      	adds	r3, #7
    5050:	f023 0307 	bic.w	r3, r3, #7
    5054:	9307      	str	r3, [sp, #28]

  // Search for hole big enough
  p = MemBlockPtr(mem, sizeof(mem_head_t));
    5056:	2108      	movs	r1, #8
    5058:	9803      	ldr	r0, [sp, #12]
    505a:	f7ff ff87 	bl	4f6c <MemBlockPtr>
    505e:	9008      	str	r0, [sp, #32]
  for (;;) {
    //lint -e{923} -e{9078} "cast from pointer to unsigned int"
    hole_size  = (uint32_t)p->next - (uint32_t)p;
    5060:	9b08      	ldr	r3, [sp, #32]
    5062:	681b      	ldr	r3, [r3, #0]
    5064:	461a      	mov	r2, r3
    5066:	9b08      	ldr	r3, [sp, #32]
    5068:	1ad3      	subs	r3, r2, r3
    506a:	9306      	str	r3, [sp, #24]
    hole_size -= p->info & MB_INFO_LEN_MASK;
    506c:	9b08      	ldr	r3, [sp, #32]
    506e:	685b      	ldr	r3, [r3, #4]
    5070:	f023 0303 	bic.w	r3, r3, #3
    5074:	9a06      	ldr	r2, [sp, #24]
    5076:	1ad3      	subs	r3, r2, r3
    5078:	9306      	str	r3, [sp, #24]
    if (hole_size >= block_size) {
    507a:	9a06      	ldr	r2, [sp, #24]
    507c:	9b07      	ldr	r3, [sp, #28]
    507e:	429a      	cmp	r2, r3
    5080:	d20e      	bcs.n	50a0 <osRtxMemoryAlloc+0x8a>
      // Hole found
      break;
    }
    p = p->next;
    5082:	9b08      	ldr	r3, [sp, #32]
    5084:	681b      	ldr	r3, [r3, #0]
    5086:	9308      	str	r3, [sp, #32]
    if (p->next == NULL) {
    5088:	9b08      	ldr	r3, [sp, #32]
    508a:	681b      	ldr	r3, [r3, #0]
    508c:	2b00      	cmp	r3, #0
    508e:	d1e7      	bne.n	5060 <osRtxMemoryAlloc+0x4a>
      // Failed (end of list)
      EvrRtxMemoryAlloc(mem, size, type, NULL);
    5090:	2300      	movs	r3, #0
    5092:	9a01      	ldr	r2, [sp, #4]
    5094:	9902      	ldr	r1, [sp, #8]
    5096:	9803      	ldr	r0, [sp, #12]
    5098:	f7ff fad1 	bl	463e <EvrRtxMemoryAlloc>
      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
      return NULL;
    509c:	2300      	movs	r3, #0
    509e:	e053      	b.n	5148 <osRtxMemoryAlloc+0x132>
      break;
    50a0:	bf00      	nop
    }
  }

  // Update used memory
  (MemHeadPtr(mem))->used += block_size;
    50a2:	9803      	ldr	r0, [sp, #12]
    50a4:	f7ff ff5c 	bl	4f60 <MemHeadPtr>
    50a8:	4603      	mov	r3, r0
    50aa:	6859      	ldr	r1, [r3, #4]
    50ac:	9a07      	ldr	r2, [sp, #28]
    50ae:	440a      	add	r2, r1
    50b0:	605a      	str	r2, [r3, #4]

  // Update max used memory
  p_new = MemBlockPtr(mem, (MemHeadPtr(mem))->size - sizeof(mem_block_t));
    50b2:	9803      	ldr	r0, [sp, #12]
    50b4:	f7ff ff54 	bl	4f60 <MemHeadPtr>
    50b8:	4603      	mov	r3, r0
    50ba:	681b      	ldr	r3, [r3, #0]
    50bc:	3b08      	subs	r3, #8
    50be:	4619      	mov	r1, r3
    50c0:	9803      	ldr	r0, [sp, #12]
    50c2:	f7ff ff53 	bl	4f6c <MemBlockPtr>
    50c6:	9005      	str	r0, [sp, #20]
  if (p_new->info < (MemHeadPtr(mem))->used) {
    50c8:	9b05      	ldr	r3, [sp, #20]
    50ca:	685c      	ldr	r4, [r3, #4]
    50cc:	9803      	ldr	r0, [sp, #12]
    50ce:	f7ff ff47 	bl	4f60 <MemHeadPtr>
    50d2:	4603      	mov	r3, r0
    50d4:	685b      	ldr	r3, [r3, #4]
    50d6:	429c      	cmp	r4, r3
    50d8:	d206      	bcs.n	50e8 <osRtxMemoryAlloc+0xd2>
    p_new->info = (MemHeadPtr(mem))->used;
    50da:	9803      	ldr	r0, [sp, #12]
    50dc:	f7ff ff40 	bl	4f60 <MemHeadPtr>
    50e0:	4603      	mov	r3, r0
    50e2:	685a      	ldr	r2, [r3, #4]
    50e4:	9b05      	ldr	r3, [sp, #20]
    50e6:	605a      	str	r2, [r3, #4]
  }

  // Allocate block
  if (p->info == 0U) {
    50e8:	9b08      	ldr	r3, [sp, #32]
    50ea:	685b      	ldr	r3, [r3, #4]
    50ec:	2b00      	cmp	r3, #0
    50ee:	d10a      	bne.n	5106 <osRtxMemoryAlloc+0xf0>
    // No block allocated, set info of first element
    p->info = block_size | type;
    50f0:	9a07      	ldr	r2, [sp, #28]
    50f2:	9b01      	ldr	r3, [sp, #4]
    50f4:	431a      	orrs	r2, r3
    50f6:	9b08      	ldr	r3, [sp, #32]
    50f8:	605a      	str	r2, [r3, #4]
    ptr = MemBlockPtr(p, sizeof(mem_block_t));
    50fa:	2108      	movs	r1, #8
    50fc:	9808      	ldr	r0, [sp, #32]
    50fe:	f7ff ff35 	bl	4f6c <MemBlockPtr>
    5102:	9009      	str	r0, [sp, #36]	; 0x24
    5104:	e019      	b.n	513a <osRtxMemoryAlloc+0x124>
  } else {
    // Insert new element into the list
    p_new = MemBlockPtr(p, p->info & MB_INFO_LEN_MASK);
    5106:	9b08      	ldr	r3, [sp, #32]
    5108:	685b      	ldr	r3, [r3, #4]
    510a:	f023 0303 	bic.w	r3, r3, #3
    510e:	4619      	mov	r1, r3
    5110:	9808      	ldr	r0, [sp, #32]
    5112:	f7ff ff2b 	bl	4f6c <MemBlockPtr>
    5116:	9005      	str	r0, [sp, #20]
    p_new->next = p->next;
    5118:	9b08      	ldr	r3, [sp, #32]
    511a:	681a      	ldr	r2, [r3, #0]
    511c:	9b05      	ldr	r3, [sp, #20]
    511e:	601a      	str	r2, [r3, #0]
    p_new->info = block_size | type;
    5120:	9a07      	ldr	r2, [sp, #28]
    5122:	9b01      	ldr	r3, [sp, #4]
    5124:	431a      	orrs	r2, r3
    5126:	9b05      	ldr	r3, [sp, #20]
    5128:	605a      	str	r2, [r3, #4]
    p->next = p_new;
    512a:	9b08      	ldr	r3, [sp, #32]
    512c:	9a05      	ldr	r2, [sp, #20]
    512e:	601a      	str	r2, [r3, #0]
    ptr = MemBlockPtr(p_new, sizeof(mem_block_t));
    5130:	2108      	movs	r1, #8
    5132:	9805      	ldr	r0, [sp, #20]
    5134:	f7ff ff1a 	bl	4f6c <MemBlockPtr>
    5138:	9009      	str	r0, [sp, #36]	; 0x24
  }

  EvrRtxMemoryAlloc(mem, size, type, ptr);
    513a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    513c:	9a01      	ldr	r2, [sp, #4]
    513e:	9902      	ldr	r1, [sp, #8]
    5140:	9803      	ldr	r0, [sp, #12]
    5142:	f7ff fa7c 	bl	463e <EvrRtxMemoryAlloc>

  return ptr;
    5146:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    5148:	4618      	mov	r0, r3
    514a:	b00a      	add	sp, #40	; 0x28
    514c:	bd10      	pop	{r4, pc}

0000514e <osRtxMemoryFree>:

/// Return an allocated memory block back to a Memory Pool.
/// \param[in]  mem             pointer to memory pool.
/// \param[in]  block           memory block to be returned to the memory pool.
/// \return 1 - success, 0 - failure.
__WEAK uint32_t osRtxMemoryFree (void *mem, void *block) {
    514e:	b500      	push	{lr}
    5150:	b087      	sub	sp, #28
    5152:	9001      	str	r0, [sp, #4]
    5154:	9100      	str	r1, [sp, #0]
  const mem_block_t *ptr;
        mem_block_t *p, *p_prev;

  // Check parameters
  if ((mem == NULL) || (block == NULL)) {
    5156:	9b01      	ldr	r3, [sp, #4]
    5158:	2b00      	cmp	r3, #0
    515a:	d002      	beq.n	5162 <osRtxMemoryFree+0x14>
    515c:	9b00      	ldr	r3, [sp, #0]
    515e:	2b00      	cmp	r3, #0
    5160:	d106      	bne.n	5170 <osRtxMemoryFree+0x22>
    EvrRtxMemoryFree(mem, block, 0U);
    5162:	2200      	movs	r2, #0
    5164:	9900      	ldr	r1, [sp, #0]
    5166:	9801      	ldr	r0, [sp, #4]
    5168:	f7ff fa71 	bl	464e <EvrRtxMemoryFree>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    516c:	2300      	movs	r3, #0
    516e:	e03e      	b.n	51ee <osRtxMemoryFree+0xa0>
  }

  // Memory block header
  ptr = MemBlockPtr(block, 0U);
    5170:	2100      	movs	r1, #0
    5172:	9800      	ldr	r0, [sp, #0]
    5174:	f7ff fefa 	bl	4f6c <MemBlockPtr>
    5178:	9003      	str	r0, [sp, #12]
  ptr--;
    517a:	9b03      	ldr	r3, [sp, #12]
    517c:	3b08      	subs	r3, #8
    517e:	9303      	str	r3, [sp, #12]

  // Search for block header
  p_prev = NULL;
    5180:	2300      	movs	r3, #0
    5182:	9304      	str	r3, [sp, #16]
  p = MemBlockPtr(mem, sizeof(mem_head_t));
    5184:	2108      	movs	r1, #8
    5186:	9801      	ldr	r0, [sp, #4]
    5188:	f7ff fef0 	bl	4f6c <MemBlockPtr>
    518c:	9005      	str	r0, [sp, #20]
  while (p != ptr) {
    518e:	e00e      	b.n	51ae <osRtxMemoryFree+0x60>
    p_prev = p;
    5190:	9b05      	ldr	r3, [sp, #20]
    5192:	9304      	str	r3, [sp, #16]
    p = p->next;
    5194:	9b05      	ldr	r3, [sp, #20]
    5196:	681b      	ldr	r3, [r3, #0]
    5198:	9305      	str	r3, [sp, #20]
    if (p == NULL) {
    519a:	9b05      	ldr	r3, [sp, #20]
    519c:	2b00      	cmp	r3, #0
    519e:	d106      	bne.n	51ae <osRtxMemoryFree+0x60>
      // Not found
      EvrRtxMemoryFree(mem, block, 0U);
    51a0:	2200      	movs	r2, #0
    51a2:	9900      	ldr	r1, [sp, #0]
    51a4:	9801      	ldr	r0, [sp, #4]
    51a6:	f7ff fa52 	bl	464e <EvrRtxMemoryFree>
      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
      return 0U;
    51aa:	2300      	movs	r3, #0
    51ac:	e01f      	b.n	51ee <osRtxMemoryFree+0xa0>
  while (p != ptr) {
    51ae:	9a05      	ldr	r2, [sp, #20]
    51b0:	9b03      	ldr	r3, [sp, #12]
    51b2:	429a      	cmp	r2, r3
    51b4:	d1ec      	bne.n	5190 <osRtxMemoryFree+0x42>
    }
  }

  // Update used memory
  (MemHeadPtr(mem))->used -= p->info & MB_INFO_LEN_MASK;
    51b6:	9801      	ldr	r0, [sp, #4]
    51b8:	f7ff fed2 	bl	4f60 <MemHeadPtr>
    51bc:	4603      	mov	r3, r0
    51be:	6859      	ldr	r1, [r3, #4]
    51c0:	9a05      	ldr	r2, [sp, #20]
    51c2:	6852      	ldr	r2, [r2, #4]
    51c4:	f022 0203 	bic.w	r2, r2, #3
    51c8:	1a8a      	subs	r2, r1, r2
    51ca:	605a      	str	r2, [r3, #4]

  // Free block
  if (p_prev == NULL) {
    51cc:	9b04      	ldr	r3, [sp, #16]
    51ce:	2b00      	cmp	r3, #0
    51d0:	d103      	bne.n	51da <osRtxMemoryFree+0x8c>
    // Release first block, only set info to 0
    p->info = 0U;
    51d2:	9b05      	ldr	r3, [sp, #20]
    51d4:	2200      	movs	r2, #0
    51d6:	605a      	str	r2, [r3, #4]
    51d8:	e003      	b.n	51e2 <osRtxMemoryFree+0x94>
  } else {
    // Discard block from chained list
    p_prev->next = p->next;
    51da:	9b05      	ldr	r3, [sp, #20]
    51dc:	681a      	ldr	r2, [r3, #0]
    51de:	9b04      	ldr	r3, [sp, #16]
    51e0:	601a      	str	r2, [r3, #0]
  }

  EvrRtxMemoryFree(mem, block, 1U);
    51e2:	2201      	movs	r2, #1
    51e4:	9900      	ldr	r1, [sp, #0]
    51e6:	9801      	ldr	r0, [sp, #4]
    51e8:	f7ff fa31 	bl	464e <EvrRtxMemoryFree>

  return 1U;
    51ec:	2301      	movs	r3, #1
}
    51ee:	4618      	mov	r0, r3
    51f0:	b007      	add	sp, #28
    51f2:	f85d fb04 	ldr.w	pc, [sp], #4

000051f6 <atomic_inc32_lt>:
  b     %B1
3
  pop   {r4,pc}
}
#else
__STATIC_INLINE uint32_t atomic_inc32_lt (uint32_t *mem, uint32_t max) {
    51f6:	b410      	push	{r4}
    51f8:	b083      	sub	sp, #12
    51fa:	9001      	str	r0, [sp, #4]
    51fc:	9100      	str	r1, [sp, #0]
#ifdef  __ICCARM__
#pragma diag_default=Pe550
#endif
  register uint32_t ret;

  __ASM volatile (
    51fe:	9b01      	ldr	r3, [sp, #4]
    5200:	9a00      	ldr	r2, [sp, #0]
    5202:	e853 1f00 	ldrex	r1, [r3]
    5206:	428a      	cmp	r2, r1
    5208:	d802      	bhi.n	5210 <atomic_inc32_lt+0x1a>
    520a:	f3bf 8f2f 	clrex
    520e:	e004      	b.n	521a <atomic_inc32_lt+0x24>
    5210:	1c48      	adds	r0, r1, #1
    5212:	e843 0400 	strex	r4, r0, [r3]
    5216:	b104      	cbz	r4, 521a <atomic_inc32_lt+0x24>
    5218:	e7f3      	b.n	5202 <atomic_inc32_lt+0xc>
    521a:	460c      	mov	r4, r1
  : [mem] "l"   (mem),
    [max] "l"   (max)
  : "cc", "memory"
  );

  return ret;
    521c:	4623      	mov	r3, r4
}
    521e:	4618      	mov	r0, r3
    5220:	b003      	add	sp, #12
    5222:	f85d 4b04 	ldr.w	r4, [sp], #4
    5226:	4770      	bx	lr

00005228 <atomic_dec32_nz>:
  b     %B1
3
  bx     lr
}
#else
__STATIC_INLINE uint32_t atomic_dec32_nz (uint32_t *mem) {
    5228:	b410      	push	{r4}
    522a:	b083      	sub	sp, #12
    522c:	9001      	str	r0, [sp, #4]
#ifdef  __ICCARM__
#pragma diag_default=Pe550
#endif
  register uint32_t ret;

  __ASM volatile (
    522e:	9b01      	ldr	r3, [sp, #4]
    5230:	e853 2f00 	ldrex	r2, [r3]
    5234:	b912      	cbnz	r2, 523c <atomic_dec32_nz+0x14>
    5236:	f3bf 8f2f 	clrex
    523a:	e004      	b.n	5246 <atomic_dec32_nz+0x1e>
    523c:	1e51      	subs	r1, r2, #1
    523e:	e843 1000 	strex	r0, r1, [r3]
    5242:	b100      	cbz	r0, 5246 <atomic_dec32_nz+0x1e>
    5244:	e7f4      	b.n	5230 <atomic_dec32_nz+0x8>
    5246:	4614      	mov	r4, r2
    [res] "=&l" (res)
  : [mem] "l"   (mem)
  : "cc", "memory"
  );

  return ret;
    5248:	4623      	mov	r3, r4
}
    524a:	4618      	mov	r0, r3
    524c:	b003      	add	sp, #12
    524e:	f85d 4b04 	ldr.w	r4, [sp], #4
    5252:	4770      	bx	lr

00005254 <atomic_link_get>:
  b     %B1
3
  bx     lr
}
#else
__STATIC_INLINE void *atomic_link_get (void **root) {
    5254:	b410      	push	{r4}
    5256:	b083      	sub	sp, #12
    5258:	9001      	str	r0, [sp, #4]
#ifdef  __ICCARM__
#pragma diag_default=Pe550
#endif
  register void    *ret;

  __ASM volatile (
    525a:	9b01      	ldr	r3, [sp, #4]
    525c:	e853 2f00 	ldrex	r2, [r3]
    5260:	b912      	cbnz	r2, 5268 <atomic_link_get+0x14>
    5262:	f3bf 8f2f 	clrex
    5266:	e004      	b.n	5272 <atomic_link_get+0x1e>
    5268:	6811      	ldr	r1, [r2, #0]
    526a:	e843 1000 	strex	r0, r1, [r3]
    526e:	b100      	cbz	r0, 5272 <atomic_link_get+0x1e>
    5270:	e7f4      	b.n	525c <atomic_link_get+0x8>
    5272:	4614      	mov	r4, r2
    [res]  "=&l" (res)
  : [root] "l"   (root)
  : "cc", "memory"
  );

  return ret;
    5274:	4623      	mov	r3, r4
}
    5276:	4618      	mov	r0, r3
    5278:	b003      	add	sp, #12
    527a:	f85d 4b04 	ldr.w	r4, [sp], #4
    527e:	4770      	bx	lr

00005280 <atomic_link_put>:
  b     %B1
2
  bx    lr
}
#else
__STATIC_INLINE void atomic_link_put (void **root, void *link) {
    5280:	b410      	push	{r4}
    5282:	b083      	sub	sp, #12
    5284:	9001      	str	r0, [sp, #4]
    5286:	9100      	str	r1, [sp, #0]
  register uint32_t val1, val2, res;
#ifdef  __ICCARM__
#pragma diag_default=Pe550
#endif

  __ASM volatile (
    5288:	9b01      	ldr	r3, [sp, #4]
    528a:	9a00      	ldr	r2, [sp, #0]
    528c:	6819      	ldr	r1, [r3, #0]
    528e:	6011      	str	r1, [r2, #0]
    5290:	f3bf 8f5f 	dmb	sy
    5294:	e853 1f00 	ldrex	r1, [r3]
    5298:	6810      	ldr	r0, [r2, #0]
    529a:	4288      	cmp	r0, r1
    529c:	d1f6      	bne.n	528c <atomic_link_put+0xc>
    529e:	e843 2400 	strex	r4, r2, [r3]
    52a2:	b104      	cbz	r4, 52a6 <atomic_link_put+0x26>
    52a4:	e7f2      	b.n	528c <atomic_link_put+0xc>
    [res]  "=&l" (res)
  : [root] "l"   (root),
    [link] "l"   (link)
  : "cc", "memory"
  );
}
    52a6:	bf00      	nop
    52a8:	b003      	add	sp, #12
    52aa:	f85d 4b04 	ldr.w	r4, [sp], #4
    52ae:	4770      	bx	lr

000052b0 <osRtxMemoryPoolInit>:
/// \param[in]  mp_info         memory pool info.
/// \param[in]  block_count     maximum number of memory blocks in memory pool.
/// \param[in]  block_size      size of a memory block in bytes.
/// \param[in]  block_mem       pointer to memory for block storage.
/// \return 1 - success, 0 - failure.
uint32_t osRtxMemoryPoolInit (os_mp_info_t *mp_info, uint32_t block_count, uint32_t block_size, void *block_mem) {
    52b0:	b500      	push	{lr}
    52b2:	b087      	sub	sp, #28
    52b4:	9003      	str	r0, [sp, #12]
    52b6:	9102      	str	r1, [sp, #8]
    52b8:	9201      	str	r2, [sp, #4]
    52ba:	9300      	str	r3, [sp, #0]
  //lint --e{9079} --e{9087} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
  void *mem;
  void *block;

  // Check parameters
  if ((mp_info == NULL) || (block_count == 0U) || (block_size  == 0U) || (block_mem  == NULL)) {
    52bc:	9b03      	ldr	r3, [sp, #12]
    52be:	2b00      	cmp	r3, #0
    52c0:	d008      	beq.n	52d4 <osRtxMemoryPoolInit+0x24>
    52c2:	9b02      	ldr	r3, [sp, #8]
    52c4:	2b00      	cmp	r3, #0
    52c6:	d005      	beq.n	52d4 <osRtxMemoryPoolInit+0x24>
    52c8:	9b01      	ldr	r3, [sp, #4]
    52ca:	2b00      	cmp	r3, #0
    52cc:	d002      	beq.n	52d4 <osRtxMemoryPoolInit+0x24>
    52ce:	9b00      	ldr	r3, [sp, #0]
    52d0:	2b00      	cmp	r3, #0
    52d2:	d101      	bne.n	52d8 <osRtxMemoryPoolInit+0x28>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    52d4:	2300      	movs	r3, #0
    52d6:	e032      	b.n	533e <osRtxMemoryPoolInit+0x8e>
  }

  // Initialize information structure
  mp_info->max_blocks  = block_count;
    52d8:	9b03      	ldr	r3, [sp, #12]
    52da:	9a02      	ldr	r2, [sp, #8]
    52dc:	601a      	str	r2, [r3, #0]
  mp_info->used_blocks = 0U;
    52de:	9b03      	ldr	r3, [sp, #12]
    52e0:	2200      	movs	r2, #0
    52e2:	605a      	str	r2, [r3, #4]
  mp_info->block_size  = block_size;
    52e4:	9b03      	ldr	r3, [sp, #12]
    52e6:	9a01      	ldr	r2, [sp, #4]
    52e8:	609a      	str	r2, [r3, #8]
  mp_info->block_base  = block_mem;
    52ea:	9b03      	ldr	r3, [sp, #12]
    52ec:	9a00      	ldr	r2, [sp, #0]
    52ee:	60da      	str	r2, [r3, #12]
  mp_info->block_free  = block_mem;
    52f0:	9b03      	ldr	r3, [sp, #12]
    52f2:	9a00      	ldr	r2, [sp, #0]
    52f4:	615a      	str	r2, [r3, #20]
  mp_info->block_lim   = &(((uint8_t *)block_mem)[block_count * block_size]);
    52f6:	9b02      	ldr	r3, [sp, #8]
    52f8:	9a01      	ldr	r2, [sp, #4]
    52fa:	fb02 f303 	mul.w	r3, r2, r3
    52fe:	9a00      	ldr	r2, [sp, #0]
    5300:	441a      	add	r2, r3
    5302:	9b03      	ldr	r3, [sp, #12]
    5304:	611a      	str	r2, [r3, #16]

  EvrRtxMemoryBlockInit(mp_info, block_count, block_size, block_mem);
    5306:	9b00      	ldr	r3, [sp, #0]
    5308:	9a01      	ldr	r2, [sp, #4]
    530a:	9902      	ldr	r1, [sp, #8]
    530c:	9803      	ldr	r0, [sp, #12]
    530e:	f7ff f9a5 	bl	465c <EvrRtxMemoryBlockInit>

  // Link all free blocks
  mem = block_mem;
    5312:	9b00      	ldr	r3, [sp, #0]
    5314:	9305      	str	r3, [sp, #20]
  while (--block_count != 0U) {
    5316:	e008      	b.n	532a <osRtxMemoryPoolInit+0x7a>
    block = &((uint8_t *)mem)[block_size];
    5318:	9a05      	ldr	r2, [sp, #20]
    531a:	9b01      	ldr	r3, [sp, #4]
    531c:	4413      	add	r3, r2
    531e:	9304      	str	r3, [sp, #16]
    *((void **)mem) = block;
    5320:	9b05      	ldr	r3, [sp, #20]
    5322:	9a04      	ldr	r2, [sp, #16]
    5324:	601a      	str	r2, [r3, #0]
    mem = block;
    5326:	9b04      	ldr	r3, [sp, #16]
    5328:	9305      	str	r3, [sp, #20]
  while (--block_count != 0U) {
    532a:	9b02      	ldr	r3, [sp, #8]
    532c:	3b01      	subs	r3, #1
    532e:	9302      	str	r3, [sp, #8]
    5330:	9b02      	ldr	r3, [sp, #8]
    5332:	2b00      	cmp	r3, #0
    5334:	d1f0      	bne.n	5318 <osRtxMemoryPoolInit+0x68>
  }
  *((void **)mem) = NULL;
    5336:	9b05      	ldr	r3, [sp, #20]
    5338:	2200      	movs	r2, #0
    533a:	601a      	str	r2, [r3, #0]

  return 1U;
    533c:	2301      	movs	r3, #1
}
    533e:	4618      	mov	r0, r3
    5340:	b007      	add	sp, #28
    5342:	f85d fb04 	ldr.w	pc, [sp], #4

00005346 <osRtxMemoryPoolAlloc>:

/// Allocate a memory block from a Memory Pool.
/// \param[in]  mp_info         memory pool info.
/// \return address of the allocated memory block or NULL in case of no memory is available.
void *osRtxMemoryPoolAlloc (os_mp_info_t *mp_info) {
    5346:	b500      	push	{lr}
    5348:	b085      	sub	sp, #20
    534a:	9001      	str	r0, [sp, #4]
#if (EXCLUSIVE_ACCESS == 0)
  uint32_t primask = __get_PRIMASK();
#endif
  void *block;

  if (mp_info == NULL) {
    534c:	9b01      	ldr	r3, [sp, #4]
    534e:	2b00      	cmp	r3, #0
    5350:	d105      	bne.n	535e <osRtxMemoryPoolAlloc+0x18>
    EvrRtxMemoryBlockAlloc(NULL, NULL);
    5352:	2100      	movs	r1, #0
    5354:	2000      	movs	r0, #0
    5356:	f7ff f989 	bl	466c <EvrRtxMemoryBlockAlloc>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return NULL;
    535a:	2300      	movs	r3, #0
    535c:	e01a      	b.n	5394 <osRtxMemoryPoolAlloc+0x4e>

  if (primask == 0U) {
    __enable_irq();
  }
#else
  if (atomic_inc32_lt(&mp_info->used_blocks, mp_info->max_blocks) < mp_info->max_blocks) {
    535e:	9b01      	ldr	r3, [sp, #4]
    5360:	1d1a      	adds	r2, r3, #4
    5362:	9b01      	ldr	r3, [sp, #4]
    5364:	681b      	ldr	r3, [r3, #0]
    5366:	4619      	mov	r1, r3
    5368:	4610      	mov	r0, r2
    536a:	f7ff ff44 	bl	51f6 <atomic_inc32_lt>
    536e:	4602      	mov	r2, r0
    5370:	9b01      	ldr	r3, [sp, #4]
    5372:	681b      	ldr	r3, [r3, #0]
    5374:	429a      	cmp	r2, r3
    5376:	d206      	bcs.n	5386 <osRtxMemoryPoolAlloc+0x40>
    block = atomic_link_get(&mp_info->block_free);
    5378:	9b01      	ldr	r3, [sp, #4]
    537a:	3314      	adds	r3, #20
    537c:	4618      	mov	r0, r3
    537e:	f7ff ff69 	bl	5254 <atomic_link_get>
    5382:	9003      	str	r0, [sp, #12]
    5384:	e001      	b.n	538a <osRtxMemoryPoolAlloc+0x44>
  } else {
    block = NULL;
    5386:	2300      	movs	r3, #0
    5388:	9303      	str	r3, [sp, #12]
  }
#endif

  EvrRtxMemoryBlockAlloc(mp_info, block);
    538a:	9903      	ldr	r1, [sp, #12]
    538c:	9801      	ldr	r0, [sp, #4]
    538e:	f7ff f96d 	bl	466c <EvrRtxMemoryBlockAlloc>

  return block;
    5392:	9b03      	ldr	r3, [sp, #12]
}
    5394:	4618      	mov	r0, r3
    5396:	b005      	add	sp, #20
    5398:	f85d fb04 	ldr.w	pc, [sp], #4

0000539c <osRtxMemoryPoolFree>:

/// Return an allocated memory block back to a Memory Pool.
/// \param[in]  mp_info         memory pool info.
/// \param[in]  block           address of the allocated memory block to be returned to the memory pool.
/// \return status code that indicates the execution status of the function.
osStatus_t osRtxMemoryPoolFree (os_mp_info_t *mp_info, void *block) {
    539c:	b500      	push	{lr}
    539e:	b085      	sub	sp, #20
    53a0:	9001      	str	r0, [sp, #4]
    53a2:	9100      	str	r1, [sp, #0]
  uint32_t primask = __get_PRIMASK();
#endif
  osStatus_t status;

  //lint -e{946} "Relational operator applied to pointers"
  if ((mp_info == NULL) || (block < mp_info->block_base) || (block >= mp_info->block_lim)) {
    53a4:	9b01      	ldr	r3, [sp, #4]
    53a6:	2b00      	cmp	r3, #0
    53a8:	d009      	beq.n	53be <osRtxMemoryPoolFree+0x22>
    53aa:	9b01      	ldr	r3, [sp, #4]
    53ac:	68da      	ldr	r2, [r3, #12]
    53ae:	9b00      	ldr	r3, [sp, #0]
    53b0:	429a      	cmp	r2, r3
    53b2:	d804      	bhi.n	53be <osRtxMemoryPoolFree+0x22>
    53b4:	9b01      	ldr	r3, [sp, #4]
    53b6:	691a      	ldr	r2, [r3, #16]
    53b8:	9b00      	ldr	r3, [sp, #0]
    53ba:	429a      	cmp	r2, r3
    53bc:	d808      	bhi.n	53d0 <osRtxMemoryPoolFree+0x34>
    EvrRtxMemoryBlockFree(mp_info, block, (int32_t)osErrorParameter);
    53be:	f06f 0203 	mvn.w	r2, #3
    53c2:	9900      	ldr	r1, [sp, #0]
    53c4:	9801      	ldr	r0, [sp, #4]
    53c6:	f7ff f957 	bl	4678 <EvrRtxMemoryBlockFree>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorParameter;
    53ca:	f06f 0303 	mvn.w	r3, #3
    53ce:	e019      	b.n	5404 <osRtxMemoryPoolFree+0x68>

  if (primask == 0U) {
    __enable_irq();
  }
#else
  if (atomic_dec32_nz(&mp_info->used_blocks) != 0U) {
    53d0:	9b01      	ldr	r3, [sp, #4]
    53d2:	3304      	adds	r3, #4
    53d4:	4618      	mov	r0, r3
    53d6:	f7ff ff27 	bl	5228 <atomic_dec32_nz>
    53da:	4603      	mov	r3, r0
    53dc:	2b00      	cmp	r3, #0
    53de:	d008      	beq.n	53f2 <osRtxMemoryPoolFree+0x56>
    atomic_link_put(&mp_info->block_free, block);
    53e0:	9b01      	ldr	r3, [sp, #4]
    53e2:	3314      	adds	r3, #20
    53e4:	9900      	ldr	r1, [sp, #0]
    53e6:	4618      	mov	r0, r3
    53e8:	f7ff ff4a 	bl	5280 <atomic_link_put>
    status = osOK;
    53ec:	2300      	movs	r3, #0
    53ee:	9303      	str	r3, [sp, #12]
    53f0:	e002      	b.n	53f8 <osRtxMemoryPoolFree+0x5c>
  } else {
    status = osErrorResource;
    53f2:	f06f 0302 	mvn.w	r3, #2
    53f6:	9303      	str	r3, [sp, #12]
  }
#endif

  EvrRtxMemoryBlockFree(mp_info, block, (int32_t)status);
    53f8:	9a03      	ldr	r2, [sp, #12]
    53fa:	9900      	ldr	r1, [sp, #0]
    53fc:	9801      	ldr	r0, [sp, #4]
    53fe:	f7ff f93b 	bl	4678 <EvrRtxMemoryBlockFree>

  return status;
    5402:	9b03      	ldr	r3, [sp, #12]
}
    5404:	4618      	mov	r0, r3
    5406:	b005      	add	sp, #20
    5408:	f85d fb04 	ldr.w	pc, [sp], #4

0000540c <IsIrqMode>:
__STATIC_INLINE bool_t IsIrqMode (void) {
    540c:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    540e:	f3ef 8305 	mrs	r3, IPSR
    5412:	9301      	str	r3, [sp, #4]
  return(result);
    5414:	9b01      	ldr	r3, [sp, #4]
  return (__get_IPSR() != 0U);
    5416:	2b00      	cmp	r3, #0
    5418:	bf14      	ite	ne
    541a:	2301      	movne	r3, #1
    541c:	2300      	moveq	r3, #0
    541e:	b2db      	uxtb	r3, r3
}
    5420:	4618      	mov	r0, r3
    5422:	b002      	add	sp, #8
    5424:	4770      	bx	lr

00005426 <IsIrqMasked>:
__STATIC_INLINE bool_t IsIrqMasked (void) {
    5426:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    5428:	f3ef 8310 	mrs	r3, PRIMASK
    542c:	9301      	str	r3, [sp, #4]
  return(result);
    542e:	9b01      	ldr	r3, [sp, #4]
  return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
    5430:	2b00      	cmp	r3, #0
    5432:	d105      	bne.n	5440 <IsIrqMasked+0x1a>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
    5434:	f3ef 8311 	mrs	r3, BASEPRI
    5438:	9300      	str	r3, [sp, #0]
  return(result);
    543a:	9b00      	ldr	r3, [sp, #0]
    543c:	2b00      	cmp	r3, #0
    543e:	d001      	beq.n	5444 <IsIrqMasked+0x1e>
    5440:	2301      	movs	r3, #1
    5442:	e000      	b.n	5446 <IsIrqMasked+0x20>
    5444:	2300      	movs	r3, #0
    5446:	f003 0301 	and.w	r3, r3, #1
    544a:	b2db      	uxtb	r3, r3
}
    544c:	4618      	mov	r0, r3
    544e:	b002      	add	sp, #8
    5450:	4770      	bx	lr

00005452 <atomic_wr8>:
__STATIC_INLINE uint8_t atomic_wr8 (uint8_t *mem, uint8_t val) {
    5452:	b410      	push	{r4}
    5454:	b083      	sub	sp, #12
    5456:	9001      	str	r0, [sp, #4]
    5458:	460b      	mov	r3, r1
    545a:	f88d 3003 	strb.w	r3, [sp, #3]
  __ASM volatile (
    545e:	9b01      	ldr	r3, [sp, #4]
    5460:	f89d 2003 	ldrb.w	r2, [sp, #3]
    5464:	e8d3 1f4f 	ldrexb	r1, [r3]
    5468:	e8c3 2f40 	strexb	r0, r2, [r3]
    546c:	b100      	cbz	r0, 5470 <atomic_wr8+0x1e>
    546e:	e7f9      	b.n	5464 <atomic_wr8+0x12>
    5470:	b2cc      	uxtb	r4, r1
  return ret;
    5472:	4623      	mov	r3, r4
}
    5474:	4618      	mov	r0, r3
    5476:	b003      	add	sp, #12
    5478:	f85d 4b04 	ldr.w	r4, [sp], #4
    547c:	4770      	bx	lr

0000547e <atomic_inc32>:
__STATIC_INLINE uint32_t atomic_inc32 (uint32_t *mem) {
    547e:	b410      	push	{r4}
    5480:	b083      	sub	sp, #12
    5482:	9001      	str	r0, [sp, #4]
  __ASM volatile (
    5484:	9b01      	ldr	r3, [sp, #4]
    5486:	e853 2f00 	ldrex	r2, [r3]
    548a:	1c51      	adds	r1, r2, #1
    548c:	e843 1000 	strex	r0, r1, [r3]
    5490:	b100      	cbz	r0, 5494 <atomic_inc32+0x16>
    5492:	e7f8      	b.n	5486 <atomic_inc32+0x8>
    5494:	4614      	mov	r4, r2
  return ret;
    5496:	4623      	mov	r3, r4
}
    5498:	4618      	mov	r0, r3
    549a:	b003      	add	sp, #12
    549c:	f85d 4b04 	ldr.w	r4, [sp], #4
    54a0:	4770      	bx	lr

000054a2 <atomic_dec32_nz>:
__STATIC_INLINE uint32_t atomic_dec32_nz (uint32_t *mem) {
    54a2:	b410      	push	{r4}
    54a4:	b083      	sub	sp, #12
    54a6:	9001      	str	r0, [sp, #4]
  __ASM volatile (
    54a8:	9b01      	ldr	r3, [sp, #4]
    54aa:	e853 2f00 	ldrex	r2, [r3]
    54ae:	b912      	cbnz	r2, 54b6 <atomic_dec32_nz+0x14>
    54b0:	f3bf 8f2f 	clrex
    54b4:	e004      	b.n	54c0 <atomic_dec32_nz+0x1e>
    54b6:	1e51      	subs	r1, r2, #1
    54b8:	e843 1000 	strex	r0, r1, [r3]
    54bc:	b100      	cbz	r0, 54c0 <atomic_dec32_nz+0x1e>
    54be:	e7f4      	b.n	54aa <atomic_dec32_nz+0x8>
    54c0:	4614      	mov	r4, r2
  return ret;
    54c2:	4623      	mov	r3, r4
}
    54c4:	4618      	mov	r0, r3
    54c6:	b003      	add	sp, #12
    54c8:	f85d 4b04 	ldr.w	r4, [sp], #4
    54cc:	4770      	bx	lr

000054ce <osRtxMessageQueueId>:
__STATIC_INLINE os_message_queue_t *osRtxMessageQueueId (osMessageQueueId_t mq_id) {
    54ce:	b082      	sub	sp, #8
    54d0:	9001      	str	r0, [sp, #4]
  return ((os_message_queue_t *)mq_id);
    54d2:	9b01      	ldr	r3, [sp, #4]
}
    54d4:	4618      	mov	r0, r3
    54d6:	b002      	add	sp, #8
    54d8:	4770      	bx	lr

000054da <osRtxObject>:
__STATIC_INLINE os_object_t *osRtxObject (void *object) {
    54da:	b082      	sub	sp, #8
    54dc:	9001      	str	r0, [sp, #4]
  return ((os_object_t *)object);
    54de:	9b01      	ldr	r3, [sp, #4]
}
    54e0:	4618      	mov	r0, r3
    54e2:	b002      	add	sp, #8
    54e4:	4770      	bx	lr
	...

000054e8 <osRtxThreadGetRunning>:
  return osRtxInfo.kernel.state;
}

// Thread Get/Set Running
__STATIC_INLINE os_thread_t *osRtxThreadGetRunning (void) {
  return osRtxInfo.thread.run.curr;
    54e8:	4b01      	ldr	r3, [pc, #4]	; (54f0 <osRtxThreadGetRunning+0x8>)
    54ea:	695b      	ldr	r3, [r3, #20]
}
    54ec:	4618      	mov	r0, r3
    54ee:	4770      	bx	lr
    54f0:	20000110 	.word	0x20000110

000054f4 <MessageQueuePut>:
//  ==== Helper functions ====

/// Put a Message into Queue sorted by Priority (Highest at Head).
/// \param[in]  mq              message queue object.
/// \param[in]  msg             message object.
static void MessageQueuePut (os_message_queue_t *mq, os_message_t *msg) {
    54f4:	b500      	push	{lr}
    54f6:	b085      	sub	sp, #20
    54f8:	9001      	str	r0, [sp, #4]
    54fa:	9100      	str	r1, [sp, #0]
#if (EXCLUSIVE_ACCESS == 0)
  uint32_t      primask = __get_PRIMASK();
#endif
  os_message_t *prev, *next;

  if (mq->msg_last != NULL) {
    54fc:	9b01      	ldr	r3, [sp, #4]
    54fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    5500:	2b00      	cmp	r3, #0
    5502:	d02e      	beq.n	5562 <MessageQueuePut+0x6e>
    prev = mq->msg_last;
    5504:	9b01      	ldr	r3, [sp, #4]
    5506:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    5508:	9303      	str	r3, [sp, #12]
    next = NULL;
    550a:	2300      	movs	r3, #0
    550c:	9302      	str	r3, [sp, #8]
    while ((prev != NULL) && (prev->priority < msg->priority)) {
    550e:	e004      	b.n	551a <MessageQueuePut+0x26>
      next = prev;
    5510:	9b03      	ldr	r3, [sp, #12]
    5512:	9302      	str	r3, [sp, #8]
      prev = prev->prev;
    5514:	9b03      	ldr	r3, [sp, #12]
    5516:	685b      	ldr	r3, [r3, #4]
    5518:	9303      	str	r3, [sp, #12]
    while ((prev != NULL) && (prev->priority < msg->priority)) {
    551a:	9b03      	ldr	r3, [sp, #12]
    551c:	2b00      	cmp	r3, #0
    551e:	d005      	beq.n	552c <MessageQueuePut+0x38>
    5520:	9b03      	ldr	r3, [sp, #12]
    5522:	78da      	ldrb	r2, [r3, #3]
    5524:	9b00      	ldr	r3, [sp, #0]
    5526:	78db      	ldrb	r3, [r3, #3]
    5528:	429a      	cmp	r2, r3
    552a:	d3f1      	bcc.n	5510 <MessageQueuePut+0x1c>
    }
    msg->prev = prev;
    552c:	9b00      	ldr	r3, [sp, #0]
    552e:	9a03      	ldr	r2, [sp, #12]
    5530:	605a      	str	r2, [r3, #4]
    msg->next = next;
    5532:	9b00      	ldr	r3, [sp, #0]
    5534:	9a02      	ldr	r2, [sp, #8]
    5536:	609a      	str	r2, [r3, #8]
    if (prev != NULL) {
    5538:	9b03      	ldr	r3, [sp, #12]
    553a:	2b00      	cmp	r3, #0
    553c:	d003      	beq.n	5546 <MessageQueuePut+0x52>
      prev->next = msg;
    553e:	9b03      	ldr	r3, [sp, #12]
    5540:	9a00      	ldr	r2, [sp, #0]
    5542:	609a      	str	r2, [r3, #8]
    5544:	e002      	b.n	554c <MessageQueuePut+0x58>
    } else {
      mq->msg_first = msg;
    5546:	9b01      	ldr	r3, [sp, #4]
    5548:	9a00      	ldr	r2, [sp, #0]
    554a:	62da      	str	r2, [r3, #44]	; 0x2c
    }
    if (next != NULL) {
    554c:	9b02      	ldr	r3, [sp, #8]
    554e:	2b00      	cmp	r3, #0
    5550:	d003      	beq.n	555a <MessageQueuePut+0x66>
      next->prev = msg;
    5552:	9b02      	ldr	r3, [sp, #8]
    5554:	9a00      	ldr	r2, [sp, #0]
    5556:	605a      	str	r2, [r3, #4]
    5558:	e00f      	b.n	557a <MessageQueuePut+0x86>
    } else {
      mq->msg_last = msg;
    555a:	9b01      	ldr	r3, [sp, #4]
    555c:	9a00      	ldr	r2, [sp, #0]
    555e:	631a      	str	r2, [r3, #48]	; 0x30
    5560:	e00b      	b.n	557a <MessageQueuePut+0x86>
    }
  } else {
    msg->prev = NULL;
    5562:	9b00      	ldr	r3, [sp, #0]
    5564:	2200      	movs	r2, #0
    5566:	605a      	str	r2, [r3, #4]
    msg->next = NULL;
    5568:	9b00      	ldr	r3, [sp, #0]
    556a:	2200      	movs	r2, #0
    556c:	609a      	str	r2, [r3, #8]
    mq->msg_first= msg;
    556e:	9b01      	ldr	r3, [sp, #4]
    5570:	9a00      	ldr	r2, [sp, #0]
    5572:	62da      	str	r2, [r3, #44]	; 0x2c
    mq->msg_last = msg;
    5574:	9b01      	ldr	r3, [sp, #4]
    5576:	9a00      	ldr	r2, [sp, #0]
    5578:	631a      	str	r2, [r3, #48]	; 0x30

  if (primask == 0U) {
    __enable_irq();
  }
#else
  (void)atomic_inc32(&mq->msg_count);
    557a:	9b01      	ldr	r3, [sp, #4]
    557c:	3328      	adds	r3, #40	; 0x28
    557e:	4618      	mov	r0, r3
    5580:	f7ff ff7d 	bl	547e <atomic_inc32>
#endif
}
    5584:	bf00      	nop
    5586:	b005      	add	sp, #20
    5588:	f85d fb04 	ldr.w	pc, [sp], #4

0000558c <MessageQueueGet>:

/// Get a Message from Queue with Highest Priority.
/// \param[in]  mq              message queue object.
/// \return message object or NULL.
static os_message_t *MessageQueueGet (os_message_queue_t *mq) {
    558c:	b500      	push	{lr}
    558e:	b087      	sub	sp, #28
    5590:	9001      	str	r0, [sp, #4]

  if (primask == 0U) {
    __enable_irq();
  }
#else
  count = atomic_dec32_nz(&mq->msg_count);
    5592:	9b01      	ldr	r3, [sp, #4]
    5594:	3328      	adds	r3, #40	; 0x28
    5596:	4618      	mov	r0, r3
    5598:	f7ff ff83 	bl	54a2 <atomic_dec32_nz>
    559c:	9004      	str	r0, [sp, #16]
#endif

  if (count != 0U) {
    559e:	9b04      	ldr	r3, [sp, #16]
    55a0:	2b00      	cmp	r3, #0
    55a2:	d017      	beq.n	55d4 <MessageQueueGet+0x48>
    msg = mq->msg_first;
    55a4:	9b01      	ldr	r3, [sp, #4]
    55a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    55a8:	9305      	str	r3, [sp, #20]

    while (msg != NULL) {
    55aa:	e00f      	b.n	55cc <MessageQueueGet+0x40>

      if (primask == 0U) {
        __enable_irq();
      }
#else
      flags = atomic_wr8(&msg->flags, 1U);
    55ac:	9b05      	ldr	r3, [sp, #20]
    55ae:	3302      	adds	r3, #2
    55b0:	2101      	movs	r1, #1
    55b2:	4618      	mov	r0, r3
    55b4:	f7ff ff4d 	bl	5452 <atomic_wr8>
    55b8:	4603      	mov	r3, r0
    55ba:	f88d 300f 	strb.w	r3, [sp, #15]
#endif
      if (flags == 0U) {
    55be:	f89d 300f 	ldrb.w	r3, [sp, #15]
    55c2:	2b00      	cmp	r3, #0
    55c4:	d009      	beq.n	55da <MessageQueueGet+0x4e>
        break;
      }
      msg = msg->next;
    55c6:	9b05      	ldr	r3, [sp, #20]
    55c8:	689b      	ldr	r3, [r3, #8]
    55ca:	9305      	str	r3, [sp, #20]
    while (msg != NULL) {
    55cc:	9b05      	ldr	r3, [sp, #20]
    55ce:	2b00      	cmp	r3, #0
    55d0:	d1ec      	bne.n	55ac <MessageQueueGet+0x20>
    55d2:	e003      	b.n	55dc <MessageQueueGet+0x50>
    }
  } else {
    msg = NULL;
    55d4:	2300      	movs	r3, #0
    55d6:	9305      	str	r3, [sp, #20]
    55d8:	e000      	b.n	55dc <MessageQueueGet+0x50>
        break;
    55da:	bf00      	nop
  }

  return msg;
    55dc:	9b05      	ldr	r3, [sp, #20]
}
    55de:	4618      	mov	r0, r3
    55e0:	b007      	add	sp, #28
    55e2:	f85d fb04 	ldr.w	pc, [sp], #4

000055e6 <MessageQueueRemove>:

/// Remove a Message from Queue
/// \param[in]  mq              message queue object.
/// \param[in]  msg             message object.
static void MessageQueueRemove (os_message_queue_t *mq, const os_message_t *msg) {
    55e6:	b082      	sub	sp, #8
    55e8:	9001      	str	r0, [sp, #4]
    55ea:	9100      	str	r1, [sp, #0]

  if (msg->prev != NULL) {
    55ec:	9b00      	ldr	r3, [sp, #0]
    55ee:	685b      	ldr	r3, [r3, #4]
    55f0:	2b00      	cmp	r3, #0
    55f2:	d005      	beq.n	5600 <MessageQueueRemove+0x1a>
    msg->prev->next = msg->next;
    55f4:	9b00      	ldr	r3, [sp, #0]
    55f6:	685b      	ldr	r3, [r3, #4]
    55f8:	9a00      	ldr	r2, [sp, #0]
    55fa:	6892      	ldr	r2, [r2, #8]
    55fc:	609a      	str	r2, [r3, #8]
    55fe:	e003      	b.n	5608 <MessageQueueRemove+0x22>
  } else {
    mq->msg_first = msg->next;
    5600:	9b00      	ldr	r3, [sp, #0]
    5602:	689a      	ldr	r2, [r3, #8]
    5604:	9b01      	ldr	r3, [sp, #4]
    5606:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  if (msg->next != NULL) {
    5608:	9b00      	ldr	r3, [sp, #0]
    560a:	689b      	ldr	r3, [r3, #8]
    560c:	2b00      	cmp	r3, #0
    560e:	d005      	beq.n	561c <MessageQueueRemove+0x36>
    msg->next->prev = msg->prev;
    5610:	9b00      	ldr	r3, [sp, #0]
    5612:	689b      	ldr	r3, [r3, #8]
    5614:	9a00      	ldr	r2, [sp, #0]
    5616:	6852      	ldr	r2, [r2, #4]
    5618:	605a      	str	r2, [r3, #4]
  } else {
    mq->msg_last = msg->prev;
  }
}
    561a:	e003      	b.n	5624 <MessageQueueRemove+0x3e>
    mq->msg_last = msg->prev;
    561c:	9b00      	ldr	r3, [sp, #0]
    561e:	685a      	ldr	r2, [r3, #4]
    5620:	9b01      	ldr	r3, [sp, #4]
    5622:	631a      	str	r2, [r3, #48]	; 0x30
}
    5624:	bf00      	nop
    5626:	b002      	add	sp, #8
    5628:	4770      	bx	lr

0000562a <osRtxMessageQueuePostProcess>:

//  ==== Post ISR processing ====

/// Message Queue post ISR processing.
/// \param[in]  msg             message object.
static void osRtxMessageQueuePostProcess (os_message_t *msg) {
    562a:	b500      	push	{lr}
    562c:	b089      	sub	sp, #36	; 0x24
    562e:	9001      	str	r0, [sp, #4]
  os_thread_t        *thread;
  const uint32_t     *reg;
  const void         *ptr_src;
        void         *ptr_dst;

  if (msg->state == osRtxObjectInactive) {
    5630:	9b01      	ldr	r3, [sp, #4]
    5632:	785b      	ldrb	r3, [r3, #1]
    5634:	2b00      	cmp	r3, #0
    5636:	f000 80bc 	beq.w	57b2 <osRtxMessageQueuePostProcess+0x188>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }

  if (msg->flags != 0U) {
    563a:	9b01      	ldr	r3, [sp, #4]
    563c:	789b      	ldrb	r3, [r3, #2]
    563e:	2b00      	cmp	r3, #0
    5640:	d05f      	beq.n	5702 <osRtxMessageQueuePostProcess+0xd8>
    // Remove Message
    //lint -e{9079} -e{9087} "cast between pointers to different object types"
    mq = *((os_message_queue_t **)(void *)&msg[1]);
    5642:	9b01      	ldr	r3, [sp, #4]
    5644:	68db      	ldr	r3, [r3, #12]
    5646:	9307      	str	r3, [sp, #28]
    if (mq->state == osRtxObjectInactive) {
    5648:	9b07      	ldr	r3, [sp, #28]
    564a:	785b      	ldrb	r3, [r3, #1]
    564c:	2b00      	cmp	r3, #0
    564e:	f000 80b2 	beq.w	57b6 <osRtxMessageQueuePostProcess+0x18c>
      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
      return;
    }
    MessageQueueRemove(mq, msg);
    5652:	9901      	ldr	r1, [sp, #4]
    5654:	9807      	ldr	r0, [sp, #28]
    5656:	f7ff ffc6 	bl	55e6 <MessageQueueRemove>
    // Free memory
    msg->state = osRtxObjectInactive;
    565a:	9b01      	ldr	r3, [sp, #4]
    565c:	2200      	movs	r2, #0
    565e:	705a      	strb	r2, [r3, #1]
    (void)osRtxMemoryPoolFree(&mq->mp_info, msg);
    5660:	9b07      	ldr	r3, [sp, #28]
    5662:	330c      	adds	r3, #12
    5664:	9901      	ldr	r1, [sp, #4]
    5666:	4618      	mov	r0, r3
    5668:	f7ff fe98 	bl	539c <osRtxMemoryPoolFree>
    // Check if Thread is waiting to send a Message
    if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessagePut)) {
    566c:	9b07      	ldr	r3, [sp, #28]
    566e:	689b      	ldr	r3, [r3, #8]
    5670:	2b00      	cmp	r3, #0
    5672:	f000 80a3 	beq.w	57bc <osRtxMessageQueuePostProcess+0x192>
    5676:	9b07      	ldr	r3, [sp, #28]
    5678:	689b      	ldr	r3, [r3, #8]
    567a:	785b      	ldrb	r3, [r3, #1]
    567c:	2b93      	cmp	r3, #147	; 0x93
    567e:	f040 809d 	bne.w	57bc <osRtxMessageQueuePostProcess+0x192>
      // Try to allocate memory
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      msg0 = osRtxMemoryPoolAlloc(&mq->mp_info);
    5682:	9b07      	ldr	r3, [sp, #28]
    5684:	330c      	adds	r3, #12
    5686:	4618      	mov	r0, r3
    5688:	f7ff fe5d 	bl	5346 <osRtxMemoryPoolAlloc>
    568c:	9006      	str	r0, [sp, #24]
      if (msg0 != NULL) {
    568e:	9b06      	ldr	r3, [sp, #24]
    5690:	2b00      	cmp	r3, #0
    5692:	f000 8093 	beq.w	57bc <osRtxMessageQueuePostProcess+0x192>
        // Wakeup waiting Thread with highest Priority
        thread = osRtxThreadListGet(osRtxObject(mq));
    5696:	9807      	ldr	r0, [sp, #28]
    5698:	f7ff ff1f 	bl	54da <osRtxObject>
    569c:	4603      	mov	r3, r0
    569e:	4618      	mov	r0, r3
    56a0:	f001 fa9e 	bl	6be0 <osRtxThreadListGet>
    56a4:	9005      	str	r0, [sp, #20]
        osRtxThreadWaitExit(thread, (uint32_t)osOK, FALSE);
    56a6:	2200      	movs	r2, #0
    56a8:	2100      	movs	r1, #0
    56aa:	9805      	ldr	r0, [sp, #20]
    56ac:	f001 fd38 	bl	7120 <osRtxThreadWaitExit>
        // Copy Message (R2: const void *msg_ptr, R3: uint8_t msg_prio)
        reg = osRtxThreadRegPtr(thread);
    56b0:	9805      	ldr	r0, [sp, #20]
    56b2:	f001 fc5f 	bl	6f74 <osRtxThreadRegPtr>
    56b6:	9004      	str	r0, [sp, #16]
        //lint -e{923} "cast from unsigned int to pointer"
        ptr_src = (const void *)reg[2];
    56b8:	9b04      	ldr	r3, [sp, #16]
    56ba:	3308      	adds	r3, #8
    56bc:	681b      	ldr	r3, [r3, #0]
    56be:	9303      	str	r3, [sp, #12]
        memcpy(&msg0[1], ptr_src, mq->msg_size);
    56c0:	9b06      	ldr	r3, [sp, #24]
    56c2:	f103 000c 	add.w	r0, r3, #12
    56c6:	9b07      	ldr	r3, [sp, #28]
    56c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    56ca:	461a      	mov	r2, r3
    56cc:	9903      	ldr	r1, [sp, #12]
    56ce:	f7fb f927 	bl	920 <memcpy>
        // Store Message into Queue
        msg0->id       = osRtxIdMessage;
    56d2:	9b06      	ldr	r3, [sp, #24]
    56d4:	2207      	movs	r2, #7
    56d6:	701a      	strb	r2, [r3, #0]
        msg0->state    = osRtxObjectActive;
    56d8:	9b06      	ldr	r3, [sp, #24]
    56da:	2201      	movs	r2, #1
    56dc:	705a      	strb	r2, [r3, #1]
        msg0->flags    = 0U;
    56de:	9b06      	ldr	r3, [sp, #24]
    56e0:	2200      	movs	r2, #0
    56e2:	709a      	strb	r2, [r3, #2]
        msg0->priority = (uint8_t)reg[3];
    56e4:	9b04      	ldr	r3, [sp, #16]
    56e6:	330c      	adds	r3, #12
    56e8:	681b      	ldr	r3, [r3, #0]
    56ea:	b2da      	uxtb	r2, r3
    56ec:	9b06      	ldr	r3, [sp, #24]
    56ee:	70da      	strb	r2, [r3, #3]
        MessageQueuePut(mq, msg0);
    56f0:	9906      	ldr	r1, [sp, #24]
    56f2:	9807      	ldr	r0, [sp, #28]
    56f4:	f7ff fefe 	bl	54f4 <MessageQueuePut>
        EvrRtxMessageQueueInserted(mq, ptr_src);
    56f8:	9903      	ldr	r1, [sp, #12]
    56fa:	9807      	ldr	r0, [sp, #28]
    56fc:	f7ff f8a8 	bl	4850 <EvrRtxMessageQueueInserted>
    5700:	e05c      	b.n	57bc <osRtxMessageQueuePostProcess+0x192>
      }
    }
  } else {
    // New Message
    //lint -e{9079} -e{9087} "cast between pointers to different object types"
    mq = (void *)msg->next;
    5702:	9b01      	ldr	r3, [sp, #4]
    5704:	689b      	ldr	r3, [r3, #8]
    5706:	9307      	str	r3, [sp, #28]
    if (mq->state == osRtxObjectInactive) {
    5708:	9b07      	ldr	r3, [sp, #28]
    570a:	785b      	ldrb	r3, [r3, #1]
    570c:	2b00      	cmp	r3, #0
    570e:	d054      	beq.n	57ba <osRtxMessageQueuePostProcess+0x190>
      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
      return;
    }
    //lint -e{9087} "cast between pointers to different object types"
    ptr_src = (const void *)msg->prev;
    5710:	9b01      	ldr	r3, [sp, #4]
    5712:	685b      	ldr	r3, [r3, #4]
    5714:	9303      	str	r3, [sp, #12]
    // Check if Thread is waiting to receive a Message
    if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessageGet)) {
    5716:	9b07      	ldr	r3, [sp, #28]
    5718:	689b      	ldr	r3, [r3, #8]
    571a:	2b00      	cmp	r3, #0
    571c:	d040      	beq.n	57a0 <osRtxMessageQueuePostProcess+0x176>
    571e:	9b07      	ldr	r3, [sp, #28]
    5720:	689b      	ldr	r3, [r3, #8]
    5722:	785b      	ldrb	r3, [r3, #1]
    5724:	2b83      	cmp	r3, #131	; 0x83
    5726:	d13b      	bne.n	57a0 <osRtxMessageQueuePostProcess+0x176>
      EvrRtxMessageQueueInserted(mq, ptr_src);
    5728:	9903      	ldr	r1, [sp, #12]
    572a:	9807      	ldr	r0, [sp, #28]
    572c:	f7ff f890 	bl	4850 <EvrRtxMessageQueueInserted>
      // Wakeup waiting Thread with highest Priority
      thread = osRtxThreadListGet(osRtxObject(mq));
    5730:	9807      	ldr	r0, [sp, #28]
    5732:	f7ff fed2 	bl	54da <osRtxObject>
    5736:	4603      	mov	r3, r0
    5738:	4618      	mov	r0, r3
    573a:	f001 fa51 	bl	6be0 <osRtxThreadListGet>
    573e:	9005      	str	r0, [sp, #20]
      osRtxThreadWaitExit(thread, (uint32_t)osOK, FALSE);
    5740:	2200      	movs	r2, #0
    5742:	2100      	movs	r1, #0
    5744:	9805      	ldr	r0, [sp, #20]
    5746:	f001 fceb 	bl	7120 <osRtxThreadWaitExit>
      // Copy Message (R2: void *msg_ptr, R3: uint8_t *msg_prio)
      reg = osRtxThreadRegPtr(thread);
    574a:	9805      	ldr	r0, [sp, #20]
    574c:	f001 fc12 	bl	6f74 <osRtxThreadRegPtr>
    5750:	9004      	str	r0, [sp, #16]
      //lint -e{923} "cast from unsigned int to pointer"
      ptr_dst = (void *)reg[2];
    5752:	9b04      	ldr	r3, [sp, #16]
    5754:	3308      	adds	r3, #8
    5756:	681b      	ldr	r3, [r3, #0]
    5758:	9302      	str	r3, [sp, #8]
      memcpy(ptr_dst, &msg[1], mq->msg_size);
    575a:	9b01      	ldr	r3, [sp, #4]
    575c:	f103 010c 	add.w	r1, r3, #12
    5760:	9b07      	ldr	r3, [sp, #28]
    5762:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5764:	461a      	mov	r2, r3
    5766:	9802      	ldr	r0, [sp, #8]
    5768:	f7fb f8da 	bl	920 <memcpy>
      if (reg[3] != 0U) {
    576c:	9b04      	ldr	r3, [sp, #16]
    576e:	330c      	adds	r3, #12
    5770:	681b      	ldr	r3, [r3, #0]
    5772:	2b00      	cmp	r3, #0
    5774:	d006      	beq.n	5784 <osRtxMessageQueuePostProcess+0x15a>
        //lint -e{923} -e{9078} "cast from unsigned int to pointer"
        *((uint8_t *)reg[3]) = msg->priority;
    5776:	9b04      	ldr	r3, [sp, #16]
    5778:	330c      	adds	r3, #12
    577a:	681b      	ldr	r3, [r3, #0]
    577c:	461a      	mov	r2, r3
    577e:	9b01      	ldr	r3, [sp, #4]
    5780:	78db      	ldrb	r3, [r3, #3]
    5782:	7013      	strb	r3, [r2, #0]
      }
      EvrRtxMessageQueueRetrieved(mq, ptr_dst);
    5784:	9902      	ldr	r1, [sp, #8]
    5786:	9807      	ldr	r0, [sp, #28]
    5788:	f7ff f882 	bl	4890 <EvrRtxMessageQueueRetrieved>
      // Free memory
      msg->state = osRtxObjectInactive;
    578c:	9b01      	ldr	r3, [sp, #4]
    578e:	2200      	movs	r2, #0
    5790:	705a      	strb	r2, [r3, #1]
      (void)osRtxMemoryPoolFree(&mq->mp_info, msg);
    5792:	9b07      	ldr	r3, [sp, #28]
    5794:	330c      	adds	r3, #12
    5796:	9901      	ldr	r1, [sp, #4]
    5798:	4618      	mov	r0, r3
    579a:	f7ff fdff 	bl	539c <osRtxMemoryPoolFree>
    579e:	e00d      	b.n	57bc <osRtxMessageQueuePostProcess+0x192>
    } else {
      EvrRtxMessageQueueInserted(mq, ptr_src);
    57a0:	9903      	ldr	r1, [sp, #12]
    57a2:	9807      	ldr	r0, [sp, #28]
    57a4:	f7ff f854 	bl	4850 <EvrRtxMessageQueueInserted>
      MessageQueuePut(mq, msg);
    57a8:	9901      	ldr	r1, [sp, #4]
    57aa:	9807      	ldr	r0, [sp, #28]
    57ac:	f7ff fea2 	bl	54f4 <MessageQueuePut>
    57b0:	e004      	b.n	57bc <osRtxMessageQueuePostProcess+0x192>
    return;
    57b2:	bf00      	nop
    57b4:	e002      	b.n	57bc <osRtxMessageQueuePostProcess+0x192>
      return;
    57b6:	bf00      	nop
    57b8:	e000      	b.n	57bc <osRtxMessageQueuePostProcess+0x192>
      return;
    57ba:	bf00      	nop
    }
  }
}
    57bc:	b009      	add	sp, #36	; 0x24
    57be:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000057c4 <svcRtxMessageQueueNew>:

//  ==== Service Calls ====

/// Create and Initialize a Message Queue object.
/// \note API identical to osMessageQueueNew
static osMessageQueueId_t svcRtxMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
    57c4:	b500      	push	{lr}
    57c6:	b08d      	sub	sp, #52	; 0x34
    57c8:	9003      	str	r0, [sp, #12]
    57ca:	9102      	str	r1, [sp, #8]
    57cc:	9201      	str	r2, [sp, #4]
  uint32_t            size;
  uint8_t             flags;
  const char         *name;

  // Check parameters
  if ((msg_count == 0U) || (msg_size  == 0U)) {
    57ce:	9b03      	ldr	r3, [sp, #12]
    57d0:	2b00      	cmp	r3, #0
    57d2:	d002      	beq.n	57da <svcRtxMessageQueueNew+0x16>
    57d4:	9b02      	ldr	r3, [sp, #8]
    57d6:	2b00      	cmp	r3, #0
    57d8:	d106      	bne.n	57e8 <svcRtxMessageQueueNew+0x24>
    EvrRtxMessageQueueError(NULL, (int32_t)osErrorParameter);
    57da:	f06f 0103 	mvn.w	r1, #3
    57de:	2000      	movs	r0, #0
    57e0:	f7fe fe88 	bl	44f4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return NULL;
    57e4:	2300      	movs	r3, #0
    57e6:	e0fd      	b.n	59e4 <svcRtxMessageQueueNew+0x220>
  }
  block_size = ((msg_size + 3U) & ~3UL) + sizeof(os_message_t);
    57e8:	9b02      	ldr	r3, [sp, #8]
    57ea:	3303      	adds	r3, #3
    57ec:	f023 0303 	bic.w	r3, r3, #3
    57f0:	330c      	adds	r3, #12
    57f2:	9307      	str	r3, [sp, #28]
  if ((__CLZ(msg_count) + __CLZ(block_size)) < 32U) {
    57f4:	9b03      	ldr	r3, [sp, #12]
    57f6:	fab3 f383 	clz	r3, r3
    57fa:	b2db      	uxtb	r3, r3
    57fc:	461a      	mov	r2, r3
    57fe:	9b07      	ldr	r3, [sp, #28]
    5800:	fab3 f383 	clz	r3, r3
    5804:	b2db      	uxtb	r3, r3
    5806:	4413      	add	r3, r2
    5808:	2b1f      	cmp	r3, #31
    580a:	d806      	bhi.n	581a <svcRtxMessageQueueNew+0x56>
    EvrRtxMessageQueueError(NULL, (int32_t)osErrorParameter);
    580c:	f06f 0103 	mvn.w	r1, #3
    5810:	2000      	movs	r0, #0
    5812:	f7fe fe6f 	bl	44f4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return NULL;
    5816:	2300      	movs	r3, #0
    5818:	e0e4      	b.n	59e4 <svcRtxMessageQueueNew+0x220>
  }

  size = msg_count * block_size;
    581a:	9b03      	ldr	r3, [sp, #12]
    581c:	9a07      	ldr	r2, [sp, #28]
    581e:	fb02 f303 	mul.w	r3, r2, r3
    5822:	9306      	str	r3, [sp, #24]

  // Process attributes
  if (attr != NULL) {
    5824:	9b01      	ldr	r3, [sp, #4]
    5826:	2b00      	cmp	r3, #0
    5828:	d046      	beq.n	58b8 <svcRtxMessageQueueNew+0xf4>
    name    = attr->name;
    582a:	9b01      	ldr	r3, [sp, #4]
    582c:	681b      	ldr	r3, [r3, #0]
    582e:	9308      	str	r3, [sp, #32]
    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
    mq      = attr->cb_mem;
    5830:	9b01      	ldr	r3, [sp, #4]
    5832:	689b      	ldr	r3, [r3, #8]
    5834:	930b      	str	r3, [sp, #44]	; 0x2c
    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
    mq_mem  = attr->mq_mem;
    5836:	9b01      	ldr	r3, [sp, #4]
    5838:	691b      	ldr	r3, [r3, #16]
    583a:	930a      	str	r3, [sp, #40]	; 0x28
    mq_size = attr->mq_size;
    583c:	9b01      	ldr	r3, [sp, #4]
    583e:	695b      	ldr	r3, [r3, #20]
    5840:	9305      	str	r3, [sp, #20]
    if (mq != NULL) {
    5842:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5844:	2b00      	cmp	r3, #0
    5846:	d00f      	beq.n	5868 <svcRtxMessageQueueNew+0xa4>
      //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
      if ((((uint32_t)mq & 3U) != 0U) || (attr->cb_size < sizeof(os_message_queue_t))) {
    5848:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    584a:	f003 0303 	and.w	r3, r3, #3
    584e:	2b00      	cmp	r3, #0
    5850:	d103      	bne.n	585a <svcRtxMessageQueueNew+0x96>
    5852:	9b01      	ldr	r3, [sp, #4]
    5854:	68db      	ldr	r3, [r3, #12]
    5856:	2b33      	cmp	r3, #51	; 0x33
    5858:	d811      	bhi.n	587e <svcRtxMessageQueueNew+0xba>
        EvrRtxMessageQueueError(NULL, osRtxErrorInvalidControlBlock);
    585a:	f06f 0108 	mvn.w	r1, #8
    585e:	2000      	movs	r0, #0
    5860:	f7fe fe48 	bl	44f4 <EvrRtxMessageQueueError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    5864:	2300      	movs	r3, #0
    5866:	e0bd      	b.n	59e4 <svcRtxMessageQueueNew+0x220>
      }
    } else {
      if (attr->cb_size != 0U) {
    5868:	9b01      	ldr	r3, [sp, #4]
    586a:	68db      	ldr	r3, [r3, #12]
    586c:	2b00      	cmp	r3, #0
    586e:	d006      	beq.n	587e <svcRtxMessageQueueNew+0xba>
        EvrRtxMessageQueueError(NULL, osRtxErrorInvalidControlBlock);
    5870:	f06f 0108 	mvn.w	r1, #8
    5874:	2000      	movs	r0, #0
    5876:	f7fe fe3d 	bl	44f4 <EvrRtxMessageQueueError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    587a:	2300      	movs	r3, #0
    587c:	e0b2      	b.n	59e4 <svcRtxMessageQueueNew+0x220>
      }
    }
    if (mq_mem != NULL) {
    587e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5880:	2b00      	cmp	r3, #0
    5882:	d00f      	beq.n	58a4 <svcRtxMessageQueueNew+0xe0>
      //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
      if ((((uint32_t)mq_mem & 3U) != 0U) || (mq_size < size)) {
    5884:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5886:	f003 0303 	and.w	r3, r3, #3
    588a:	2b00      	cmp	r3, #0
    588c:	d103      	bne.n	5896 <svcRtxMessageQueueNew+0xd2>
    588e:	9a05      	ldr	r2, [sp, #20]
    5890:	9b06      	ldr	r3, [sp, #24]
    5892:	429a      	cmp	r2, r3
    5894:	d216      	bcs.n	58c4 <svcRtxMessageQueueNew+0x100>
        EvrRtxMessageQueueError(NULL, osRtxErrorInvalidDataMemory);
    5896:	f06f 0109 	mvn.w	r1, #9
    589a:	2000      	movs	r0, #0
    589c:	f7fe fe2a 	bl	44f4 <EvrRtxMessageQueueError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    58a0:	2300      	movs	r3, #0
    58a2:	e09f      	b.n	59e4 <svcRtxMessageQueueNew+0x220>
      }
    } else {
      if (mq_size != 0U) {
    58a4:	9b05      	ldr	r3, [sp, #20]
    58a6:	2b00      	cmp	r3, #0
    58a8:	d00c      	beq.n	58c4 <svcRtxMessageQueueNew+0x100>
        EvrRtxMessageQueueError(NULL, osRtxErrorInvalidDataMemory);
    58aa:	f06f 0109 	mvn.w	r1, #9
    58ae:	2000      	movs	r0, #0
    58b0:	f7fe fe20 	bl	44f4 <EvrRtxMessageQueueError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    58b4:	2300      	movs	r3, #0
    58b6:	e095      	b.n	59e4 <svcRtxMessageQueueNew+0x220>
      }
    }
  } else {
    name   = NULL;
    58b8:	2300      	movs	r3, #0
    58ba:	9308      	str	r3, [sp, #32]
    mq     = NULL;
    58bc:	2300      	movs	r3, #0
    58be:	930b      	str	r3, [sp, #44]	; 0x2c
    mq_mem = NULL;
    58c0:	2300      	movs	r3, #0
    58c2:	930a      	str	r3, [sp, #40]	; 0x28
  }

  // Allocate object memory if not provided
  if (mq == NULL) {
    58c4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    58c6:	2b00      	cmp	r3, #0
    58c8:	d119      	bne.n	58fe <svcRtxMessageQueueNew+0x13a>
    if (osRtxInfo.mpi.message_queue != NULL) {
    58ca:	4b48      	ldr	r3, [pc, #288]	; (59ec <svcRtxMessageQueueNew+0x228>)
    58cc:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    58d0:	2b00      	cmp	r3, #0
    58d2:	d007      	beq.n	58e4 <svcRtxMessageQueueNew+0x120>
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      mq = osRtxMemoryPoolAlloc(osRtxInfo.mpi.message_queue);
    58d4:	4b45      	ldr	r3, [pc, #276]	; (59ec <svcRtxMessageQueueNew+0x228>)
    58d6:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    58da:	4618      	mov	r0, r3
    58dc:	f7ff fd33 	bl	5346 <osRtxMemoryPoolAlloc>
    58e0:	900b      	str	r0, [sp, #44]	; 0x2c
    58e2:	e008      	b.n	58f6 <svcRtxMessageQueueNew+0x132>
    } else {
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      mq = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_message_queue_t), 1U);
    58e4:	4b41      	ldr	r3, [pc, #260]	; (59ec <svcRtxMessageQueueNew+0x228>)
    58e6:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    58ea:	2201      	movs	r2, #1
    58ec:	2134      	movs	r1, #52	; 0x34
    58ee:	4618      	mov	r0, r3
    58f0:	f7ff fb91 	bl	5016 <osRtxMemoryAlloc>
    58f4:	900b      	str	r0, [sp, #44]	; 0x2c
      if (osRtxMessageQueueMemUsage.max_used < used) {
        osRtxMessageQueueMemUsage.max_used = used;
      }
    }
#endif
    flags = osRtxFlagSystemObject;
    58f6:	2301      	movs	r3, #1
    58f8:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    58fc:	e002      	b.n	5904 <svcRtxMessageQueueNew+0x140>
  } else {
    flags = 0U;
    58fe:	2300      	movs	r3, #0
    5900:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
  }

  // Allocate data memory if not provided
  if ((mq != NULL) && (mq_mem == NULL)) {
    5904:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5906:	2b00      	cmp	r3, #0
    5908:	d035      	beq.n	5976 <svcRtxMessageQueueNew+0x1b2>
    590a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    590c:	2b00      	cmp	r3, #0
    590e:	d132      	bne.n	5976 <svcRtxMessageQueueNew+0x1b2>
    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
    mq_mem = osRtxMemoryAlloc(osRtxInfo.mem.mq_data, size, 0U);
    5910:	4b36      	ldr	r3, [pc, #216]	; (59ec <svcRtxMessageQueueNew+0x228>)
    5912:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    5914:	2200      	movs	r2, #0
    5916:	9906      	ldr	r1, [sp, #24]
    5918:	4618      	mov	r0, r3
    591a:	f7ff fb7c 	bl	5016 <osRtxMemoryAlloc>
    591e:	900a      	str	r0, [sp, #40]	; 0x28
    if (mq_mem == NULL) {
    5920:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5922:	2b00      	cmp	r3, #0
    5924:	d11c      	bne.n	5960 <svcRtxMessageQueueNew+0x19c>
      if ((flags & osRtxFlagSystemObject) != 0U) {
    5926:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    592a:	f003 0301 	and.w	r3, r3, #1
    592e:	2b00      	cmp	r3, #0
    5930:	d013      	beq.n	595a <svcRtxMessageQueueNew+0x196>
        if (osRtxInfo.mpi.message_queue != NULL) {
    5932:	4b2e      	ldr	r3, [pc, #184]	; (59ec <svcRtxMessageQueueNew+0x228>)
    5934:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    5938:	2b00      	cmp	r3, #0
    593a:	d007      	beq.n	594c <svcRtxMessageQueueNew+0x188>
          (void)osRtxMemoryPoolFree(osRtxInfo.mpi.message_queue, mq);
    593c:	4b2b      	ldr	r3, [pc, #172]	; (59ec <svcRtxMessageQueueNew+0x228>)
    593e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    5942:	990b      	ldr	r1, [sp, #44]	; 0x2c
    5944:	4618      	mov	r0, r3
    5946:	f7ff fd29 	bl	539c <osRtxMemoryPoolFree>
    594a:	e006      	b.n	595a <svcRtxMessageQueueNew+0x196>
        } else {
          (void)osRtxMemoryFree(osRtxInfo.mem.common, mq);
    594c:	4b27      	ldr	r3, [pc, #156]	; (59ec <svcRtxMessageQueueNew+0x228>)
    594e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    5952:	990b      	ldr	r1, [sp, #44]	; 0x2c
    5954:	4618      	mov	r0, r3
    5956:	f7ff fbfa 	bl	514e <osRtxMemoryFree>
        }
#if (defined(OS_OBJ_MEM_USAGE) && (OS_OBJ_MEM_USAGE != 0))
        osRtxMessageQueueMemUsage.cnt_free++;
#endif
      }
      mq = NULL;
    595a:	2300      	movs	r3, #0
    595c:	930b      	str	r3, [sp, #44]	; 0x2c
    595e:	e004      	b.n	596a <svcRtxMessageQueueNew+0x1a6>
    } else {
      memset(mq_mem, 0, size);
    5960:	9a06      	ldr	r2, [sp, #24]
    5962:	2100      	movs	r1, #0
    5964:	980a      	ldr	r0, [sp, #40]	; 0x28
    5966:	f005 fd9d 	bl	b4a4 <memset>
    }
    flags |= osRtxFlagSystemMemory;
    596a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    596e:	f043 0302 	orr.w	r3, r3, #2
    5972:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
  }

  if (mq != NULL) {
    5976:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5978:	2b00      	cmp	r3, #0
    597a:	d02d      	beq.n	59d8 <svcRtxMessageQueueNew+0x214>
    // Initialize control block
    mq->id          = osRtxIdMessageQueue;
    597c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    597e:	2208      	movs	r2, #8
    5980:	701a      	strb	r2, [r3, #0]
    mq->state       = osRtxObjectActive;
    5982:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5984:	2201      	movs	r2, #1
    5986:	705a      	strb	r2, [r3, #1]
    mq->flags       = flags;
    5988:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    598a:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
    598e:	709a      	strb	r2, [r3, #2]
    mq->name        = name;
    5990:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5992:	9a08      	ldr	r2, [sp, #32]
    5994:	605a      	str	r2, [r3, #4]
    mq->thread_list = NULL;
    5996:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5998:	2200      	movs	r2, #0
    599a:	609a      	str	r2, [r3, #8]
    mq->msg_size    = msg_size;
    599c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    599e:	9a02      	ldr	r2, [sp, #8]
    59a0:	625a      	str	r2, [r3, #36]	; 0x24
    mq->msg_count   = 0U;
    59a2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    59a4:	2200      	movs	r2, #0
    59a6:	629a      	str	r2, [r3, #40]	; 0x28
    mq->msg_first   = NULL;
    59a8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    59aa:	2200      	movs	r2, #0
    59ac:	62da      	str	r2, [r3, #44]	; 0x2c
    mq->msg_last    = NULL;
    59ae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    59b0:	2200      	movs	r2, #0
    59b2:	631a      	str	r2, [r3, #48]	; 0x30
    (void)osRtxMemoryPoolInit(&mq->mp_info, msg_count, block_size, mq_mem);
    59b4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    59b6:	f103 000c 	add.w	r0, r3, #12
    59ba:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    59bc:	9a07      	ldr	r2, [sp, #28]
    59be:	9903      	ldr	r1, [sp, #12]
    59c0:	f7ff fc76 	bl	52b0 <osRtxMemoryPoolInit>

    // Register post ISR processing function
    osRtxInfo.post_process.message = osRtxMessageQueuePostProcess;
    59c4:	4b09      	ldr	r3, [pc, #36]	; (59ec <svcRtxMessageQueueNew+0x228>)
    59c6:	4a0a      	ldr	r2, [pc, #40]	; (59f0 <svcRtxMessageQueueNew+0x22c>)
    59c8:	671a      	str	r2, [r3, #112]	; 0x70

    EvrRtxMessageQueueCreated(mq, mq->name);
    59ca:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    59cc:	685b      	ldr	r3, [r3, #4]
    59ce:	4619      	mov	r1, r3
    59d0:	980b      	ldr	r0, [sp, #44]	; 0x2c
    59d2:	f7fe ff1b 	bl	480c <EvrRtxMessageQueueCreated>
    59d6:	e004      	b.n	59e2 <svcRtxMessageQueueNew+0x21e>
  } else {
    EvrRtxMessageQueueError(NULL, (int32_t)osErrorNoMemory);
    59d8:	f06f 0104 	mvn.w	r1, #4
    59dc:	2000      	movs	r0, #0
    59de:	f7fe fd89 	bl	44f4 <EvrRtxMessageQueueError>
  }

  return mq;
    59e2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
}
    59e4:	4618      	mov	r0, r3
    59e6:	b00d      	add	sp, #52	; 0x34
    59e8:	f85d fb04 	ldr.w	pc, [sp], #4
    59ec:	20000110 	.word	0x20000110
    59f0:	0000562b 	.word	0x0000562b

000059f4 <svcRtxMessageQueuePut>:
  return mq->name;
}

/// Put a Message into a Queue or timeout if Queue is full.
/// \note API identical to osMessageQueuePut
static osStatus_t svcRtxMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
    59f4:	b510      	push	{r4, lr}
    59f6:	b08a      	sub	sp, #40	; 0x28
    59f8:	9003      	str	r0, [sp, #12]
    59fa:	9102      	str	r1, [sp, #8]
    59fc:	9300      	str	r3, [sp, #0]
    59fe:	4613      	mov	r3, r2
    5a00:	f88d 3007 	strb.w	r3, [sp, #7]
  os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
    5a04:	9803      	ldr	r0, [sp, #12]
    5a06:	f7ff fd62 	bl	54ce <osRtxMessageQueueId>
    5a0a:	9008      	str	r0, [sp, #32]
  uint32_t           *reg;
  void               *ptr;
  osStatus_t          status;

  // Check parameters
  if ((mq == NULL) || (mq->id != osRtxIdMessageQueue) || (msg_ptr == NULL)) {
    5a0c:	9b08      	ldr	r3, [sp, #32]
    5a0e:	2b00      	cmp	r3, #0
    5a10:	d006      	beq.n	5a20 <svcRtxMessageQueuePut+0x2c>
    5a12:	9b08      	ldr	r3, [sp, #32]
    5a14:	781b      	ldrb	r3, [r3, #0]
    5a16:	2b08      	cmp	r3, #8
    5a18:	d102      	bne.n	5a20 <svcRtxMessageQueuePut+0x2c>
    5a1a:	9b02      	ldr	r3, [sp, #8]
    5a1c:	2b00      	cmp	r3, #0
    5a1e:	d107      	bne.n	5a30 <svcRtxMessageQueuePut+0x3c>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorParameter);
    5a20:	f06f 0103 	mvn.w	r1, #3
    5a24:	9808      	ldr	r0, [sp, #32]
    5a26:	f7fe fd65 	bl	44f4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorParameter;
    5a2a:	f06f 0303 	mvn.w	r3, #3
    5a2e:	e0a9      	b.n	5b84 <svcRtxMessageQueuePut+0x190>
  }

  // Check object state
  if (mq->state == osRtxObjectInactive) {
    5a30:	9b08      	ldr	r3, [sp, #32]
    5a32:	785b      	ldrb	r3, [r3, #1]
    5a34:	2b00      	cmp	r3, #0
    5a36:	d107      	bne.n	5a48 <svcRtxMessageQueuePut+0x54>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorResource);
    5a38:	f06f 0102 	mvn.w	r1, #2
    5a3c:	9808      	ldr	r0, [sp, #32]
    5a3e:	f7fe fd59 	bl	44f4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    5a42:	f06f 0302 	mvn.w	r3, #2
    5a46:	e09d      	b.n	5b84 <svcRtxMessageQueuePut+0x190>
  }

  // Check if Thread is waiting to receive a Message
  if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessageGet)) {
    5a48:	9b08      	ldr	r3, [sp, #32]
    5a4a:	689b      	ldr	r3, [r3, #8]
    5a4c:	2b00      	cmp	r3, #0
    5a4e:	d037      	beq.n	5ac0 <svcRtxMessageQueuePut+0xcc>
    5a50:	9b08      	ldr	r3, [sp, #32]
    5a52:	689b      	ldr	r3, [r3, #8]
    5a54:	785b      	ldrb	r3, [r3, #1]
    5a56:	2b83      	cmp	r3, #131	; 0x83
    5a58:	d132      	bne.n	5ac0 <svcRtxMessageQueuePut+0xcc>
    EvrRtxMessageQueueInserted(mq, msg_ptr);
    5a5a:	9902      	ldr	r1, [sp, #8]
    5a5c:	9808      	ldr	r0, [sp, #32]
    5a5e:	f7fe fef7 	bl	4850 <EvrRtxMessageQueueInserted>
    // Wakeup waiting Thread with highest Priority
    thread = osRtxThreadListGet(osRtxObject(mq));
    5a62:	9808      	ldr	r0, [sp, #32]
    5a64:	f7ff fd39 	bl	54da <osRtxObject>
    5a68:	4603      	mov	r3, r0
    5a6a:	4618      	mov	r0, r3
    5a6c:	f001 f8b8 	bl	6be0 <osRtxThreadListGet>
    5a70:	9007      	str	r0, [sp, #28]
    osRtxThreadWaitExit(thread, (uint32_t)osOK, TRUE);
    5a72:	2201      	movs	r2, #1
    5a74:	2100      	movs	r1, #0
    5a76:	9807      	ldr	r0, [sp, #28]
    5a78:	f001 fb52 	bl	7120 <osRtxThreadWaitExit>
    // Copy Message (R2: void *msg_ptr, R3: uint8_t *msg_prio)
    reg = osRtxThreadRegPtr(thread);
    5a7c:	9807      	ldr	r0, [sp, #28]
    5a7e:	f001 fa79 	bl	6f74 <osRtxThreadRegPtr>
    5a82:	9006      	str	r0, [sp, #24]
    //lint -e{923} "cast from unsigned int to pointer"
    ptr = (void *)reg[2];
    5a84:	9b06      	ldr	r3, [sp, #24]
    5a86:	3308      	adds	r3, #8
    5a88:	681b      	ldr	r3, [r3, #0]
    5a8a:	9305      	str	r3, [sp, #20]
    memcpy(ptr, msg_ptr, mq->msg_size);
    5a8c:	9b08      	ldr	r3, [sp, #32]
    5a8e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5a90:	461a      	mov	r2, r3
    5a92:	9902      	ldr	r1, [sp, #8]
    5a94:	9805      	ldr	r0, [sp, #20]
    5a96:	f7fa ff43 	bl	920 <memcpy>
    if (reg[3] != 0U) {
    5a9a:	9b06      	ldr	r3, [sp, #24]
    5a9c:	330c      	adds	r3, #12
    5a9e:	681b      	ldr	r3, [r3, #0]
    5aa0:	2b00      	cmp	r3, #0
    5aa2:	d006      	beq.n	5ab2 <svcRtxMessageQueuePut+0xbe>
      //lint -e{923} -e{9078} "cast from unsigned int to pointer"
      *((uint8_t *)reg[3]) = msg_prio;
    5aa4:	9b06      	ldr	r3, [sp, #24]
    5aa6:	330c      	adds	r3, #12
    5aa8:	681b      	ldr	r3, [r3, #0]
    5aaa:	461a      	mov	r2, r3
    5aac:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5ab0:	7013      	strb	r3, [r2, #0]
    }
    EvrRtxMessageQueueRetrieved(mq, ptr);
    5ab2:	9905      	ldr	r1, [sp, #20]
    5ab4:	9808      	ldr	r0, [sp, #32]
    5ab6:	f7fe feeb 	bl	4890 <EvrRtxMessageQueueRetrieved>
    status = osOK;
    5aba:	2300      	movs	r3, #0
    5abc:	9309      	str	r3, [sp, #36]	; 0x24
    5abe:	e060      	b.n	5b82 <svcRtxMessageQueuePut+0x18e>
  } else {
    // Try to allocate memory
    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
    msg = osRtxMemoryPoolAlloc(&mq->mp_info);
    5ac0:	9b08      	ldr	r3, [sp, #32]
    5ac2:	330c      	adds	r3, #12
    5ac4:	4618      	mov	r0, r3
    5ac6:	f7ff fc3e 	bl	5346 <osRtxMemoryPoolAlloc>
    5aca:	9004      	str	r0, [sp, #16]
    if (msg != NULL) {
    5acc:	9b04      	ldr	r3, [sp, #16]
    5ace:	2b00      	cmp	r3, #0
    5ad0:	d020      	beq.n	5b14 <svcRtxMessageQueuePut+0x120>
      // Copy Message
      memcpy(&msg[1], msg_ptr, mq->msg_size);
    5ad2:	9b04      	ldr	r3, [sp, #16]
    5ad4:	f103 000c 	add.w	r0, r3, #12
    5ad8:	9b08      	ldr	r3, [sp, #32]
    5ada:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5adc:	461a      	mov	r2, r3
    5ade:	9902      	ldr	r1, [sp, #8]
    5ae0:	f7fa ff1e 	bl	920 <memcpy>
      // Put Message into Queue
      msg->id       = osRtxIdMessage;
    5ae4:	9b04      	ldr	r3, [sp, #16]
    5ae6:	2207      	movs	r2, #7
    5ae8:	701a      	strb	r2, [r3, #0]
      msg->state    = osRtxObjectActive;
    5aea:	9b04      	ldr	r3, [sp, #16]
    5aec:	2201      	movs	r2, #1
    5aee:	705a      	strb	r2, [r3, #1]
      msg->flags    = 0U;
    5af0:	9b04      	ldr	r3, [sp, #16]
    5af2:	2200      	movs	r2, #0
    5af4:	709a      	strb	r2, [r3, #2]
      msg->priority = msg_prio;
    5af6:	9b04      	ldr	r3, [sp, #16]
    5af8:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5afc:	70da      	strb	r2, [r3, #3]
      MessageQueuePut(mq, msg);
    5afe:	9904      	ldr	r1, [sp, #16]
    5b00:	9808      	ldr	r0, [sp, #32]
    5b02:	f7ff fcf7 	bl	54f4 <MessageQueuePut>
      EvrRtxMessageQueueInserted(mq, msg_ptr);
    5b06:	9902      	ldr	r1, [sp, #8]
    5b08:	9808      	ldr	r0, [sp, #32]
    5b0a:	f7fe fea1 	bl	4850 <EvrRtxMessageQueueInserted>
      status = osOK;
    5b0e:	2300      	movs	r3, #0
    5b10:	9309      	str	r3, [sp, #36]	; 0x24
    5b12:	e036      	b.n	5b82 <svcRtxMessageQueuePut+0x18e>
    } else {
      // No memory available
      if (timeout != 0U) {
    5b14:	9b00      	ldr	r3, [sp, #0]
    5b16:	2b00      	cmp	r3, #0
    5b18:	d02c      	beq.n	5b74 <svcRtxMessageQueuePut+0x180>
        EvrRtxMessageQueuePutPending(mq, msg_ptr, timeout);
    5b1a:	9a00      	ldr	r2, [sp, #0]
    5b1c:	9902      	ldr	r1, [sp, #8]
    5b1e:	9808      	ldr	r0, [sp, #32]
    5b20:	f7fe fe84 	bl	482c <EvrRtxMessageQueuePutPending>
        // Suspend current Thread
        if (osRtxThreadWaitEnter(osRtxThreadWaitingMessagePut, timeout)) {
    5b24:	9900      	ldr	r1, [sp, #0]
    5b26:	2093      	movs	r0, #147	; 0x93
    5b28:	f001 fb1e 	bl	7168 <osRtxThreadWaitEnter>
    5b2c:	4603      	mov	r3, r0
    5b2e:	2b00      	cmp	r3, #0
    5b30:	d019      	beq.n	5b66 <svcRtxMessageQueuePut+0x172>
          osRtxThreadListPut(osRtxObject(mq), osRtxThreadGetRunning());
    5b32:	9808      	ldr	r0, [sp, #32]
    5b34:	f7ff fcd1 	bl	54da <osRtxObject>
    5b38:	4604      	mov	r4, r0
    5b3a:	f7ff fcd5 	bl	54e8 <osRtxThreadGetRunning>
    5b3e:	4603      	mov	r3, r0
    5b40:	4619      	mov	r1, r3
    5b42:	4620      	mov	r0, r4
    5b44:	f001 f816 	bl	6b74 <osRtxThreadListPut>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
    5b48:	f3ef 8309 	mrs	r3, PSP
    5b4c:	461c      	mov	r4, r3
  return(result);
    5b4e:	4623      	mov	r3, r4
          // Save arguments (R2: const void *msg_ptr, R3: uint8_t msg_prio)
          //lint -e{923} -e{9078} "cast from unsigned int to pointer"
          reg = (uint32_t *)(__get_PSP());
    5b50:	9306      	str	r3, [sp, #24]
          //lint -e{923} -e{9078} "cast from pointer to unsigned int"
          reg[2] = (uint32_t)msg_ptr;
    5b52:	9b06      	ldr	r3, [sp, #24]
    5b54:	3308      	adds	r3, #8
    5b56:	9a02      	ldr	r2, [sp, #8]
    5b58:	601a      	str	r2, [r3, #0]
          //lint -e{923} -e{9078} "cast from pointer to unsigned int"
          reg[3] = (uint32_t)msg_prio;
    5b5a:	9b06      	ldr	r3, [sp, #24]
    5b5c:	330c      	adds	r3, #12
    5b5e:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5b62:	601a      	str	r2, [r3, #0]
    5b64:	e002      	b.n	5b6c <svcRtxMessageQueuePut+0x178>
        } else {
          EvrRtxMessageQueuePutTimeout(mq);
    5b66:	9808      	ldr	r0, [sp, #32]
    5b68:	f7fe fe67 	bl	483a <EvrRtxMessageQueuePutTimeout>
        }
        status = osErrorTimeout;
    5b6c:	f06f 0301 	mvn.w	r3, #1
    5b70:	9309      	str	r3, [sp, #36]	; 0x24
    5b72:	e006      	b.n	5b82 <svcRtxMessageQueuePut+0x18e>
      } else {
        EvrRtxMessageQueueNotInserted(mq, msg_ptr);
    5b74:	9902      	ldr	r1, [sp, #8]
    5b76:	9808      	ldr	r0, [sp, #32]
    5b78:	f7fe fe70 	bl	485c <EvrRtxMessageQueueNotInserted>
        status = osErrorResource;
    5b7c:	f06f 0302 	mvn.w	r3, #2
    5b80:	9309      	str	r3, [sp, #36]	; 0x24
      }
    }
  }

  return status;
    5b82:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    5b84:	4618      	mov	r0, r3
    5b86:	b00a      	add	sp, #40	; 0x28
    5b88:	bd10      	pop	{r4, pc}

00005b8a <svcRtxMessageQueueGet>:

/// Get a Message from a Queue or timeout if Queue is empty.
/// \note API identical to osMessageQueueGet
static osStatus_t svcRtxMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
    5b8a:	b510      	push	{r4, lr}
    5b8c:	b08a      	sub	sp, #40	; 0x28
    5b8e:	9003      	str	r0, [sp, #12]
    5b90:	9102      	str	r1, [sp, #8]
    5b92:	9201      	str	r2, [sp, #4]
    5b94:	9300      	str	r3, [sp, #0]
  os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
    5b96:	9803      	ldr	r0, [sp, #12]
    5b98:	f7ff fc99 	bl	54ce <osRtxMessageQueueId>
    5b9c:	9008      	str	r0, [sp, #32]
  uint32_t           *reg;
  const void         *ptr;
  osStatus_t          status;

  // Check parameters
  if ((mq == NULL) || (mq->id != osRtxIdMessageQueue) || (msg_ptr == NULL)) {
    5b9e:	9b08      	ldr	r3, [sp, #32]
    5ba0:	2b00      	cmp	r3, #0
    5ba2:	d006      	beq.n	5bb2 <svcRtxMessageQueueGet+0x28>
    5ba4:	9b08      	ldr	r3, [sp, #32]
    5ba6:	781b      	ldrb	r3, [r3, #0]
    5ba8:	2b08      	cmp	r3, #8
    5baa:	d102      	bne.n	5bb2 <svcRtxMessageQueueGet+0x28>
    5bac:	9b02      	ldr	r3, [sp, #8]
    5bae:	2b00      	cmp	r3, #0
    5bb0:	d107      	bne.n	5bc2 <svcRtxMessageQueueGet+0x38>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorParameter);
    5bb2:	f06f 0103 	mvn.w	r1, #3
    5bb6:	9808      	ldr	r0, [sp, #32]
    5bb8:	f7fe fc9c 	bl	44f4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorParameter;
    5bbc:	f06f 0303 	mvn.w	r3, #3
    5bc0:	e0b4      	b.n	5d2c <svcRtxMessageQueueGet+0x1a2>
  }

  // Check object state
  if (mq->state == osRtxObjectInactive) {
    5bc2:	9b08      	ldr	r3, [sp, #32]
    5bc4:	785b      	ldrb	r3, [r3, #1]
    5bc6:	2b00      	cmp	r3, #0
    5bc8:	d107      	bne.n	5bda <svcRtxMessageQueueGet+0x50>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorResource);
    5bca:	f06f 0102 	mvn.w	r1, #2
    5bce:	9808      	ldr	r0, [sp, #32]
    5bd0:	f7fe fc90 	bl	44f4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    5bd4:	f06f 0302 	mvn.w	r3, #2
    5bd8:	e0a8      	b.n	5d2c <svcRtxMessageQueueGet+0x1a2>
  }

  // Get Message from Queue
  msg = MessageQueueGet(mq);
    5bda:	9808      	ldr	r0, [sp, #32]
    5bdc:	f7ff fcd6 	bl	558c <MessageQueueGet>
    5be0:	9007      	str	r0, [sp, #28]
  if (msg != NULL) {
    5be2:	9b07      	ldr	r3, [sp, #28]
    5be4:	2b00      	cmp	r3, #0
    5be6:	d06a      	beq.n	5cbe <svcRtxMessageQueueGet+0x134>
    MessageQueueRemove(mq, msg);
    5be8:	9907      	ldr	r1, [sp, #28]
    5bea:	9808      	ldr	r0, [sp, #32]
    5bec:	f7ff fcfb 	bl	55e6 <MessageQueueRemove>
    // Copy Message
    memcpy(msg_ptr, &msg[1], mq->msg_size);
    5bf0:	9b07      	ldr	r3, [sp, #28]
    5bf2:	f103 010c 	add.w	r1, r3, #12
    5bf6:	9b08      	ldr	r3, [sp, #32]
    5bf8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5bfa:	461a      	mov	r2, r3
    5bfc:	9802      	ldr	r0, [sp, #8]
    5bfe:	f7fa fe8f 	bl	920 <memcpy>
    if (msg_prio != NULL) {
    5c02:	9b01      	ldr	r3, [sp, #4]
    5c04:	2b00      	cmp	r3, #0
    5c06:	d003      	beq.n	5c10 <svcRtxMessageQueueGet+0x86>
      *msg_prio = msg->priority;
    5c08:	9b07      	ldr	r3, [sp, #28]
    5c0a:	78da      	ldrb	r2, [r3, #3]
    5c0c:	9b01      	ldr	r3, [sp, #4]
    5c0e:	701a      	strb	r2, [r3, #0]
    }
    EvrRtxMessageQueueRetrieved(mq, msg_ptr);
    5c10:	9902      	ldr	r1, [sp, #8]
    5c12:	9808      	ldr	r0, [sp, #32]
    5c14:	f7fe fe3c 	bl	4890 <EvrRtxMessageQueueRetrieved>
    // Free memory
    msg->state = osRtxObjectInactive;
    5c18:	9b07      	ldr	r3, [sp, #28]
    5c1a:	2200      	movs	r2, #0
    5c1c:	705a      	strb	r2, [r3, #1]
    (void)osRtxMemoryPoolFree(&mq->mp_info, msg);
    5c1e:	9b08      	ldr	r3, [sp, #32]
    5c20:	330c      	adds	r3, #12
    5c22:	9907      	ldr	r1, [sp, #28]
    5c24:	4618      	mov	r0, r3
    5c26:	f7ff fbb9 	bl	539c <osRtxMemoryPoolFree>
    // Check if Thread is waiting to send a Message
    if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessagePut)) {
    5c2a:	9b08      	ldr	r3, [sp, #32]
    5c2c:	689b      	ldr	r3, [r3, #8]
    5c2e:	2b00      	cmp	r3, #0
    5c30:	d042      	beq.n	5cb8 <svcRtxMessageQueueGet+0x12e>
    5c32:	9b08      	ldr	r3, [sp, #32]
    5c34:	689b      	ldr	r3, [r3, #8]
    5c36:	785b      	ldrb	r3, [r3, #1]
    5c38:	2b93      	cmp	r3, #147	; 0x93
    5c3a:	d13d      	bne.n	5cb8 <svcRtxMessageQueueGet+0x12e>
      // Try to allocate memory
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      msg = osRtxMemoryPoolAlloc(&mq->mp_info);
    5c3c:	9b08      	ldr	r3, [sp, #32]
    5c3e:	330c      	adds	r3, #12
    5c40:	4618      	mov	r0, r3
    5c42:	f7ff fb80 	bl	5346 <osRtxMemoryPoolAlloc>
    5c46:	9007      	str	r0, [sp, #28]
      if (msg != NULL) {
    5c48:	9b07      	ldr	r3, [sp, #28]
    5c4a:	2b00      	cmp	r3, #0
    5c4c:	d034      	beq.n	5cb8 <svcRtxMessageQueueGet+0x12e>
        // Wakeup waiting Thread with highest Priority
        thread = osRtxThreadListGet(osRtxObject(mq));
    5c4e:	9808      	ldr	r0, [sp, #32]
    5c50:	f7ff fc43 	bl	54da <osRtxObject>
    5c54:	4603      	mov	r3, r0
    5c56:	4618      	mov	r0, r3
    5c58:	f000 ffc2 	bl	6be0 <osRtxThreadListGet>
    5c5c:	9006      	str	r0, [sp, #24]
        osRtxThreadWaitExit(thread, (uint32_t)osOK, TRUE);
    5c5e:	2201      	movs	r2, #1
    5c60:	2100      	movs	r1, #0
    5c62:	9806      	ldr	r0, [sp, #24]
    5c64:	f001 fa5c 	bl	7120 <osRtxThreadWaitExit>
        // Copy Message (R2: const void *msg_ptr, R3: uint8_t msg_prio)
        reg = osRtxThreadRegPtr(thread);
    5c68:	9806      	ldr	r0, [sp, #24]
    5c6a:	f001 f983 	bl	6f74 <osRtxThreadRegPtr>
    5c6e:	9005      	str	r0, [sp, #20]
        //lint -e{923} "cast from unsigned int to pointer"
        ptr = (const void *)reg[2];
    5c70:	9b05      	ldr	r3, [sp, #20]
    5c72:	3308      	adds	r3, #8
    5c74:	681b      	ldr	r3, [r3, #0]
    5c76:	9304      	str	r3, [sp, #16]
        memcpy(&msg[1], ptr, mq->msg_size);
    5c78:	9b07      	ldr	r3, [sp, #28]
    5c7a:	f103 000c 	add.w	r0, r3, #12
    5c7e:	9b08      	ldr	r3, [sp, #32]
    5c80:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5c82:	461a      	mov	r2, r3
    5c84:	9904      	ldr	r1, [sp, #16]
    5c86:	f7fa fe4b 	bl	920 <memcpy>
        // Store Message into Queue
        msg->id       = osRtxIdMessage;
    5c8a:	9b07      	ldr	r3, [sp, #28]
    5c8c:	2207      	movs	r2, #7
    5c8e:	701a      	strb	r2, [r3, #0]
        msg->state    = osRtxObjectActive;
    5c90:	9b07      	ldr	r3, [sp, #28]
    5c92:	2201      	movs	r2, #1
    5c94:	705a      	strb	r2, [r3, #1]
        msg->flags    = 0U;
    5c96:	9b07      	ldr	r3, [sp, #28]
    5c98:	2200      	movs	r2, #0
    5c9a:	709a      	strb	r2, [r3, #2]
        msg->priority = (uint8_t)reg[3];
    5c9c:	9b05      	ldr	r3, [sp, #20]
    5c9e:	330c      	adds	r3, #12
    5ca0:	681b      	ldr	r3, [r3, #0]
    5ca2:	b2da      	uxtb	r2, r3
    5ca4:	9b07      	ldr	r3, [sp, #28]
    5ca6:	70da      	strb	r2, [r3, #3]
        MessageQueuePut(mq, msg);
    5ca8:	9907      	ldr	r1, [sp, #28]
    5caa:	9808      	ldr	r0, [sp, #32]
    5cac:	f7ff fc22 	bl	54f4 <MessageQueuePut>
        EvrRtxMessageQueueInserted(mq, ptr);
    5cb0:	9904      	ldr	r1, [sp, #16]
    5cb2:	9808      	ldr	r0, [sp, #32]
    5cb4:	f7fe fdcc 	bl	4850 <EvrRtxMessageQueueInserted>
      }
    }
    status = osOK;
    5cb8:	2300      	movs	r3, #0
    5cba:	9309      	str	r3, [sp, #36]	; 0x24
    5cbc:	e035      	b.n	5d2a <svcRtxMessageQueueGet+0x1a0>
  } else {
    // No Message available
    if (timeout != 0U) {
    5cbe:	9b00      	ldr	r3, [sp, #0]
    5cc0:	2b00      	cmp	r3, #0
    5cc2:	d02b      	beq.n	5d1c <svcRtxMessageQueueGet+0x192>
      EvrRtxMessageQueueGetPending(mq, msg_ptr, timeout);
    5cc4:	9a00      	ldr	r2, [sp, #0]
    5cc6:	9902      	ldr	r1, [sp, #8]
    5cc8:	9808      	ldr	r0, [sp, #32]
    5cca:	f7fe fdd5 	bl	4878 <EvrRtxMessageQueueGetPending>
      // Suspend current Thread
      if (osRtxThreadWaitEnter(osRtxThreadWaitingMessageGet, timeout)) {
    5cce:	9900      	ldr	r1, [sp, #0]
    5cd0:	2083      	movs	r0, #131	; 0x83
    5cd2:	f001 fa49 	bl	7168 <osRtxThreadWaitEnter>
    5cd6:	4603      	mov	r3, r0
    5cd8:	2b00      	cmp	r3, #0
    5cda:	d018      	beq.n	5d0e <svcRtxMessageQueueGet+0x184>
        osRtxThreadListPut(osRtxObject(mq), osRtxThreadGetRunning());
    5cdc:	9808      	ldr	r0, [sp, #32]
    5cde:	f7ff fbfc 	bl	54da <osRtxObject>
    5ce2:	4604      	mov	r4, r0
    5ce4:	f7ff fc00 	bl	54e8 <osRtxThreadGetRunning>
    5ce8:	4603      	mov	r3, r0
    5cea:	4619      	mov	r1, r3
    5cec:	4620      	mov	r0, r4
    5cee:	f000 ff41 	bl	6b74 <osRtxThreadListPut>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
    5cf2:	f3ef 8309 	mrs	r3, PSP
    5cf6:	461c      	mov	r4, r3
  return(result);
    5cf8:	4623      	mov	r3, r4
        // Save arguments (R2: void *msg_ptr, R3: uint8_t *msg_prio)
        //lint -e{923} -e{9078} "cast from unsigned int to pointer"
        reg = (uint32_t *)(__get_PSP());
    5cfa:	9305      	str	r3, [sp, #20]
        //lint -e{923} -e{9078} "cast from pointer to unsigned int"
        reg[2] = (uint32_t)msg_ptr;
    5cfc:	9b05      	ldr	r3, [sp, #20]
    5cfe:	3308      	adds	r3, #8
    5d00:	9a02      	ldr	r2, [sp, #8]
    5d02:	601a      	str	r2, [r3, #0]
        //lint -e{923} -e{9078} "cast from pointer to unsigned int"
        reg[3] = (uint32_t)msg_prio;
    5d04:	9b05      	ldr	r3, [sp, #20]
    5d06:	330c      	adds	r3, #12
    5d08:	9a01      	ldr	r2, [sp, #4]
    5d0a:	601a      	str	r2, [r3, #0]
    5d0c:	e002      	b.n	5d14 <svcRtxMessageQueueGet+0x18a>
      } else {
        EvrRtxMessageQueueGetTimeout(mq);
    5d0e:	9808      	ldr	r0, [sp, #32]
    5d10:	f7fe fdb9 	bl	4886 <EvrRtxMessageQueueGetTimeout>
      }
      status = osErrorTimeout;
    5d14:	f06f 0301 	mvn.w	r3, #1
    5d18:	9309      	str	r3, [sp, #36]	; 0x24
    5d1a:	e006      	b.n	5d2a <svcRtxMessageQueueGet+0x1a0>
    } else {
      EvrRtxMessageQueueNotRetrieved(mq, msg_ptr);
    5d1c:	9902      	ldr	r1, [sp, #8]
    5d1e:	9808      	ldr	r0, [sp, #32]
    5d20:	f7fe fdbc 	bl	489c <EvrRtxMessageQueueNotRetrieved>
      status = osErrorResource;
    5d24:	f06f 0302 	mvn.w	r3, #2
    5d28:	9309      	str	r3, [sp, #36]	; 0x24
    }
  }

  return status;
    5d2a:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    5d2c:	4618      	mov	r0, r3
    5d2e:	b00a      	add	sp, #40	; 0x28
    5d30:	bd10      	pop	{r4, pc}

00005d32 <isrRtxMessageQueuePut>:
//  ==== ISR Calls ====

/// Put a Message into a Queue or timeout if Queue is full.
/// \note API identical to osMessageQueuePut
__STATIC_INLINE
osStatus_t isrRtxMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
    5d32:	b500      	push	{lr}
    5d34:	b089      	sub	sp, #36	; 0x24
    5d36:	9003      	str	r0, [sp, #12]
    5d38:	9102      	str	r1, [sp, #8]
    5d3a:	9300      	str	r3, [sp, #0]
    5d3c:	4613      	mov	r3, r2
    5d3e:	f88d 3007 	strb.w	r3, [sp, #7]
  os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
    5d42:	9803      	ldr	r0, [sp, #12]
    5d44:	f7ff fbc3 	bl	54ce <osRtxMessageQueueId>
    5d48:	9006      	str	r0, [sp, #24]
  os_message_t       *msg;
  osStatus_t          status;

  // Check parameters
  if ((mq == NULL) || (mq->id != osRtxIdMessageQueue) || (msg_ptr == NULL) || (timeout != 0U)) {
    5d4a:	9b06      	ldr	r3, [sp, #24]
    5d4c:	2b00      	cmp	r3, #0
    5d4e:	d009      	beq.n	5d64 <isrRtxMessageQueuePut+0x32>
    5d50:	9b06      	ldr	r3, [sp, #24]
    5d52:	781b      	ldrb	r3, [r3, #0]
    5d54:	2b08      	cmp	r3, #8
    5d56:	d105      	bne.n	5d64 <isrRtxMessageQueuePut+0x32>
    5d58:	9b02      	ldr	r3, [sp, #8]
    5d5a:	2b00      	cmp	r3, #0
    5d5c:	d002      	beq.n	5d64 <isrRtxMessageQueuePut+0x32>
    5d5e:	9b00      	ldr	r3, [sp, #0]
    5d60:	2b00      	cmp	r3, #0
    5d62:	d007      	beq.n	5d74 <isrRtxMessageQueuePut+0x42>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorParameter);
    5d64:	f06f 0103 	mvn.w	r1, #3
    5d68:	9806      	ldr	r0, [sp, #24]
    5d6a:	f7fe fbc3 	bl	44f4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorParameter;
    5d6e:	f06f 0303 	mvn.w	r3, #3
    5d72:	e048      	b.n	5e06 <isrRtxMessageQueuePut+0xd4>
  }

  // Check object state
  if (mq->state == osRtxObjectInactive) {
    5d74:	9b06      	ldr	r3, [sp, #24]
    5d76:	785b      	ldrb	r3, [r3, #1]
    5d78:	2b00      	cmp	r3, #0
    5d7a:	d107      	bne.n	5d8c <isrRtxMessageQueuePut+0x5a>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorResource);
    5d7c:	f06f 0102 	mvn.w	r1, #2
    5d80:	9806      	ldr	r0, [sp, #24]
    5d82:	f7fe fbb7 	bl	44f4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    5d86:	f06f 0302 	mvn.w	r3, #2
    5d8a:	e03c      	b.n	5e06 <isrRtxMessageQueuePut+0xd4>
  }

  // Try to allocate memory
  //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
  msg = osRtxMemoryPoolAlloc(&mq->mp_info);
    5d8c:	9b06      	ldr	r3, [sp, #24]
    5d8e:	330c      	adds	r3, #12
    5d90:	4618      	mov	r0, r3
    5d92:	f7ff fad8 	bl	5346 <osRtxMemoryPoolAlloc>
    5d96:	9005      	str	r0, [sp, #20]
  if (msg != NULL) {
    5d98:	9b05      	ldr	r3, [sp, #20]
    5d9a:	2b00      	cmp	r3, #0
    5d9c:	d02b      	beq.n	5df6 <isrRtxMessageQueuePut+0xc4>
    // Copy Message
    memcpy(&msg[1], msg_ptr, mq->msg_size);
    5d9e:	9b05      	ldr	r3, [sp, #20]
    5da0:	f103 000c 	add.w	r0, r3, #12
    5da4:	9b06      	ldr	r3, [sp, #24]
    5da6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5da8:	461a      	mov	r2, r3
    5daa:	9902      	ldr	r1, [sp, #8]
    5dac:	f7fa fdb8 	bl	920 <memcpy>
    msg->id       = osRtxIdMessage;
    5db0:	9b05      	ldr	r3, [sp, #20]
    5db2:	2207      	movs	r2, #7
    5db4:	701a      	strb	r2, [r3, #0]
    msg->state    = osRtxObjectActive;
    5db6:	9b05      	ldr	r3, [sp, #20]
    5db8:	2201      	movs	r2, #1
    5dba:	705a      	strb	r2, [r3, #1]
    msg->flags    = 0U;
    5dbc:	9b05      	ldr	r3, [sp, #20]
    5dbe:	2200      	movs	r2, #0
    5dc0:	709a      	strb	r2, [r3, #2]
    msg->priority = msg_prio;
    5dc2:	9b05      	ldr	r3, [sp, #20]
    5dc4:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5dc8:	70da      	strb	r2, [r3, #3]
    // Register post ISR processing
    //lint -e{9079} -e{9087} "cast between pointers to different object types"
    *((const void **)(void *)&msg->prev) = msg_ptr;
    5dca:	9b05      	ldr	r3, [sp, #20]
    5dcc:	3304      	adds	r3, #4
    5dce:	9a02      	ldr	r2, [sp, #8]
    5dd0:	601a      	str	r2, [r3, #0]
    //lint -e{9079} -e{9087} "cast between pointers to different object types"
    *(      (void **)        &msg->next) = mq;
    5dd2:	9b05      	ldr	r3, [sp, #20]
    5dd4:	3308      	adds	r3, #8
    5dd6:	9a06      	ldr	r2, [sp, #24]
    5dd8:	601a      	str	r2, [r3, #0]
    osRtxPostProcess(osRtxObject(msg));
    5dda:	9805      	ldr	r0, [sp, #20]
    5ddc:	f7ff fb7d 	bl	54da <osRtxObject>
    5de0:	4603      	mov	r3, r0
    5de2:	4618      	mov	r0, r3
    5de4:	f000 fdc8 	bl	6978 <osRtxPostProcess>
    EvrRtxMessageQueueInsertPending(mq, msg_ptr);
    5de8:	9902      	ldr	r1, [sp, #8]
    5dea:	9806      	ldr	r0, [sp, #24]
    5dec:	f7fe fd2a 	bl	4844 <EvrRtxMessageQueueInsertPending>
    status = osOK;
    5df0:	2300      	movs	r3, #0
    5df2:	9307      	str	r3, [sp, #28]
    5df4:	e006      	b.n	5e04 <isrRtxMessageQueuePut+0xd2>
  } else {
    // No memory available
    EvrRtxMessageQueueNotInserted(mq, msg_ptr);
    5df6:	9902      	ldr	r1, [sp, #8]
    5df8:	9806      	ldr	r0, [sp, #24]
    5dfa:	f7fe fd2f 	bl	485c <EvrRtxMessageQueueNotInserted>
    status = osErrorResource;
    5dfe:	f06f 0302 	mvn.w	r3, #2
    5e02:	9307      	str	r3, [sp, #28]
  }

  return status;
    5e04:	9b07      	ldr	r3, [sp, #28]
}
    5e06:	4618      	mov	r0, r3
    5e08:	b009      	add	sp, #36	; 0x24
    5e0a:	f85d fb04 	ldr.w	pc, [sp], #4

00005e0e <isrRtxMessageQueueGet>:

/// Get a Message from a Queue or timeout if Queue is empty.
/// \note API identical to osMessageQueueGet
__STATIC_INLINE
osStatus_t isrRtxMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
    5e0e:	b500      	push	{lr}
    5e10:	b089      	sub	sp, #36	; 0x24
    5e12:	9003      	str	r0, [sp, #12]
    5e14:	9102      	str	r1, [sp, #8]
    5e16:	9201      	str	r2, [sp, #4]
    5e18:	9300      	str	r3, [sp, #0]
  os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
    5e1a:	9803      	ldr	r0, [sp, #12]
    5e1c:	f7ff fb57 	bl	54ce <osRtxMessageQueueId>
    5e20:	9006      	str	r0, [sp, #24]
  os_message_t       *msg;
  osStatus_t          status;

  // Check parameters
  if ((mq == NULL) || (mq->id != osRtxIdMessageQueue) || (msg_ptr == NULL) || (timeout != 0U)) {
    5e22:	9b06      	ldr	r3, [sp, #24]
    5e24:	2b00      	cmp	r3, #0
    5e26:	d009      	beq.n	5e3c <isrRtxMessageQueueGet+0x2e>
    5e28:	9b06      	ldr	r3, [sp, #24]
    5e2a:	781b      	ldrb	r3, [r3, #0]
    5e2c:	2b08      	cmp	r3, #8
    5e2e:	d105      	bne.n	5e3c <isrRtxMessageQueueGet+0x2e>
    5e30:	9b02      	ldr	r3, [sp, #8]
    5e32:	2b00      	cmp	r3, #0
    5e34:	d002      	beq.n	5e3c <isrRtxMessageQueueGet+0x2e>
    5e36:	9b00      	ldr	r3, [sp, #0]
    5e38:	2b00      	cmp	r3, #0
    5e3a:	d007      	beq.n	5e4c <isrRtxMessageQueueGet+0x3e>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorParameter);
    5e3c:	f06f 0103 	mvn.w	r1, #3
    5e40:	9806      	ldr	r0, [sp, #24]
    5e42:	f7fe fb57 	bl	44f4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorParameter;
    5e46:	f06f 0303 	mvn.w	r3, #3
    5e4a:	e03c      	b.n	5ec6 <isrRtxMessageQueueGet+0xb8>
  }

  // Check object state
  if (mq->state == osRtxObjectInactive) {
    5e4c:	9b06      	ldr	r3, [sp, #24]
    5e4e:	785b      	ldrb	r3, [r3, #1]
    5e50:	2b00      	cmp	r3, #0
    5e52:	d107      	bne.n	5e64 <isrRtxMessageQueueGet+0x56>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorResource);
    5e54:	f06f 0102 	mvn.w	r1, #2
    5e58:	9806      	ldr	r0, [sp, #24]
    5e5a:	f7fe fb4b 	bl	44f4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    5e5e:	f06f 0302 	mvn.w	r3, #2
    5e62:	e030      	b.n	5ec6 <isrRtxMessageQueueGet+0xb8>
  }

  // Get Message from Queue
  msg = MessageQueueGet(mq);
    5e64:	9806      	ldr	r0, [sp, #24]
    5e66:	f7ff fb91 	bl	558c <MessageQueueGet>
    5e6a:	9005      	str	r0, [sp, #20]
  if (msg != NULL) {
    5e6c:	9b05      	ldr	r3, [sp, #20]
    5e6e:	2b00      	cmp	r3, #0
    5e70:	d021      	beq.n	5eb6 <isrRtxMessageQueueGet+0xa8>
    // Copy Message
    memcpy(msg_ptr, &msg[1], mq->msg_size);
    5e72:	9b05      	ldr	r3, [sp, #20]
    5e74:	f103 010c 	add.w	r1, r3, #12
    5e78:	9b06      	ldr	r3, [sp, #24]
    5e7a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5e7c:	461a      	mov	r2, r3
    5e7e:	9802      	ldr	r0, [sp, #8]
    5e80:	f7fa fd4e 	bl	920 <memcpy>
    if (msg_prio != NULL) {
    5e84:	9b01      	ldr	r3, [sp, #4]
    5e86:	2b00      	cmp	r3, #0
    5e88:	d003      	beq.n	5e92 <isrRtxMessageQueueGet+0x84>
      *msg_prio = msg->priority;
    5e8a:	9b05      	ldr	r3, [sp, #20]
    5e8c:	78da      	ldrb	r2, [r3, #3]
    5e8e:	9b01      	ldr	r3, [sp, #4]
    5e90:	701a      	strb	r2, [r3, #0]
    }
    // Register post ISR processing
    //lint -e{9079} -e{9087} "cast between pointers to different object types"
    *((os_message_queue_t **)(void *)&msg[1]) = mq;
    5e92:	9b05      	ldr	r3, [sp, #20]
    5e94:	330c      	adds	r3, #12
    5e96:	9a06      	ldr	r2, [sp, #24]
    5e98:	601a      	str	r2, [r3, #0]
    osRtxPostProcess(osRtxObject(msg));
    5e9a:	9805      	ldr	r0, [sp, #20]
    5e9c:	f7ff fb1d 	bl	54da <osRtxObject>
    5ea0:	4603      	mov	r3, r0
    5ea2:	4618      	mov	r0, r3
    5ea4:	f000 fd68 	bl	6978 <osRtxPostProcess>
    EvrRtxMessageQueueRetrieved(mq, msg_ptr);
    5ea8:	9902      	ldr	r1, [sp, #8]
    5eaa:	9806      	ldr	r0, [sp, #24]
    5eac:	f7fe fcf0 	bl	4890 <EvrRtxMessageQueueRetrieved>
    status = osOK;
    5eb0:	2300      	movs	r3, #0
    5eb2:	9307      	str	r3, [sp, #28]
    5eb4:	e006      	b.n	5ec4 <isrRtxMessageQueueGet+0xb6>
  } else {
    // No Message available
    EvrRtxMessageQueueNotRetrieved(mq, msg_ptr);
    5eb6:	9902      	ldr	r1, [sp, #8]
    5eb8:	9806      	ldr	r0, [sp, #24]
    5eba:	f7fe fcef 	bl	489c <EvrRtxMessageQueueNotRetrieved>
    status = osErrorResource;
    5ebe:	f06f 0302 	mvn.w	r3, #2
    5ec2:	9307      	str	r3, [sp, #28]
  }

  return status;
    5ec4:	9b07      	ldr	r3, [sp, #28]
}
    5ec6:	4618      	mov	r0, r3
    5ec8:	b009      	add	sp, #36	; 0x24
    5eca:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00005ed0 <osMessageQueueNew>:


//  ==== Public API ====

/// Create and Initialize a Message Queue object.
osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
    5ed0:	b500      	push	{lr}
    5ed2:	b089      	sub	sp, #36	; 0x24
    5ed4:	9003      	str	r0, [sp, #12]
    5ed6:	9102      	str	r1, [sp, #8]
    5ed8:	9201      	str	r2, [sp, #4]
  osMessageQueueId_t mq_id;

  EvrRtxMessageQueueNew(msg_count, msg_size, attr);
    5eda:	9a01      	ldr	r2, [sp, #4]
    5edc:	9902      	ldr	r1, [sp, #8]
    5ede:	9803      	ldr	r0, [sp, #12]
    5ee0:	f7fe fc8d 	bl	47fe <EvrRtxMessageQueueNew>
  if (IsIrqMode() || IsIrqMasked()) {
    5ee4:	f7ff fa92 	bl	540c <IsIrqMode>
    5ee8:	4603      	mov	r3, r0
    5eea:	2b00      	cmp	r3, #0
    5eec:	d104      	bne.n	5ef8 <osMessageQueueNew+0x28>
    5eee:	f7ff fa9a 	bl	5426 <IsIrqMasked>
    5ef2:	4603      	mov	r3, r0
    5ef4:	2b00      	cmp	r3, #0
    5ef6:	d007      	beq.n	5f08 <osMessageQueueNew+0x38>
    EvrRtxMessageQueueError(NULL, (int32_t)osErrorISR);
    5ef8:	f06f 0105 	mvn.w	r1, #5
    5efc:	2000      	movs	r0, #0
    5efe:	f7fe faf9 	bl	44f4 <EvrRtxMessageQueueError>
    mq_id = NULL;
    5f02:	2300      	movs	r3, #0
    5f04:	9307      	str	r3, [sp, #28]
    5f06:	e00e      	b.n	5f26 <osMessageQueueNew+0x56>
    5f08:	9b03      	ldr	r3, [sp, #12]
    5f0a:	9306      	str	r3, [sp, #24]
    5f0c:	9b02      	ldr	r3, [sp, #8]
    5f0e:	9305      	str	r3, [sp, #20]
    5f10:	9b01      	ldr	r3, [sp, #4]
    5f12:	9304      	str	r3, [sp, #16]
SVC0_3(MessageQueueNew,         osMessageQueueId_t, uint32_t, uint32_t, const osMessageQueueAttr_t *)
    5f14:	9806      	ldr	r0, [sp, #24]
    5f16:	9905      	ldr	r1, [sp, #20]
    5f18:	9b04      	ldr	r3, [sp, #16]
    5f1a:	461a      	mov	r2, r3
    5f1c:	4b04      	ldr	r3, [pc, #16]	; (5f30 <osMessageQueueNew+0x60>)
    5f1e:	469c      	mov	ip, r3
    5f20:	df00      	svc	0
    5f22:	4603      	mov	r3, r0
  } else {
    mq_id = __svcMessageQueueNew(msg_count, msg_size, attr);
    5f24:	9307      	str	r3, [sp, #28]
  }
  return mq_id;
    5f26:	9b07      	ldr	r3, [sp, #28]
}
    5f28:	4618      	mov	r0, r3
    5f2a:	b009      	add	sp, #36	; 0x24
    5f2c:	f85d fb04 	ldr.w	pc, [sp], #4
    5f30:	000057c5 	.word	0x000057c5

00005f34 <osMessageQueuePut>:
  }
  return name;
}

/// Put a Message into a Queue or timeout if Queue is full.
osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
    5f34:	b510      	push	{r4, lr}
    5f36:	b08a      	sub	sp, #40	; 0x28
    5f38:	9003      	str	r0, [sp, #12]
    5f3a:	9102      	str	r1, [sp, #8]
    5f3c:	9300      	str	r3, [sp, #0]
    5f3e:	4613      	mov	r3, r2
    5f40:	f88d 3007 	strb.w	r3, [sp, #7]
  osStatus_t status;

  EvrRtxMessageQueuePut(mq_id, msg_ptr, msg_prio, timeout);
    5f44:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5f48:	9b00      	ldr	r3, [sp, #0]
    5f4a:	9902      	ldr	r1, [sp, #8]
    5f4c:	9803      	ldr	r0, [sp, #12]
    5f4e:	f7fe fc63 	bl	4818 <EvrRtxMessageQueuePut>
  if (IsIrqMode() || IsIrqMasked()) {
    5f52:	f7ff fa5b 	bl	540c <IsIrqMode>
    5f56:	4603      	mov	r3, r0
    5f58:	2b00      	cmp	r3, #0
    5f5a:	d104      	bne.n	5f66 <osMessageQueuePut+0x32>
    5f5c:	f7ff fa63 	bl	5426 <IsIrqMasked>
    5f60:	4603      	mov	r3, r0
    5f62:	2b00      	cmp	r3, #0
    5f64:	d008      	beq.n	5f78 <osMessageQueuePut+0x44>
    status = isrRtxMessageQueuePut(mq_id, msg_ptr, msg_prio, timeout);
    5f66:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5f6a:	9b00      	ldr	r3, [sp, #0]
    5f6c:	9902      	ldr	r1, [sp, #8]
    5f6e:	9803      	ldr	r0, [sp, #12]
    5f70:	f7ff fedf 	bl	5d32 <isrRtxMessageQueuePut>
    5f74:	9009      	str	r0, [sp, #36]	; 0x24
    5f76:	e016      	b.n	5fa6 <osMessageQueuePut+0x72>
    5f78:	9b03      	ldr	r3, [sp, #12]
    5f7a:	9308      	str	r3, [sp, #32]
    5f7c:	9b02      	ldr	r3, [sp, #8]
    5f7e:	9307      	str	r3, [sp, #28]
    5f80:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5f84:	f88d 301b 	strb.w	r3, [sp, #27]
    5f88:	9b00      	ldr	r3, [sp, #0]
    5f8a:	9305      	str	r3, [sp, #20]
SVC0_4(MessageQueuePut,         osStatus_t,         osMessageQueueId_t, const void *, uint8_t,   uint32_t)
    5f8c:	9b08      	ldr	r3, [sp, #32]
    5f8e:	4618      	mov	r0, r3
    5f90:	9b07      	ldr	r3, [sp, #28]
    5f92:	4619      	mov	r1, r3
    5f94:	f89d 301b 	ldrb.w	r3, [sp, #27]
    5f98:	461a      	mov	r2, r3
    5f9a:	9b05      	ldr	r3, [sp, #20]
    5f9c:	4c04      	ldr	r4, [pc, #16]	; (5fb0 <osMessageQueuePut+0x7c>)
    5f9e:	46a4      	mov	ip, r4
    5fa0:	df00      	svc	0
    5fa2:	4603      	mov	r3, r0
  } else {
    status =  __svcMessageQueuePut(mq_id, msg_ptr, msg_prio, timeout);
    5fa4:	9309      	str	r3, [sp, #36]	; 0x24
  }
  return status;
    5fa6:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    5fa8:	4618      	mov	r0, r3
    5faa:	b00a      	add	sp, #40	; 0x28
    5fac:	bd10      	pop	{r4, pc}
    5fae:	bf00      	nop
    5fb0:	000059f5 	.word	0x000059f5

00005fb4 <osMessageQueueGet>:

/// Get a Message from a Queue or timeout if Queue is empty.
osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
    5fb4:	b510      	push	{r4, lr}
    5fb6:	b08a      	sub	sp, #40	; 0x28
    5fb8:	9003      	str	r0, [sp, #12]
    5fba:	9102      	str	r1, [sp, #8]
    5fbc:	9201      	str	r2, [sp, #4]
    5fbe:	9300      	str	r3, [sp, #0]
  osStatus_t status;

  EvrRtxMessageQueueGet(mq_id, msg_ptr, msg_prio, timeout);
    5fc0:	9b00      	ldr	r3, [sp, #0]
    5fc2:	9a01      	ldr	r2, [sp, #4]
    5fc4:	9902      	ldr	r1, [sp, #8]
    5fc6:	9803      	ldr	r0, [sp, #12]
    5fc8:	f7fe fc4e 	bl	4868 <EvrRtxMessageQueueGet>
  if (IsIrqMode() || IsIrqMasked()) {
    5fcc:	f7ff fa1e 	bl	540c <IsIrqMode>
    5fd0:	4603      	mov	r3, r0
    5fd2:	2b00      	cmp	r3, #0
    5fd4:	d104      	bne.n	5fe0 <osMessageQueueGet+0x2c>
    5fd6:	f7ff fa26 	bl	5426 <IsIrqMasked>
    5fda:	4603      	mov	r3, r0
    5fdc:	2b00      	cmp	r3, #0
    5fde:	d007      	beq.n	5ff0 <osMessageQueueGet+0x3c>
    status = isrRtxMessageQueueGet(mq_id, msg_ptr, msg_prio, timeout);
    5fe0:	9b00      	ldr	r3, [sp, #0]
    5fe2:	9a01      	ldr	r2, [sp, #4]
    5fe4:	9902      	ldr	r1, [sp, #8]
    5fe6:	9803      	ldr	r0, [sp, #12]
    5fe8:	f7ff ff11 	bl	5e0e <isrRtxMessageQueueGet>
    5fec:	9009      	str	r0, [sp, #36]	; 0x24
    5fee:	e013      	b.n	6018 <HEAP_SIZE+0x18>
    5ff0:	9b03      	ldr	r3, [sp, #12]
    5ff2:	9308      	str	r3, [sp, #32]
    5ff4:	9b02      	ldr	r3, [sp, #8]
    5ff6:	9307      	str	r3, [sp, #28]
    5ff8:	9b01      	ldr	r3, [sp, #4]
    5ffa:	9306      	str	r3, [sp, #24]
    5ffc:	9b00      	ldr	r3, [sp, #0]
    5ffe:	9305      	str	r3, [sp, #20]
SVC0_4(MessageQueueGet,         osStatus_t,         osMessageQueueId_t,       void *, uint8_t *, uint32_t)
    6000:	9b08      	ldr	r3, [sp, #32]
    6002:	4618      	mov	r0, r3
    6004:	9b07      	ldr	r3, [sp, #28]
    6006:	4619      	mov	r1, r3
    6008:	9b06      	ldr	r3, [sp, #24]
    600a:	461a      	mov	r2, r3
    600c:	9b05      	ldr	r3, [sp, #20]
    600e:	4c04      	ldr	r4, [pc, #16]	; (6020 <HEAP_SIZE+0x20>)
    6010:	46a4      	mov	ip, r4
    6012:	df00      	svc	0
    6014:	4603      	mov	r3, r0
  } else {
    status =  __svcMessageQueueGet(mq_id, msg_ptr, msg_prio, timeout);
    6016:	9309      	str	r3, [sp, #36]	; 0x24
  }
  return status;
    6018:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    601a:	4618      	mov	r0, r3
    601c:	b00a      	add	sp, #40	; 0x28
    601e:	bd10      	pop	{r4, pc}
    6020:	00005b8b 	.word	0x00005b8b

00006024 <IsIrqMode>:
__STATIC_INLINE bool_t IsIrqMode (void) {
    6024:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    6026:	f3ef 8305 	mrs	r3, IPSR
    602a:	9301      	str	r3, [sp, #4]
  return(result);
    602c:	9b01      	ldr	r3, [sp, #4]
  return (__get_IPSR() != 0U);
    602e:	2b00      	cmp	r3, #0
    6030:	bf14      	ite	ne
    6032:	2301      	movne	r3, #1
    6034:	2300      	moveq	r3, #0
    6036:	b2db      	uxtb	r3, r3
}
    6038:	4618      	mov	r0, r3
    603a:	b002      	add	sp, #8
    603c:	4770      	bx	lr

0000603e <IsIrqMasked>:
__STATIC_INLINE bool_t IsIrqMasked (void) {
    603e:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    6040:	f3ef 8310 	mrs	r3, PRIMASK
    6044:	9301      	str	r3, [sp, #4]
  return(result);
    6046:	9b01      	ldr	r3, [sp, #4]
  return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
    6048:	2b00      	cmp	r3, #0
    604a:	d105      	bne.n	6058 <IsIrqMasked+0x1a>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
    604c:	f3ef 8311 	mrs	r3, BASEPRI
    6050:	9300      	str	r3, [sp, #0]
  return(result);
    6052:	9b00      	ldr	r3, [sp, #0]
    6054:	2b00      	cmp	r3, #0
    6056:	d001      	beq.n	605c <IsIrqMasked+0x1e>
    6058:	2301      	movs	r3, #1
    605a:	e000      	b.n	605e <IsIrqMasked+0x20>
    605c:	2300      	movs	r3, #0
    605e:	f003 0301 	and.w	r3, r3, #1
    6062:	b2db      	uxtb	r3, r3
}
    6064:	4618      	mov	r0, r3
    6066:	b002      	add	sp, #8
    6068:	4770      	bx	lr

0000606a <osRtxMutexId>:
__STATIC_INLINE os_mutex_t *osRtxMutexId (osMutexId_t mutex_id) {
    606a:	b082      	sub	sp, #8
    606c:	9001      	str	r0, [sp, #4]
  return ((os_mutex_t *)mutex_id);
    606e:	9b01      	ldr	r3, [sp, #4]
}
    6070:	4618      	mov	r0, r3
    6072:	b002      	add	sp, #8
    6074:	4770      	bx	lr

00006076 <osRtxObject>:
__STATIC_INLINE os_object_t *osRtxObject (void *object) {
    6076:	b082      	sub	sp, #8
    6078:	9001      	str	r0, [sp, #4]
  return ((os_object_t *)object);
    607a:	9b01      	ldr	r3, [sp, #4]
}
    607c:	4618      	mov	r0, r3
    607e:	b002      	add	sp, #8
    6080:	4770      	bx	lr
	...

00006084 <osRtxThreadGetRunning>:
  return osRtxInfo.thread.run.curr;
    6084:	4b01      	ldr	r3, [pc, #4]	; (608c <osRtxThreadGetRunning+0x8>)
    6086:	695b      	ldr	r3, [r3, #20]
}
    6088:	4618      	mov	r0, r3
    608a:	4770      	bx	lr
    608c:	20000110 	.word	0x20000110

00006090 <osRtxMutexOwnerRelease>:
//  ==== Library functions ====

/// Release Mutex list when owner Thread terminates.
/// \param[in]  mutex           mutex object.
/// \return 1 - success, 0 - failure.
void osRtxMutexOwnerRelease (os_mutex_t *mutex_list) {
    6090:	b500      	push	{lr}
    6092:	b087      	sub	sp, #28
    6094:	9001      	str	r0, [sp, #4]
  os_mutex_t  *mutex;
  os_mutex_t  *mutex_next;
  os_thread_t *thread;

  mutex = mutex_list;
    6096:	9b01      	ldr	r3, [sp, #4]
    6098:	9305      	str	r3, [sp, #20]
  while (mutex != NULL) {
    609a:	e036      	b.n	610a <osRtxMutexOwnerRelease+0x7a>
    mutex_next = mutex->owner_next;
    609c:	9b05      	ldr	r3, [sp, #20]
    609e:	695b      	ldr	r3, [r3, #20]
    60a0:	9304      	str	r3, [sp, #16]
    // Check if Mutex is Robust
    if ((mutex->attr & osMutexRobust) != 0U) {
    60a2:	9b05      	ldr	r3, [sp, #20]
    60a4:	78db      	ldrb	r3, [r3, #3]
    60a6:	f003 0308 	and.w	r3, r3, #8
    60aa:	2b00      	cmp	r3, #0
    60ac:	d02b      	beq.n	6106 <osRtxMutexOwnerRelease+0x76>
      // Clear Lock counter
      mutex->lock = 0U;
    60ae:	9b05      	ldr	r3, [sp, #20]
    60b0:	2200      	movs	r2, #0
    60b2:	761a      	strb	r2, [r3, #24]
      EvrRtxMutexReleased(mutex, 0U);
    60b4:	2100      	movs	r1, #0
    60b6:	9805      	ldr	r0, [sp, #20]
    60b8:	f7fe fb91 	bl	47de <EvrRtxMutexReleased>
      // Check if Thread is waiting for a Mutex
      if (mutex->thread_list != NULL) {
    60bc:	9b05      	ldr	r3, [sp, #20]
    60be:	689b      	ldr	r3, [r3, #8]
    60c0:	2b00      	cmp	r3, #0
    60c2:	d020      	beq.n	6106 <osRtxMutexOwnerRelease+0x76>
        // Wakeup waiting Thread with highest Priority
        thread = osRtxThreadListGet(osRtxObject(mutex));
    60c4:	9805      	ldr	r0, [sp, #20]
    60c6:	f7ff ffd6 	bl	6076 <osRtxObject>
    60ca:	4603      	mov	r3, r0
    60cc:	4618      	mov	r0, r3
    60ce:	f000 fd87 	bl	6be0 <osRtxThreadListGet>
    60d2:	9003      	str	r0, [sp, #12]
        osRtxThreadWaitExit(thread, (uint32_t)osOK, FALSE);
    60d4:	2200      	movs	r2, #0
    60d6:	2100      	movs	r1, #0
    60d8:	9803      	ldr	r0, [sp, #12]
    60da:	f001 f821 	bl	7120 <osRtxThreadWaitExit>
        // Thread is the new Mutex owner
        mutex->owner_thread = thread;
    60de:	9b05      	ldr	r3, [sp, #20]
    60e0:	9a03      	ldr	r2, [sp, #12]
    60e2:	60da      	str	r2, [r3, #12]
        mutex->owner_next   = thread->mutex_list;
    60e4:	9b03      	ldr	r3, [sp, #12]
    60e6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    60e8:	9b05      	ldr	r3, [sp, #20]
    60ea:	615a      	str	r2, [r3, #20]
        mutex->owner_prev   = NULL;
    60ec:	9b05      	ldr	r3, [sp, #20]
    60ee:	2200      	movs	r2, #0
    60f0:	611a      	str	r2, [r3, #16]
        thread->mutex_list  = mutex;
    60f2:	9b03      	ldr	r3, [sp, #12]
    60f4:	9a05      	ldr	r2, [sp, #20]
    60f6:	62da      	str	r2, [r3, #44]	; 0x2c
        mutex->lock = 1U;
    60f8:	9b05      	ldr	r3, [sp, #20]
    60fa:	2201      	movs	r2, #1
    60fc:	761a      	strb	r2, [r3, #24]
        EvrRtxMutexAcquired(mutex, 1U);
    60fe:	2101      	movs	r1, #1
    6100:	9805      	ldr	r0, [sp, #20]
    6102:	f7fe fb5c 	bl	47be <EvrRtxMutexAcquired>
      }
    }
    mutex = mutex_next;
    6106:	9b04      	ldr	r3, [sp, #16]
    6108:	9305      	str	r3, [sp, #20]
  while (mutex != NULL) {
    610a:	9b05      	ldr	r3, [sp, #20]
    610c:	2b00      	cmp	r3, #0
    610e:	d1c5      	bne.n	609c <osRtxMutexOwnerRelease+0xc>
  }
}
    6110:	bf00      	nop
    6112:	b007      	add	sp, #28
    6114:	f85d fb04 	ldr.w	pc, [sp], #4

00006118 <svcRtxMutexNew>:

//  ==== Service Calls ====

/// Create and Initialize a Mutex object.
/// \note API identical to osMutexNew
static osMutexId_t svcRtxMutexNew (const osMutexAttr_t *attr) {
    6118:	b500      	push	{lr}
    611a:	b087      	sub	sp, #28
    611c:	9001      	str	r0, [sp, #4]
  uint32_t    attr_bits;
  uint8_t     flags;
  const char *name;

  // Process attributes
  if (attr != NULL) {
    611e:	9b01      	ldr	r3, [sp, #4]
    6120:	2b00      	cmp	r3, #0
    6122:	d026      	beq.n	6172 <svcRtxMutexNew+0x5a>
    name      = attr->name;
    6124:	9b01      	ldr	r3, [sp, #4]
    6126:	681b      	ldr	r3, [r3, #0]
    6128:	9302      	str	r3, [sp, #8]
    attr_bits = attr->attr_bits;
    612a:	9b01      	ldr	r3, [sp, #4]
    612c:	685b      	ldr	r3, [r3, #4]
    612e:	9304      	str	r3, [sp, #16]
    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
    mutex     = attr->cb_mem;
    6130:	9b01      	ldr	r3, [sp, #4]
    6132:	689b      	ldr	r3, [r3, #8]
    6134:	9305      	str	r3, [sp, #20]
    if (mutex != NULL) {
    6136:	9b05      	ldr	r3, [sp, #20]
    6138:	2b00      	cmp	r3, #0
    613a:	d00f      	beq.n	615c <svcRtxMutexNew+0x44>
      //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
      if ((((uint32_t)mutex & 3U) != 0U) || (attr->cb_size < sizeof(os_mutex_t))) {
    613c:	9b05      	ldr	r3, [sp, #20]
    613e:	f003 0303 	and.w	r3, r3, #3
    6142:	2b00      	cmp	r3, #0
    6144:	d103      	bne.n	614e <svcRtxMutexNew+0x36>
    6146:	9b01      	ldr	r3, [sp, #4]
    6148:	68db      	ldr	r3, [r3, #12]
    614a:	2b1b      	cmp	r3, #27
    614c:	d817      	bhi.n	617e <svcRtxMutexNew+0x66>
        EvrRtxMutexError(NULL, osRtxErrorInvalidControlBlock);
    614e:	f06f 0108 	mvn.w	r1, #8
    6152:	2000      	movs	r0, #0
    6154:	f7fe f9b8 	bl	44c8 <EvrRtxMutexError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    6158:	2300      	movs	r3, #0
    615a:	e060      	b.n	621e <svcRtxMutexNew+0x106>
      }
    } else {
      if (attr->cb_size != 0U) {
    615c:	9b01      	ldr	r3, [sp, #4]
    615e:	68db      	ldr	r3, [r3, #12]
    6160:	2b00      	cmp	r3, #0
    6162:	d00c      	beq.n	617e <svcRtxMutexNew+0x66>
        EvrRtxMutexError(NULL, osRtxErrorInvalidControlBlock);
    6164:	f06f 0108 	mvn.w	r1, #8
    6168:	2000      	movs	r0, #0
    616a:	f7fe f9ad 	bl	44c8 <EvrRtxMutexError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    616e:	2300      	movs	r3, #0
    6170:	e055      	b.n	621e <svcRtxMutexNew+0x106>
      }
    }
  } else {
    name      = NULL;
    6172:	2300      	movs	r3, #0
    6174:	9302      	str	r3, [sp, #8]
    attr_bits = 0U;
    6176:	2300      	movs	r3, #0
    6178:	9304      	str	r3, [sp, #16]
    mutex     = NULL;
    617a:	2300      	movs	r3, #0
    617c:	9305      	str	r3, [sp, #20]
  }

  // Allocate object memory if not provided
  if (mutex == NULL) {
    617e:	9b05      	ldr	r3, [sp, #20]
    6180:	2b00      	cmp	r3, #0
    6182:	d119      	bne.n	61b8 <svcRtxMutexNew+0xa0>
    if (osRtxInfo.mpi.mutex != NULL) {
    6184:	4b28      	ldr	r3, [pc, #160]	; (6228 <svcRtxMutexNew+0x110>)
    6186:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    618a:	2b00      	cmp	r3, #0
    618c:	d007      	beq.n	619e <svcRtxMutexNew+0x86>
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      mutex = osRtxMemoryPoolAlloc(osRtxInfo.mpi.mutex);
    618e:	4b26      	ldr	r3, [pc, #152]	; (6228 <svcRtxMutexNew+0x110>)
    6190:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    6194:	4618      	mov	r0, r3
    6196:	f7ff f8d6 	bl	5346 <osRtxMemoryPoolAlloc>
    619a:	9005      	str	r0, [sp, #20]
    619c:	e008      	b.n	61b0 <svcRtxMutexNew+0x98>
    } else {
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      mutex = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_mutex_t), 1U);
    619e:	4b22      	ldr	r3, [pc, #136]	; (6228 <svcRtxMutexNew+0x110>)
    61a0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    61a4:	2201      	movs	r2, #1
    61a6:	211c      	movs	r1, #28
    61a8:	4618      	mov	r0, r3
    61aa:	f7fe ff34 	bl	5016 <osRtxMemoryAlloc>
    61ae:	9005      	str	r0, [sp, #20]
      if (osRtxMutexMemUsage.max_used < used) {
        osRtxMutexMemUsage.max_used = used;
      }
    }
#endif
    flags = osRtxFlagSystemObject;
    61b0:	2301      	movs	r3, #1
    61b2:	f88d 300f 	strb.w	r3, [sp, #15]
    61b6:	e002      	b.n	61be <svcRtxMutexNew+0xa6>
  } else {
    flags = 0U;
    61b8:	2300      	movs	r3, #0
    61ba:	f88d 300f 	strb.w	r3, [sp, #15]
  }

  if (mutex != NULL) {
    61be:	9b05      	ldr	r3, [sp, #20]
    61c0:	2b00      	cmp	r3, #0
    61c2:	d026      	beq.n	6212 <svcRtxMutexNew+0xfa>
    // Initialize control block
    mutex->id           = osRtxIdMutex;
    61c4:	9b05      	ldr	r3, [sp, #20]
    61c6:	2204      	movs	r2, #4
    61c8:	701a      	strb	r2, [r3, #0]
    mutex->state        = osRtxObjectActive;
    61ca:	9b05      	ldr	r3, [sp, #20]
    61cc:	2201      	movs	r2, #1
    61ce:	705a      	strb	r2, [r3, #1]
    mutex->flags        = flags;
    61d0:	9b05      	ldr	r3, [sp, #20]
    61d2:	f89d 200f 	ldrb.w	r2, [sp, #15]
    61d6:	709a      	strb	r2, [r3, #2]
    mutex->attr         = (uint8_t)attr_bits;
    61d8:	9b04      	ldr	r3, [sp, #16]
    61da:	b2da      	uxtb	r2, r3
    61dc:	9b05      	ldr	r3, [sp, #20]
    61de:	70da      	strb	r2, [r3, #3]
    mutex->name         = name;
    61e0:	9b05      	ldr	r3, [sp, #20]
    61e2:	9a02      	ldr	r2, [sp, #8]
    61e4:	605a      	str	r2, [r3, #4]
    mutex->thread_list  = NULL;
    61e6:	9b05      	ldr	r3, [sp, #20]
    61e8:	2200      	movs	r2, #0
    61ea:	609a      	str	r2, [r3, #8]
    mutex->owner_thread = NULL;
    61ec:	9b05      	ldr	r3, [sp, #20]
    61ee:	2200      	movs	r2, #0
    61f0:	60da      	str	r2, [r3, #12]
    mutex->owner_prev   = NULL;
    61f2:	9b05      	ldr	r3, [sp, #20]
    61f4:	2200      	movs	r2, #0
    61f6:	611a      	str	r2, [r3, #16]
    mutex->owner_next   = NULL;
    61f8:	9b05      	ldr	r3, [sp, #20]
    61fa:	2200      	movs	r2, #0
    61fc:	615a      	str	r2, [r3, #20]
    mutex->lock         = 0U;
    61fe:	9b05      	ldr	r3, [sp, #20]
    6200:	2200      	movs	r2, #0
    6202:	761a      	strb	r2, [r3, #24]

    EvrRtxMutexCreated(mutex, mutex->name);
    6204:	9b05      	ldr	r3, [sp, #20]
    6206:	685b      	ldr	r3, [r3, #4]
    6208:	4619      	mov	r1, r3
    620a:	9805      	ldr	r0, [sp, #20]
    620c:	f7fe fac0 	bl	4790 <EvrRtxMutexCreated>
    6210:	e004      	b.n	621c <svcRtxMutexNew+0x104>
  } else {
    EvrRtxMutexError(NULL, (int32_t)osErrorNoMemory);
    6212:	f06f 0104 	mvn.w	r1, #4
    6216:	2000      	movs	r0, #0
    6218:	f7fe f956 	bl	44c8 <EvrRtxMutexError>
  }

  return mutex;
    621c:	9b05      	ldr	r3, [sp, #20]
}
    621e:	4618      	mov	r0, r3
    6220:	b007      	add	sp, #28
    6222:	f85d fb04 	ldr.w	pc, [sp], #4
    6226:	bf00      	nop
    6228:	20000110 	.word	0x20000110

0000622c <svcRtxMutexAcquire>:
  return mutex->name;
}

/// Acquire a Mutex or timeout if it is locked.
/// \note API identical to osMutexAcquire
static osStatus_t svcRtxMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
    622c:	b500      	push	{lr}
    622e:	b087      	sub	sp, #28
    6230:	9001      	str	r0, [sp, #4]
    6232:	9100      	str	r1, [sp, #0]
  os_mutex_t  *mutex = osRtxMutexId(mutex_id);
    6234:	9801      	ldr	r0, [sp, #4]
    6236:	f7ff ff18 	bl	606a <osRtxMutexId>
    623a:	9004      	str	r0, [sp, #16]
  os_thread_t *runnig_thread;
  osStatus_t   status;

  // Check running thread
  runnig_thread = osRtxThreadGetRunning();
    623c:	f7ff ff22 	bl	6084 <osRtxThreadGetRunning>
    6240:	9003      	str	r0, [sp, #12]
  if (runnig_thread == NULL) {
    6242:	9b03      	ldr	r3, [sp, #12]
    6244:	2b00      	cmp	r3, #0
    6246:	d107      	bne.n	6258 <svcRtxMutexAcquire+0x2c>
    EvrRtxMutexError(mutex, osRtxErrorKernelNotRunning);
    6248:	f06f 0107 	mvn.w	r1, #7
    624c:	9804      	ldr	r0, [sp, #16]
    624e:	f7fe f93b 	bl	44c8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    6252:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    6256:	e0a6      	b.n	63a6 <svcRtxMutexAcquire+0x17a>
  }

  // Check parameters
  if ((mutex == NULL) || (mutex->id != osRtxIdMutex)) {
    6258:	9b04      	ldr	r3, [sp, #16]
    625a:	2b00      	cmp	r3, #0
    625c:	d003      	beq.n	6266 <svcRtxMutexAcquire+0x3a>
    625e:	9b04      	ldr	r3, [sp, #16]
    6260:	781b      	ldrb	r3, [r3, #0]
    6262:	2b04      	cmp	r3, #4
    6264:	d007      	beq.n	6276 <svcRtxMutexAcquire+0x4a>
    EvrRtxMutexError(mutex, (int32_t)osErrorParameter);
    6266:	f06f 0103 	mvn.w	r1, #3
    626a:	9804      	ldr	r0, [sp, #16]
    626c:	f7fe f92c 	bl	44c8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorParameter;
    6270:	f06f 0303 	mvn.w	r3, #3
    6274:	e097      	b.n	63a6 <svcRtxMutexAcquire+0x17a>
  }

  // Check object state
  if (mutex->state == osRtxObjectInactive) {
    6276:	9b04      	ldr	r3, [sp, #16]
    6278:	785b      	ldrb	r3, [r3, #1]
    627a:	2b00      	cmp	r3, #0
    627c:	d107      	bne.n	628e <svcRtxMutexAcquire+0x62>
    EvrRtxMutexError(mutex, (int32_t)osErrorResource);
    627e:	f06f 0102 	mvn.w	r1, #2
    6282:	9804      	ldr	r0, [sp, #16]
    6284:	f7fe f920 	bl	44c8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    6288:	f06f 0302 	mvn.w	r3, #2
    628c:	e08b      	b.n	63a6 <svcRtxMutexAcquire+0x17a>
  }

  // Check if Mutex is not locked
  if (mutex->lock == 0U) {
    628e:	9b04      	ldr	r3, [sp, #16]
    6290:	7e1b      	ldrb	r3, [r3, #24]
    6292:	2b00      	cmp	r3, #0
    6294:	d120      	bne.n	62d8 <svcRtxMutexAcquire+0xac>
    // Acquire Mutex
    mutex->owner_thread = runnig_thread;
    6296:	9b04      	ldr	r3, [sp, #16]
    6298:	9a03      	ldr	r2, [sp, #12]
    629a:	60da      	str	r2, [r3, #12]
    mutex->owner_next   = runnig_thread->mutex_list;
    629c:	9b03      	ldr	r3, [sp, #12]
    629e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    62a0:	9b04      	ldr	r3, [sp, #16]
    62a2:	615a      	str	r2, [r3, #20]
    mutex->owner_prev   = NULL;
    62a4:	9b04      	ldr	r3, [sp, #16]
    62a6:	2200      	movs	r2, #0
    62a8:	611a      	str	r2, [r3, #16]
    if (runnig_thread->mutex_list != NULL) {
    62aa:	9b03      	ldr	r3, [sp, #12]
    62ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    62ae:	2b00      	cmp	r3, #0
    62b0:	d003      	beq.n	62ba <svcRtxMutexAcquire+0x8e>
        runnig_thread->mutex_list->owner_prev = mutex;
    62b2:	9b03      	ldr	r3, [sp, #12]
    62b4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    62b6:	9a04      	ldr	r2, [sp, #16]
    62b8:	611a      	str	r2, [r3, #16]
    }
    runnig_thread->mutex_list = mutex;
    62ba:	9b03      	ldr	r3, [sp, #12]
    62bc:	9a04      	ldr	r2, [sp, #16]
    62be:	62da      	str	r2, [r3, #44]	; 0x2c
    mutex->lock = 1U;
    62c0:	9b04      	ldr	r3, [sp, #16]
    62c2:	2201      	movs	r2, #1
    62c4:	761a      	strb	r2, [r3, #24]
    EvrRtxMutexAcquired(mutex, mutex->lock);
    62c6:	9b04      	ldr	r3, [sp, #16]
    62c8:	7e1b      	ldrb	r3, [r3, #24]
    62ca:	4619      	mov	r1, r3
    62cc:	9804      	ldr	r0, [sp, #16]
    62ce:	f7fe fa76 	bl	47be <EvrRtxMutexAcquired>
    status = osOK;
    62d2:	2300      	movs	r3, #0
    62d4:	9305      	str	r3, [sp, #20]
    62d6:	e065      	b.n	63a4 <svcRtxMutexAcquire+0x178>
  } else {
    // Check if Mutex is recursive and running Thread is the owner
    if (((mutex->attr & osMutexRecursive) != 0U) && (mutex->owner_thread == runnig_thread)) {
    62d8:	9b04      	ldr	r3, [sp, #16]
    62da:	78db      	ldrb	r3, [r3, #3]
    62dc:	f003 0301 	and.w	r3, r3, #1
    62e0:	2b00      	cmp	r3, #0
    62e2:	d020      	beq.n	6326 <svcRtxMutexAcquire+0xfa>
    62e4:	9b04      	ldr	r3, [sp, #16]
    62e6:	68da      	ldr	r2, [r3, #12]
    62e8:	9b03      	ldr	r3, [sp, #12]
    62ea:	429a      	cmp	r2, r3
    62ec:	d11b      	bne.n	6326 <svcRtxMutexAcquire+0xfa>
      // Try to increment lock counter
      if (mutex->lock == osRtxMutexLockLimit) {
    62ee:	9b04      	ldr	r3, [sp, #16]
    62f0:	7e1b      	ldrb	r3, [r3, #24]
    62f2:	2bff      	cmp	r3, #255	; 0xff
    62f4:	d108      	bne.n	6308 <svcRtxMutexAcquire+0xdc>
        EvrRtxMutexError(mutex, osRtxErrorMutexLockLimit);
    62f6:	f06f 010f 	mvn.w	r1, #15
    62fa:	9804      	ldr	r0, [sp, #16]
    62fc:	f7fe f8e4 	bl	44c8 <EvrRtxMutexError>
        status = osErrorResource;
    6300:	f06f 0302 	mvn.w	r3, #2
    6304:	9305      	str	r3, [sp, #20]
      if (mutex->lock == osRtxMutexLockLimit) {
    6306:	e04d      	b.n	63a4 <svcRtxMutexAcquire+0x178>
      } else {
        mutex->lock++;
    6308:	9b04      	ldr	r3, [sp, #16]
    630a:	7e1b      	ldrb	r3, [r3, #24]
    630c:	3301      	adds	r3, #1
    630e:	b2da      	uxtb	r2, r3
    6310:	9b04      	ldr	r3, [sp, #16]
    6312:	761a      	strb	r2, [r3, #24]
        EvrRtxMutexAcquired(mutex, mutex->lock);
    6314:	9b04      	ldr	r3, [sp, #16]
    6316:	7e1b      	ldrb	r3, [r3, #24]
    6318:	4619      	mov	r1, r3
    631a:	9804      	ldr	r0, [sp, #16]
    631c:	f7fe fa4f 	bl	47be <EvrRtxMutexAcquired>
        status = osOK;
    6320:	2300      	movs	r3, #0
    6322:	9305      	str	r3, [sp, #20]
      if (mutex->lock == osRtxMutexLockLimit) {
    6324:	e03e      	b.n	63a4 <svcRtxMutexAcquire+0x178>
      }
    } else {
      // Check if timeout is specified
      if (timeout != 0U) {
    6326:	9b00      	ldr	r3, [sp, #0]
    6328:	2b00      	cmp	r3, #0
    632a:	d035      	beq.n	6398 <svcRtxMutexAcquire+0x16c>
        // Check if Priority inheritance protocol is enabled
        if ((mutex->attr & osMutexPrioInherit) != 0U) {
    632c:	9b04      	ldr	r3, [sp, #16]
    632e:	78db      	ldrb	r3, [r3, #3]
    6330:	f003 0302 	and.w	r3, r3, #2
    6334:	2b00      	cmp	r3, #0
    6336:	d014      	beq.n	6362 <svcRtxMutexAcquire+0x136>
          // Raise priority of owner Thread if lower than priority of running Thread
          if (mutex->owner_thread->priority < runnig_thread->priority) {
    6338:	9b04      	ldr	r3, [sp, #16]
    633a:	68db      	ldr	r3, [r3, #12]
    633c:	f993 2020 	ldrsb.w	r2, [r3, #32]
    6340:	9b03      	ldr	r3, [sp, #12]
    6342:	f993 3020 	ldrsb.w	r3, [r3, #32]
    6346:	429a      	cmp	r2, r3
    6348:	da0b      	bge.n	6362 <svcRtxMutexAcquire+0x136>
            mutex->owner_thread->priority = runnig_thread->priority;
    634a:	9b04      	ldr	r3, [sp, #16]
    634c:	68db      	ldr	r3, [r3, #12]
    634e:	9a03      	ldr	r2, [sp, #12]
    6350:	f992 2020 	ldrsb.w	r2, [r2, #32]
    6354:	f883 2020 	strb.w	r2, [r3, #32]
            osRtxThreadListSort(mutex->owner_thread);
    6358:	9b04      	ldr	r3, [sp, #16]
    635a:	68db      	ldr	r3, [r3, #12]
    635c:	4618      	mov	r0, r3
    635e:	f000 fc71 	bl	6c44 <osRtxThreadListSort>
          }
        }
        EvrRtxMutexAcquirePending(mutex, timeout);
    6362:	9900      	ldr	r1, [sp, #0]
    6364:	9804      	ldr	r0, [sp, #16]
    6366:	f7fe fa1f 	bl	47a8 <EvrRtxMutexAcquirePending>
        // Suspend current Thread
        if (osRtxThreadWaitEnter(osRtxThreadWaitingMutex, timeout)) {
    636a:	9900      	ldr	r1, [sp, #0]
    636c:	2053      	movs	r0, #83	; 0x53
    636e:	f000 fefb 	bl	7168 <osRtxThreadWaitEnter>
    6372:	4603      	mov	r3, r0
    6374:	2b00      	cmp	r3, #0
    6376:	d008      	beq.n	638a <svcRtxMutexAcquire+0x15e>
          osRtxThreadListPut(osRtxObject(mutex), runnig_thread);
    6378:	9804      	ldr	r0, [sp, #16]
    637a:	f7ff fe7c 	bl	6076 <osRtxObject>
    637e:	4603      	mov	r3, r0
    6380:	9903      	ldr	r1, [sp, #12]
    6382:	4618      	mov	r0, r3
    6384:	f000 fbf6 	bl	6b74 <osRtxThreadListPut>
    6388:	e002      	b.n	6390 <svcRtxMutexAcquire+0x164>
        } else {
          EvrRtxMutexAcquireTimeout(mutex);
    638a:	9804      	ldr	r0, [sp, #16]
    638c:	f7fe fa12 	bl	47b4 <EvrRtxMutexAcquireTimeout>
        }
        status = osErrorTimeout;
    6390:	f06f 0301 	mvn.w	r3, #1
    6394:	9305      	str	r3, [sp, #20]
    6396:	e005      	b.n	63a4 <svcRtxMutexAcquire+0x178>
      } else {
        EvrRtxMutexNotAcquired(mutex);
    6398:	9804      	ldr	r0, [sp, #16]
    639a:	f7fe fa16 	bl	47ca <EvrRtxMutexNotAcquired>
        status = osErrorResource;
    639e:	f06f 0302 	mvn.w	r3, #2
    63a2:	9305      	str	r3, [sp, #20]
      }
    }
  }

  return status;
    63a4:	9b05      	ldr	r3, [sp, #20]
}
    63a6:	4618      	mov	r0, r3
    63a8:	b007      	add	sp, #28
    63aa:	f85d fb04 	ldr.w	pc, [sp], #4

000063ae <svcRtxMutexRelease>:

/// Release a Mutex that was acquired by osMutexAcquire.
/// \note API identical to osMutexRelease
static osStatus_t svcRtxMutexRelease (osMutexId_t mutex_id) {
    63ae:	b500      	push	{lr}
    63b0:	b089      	sub	sp, #36	; 0x24
    63b2:	9001      	str	r0, [sp, #4]
        os_mutex_t  *mutex = osRtxMutexId(mutex_id);
    63b4:	9801      	ldr	r0, [sp, #4]
    63b6:	f7ff fe58 	bl	606a <osRtxMutexId>
    63ba:	9005      	str	r0, [sp, #20]
        os_thread_t *thread;
        os_thread_t *runnig_thread;
        int8_t       priority;

  // Check running thread
  runnig_thread = osRtxThreadGetRunning();
    63bc:	f7ff fe62 	bl	6084 <osRtxThreadGetRunning>
    63c0:	9004      	str	r0, [sp, #16]
  if (runnig_thread == NULL) {
    63c2:	9b04      	ldr	r3, [sp, #16]
    63c4:	2b00      	cmp	r3, #0
    63c6:	d107      	bne.n	63d8 <svcRtxMutexRelease+0x2a>
    EvrRtxMutexError(mutex, osRtxErrorKernelNotRunning);
    63c8:	f06f 0107 	mvn.w	r1, #7
    63cc:	9805      	ldr	r0, [sp, #20]
    63ce:	f7fe f87b 	bl	44c8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    63d2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    63d6:	e0af      	b.n	6538 <svcRtxMutexRelease+0x18a>
  }

  // Check parameters
  if ((mutex == NULL) || (mutex->id != osRtxIdMutex)) {
    63d8:	9b05      	ldr	r3, [sp, #20]
    63da:	2b00      	cmp	r3, #0
    63dc:	d003      	beq.n	63e6 <svcRtxMutexRelease+0x38>
    63de:	9b05      	ldr	r3, [sp, #20]
    63e0:	781b      	ldrb	r3, [r3, #0]
    63e2:	2b04      	cmp	r3, #4
    63e4:	d007      	beq.n	63f6 <svcRtxMutexRelease+0x48>
    EvrRtxMutexError(mutex, (int32_t)osErrorParameter);
    63e6:	f06f 0103 	mvn.w	r1, #3
    63ea:	9805      	ldr	r0, [sp, #20]
    63ec:	f7fe f86c 	bl	44c8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorParameter;
    63f0:	f06f 0303 	mvn.w	r3, #3
    63f4:	e0a0      	b.n	6538 <svcRtxMutexRelease+0x18a>
  }

  // Check object state
  if (mutex->state == osRtxObjectInactive) {
    63f6:	9b05      	ldr	r3, [sp, #20]
    63f8:	785b      	ldrb	r3, [r3, #1]
    63fa:	2b00      	cmp	r3, #0
    63fc:	d107      	bne.n	640e <svcRtxMutexRelease+0x60>
    EvrRtxMutexError(mutex, (int32_t)osErrorResource);
    63fe:	f06f 0102 	mvn.w	r1, #2
    6402:	9805      	ldr	r0, [sp, #20]
    6404:	f7fe f860 	bl	44c8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    6408:	f06f 0302 	mvn.w	r3, #2
    640c:	e094      	b.n	6538 <svcRtxMutexRelease+0x18a>
  }

  // Check if running Thread is not the owner
  if (mutex->owner_thread != runnig_thread) {
    640e:	9b05      	ldr	r3, [sp, #20]
    6410:	68da      	ldr	r2, [r3, #12]
    6412:	9b04      	ldr	r3, [sp, #16]
    6414:	429a      	cmp	r2, r3
    6416:	d007      	beq.n	6428 <svcRtxMutexRelease+0x7a>
    EvrRtxMutexError(mutex, osRtxErrorMutexNotOwned);
    6418:	f06f 010d 	mvn.w	r1, #13
    641c:	9805      	ldr	r0, [sp, #20]
    641e:	f7fe f853 	bl	44c8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    6422:	f06f 0302 	mvn.w	r3, #2
    6426:	e087      	b.n	6538 <svcRtxMutexRelease+0x18a>
  }

  // Check if Mutex is not locked
  if (mutex->lock == 0U) {
    6428:	9b05      	ldr	r3, [sp, #20]
    642a:	7e1b      	ldrb	r3, [r3, #24]
    642c:	2b00      	cmp	r3, #0
    642e:	d107      	bne.n	6440 <svcRtxMutexRelease+0x92>
    EvrRtxMutexError(mutex, osRtxErrorMutexNotLocked);
    6430:	f06f 010e 	mvn.w	r1, #14
    6434:	9805      	ldr	r0, [sp, #20]
    6436:	f7fe f847 	bl	44c8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    643a:	f06f 0302 	mvn.w	r3, #2
    643e:	e07b      	b.n	6538 <svcRtxMutexRelease+0x18a>
  }

  // Decrement Lock counter
  mutex->lock--;
    6440:	9b05      	ldr	r3, [sp, #20]
    6442:	7e1b      	ldrb	r3, [r3, #24]
    6444:	3b01      	subs	r3, #1
    6446:	b2da      	uxtb	r2, r3
    6448:	9b05      	ldr	r3, [sp, #20]
    644a:	761a      	strb	r2, [r3, #24]
  EvrRtxMutexReleased(mutex, mutex->lock);
    644c:	9b05      	ldr	r3, [sp, #20]
    644e:	7e1b      	ldrb	r3, [r3, #24]
    6450:	4619      	mov	r1, r3
    6452:	9805      	ldr	r0, [sp, #20]
    6454:	f7fe f9c3 	bl	47de <EvrRtxMutexReleased>

  // Check Lock counter
  if (mutex->lock == 0U) {
    6458:	9b05      	ldr	r3, [sp, #20]
    645a:	7e1b      	ldrb	r3, [r3, #24]
    645c:	2b00      	cmp	r3, #0
    645e:	d16a      	bne.n	6536 <svcRtxMutexRelease+0x188>

    // Remove Mutex from Thread owner list
    if (mutex->owner_next != NULL) {
    6460:	9b05      	ldr	r3, [sp, #20]
    6462:	695b      	ldr	r3, [r3, #20]
    6464:	2b00      	cmp	r3, #0
    6466:	d004      	beq.n	6472 <svcRtxMutexRelease+0xc4>
      mutex->owner_next->owner_prev = mutex->owner_prev;
    6468:	9b05      	ldr	r3, [sp, #20]
    646a:	695b      	ldr	r3, [r3, #20]
    646c:	9a05      	ldr	r2, [sp, #20]
    646e:	6912      	ldr	r2, [r2, #16]
    6470:	611a      	str	r2, [r3, #16]
    }
    if (mutex->owner_prev != NULL) {
    6472:	9b05      	ldr	r3, [sp, #20]
    6474:	691b      	ldr	r3, [r3, #16]
    6476:	2b00      	cmp	r3, #0
    6478:	d005      	beq.n	6486 <svcRtxMutexRelease+0xd8>
      mutex->owner_prev->owner_next = mutex->owner_next;
    647a:	9b05      	ldr	r3, [sp, #20]
    647c:	691b      	ldr	r3, [r3, #16]
    647e:	9a05      	ldr	r2, [sp, #20]
    6480:	6952      	ldr	r2, [r2, #20]
    6482:	615a      	str	r2, [r3, #20]
    6484:	e003      	b.n	648e <svcRtxMutexRelease+0xe0>
    } else {
      runnig_thread->mutex_list = mutex->owner_next;
    6486:	9b05      	ldr	r3, [sp, #20]
    6488:	695a      	ldr	r2, [r3, #20]
    648a:	9b04      	ldr	r3, [sp, #16]
    648c:	62da      	str	r2, [r3, #44]	; 0x2c
    }

    // Restore running Thread priority
    if ((mutex->attr & osMutexPrioInherit) != 0U) {
    648e:	9b05      	ldr	r3, [sp, #20]
    6490:	78db      	ldrb	r3, [r3, #3]
    6492:	f003 0302 	and.w	r3, r3, #2
    6496:	2b00      	cmp	r3, #0
    6498:	d025      	beq.n	64e6 <svcRtxMutexRelease+0x138>
      priority = runnig_thread->priority_base;
    649a:	9b04      	ldr	r3, [sp, #16]
    649c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    64a0:	f88d 301b 	strb.w	r3, [sp, #27]
      mutex0   = runnig_thread->mutex_list;
    64a4:	9b04      	ldr	r3, [sp, #16]
    64a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    64a8:	9307      	str	r3, [sp, #28]
      while (mutex0 != NULL) {
    64aa:	e014      	b.n	64d6 <svcRtxMutexRelease+0x128>
        // Mutexes owned by running Thread
        if ((mutex0->thread_list != NULL) && (mutex0->thread_list->priority > priority)) {
    64ac:	9b07      	ldr	r3, [sp, #28]
    64ae:	689b      	ldr	r3, [r3, #8]
    64b0:	2b00      	cmp	r3, #0
    64b2:	d00d      	beq.n	64d0 <svcRtxMutexRelease+0x122>
    64b4:	9b07      	ldr	r3, [sp, #28]
    64b6:	689b      	ldr	r3, [r3, #8]
    64b8:	f993 3020 	ldrsb.w	r3, [r3, #32]
    64bc:	f99d 201b 	ldrsb.w	r2, [sp, #27]
    64c0:	429a      	cmp	r2, r3
    64c2:	da05      	bge.n	64d0 <svcRtxMutexRelease+0x122>
          // Higher priority Thread is waiting for Mutex
          priority = mutex0->thread_list->priority;
    64c4:	9b07      	ldr	r3, [sp, #28]
    64c6:	689b      	ldr	r3, [r3, #8]
    64c8:	f893 3020 	ldrb.w	r3, [r3, #32]
    64cc:	f88d 301b 	strb.w	r3, [sp, #27]
        }
        mutex0 = mutex0->owner_next;
    64d0:	9b07      	ldr	r3, [sp, #28]
    64d2:	695b      	ldr	r3, [r3, #20]
    64d4:	9307      	str	r3, [sp, #28]
      while (mutex0 != NULL) {
    64d6:	9b07      	ldr	r3, [sp, #28]
    64d8:	2b00      	cmp	r3, #0
    64da:	d1e7      	bne.n	64ac <svcRtxMutexRelease+0xfe>
      }
      runnig_thread->priority = priority;
    64dc:	9b04      	ldr	r3, [sp, #16]
    64de:	f89d 201b 	ldrb.w	r2, [sp, #27]
    64e2:	f883 2020 	strb.w	r2, [r3, #32]
    }

    // Check if Thread is waiting for a Mutex
    if (mutex->thread_list != NULL) {
    64e6:	9b05      	ldr	r3, [sp, #20]
    64e8:	689b      	ldr	r3, [r3, #8]
    64ea:	2b00      	cmp	r3, #0
    64ec:	d020      	beq.n	6530 <svcRtxMutexRelease+0x182>
      // Wakeup waiting Thread with highest Priority
      thread = osRtxThreadListGet(osRtxObject(mutex));
    64ee:	9805      	ldr	r0, [sp, #20]
    64f0:	f7ff fdc1 	bl	6076 <osRtxObject>
    64f4:	4603      	mov	r3, r0
    64f6:	4618      	mov	r0, r3
    64f8:	f000 fb72 	bl	6be0 <osRtxThreadListGet>
    64fc:	9003      	str	r0, [sp, #12]
      osRtxThreadWaitExit(thread, (uint32_t)osOK, FALSE);
    64fe:	2200      	movs	r2, #0
    6500:	2100      	movs	r1, #0
    6502:	9803      	ldr	r0, [sp, #12]
    6504:	f000 fe0c 	bl	7120 <osRtxThreadWaitExit>
      // Thread is the new Mutex owner
      mutex->owner_thread = thread;
    6508:	9b05      	ldr	r3, [sp, #20]
    650a:	9a03      	ldr	r2, [sp, #12]
    650c:	60da      	str	r2, [r3, #12]
      mutex->owner_next   = thread->mutex_list;
    650e:	9b03      	ldr	r3, [sp, #12]
    6510:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    6512:	9b05      	ldr	r3, [sp, #20]
    6514:	615a      	str	r2, [r3, #20]
      mutex->owner_prev   = NULL;
    6516:	9b05      	ldr	r3, [sp, #20]
    6518:	2200      	movs	r2, #0
    651a:	611a      	str	r2, [r3, #16]
      thread->mutex_list  = mutex;
    651c:	9b03      	ldr	r3, [sp, #12]
    651e:	9a05      	ldr	r2, [sp, #20]
    6520:	62da      	str	r2, [r3, #44]	; 0x2c
      mutex->lock = 1U;
    6522:	9b05      	ldr	r3, [sp, #20]
    6524:	2201      	movs	r2, #1
    6526:	761a      	strb	r2, [r3, #24]
      EvrRtxMutexAcquired(mutex, 1U);
    6528:	2101      	movs	r1, #1
    652a:	9805      	ldr	r0, [sp, #20]
    652c:	f7fe f947 	bl	47be <EvrRtxMutexAcquired>
    }

    osRtxThreadDispatch(NULL);
    6530:	2000      	movs	r0, #0
    6532:	f000 fda9 	bl	7088 <osRtxThreadDispatch>
  }

  return osOK;
    6536:	2300      	movs	r3, #0
}
    6538:	4618      	mov	r0, r3
    653a:	b009      	add	sp, #36	; 0x24
    653c:	f85d fb04 	ldr.w	pc, [sp], #4

00006540 <osMutexNew>:


//  ==== Public API ====

/// Create and Initialize a Mutex object.
osMutexId_t osMutexNew (const osMutexAttr_t *attr) {
    6540:	b500      	push	{lr}
    6542:	b085      	sub	sp, #20
    6544:	9001      	str	r0, [sp, #4]
  osMutexId_t mutex_id;

  EvrRtxMutexNew(attr);
    6546:	9801      	ldr	r0, [sp, #4]
    6548:	f7fe f91d 	bl	4786 <EvrRtxMutexNew>
  if (IsIrqMode() || IsIrqMasked()) {
    654c:	f7ff fd6a 	bl	6024 <IsIrqMode>
    6550:	4603      	mov	r3, r0
    6552:	2b00      	cmp	r3, #0
    6554:	d104      	bne.n	6560 <osMutexNew+0x20>
    6556:	f7ff fd72 	bl	603e <IsIrqMasked>
    655a:	4603      	mov	r3, r0
    655c:	2b00      	cmp	r3, #0
    655e:	d007      	beq.n	6570 <osMutexNew+0x30>
    EvrRtxMutexError(NULL, (int32_t)osErrorISR);
    6560:	f06f 0105 	mvn.w	r1, #5
    6564:	2000      	movs	r0, #0
    6566:	f7fd ffaf 	bl	44c8 <EvrRtxMutexError>
    mutex_id = NULL;
    656a:	2300      	movs	r3, #0
    656c:	9303      	str	r3, [sp, #12]
    656e:	e008      	b.n	6582 <osMutexNew+0x42>
    6570:	9b01      	ldr	r3, [sp, #4]
    6572:	9302      	str	r3, [sp, #8]
SVC0_1(MutexNew,      osMutexId_t,  const osMutexAttr_t *)
    6574:	9b02      	ldr	r3, [sp, #8]
    6576:	4618      	mov	r0, r3
    6578:	4b04      	ldr	r3, [pc, #16]	; (658c <osMutexNew+0x4c>)
    657a:	469c      	mov	ip, r3
    657c:	df00      	svc	0
    657e:	4603      	mov	r3, r0
  } else {
    mutex_id = __svcMutexNew(attr);
    6580:	9303      	str	r3, [sp, #12]
  }
  return mutex_id;
    6582:	9b03      	ldr	r3, [sp, #12]
}
    6584:	4618      	mov	r0, r3
    6586:	b005      	add	sp, #20
    6588:	f85d fb04 	ldr.w	pc, [sp], #4
    658c:	00006119 	.word	0x00006119

00006590 <osMutexAcquire>:
  }
  return name;
}

/// Acquire a Mutex or timeout if it is locked.
osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
    6590:	b500      	push	{lr}
    6592:	b087      	sub	sp, #28
    6594:	9001      	str	r0, [sp, #4]
    6596:	9100      	str	r1, [sp, #0]
  osStatus_t status;

  EvrRtxMutexAcquire(mutex_id, timeout);
    6598:	9900      	ldr	r1, [sp, #0]
    659a:	9801      	ldr	r0, [sp, #4]
    659c:	f7fe f8fe 	bl	479c <EvrRtxMutexAcquire>
  if (IsIrqMode() || IsIrqMasked()) {
    65a0:	f7ff fd40 	bl	6024 <IsIrqMode>
    65a4:	4603      	mov	r3, r0
    65a6:	2b00      	cmp	r3, #0
    65a8:	d104      	bne.n	65b4 <osMutexAcquire+0x24>
    65aa:	f7ff fd48 	bl	603e <IsIrqMasked>
    65ae:	4603      	mov	r3, r0
    65b0:	2b00      	cmp	r3, #0
    65b2:	d008      	beq.n	65c6 <osMutexAcquire+0x36>
    EvrRtxMutexError(mutex_id, (int32_t)osErrorISR);
    65b4:	f06f 0105 	mvn.w	r1, #5
    65b8:	9801      	ldr	r0, [sp, #4]
    65ba:	f7fd ff85 	bl	44c8 <EvrRtxMutexError>
    status = osErrorISR;
    65be:	f06f 0305 	mvn.w	r3, #5
    65c2:	9305      	str	r3, [sp, #20]
    65c4:	e00b      	b.n	65de <osMutexAcquire+0x4e>
    65c6:	9b01      	ldr	r3, [sp, #4]
    65c8:	9304      	str	r3, [sp, #16]
    65ca:	9b00      	ldr	r3, [sp, #0]
    65cc:	9303      	str	r3, [sp, #12]
SVC0_2(MutexAcquire,  osStatus_t,   osMutexId_t, uint32_t)
    65ce:	9b04      	ldr	r3, [sp, #16]
    65d0:	4618      	mov	r0, r3
    65d2:	9903      	ldr	r1, [sp, #12]
    65d4:	4b04      	ldr	r3, [pc, #16]	; (65e8 <osMutexAcquire+0x58>)
    65d6:	469c      	mov	ip, r3
    65d8:	df00      	svc	0
    65da:	4603      	mov	r3, r0
  } else {
    status = __svcMutexAcquire(mutex_id, timeout);
    65dc:	9305      	str	r3, [sp, #20]
  }
  return status;
    65de:	9b05      	ldr	r3, [sp, #20]
}
    65e0:	4618      	mov	r0, r3
    65e2:	b007      	add	sp, #28
    65e4:	f85d fb04 	ldr.w	pc, [sp], #4
    65e8:	0000622d 	.word	0x0000622d

000065ec <osMutexRelease>:

/// Release a Mutex that was acquired by \ref osMutexAcquire.
osStatus_t osMutexRelease (osMutexId_t mutex_id) {
    65ec:	b500      	push	{lr}
    65ee:	b085      	sub	sp, #20
    65f0:	9001      	str	r0, [sp, #4]
  osStatus_t status;

  EvrRtxMutexRelease(mutex_id);
    65f2:	9801      	ldr	r0, [sp, #4]
    65f4:	f7fe f8ee 	bl	47d4 <EvrRtxMutexRelease>
  if (IsIrqMode() || IsIrqMasked()) {
    65f8:	f7ff fd14 	bl	6024 <IsIrqMode>
    65fc:	4603      	mov	r3, r0
    65fe:	2b00      	cmp	r3, #0
    6600:	d104      	bne.n	660c <osMutexRelease+0x20>
    6602:	f7ff fd1c 	bl	603e <IsIrqMasked>
    6606:	4603      	mov	r3, r0
    6608:	2b00      	cmp	r3, #0
    660a:	d008      	beq.n	661e <osMutexRelease+0x32>
    EvrRtxMutexError(mutex_id, (int32_t)osErrorISR);
    660c:	f06f 0105 	mvn.w	r1, #5
    6610:	9801      	ldr	r0, [sp, #4]
    6612:	f7fd ff59 	bl	44c8 <EvrRtxMutexError>
    status = osErrorISR;
    6616:	f06f 0305 	mvn.w	r3, #5
    661a:	9303      	str	r3, [sp, #12]
    661c:	e008      	b.n	6630 <osMutexRelease+0x44>
    661e:	9b01      	ldr	r3, [sp, #4]
    6620:	9302      	str	r3, [sp, #8]
SVC0_1(MutexRelease,  osStatus_t,   osMutexId_t)
    6622:	9b02      	ldr	r3, [sp, #8]
    6624:	4618      	mov	r0, r3
    6626:	4b05      	ldr	r3, [pc, #20]	; (663c <osMutexRelease+0x50>)
    6628:	469c      	mov	ip, r3
    662a:	df00      	svc	0
    662c:	4603      	mov	r3, r0
  } else {
    status = __svcMutexRelease(mutex_id);
    662e:	9303      	str	r3, [sp, #12]
  }
  return status;
    6630:	9b03      	ldr	r3, [sp, #12]
}
    6632:	4618      	mov	r0, r3
    6634:	b005      	add	sp, #20
    6636:	f85d fb04 	ldr.w	pc, [sp], #4
    663a:	bf00      	nop
    663c:	000063af 	.word	0x000063af

00006640 <SetPendSV>:
  SCB->ICSR = SCB_ICSR_PENDSVSET_Msk;
    6640:	4b02      	ldr	r3, [pc, #8]	; (664c <SetPendSV+0xc>)
    6642:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    6646:	605a      	str	r2, [r3, #4]
}
    6648:	bf00      	nop
    664a:	4770      	bx	lr
    664c:	e000ed00 	.word	0xe000ed00

00006650 <atomic_inc16_lt>:
__STATIC_INLINE uint16_t atomic_inc16_lt (uint16_t *mem, uint16_t max) {
    6650:	b410      	push	{r4}
    6652:	b083      	sub	sp, #12
    6654:	9001      	str	r0, [sp, #4]
    6656:	460b      	mov	r3, r1
    6658:	f8ad 3002 	strh.w	r3, [sp, #2]
  __ASM volatile (
    665c:	9b01      	ldr	r3, [sp, #4]
    665e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    6662:	e8d3 1f5f 	ldrexh	r1, [r3]
    6666:	428a      	cmp	r2, r1
    6668:	d802      	bhi.n	6670 <atomic_inc16_lt+0x20>
    666a:	f3bf 8f2f 	clrex
    666e:	e004      	b.n	667a <atomic_inc16_lt+0x2a>
    6670:	1c48      	adds	r0, r1, #1
    6672:	e8c3 0f54 	strexh	r4, r0, [r3]
    6676:	b104      	cbz	r4, 667a <atomic_inc16_lt+0x2a>
    6678:	e7f3      	b.n	6662 <atomic_inc16_lt+0x12>
    667a:	b28c      	uxth	r4, r1
  return ret;
    667c:	4623      	mov	r3, r4
}
    667e:	4618      	mov	r0, r3
    6680:	b003      	add	sp, #12
    6682:	f85d 4b04 	ldr.w	r4, [sp], #4
    6686:	4770      	bx	lr

00006688 <atomic_inc16_lim>:
__STATIC_INLINE uint16_t atomic_inc16_lim (uint16_t *mem, uint16_t lim) {
    6688:	b410      	push	{r4}
    668a:	b083      	sub	sp, #12
    668c:	9001      	str	r0, [sp, #4]
    668e:	460b      	mov	r3, r1
    6690:	f8ad 3002 	strh.w	r3, [sp, #2]
  __ASM volatile (
    6694:	9b01      	ldr	r3, [sp, #4]
    6696:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    669a:	e8d3 1f5f 	ldrexh	r1, [r3]
    669e:	1c48      	adds	r0, r1, #1
    66a0:	4282      	cmp	r2, r0
    66a2:	d800      	bhi.n	66a6 <atomic_inc16_lim+0x1e>
    66a4:	2000      	movs	r0, #0
    66a6:	e8c3 0f54 	strexh	r4, r0, [r3]
    66aa:	b104      	cbz	r4, 66ae <atomic_inc16_lim+0x26>
    66ac:	e7f5      	b.n	669a <atomic_inc16_lim+0x12>
    66ae:	b28c      	uxth	r4, r1
  return ret;
    66b0:	4623      	mov	r3, r4
}
    66b2:	4618      	mov	r0, r3
    66b4:	b003      	add	sp, #12
    66b6:	f85d 4b04 	ldr.w	r4, [sp], #4
    66ba:	4770      	bx	lr

000066bc <atomic_dec16_nz>:
__STATIC_INLINE uint16_t atomic_dec16_nz (uint16_t *mem) {
    66bc:	b410      	push	{r4}
    66be:	b083      	sub	sp, #12
    66c0:	9001      	str	r0, [sp, #4]
  __ASM volatile (
    66c2:	9b01      	ldr	r3, [sp, #4]
    66c4:	e8d3 2f5f 	ldrexh	r2, [r3]
    66c8:	b912      	cbnz	r2, 66d0 <atomic_dec16_nz+0x14>
    66ca:	f3bf 8f2f 	clrex
    66ce:	e004      	b.n	66da <atomic_dec16_nz+0x1e>
    66d0:	1e51      	subs	r1, r2, #1
    66d2:	e8c3 1f50 	strexh	r0, r1, [r3]
    66d6:	b100      	cbz	r0, 66da <atomic_dec16_nz+0x1e>
    66d8:	e7f4      	b.n	66c4 <atomic_dec16_nz+0x8>
    66da:	b294      	uxth	r4, r2
  return ret;
    66dc:	4623      	mov	r3, r4
}
    66de:	4618      	mov	r0, r3
    66e0:	b003      	add	sp, #12
    66e2:	f85d 4b04 	ldr.w	r4, [sp], #4
    66e6:	4770      	bx	lr

000066e8 <osRtxObject>:
__STATIC_INLINE os_object_t *osRtxObject (void *object) {
    66e8:	b082      	sub	sp, #8
    66ea:	9001      	str	r0, [sp, #4]
  return ((os_object_t *)object);
    66ec:	9b01      	ldr	r3, [sp, #4]
}
    66ee:	4618      	mov	r0, r3
    66f0:	b002      	add	sp, #8
    66f2:	4770      	bx	lr

000066f4 <osRtxThreadObject>:
__STATIC_INLINE os_thread_t *osRtxThreadObject (os_object_t *object) {
    66f4:	b082      	sub	sp, #8
    66f6:	9001      	str	r0, [sp, #4]
  return ((os_thread_t *)object);
    66f8:	9b01      	ldr	r3, [sp, #4]
}
    66fa:	4618      	mov	r0, r3
    66fc:	b002      	add	sp, #8
    66fe:	4770      	bx	lr

00006700 <osRtxEventFlagsObject>:
__STATIC_INLINE os_event_flags_t *osRtxEventFlagsObject (os_object_t *object) {
    6700:	b082      	sub	sp, #8
    6702:	9001      	str	r0, [sp, #4]
  return ((os_event_flags_t *)object);
    6704:	9b01      	ldr	r3, [sp, #4]
}
    6706:	4618      	mov	r0, r3
    6708:	b002      	add	sp, #8
    670a:	4770      	bx	lr

0000670c <osRtxSemaphoreObject>:
__STATIC_INLINE os_semaphore_t *osRtxSemaphoreObject (os_object_t *object) {
    670c:	b082      	sub	sp, #8
    670e:	9001      	str	r0, [sp, #4]
  return ((os_semaphore_t *)object);
    6710:	9b01      	ldr	r3, [sp, #4]
}
    6712:	4618      	mov	r0, r3
    6714:	b002      	add	sp, #8
    6716:	4770      	bx	lr

00006718 <osRtxMemoryPoolObject>:
__STATIC_INLINE os_memory_pool_t *osRtxMemoryPoolObject (os_object_t *object) {
    6718:	b082      	sub	sp, #8
    671a:	9001      	str	r0, [sp, #4]
  return ((os_memory_pool_t *)object);
    671c:	9b01      	ldr	r3, [sp, #4]
}
    671e:	4618      	mov	r0, r3
    6720:	b002      	add	sp, #8
    6722:	4770      	bx	lr

00006724 <osRtxMessageObject>:
__STATIC_INLINE os_message_t *osRtxMessageObject (os_object_t *object) {
    6724:	b082      	sub	sp, #8
    6726:	9001      	str	r0, [sp, #4]
  return ((os_message_t *)object);
    6728:	9b01      	ldr	r3, [sp, #4]
}
    672a:	4618      	mov	r0, r3
    672c:	b002      	add	sp, #8
    672e:	4770      	bx	lr

00006730 <osRtxKernelGetState>:
  return osRtxInfo.kernel.state;
    6730:	4b01      	ldr	r3, [pc, #4]	; (6738 <osRtxKernelGetState+0x8>)
    6732:	7a1b      	ldrb	r3, [r3, #8]
}
    6734:	4618      	mov	r0, r3
    6736:	4770      	bx	lr
    6738:	20000110 	.word	0x20000110

0000673c <isr_queue_put>:
//  ==== Helper functions ====

/// Put Object into ISR Queue.
/// \param[in]  object          object.
/// \return 1 - success, 0 - failure.
static uint32_t isr_queue_put (os_object_t *object) {
    673c:	b500      	push	{lr}
    673e:	b087      	sub	sp, #28
    6740:	9001      	str	r0, [sp, #4]
  uint32_t n;
#endif
  uint16_t max;
  uint32_t ret;

  max = osRtxInfo.isr_queue.max;
    6742:	4b15      	ldr	r3, [pc, #84]	; (6798 <isr_queue_put+0x5c>)
    6744:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
    6748:	f8ad 3012 	strh.w	r3, [sp, #18]
  
  if (primask == 0U) {
    __enable_irq();
  }
#else
  if (atomic_inc16_lt(&osRtxInfo.isr_queue.cnt, max) < max) {
    674c:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    6750:	4619      	mov	r1, r3
    6752:	4812      	ldr	r0, [pc, #72]	; (679c <isr_queue_put+0x60>)
    6754:	f7ff ff7c 	bl	6650 <atomic_inc16_lt>
    6758:	4603      	mov	r3, r0
    675a:	461a      	mov	r2, r3
    675c:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    6760:	4293      	cmp	r3, r2
    6762:	d911      	bls.n	6788 <isr_queue_put+0x4c>
    n = atomic_inc16_lim(&osRtxInfo.isr_queue.in, max);
    6764:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    6768:	4619      	mov	r1, r3
    676a:	480d      	ldr	r0, [pc, #52]	; (67a0 <isr_queue_put+0x64>)
    676c:	f7ff ff8c 	bl	6688 <atomic_inc16_lim>
    6770:	4603      	mov	r3, r0
    6772:	9303      	str	r3, [sp, #12]
    osRtxInfo.isr_queue.data[n] = object;
    6774:	4b08      	ldr	r3, [pc, #32]	; (6798 <isr_queue_put+0x5c>)
    6776:	6dda      	ldr	r2, [r3, #92]	; 0x5c
    6778:	9b03      	ldr	r3, [sp, #12]
    677a:	009b      	lsls	r3, r3, #2
    677c:	4413      	add	r3, r2
    677e:	9a01      	ldr	r2, [sp, #4]
    6780:	601a      	str	r2, [r3, #0]
    ret = 1U;
    6782:	2301      	movs	r3, #1
    6784:	9305      	str	r3, [sp, #20]
    6786:	e001      	b.n	678c <isr_queue_put+0x50>
  } else {
    ret = 0U;
    6788:	2300      	movs	r3, #0
    678a:	9305      	str	r3, [sp, #20]
  }
#endif

  return ret;
    678c:	9b05      	ldr	r3, [sp, #20]
}
    678e:	4618      	mov	r0, r3
    6790:	b007      	add	sp, #28
    6792:	f85d fb04 	ldr.w	pc, [sp], #4
    6796:	bf00      	nop
    6798:	20000110 	.word	0x20000110
    679c:	20000166 	.word	0x20000166
    67a0:	20000168 	.word	0x20000168

000067a4 <isr_queue_get>:

/// Get Object from ISR Queue.
/// \return object or NULL.
static os_object_t *isr_queue_get (void) {
    67a4:	b500      	push	{lr}
    67a6:	b085      	sub	sp, #20
  uint32_t     n;
#endif
  uint16_t     max;
  os_object_t *ret;

  max = osRtxInfo.isr_queue.max;
    67a8:	4b12      	ldr	r3, [pc, #72]	; (67f4 <isr_queue_get+0x50>)
    67aa:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
    67ae:	f8ad 300a 	strh.w	r3, [sp, #10]
  
  if (primask == 0U) {
    __enable_irq();
  }
#else
  if (atomic_dec16_nz(&osRtxInfo.isr_queue.cnt) != 0U) {
    67b2:	4811      	ldr	r0, [pc, #68]	; (67f8 <isr_queue_get+0x54>)
    67b4:	f7ff ff82 	bl	66bc <atomic_dec16_nz>
    67b8:	4603      	mov	r3, r0
    67ba:	2b00      	cmp	r3, #0
    67bc:	d012      	beq.n	67e4 <isr_queue_get+0x40>
    n = atomic_inc16_lim(&osRtxInfo.isr_queue.out, max);
    67be:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    67c2:	4619      	mov	r1, r3
    67c4:	480d      	ldr	r0, [pc, #52]	; (67fc <isr_queue_get+0x58>)
    67c6:	f7ff ff5f 	bl	6688 <atomic_inc16_lim>
    67ca:	4603      	mov	r3, r0
    67cc:	9301      	str	r3, [sp, #4]
    ret = osRtxObject(osRtxInfo.isr_queue.data[n]);
    67ce:	4b09      	ldr	r3, [pc, #36]	; (67f4 <isr_queue_get+0x50>)
    67d0:	6dda      	ldr	r2, [r3, #92]	; 0x5c
    67d2:	9b01      	ldr	r3, [sp, #4]
    67d4:	009b      	lsls	r3, r3, #2
    67d6:	4413      	add	r3, r2
    67d8:	681b      	ldr	r3, [r3, #0]
    67da:	4618      	mov	r0, r3
    67dc:	f7ff ff84 	bl	66e8 <osRtxObject>
    67e0:	9003      	str	r0, [sp, #12]
    67e2:	e001      	b.n	67e8 <isr_queue_get+0x44>
  } else {
    ret = NULL;
    67e4:	2300      	movs	r3, #0
    67e6:	9303      	str	r3, [sp, #12]
  }
#endif

  return ret;
    67e8:	9b03      	ldr	r3, [sp, #12]
}
    67ea:	4618      	mov	r0, r3
    67ec:	b005      	add	sp, #20
    67ee:	f85d fb04 	ldr.w	pc, [sp], #4
    67f2:	bf00      	nop
    67f4:	20000110 	.word	0x20000110
    67f8:	20000166 	.word	0x20000166
    67fc:	2000016a 	.word	0x2000016a

00006800 <osRtxTick_Handler>:

/// Tick Handler.
//lint -esym(714,osRtxTick_Handler) "Referenced by Exception handlers"
//lint -esym(759,osRtxTick_Handler) "Prototype in header"
//lint -esym(765,osRtxTick_Handler) "Global scope"
void osRtxTick_Handler (void) {
    6800:	b500      	push	{lr}
    6802:	b083      	sub	sp, #12
  os_thread_t *thread;

  OS_Tick_AcknowledgeIRQ();
    6804:	f001 fb6c 	bl	7ee0 <OS_Tick_AcknowledgeIRQ>
  osRtxInfo.kernel.tick++;
    6808:	4b2f      	ldr	r3, [pc, #188]	; (68c8 <osRtxTick_Handler+0xc8>)
    680a:	68db      	ldr	r3, [r3, #12]
    680c:	3301      	adds	r3, #1
    680e:	4a2e      	ldr	r2, [pc, #184]	; (68c8 <osRtxTick_Handler+0xc8>)
    6810:	60d3      	str	r3, [r2, #12]

  // Process Timers
  if (osRtxInfo.timer.tick != NULL) {
    6812:	4b2d      	ldr	r3, [pc, #180]	; (68c8 <osRtxTick_Handler+0xc8>)
    6814:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    6816:	2b00      	cmp	r3, #0
    6818:	d002      	beq.n	6820 <osRtxTick_Handler+0x20>
    osRtxInfo.timer.tick();
    681a:	4b2b      	ldr	r3, [pc, #172]	; (68c8 <osRtxTick_Handler+0xc8>)
    681c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    681e:	4798      	blx	r3
  }

  // Process Thread Delays
  osRtxThreadDelayTick();
    6820:	f000 fb1e 	bl	6e60 <osRtxThreadDelayTick>

  osRtxThreadDispatch(NULL);
    6824:	2000      	movs	r0, #0
    6826:	f000 fc2f 	bl	7088 <osRtxThreadDispatch>

  // Check Round Robin timeout
  if (osRtxInfo.thread.robin.timeout != 0U) {
    682a:	4b27      	ldr	r3, [pc, #156]	; (68c8 <osRtxTick_Handler+0xc8>)
    682c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    682e:	2b00      	cmp	r3, #0
    6830:	d046      	beq.n	68c0 <osRtxTick_Handler+0xc0>
    if (osRtxInfo.thread.robin.thread != osRtxInfo.thread.run.next) {
    6832:	4b25      	ldr	r3, [pc, #148]	; (68c8 <osRtxTick_Handler+0xc8>)
    6834:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    6836:	4b24      	ldr	r3, [pc, #144]	; (68c8 <osRtxTick_Handler+0xc8>)
    6838:	699b      	ldr	r3, [r3, #24]
    683a:	429a      	cmp	r2, r3
    683c:	d008      	beq.n	6850 <osRtxTick_Handler+0x50>
      // Reset Round Robin
      osRtxInfo.thread.robin.thread = osRtxInfo.thread.run.next;
    683e:	4b22      	ldr	r3, [pc, #136]	; (68c8 <osRtxTick_Handler+0xc8>)
    6840:	699b      	ldr	r3, [r3, #24]
    6842:	4a21      	ldr	r2, [pc, #132]	; (68c8 <osRtxTick_Handler+0xc8>)
    6844:	6393      	str	r3, [r2, #56]	; 0x38
      osRtxInfo.thread.robin.tick   = osRtxInfo.thread.robin.timeout;
    6846:	4b20      	ldr	r3, [pc, #128]	; (68c8 <osRtxTick_Handler+0xc8>)
    6848:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    684a:	4a1f      	ldr	r2, [pc, #124]	; (68c8 <osRtxTick_Handler+0xc8>)
    684c:	63d3      	str	r3, [r2, #60]	; 0x3c
          }
        }
      }
    }
  }
}
    684e:	e037      	b.n	68c0 <osRtxTick_Handler+0xc0>
      if (osRtxInfo.thread.robin.tick != 0U) {
    6850:	4b1d      	ldr	r3, [pc, #116]	; (68c8 <osRtxTick_Handler+0xc8>)
    6852:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    6854:	2b00      	cmp	r3, #0
    6856:	d004      	beq.n	6862 <osRtxTick_Handler+0x62>
        osRtxInfo.thread.robin.tick--;
    6858:	4b1b      	ldr	r3, [pc, #108]	; (68c8 <osRtxTick_Handler+0xc8>)
    685a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    685c:	3b01      	subs	r3, #1
    685e:	4a1a      	ldr	r2, [pc, #104]	; (68c8 <osRtxTick_Handler+0xc8>)
    6860:	63d3      	str	r3, [r2, #60]	; 0x3c
      if (osRtxInfo.thread.robin.tick == 0U) {
    6862:	4b19      	ldr	r3, [pc, #100]	; (68c8 <osRtxTick_Handler+0xc8>)
    6864:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    6866:	2b00      	cmp	r3, #0
    6868:	d12a      	bne.n	68c0 <osRtxTick_Handler+0xc0>
        if (osRtxKernelGetState() == osRtxKernelRunning) {
    686a:	f7ff ff61 	bl	6730 <osRtxKernelGetState>
    686e:	4603      	mov	r3, r0
    6870:	2b02      	cmp	r3, #2
    6872:	d125      	bne.n	68c0 <osRtxTick_Handler+0xc0>
          thread = osRtxInfo.thread.ready.thread_list;
    6874:	4b14      	ldr	r3, [pc, #80]	; (68c8 <osRtxTick_Handler+0xc8>)
    6876:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6878:	9301      	str	r3, [sp, #4]
          if ((thread != NULL) && (thread->priority == osRtxInfo.thread.robin.thread->priority)) {
    687a:	9b01      	ldr	r3, [sp, #4]
    687c:	2b00      	cmp	r3, #0
    687e:	d01f      	beq.n	68c0 <osRtxTick_Handler+0xc0>
    6880:	9b01      	ldr	r3, [sp, #4]
    6882:	f993 2020 	ldrsb.w	r2, [r3, #32]
    6886:	4b10      	ldr	r3, [pc, #64]	; (68c8 <osRtxTick_Handler+0xc8>)
    6888:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    688a:	f993 3020 	ldrsb.w	r3, [r3, #32]
    688e:	429a      	cmp	r2, r3
    6890:	d116      	bne.n	68c0 <osRtxTick_Handler+0xc0>
            osRtxThreadListRemove(thread);
    6892:	9801      	ldr	r0, [sp, #4]
    6894:	f000 f9f8 	bl	6c88 <osRtxThreadListRemove>
            osRtxThreadReadyPut(osRtxInfo.thread.robin.thread);
    6898:	4b0b      	ldr	r3, [pc, #44]	; (68c8 <osRtxTick_Handler+0xc8>)
    689a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    689c:	4618      	mov	r0, r3
    689e:	f000 fa0d 	bl	6cbc <osRtxThreadReadyPut>
            EvrRtxThreadPreempted(osRtxInfo.thread.robin.thread);
    68a2:	4b09      	ldr	r3, [pc, #36]	; (68c8 <osRtxTick_Handler+0xc8>)
    68a4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    68a6:	4618      	mov	r0, r3
    68a8:	f7fd ff37 	bl	471a <EvrRtxThreadPreempted>
            osRtxThreadSwitch(thread);
    68ac:	9801      	ldr	r0, [sp, #4]
    68ae:	f000 fbad 	bl	700c <osRtxThreadSwitch>
            osRtxInfo.thread.robin.thread = thread;
    68b2:	4a05      	ldr	r2, [pc, #20]	; (68c8 <osRtxTick_Handler+0xc8>)
    68b4:	9b01      	ldr	r3, [sp, #4]
    68b6:	6393      	str	r3, [r2, #56]	; 0x38
            osRtxInfo.thread.robin.tick   = osRtxInfo.thread.robin.timeout;
    68b8:	4b03      	ldr	r3, [pc, #12]	; (68c8 <osRtxTick_Handler+0xc8>)
    68ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    68bc:	4a02      	ldr	r2, [pc, #8]	; (68c8 <osRtxTick_Handler+0xc8>)
    68be:	63d3      	str	r3, [r2, #60]	; 0x3c
}
    68c0:	bf00      	nop
    68c2:	b003      	add	sp, #12
    68c4:	f85d fb04 	ldr.w	pc, [sp], #4
    68c8:	20000110 	.word	0x20000110

000068cc <osRtxPendSV_Handler>:

/// Pending Service Call Handler.
//lint -esym(714,osRtxPendSV_Handler) "Referenced by Exception handlers"
//lint -esym(759,osRtxPendSV_Handler) "Prototype in header"
//lint -esym(765,osRtxPendSV_Handler) "Global scope"
void osRtxPendSV_Handler (void) {
    68cc:	b510      	push	{r4, lr}
    68ce:	b082      	sub	sp, #8
  os_object_t *object;

  for (;;) {
    object = isr_queue_get();
    68d0:	f7ff ff68 	bl	67a4 <isr_queue_get>
    68d4:	9001      	str	r0, [sp, #4]
    if (object == NULL) {
    68d6:	9b01      	ldr	r3, [sp, #4]
    68d8:	2b00      	cmp	r3, #0
    68da:	d044      	beq.n	6966 <osRtxPendSV_Handler+0x9a>
      break;
    }
    switch (object->id) {
    68dc:	9b01      	ldr	r3, [sp, #4]
    68de:	781b      	ldrb	r3, [r3, #0]
    68e0:	3b01      	subs	r3, #1
    68e2:	2b06      	cmp	r3, #6
    68e4:	d83d      	bhi.n	6962 <osRtxPendSV_Handler+0x96>
    68e6:	a201      	add	r2, pc, #4	; (adr r2, 68ec <osRtxPendSV_Handler+0x20>)
    68e8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    68ec:	00006909 	.word	0x00006909
    68f0:	00006963 	.word	0x00006963
    68f4:	0000691b 	.word	0x0000691b
    68f8:	00006963 	.word	0x00006963
    68fc:	0000692d 	.word	0x0000692d
    6900:	0000693f 	.word	0x0000693f
    6904:	00006951 	.word	0x00006951
      case osRtxIdThread:
        osRtxInfo.post_process.thread(osRtxThreadObject(object));
    6908:	4b1a      	ldr	r3, [pc, #104]	; (6974 <osRtxPendSV_Handler+0xa8>)
    690a:	6e1c      	ldr	r4, [r3, #96]	; 0x60
    690c:	9801      	ldr	r0, [sp, #4]
    690e:	f7ff fef1 	bl	66f4 <osRtxThreadObject>
    6912:	4603      	mov	r3, r0
    6914:	4618      	mov	r0, r3
    6916:	47a0      	blx	r4
        break;
    6918:	e024      	b.n	6964 <osRtxPendSV_Handler+0x98>
      case osRtxIdEventFlags:
        osRtxInfo.post_process.event_flags(osRtxEventFlagsObject(object));
    691a:	4b16      	ldr	r3, [pc, #88]	; (6974 <osRtxPendSV_Handler+0xa8>)
    691c:	6e5c      	ldr	r4, [r3, #100]	; 0x64
    691e:	9801      	ldr	r0, [sp, #4]
    6920:	f7ff feee 	bl	6700 <osRtxEventFlagsObject>
    6924:	4603      	mov	r3, r0
    6926:	4618      	mov	r0, r3
    6928:	47a0      	blx	r4
        break;
    692a:	e01b      	b.n	6964 <osRtxPendSV_Handler+0x98>
      case osRtxIdSemaphore:
        osRtxInfo.post_process.semaphore(osRtxSemaphoreObject(object));
    692c:	4b11      	ldr	r3, [pc, #68]	; (6974 <osRtxPendSV_Handler+0xa8>)
    692e:	6e9c      	ldr	r4, [r3, #104]	; 0x68
    6930:	9801      	ldr	r0, [sp, #4]
    6932:	f7ff feeb 	bl	670c <osRtxSemaphoreObject>
    6936:	4603      	mov	r3, r0
    6938:	4618      	mov	r0, r3
    693a:	47a0      	blx	r4
        break;
    693c:	e012      	b.n	6964 <osRtxPendSV_Handler+0x98>
      case osRtxIdMemoryPool:
        osRtxInfo.post_process.memory_pool(osRtxMemoryPoolObject(object));
    693e:	4b0d      	ldr	r3, [pc, #52]	; (6974 <osRtxPendSV_Handler+0xa8>)
    6940:	6edc      	ldr	r4, [r3, #108]	; 0x6c
    6942:	9801      	ldr	r0, [sp, #4]
    6944:	f7ff fee8 	bl	6718 <osRtxMemoryPoolObject>
    6948:	4603      	mov	r3, r0
    694a:	4618      	mov	r0, r3
    694c:	47a0      	blx	r4
        break;
    694e:	e009      	b.n	6964 <osRtxPendSV_Handler+0x98>
      case osRtxIdMessage:
        osRtxInfo.post_process.message(osRtxMessageObject(object));
    6950:	4b08      	ldr	r3, [pc, #32]	; (6974 <osRtxPendSV_Handler+0xa8>)
    6952:	6f1c      	ldr	r4, [r3, #112]	; 0x70
    6954:	9801      	ldr	r0, [sp, #4]
    6956:	f7ff fee5 	bl	6724 <osRtxMessageObject>
    695a:	4603      	mov	r3, r0
    695c:	4618      	mov	r0, r3
    695e:	47a0      	blx	r4
        break;
    6960:	e000      	b.n	6964 <osRtxPendSV_Handler+0x98>
      default:
        // Should never come here
        break;
    6962:	bf00      	nop
    object = isr_queue_get();
    6964:	e7b4      	b.n	68d0 <osRtxPendSV_Handler+0x4>
      break;
    6966:	bf00      	nop
    }
  }

  osRtxThreadDispatch(NULL);
    6968:	2000      	movs	r0, #0
    696a:	f000 fb8d 	bl	7088 <osRtxThreadDispatch>
}
    696e:	bf00      	nop
    6970:	b002      	add	sp, #8
    6972:	bd10      	pop	{r4, pc}
    6974:	20000110 	.word	0x20000110

00006978 <osRtxPostProcess>:

/// Register post ISR processing.
/// \param[in]  object          generic object.
void osRtxPostProcess (os_object_t *object) {
    6978:	b500      	push	{lr}
    697a:	b083      	sub	sp, #12
    697c:	9001      	str	r0, [sp, #4]

  if (isr_queue_put(object) != 0U) {
    697e:	9801      	ldr	r0, [sp, #4]
    6980:	f7ff fedc 	bl	673c <isr_queue_put>
    6984:	4603      	mov	r3, r0
    6986:	2b00      	cmp	r3, #0
    6988:	d00b      	beq.n	69a2 <osRtxPostProcess+0x2a>
    if (osRtxInfo.kernel.blocked == 0U) {
    698a:	4b0a      	ldr	r3, [pc, #40]	; (69b4 <osRtxPostProcess+0x3c>)
    698c:	7a5b      	ldrb	r3, [r3, #9]
    698e:	b2db      	uxtb	r3, r3
    6990:	2b00      	cmp	r3, #0
    6992:	d102      	bne.n	699a <osRtxPostProcess+0x22>
      SetPendSV();
    6994:	f7ff fe54 	bl	6640 <SetPendSV>
      osRtxInfo.kernel.pendSV = 1U;
    }
  } else {
    (void)osRtxErrorNotify(osRtxErrorISRQueueOverflow, object);
  }
}
    6998:	e007      	b.n	69aa <osRtxPostProcess+0x32>
      osRtxInfo.kernel.pendSV = 1U;
    699a:	4b06      	ldr	r3, [pc, #24]	; (69b4 <osRtxPostProcess+0x3c>)
    699c:	2201      	movs	r2, #1
    699e:	729a      	strb	r2, [r3, #10]
}
    69a0:	e003      	b.n	69aa <osRtxPostProcess+0x32>
    (void)osRtxErrorNotify(osRtxErrorISRQueueOverflow, object);
    69a2:	9901      	ldr	r1, [sp, #4]
    69a4:	2002      	movs	r0, #2
    69a6:	f7fd fcc9 	bl	433c <osRtxErrorNotify>
}
    69aa:	bf00      	nop
    69ac:	b003      	add	sp, #12
    69ae:	f85d fb04 	ldr.w	pc, [sp], #4
    69b2:	bf00      	nop
    69b4:	20000110 	.word	0x20000110

000069b8 <xPSR_InitVal>:
__STATIC_INLINE uint32_t xPSR_InitVal (bool_t privileged, bool_t thumb) {
    69b8:	b082      	sub	sp, #8
    69ba:	4603      	mov	r3, r0
    69bc:	460a      	mov	r2, r1
    69be:	f88d 3007 	strb.w	r3, [sp, #7]
    69c2:	4613      	mov	r3, r2
    69c4:	f88d 3006 	strb.w	r3, [sp, #6]
  return (0x01000000U);
    69c8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
}
    69cc:	4618      	mov	r0, r3
    69ce:	b002      	add	sp, #8
    69d0:	4770      	bx	lr

000069d2 <StackOffsetR0>:
__STATIC_INLINE uint32_t StackOffsetR0 (uint8_t stack_frame) {
    69d2:	b082      	sub	sp, #8
    69d4:	4603      	mov	r3, r0
    69d6:	f88d 3007 	strb.w	r3, [sp, #7]
  return (((stack_frame & 0x10U) == 0U) ? ((16U+8U)*4U) : (8U*4U));
    69da:	f89d 3007 	ldrb.w	r3, [sp, #7]
    69de:	f003 0310 	and.w	r3, r3, #16
    69e2:	2b00      	cmp	r3, #0
    69e4:	d101      	bne.n	69ea <StackOffsetR0+0x18>
    69e6:	2360      	movs	r3, #96	; 0x60
    69e8:	e000      	b.n	69ec <StackOffsetR0+0x1a>
    69ea:	2320      	movs	r3, #32
}
    69ec:	4618      	mov	r0, r3
    69ee:	b002      	add	sp, #8
    69f0:	4770      	bx	lr

000069f2 <IsIrqMode>:
__STATIC_INLINE bool_t IsIrqMode (void) {
    69f2:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    69f4:	f3ef 8305 	mrs	r3, IPSR
    69f8:	9301      	str	r3, [sp, #4]
  return(result);
    69fa:	9b01      	ldr	r3, [sp, #4]
  return (__get_IPSR() != 0U);
    69fc:	2b00      	cmp	r3, #0
    69fe:	bf14      	ite	ne
    6a00:	2301      	movne	r3, #1
    6a02:	2300      	moveq	r3, #0
    6a04:	b2db      	uxtb	r3, r3
}
    6a06:	4618      	mov	r0, r3
    6a08:	b002      	add	sp, #8
    6a0a:	4770      	bx	lr

00006a0c <IsIrqMasked>:
__STATIC_INLINE bool_t IsIrqMasked (void) {
    6a0c:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    6a0e:	f3ef 8310 	mrs	r3, PRIMASK
    6a12:	9301      	str	r3, [sp, #4]
  return(result);
    6a14:	9b01      	ldr	r3, [sp, #4]
  return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
    6a16:	2b00      	cmp	r3, #0
    6a18:	d105      	bne.n	6a26 <IsIrqMasked+0x1a>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
    6a1a:	f3ef 8311 	mrs	r3, BASEPRI
    6a1e:	9300      	str	r3, [sp, #0]
  return(result);
    6a20:	9b00      	ldr	r3, [sp, #0]
    6a22:	2b00      	cmp	r3, #0
    6a24:	d001      	beq.n	6a2a <IsIrqMasked+0x1e>
    6a26:	2301      	movs	r3, #1
    6a28:	e000      	b.n	6a2c <IsIrqMasked+0x20>
    6a2a:	2300      	movs	r3, #0
    6a2c:	f003 0301 	and.w	r3, r3, #1
    6a30:	b2db      	uxtb	r3, r3
}
    6a32:	4618      	mov	r0, r3
    6a34:	b002      	add	sp, #8
    6a36:	4770      	bx	lr

00006a38 <atomic_chk32_all>:
__STATIC_INLINE uint32_t atomic_chk32_all (uint32_t *mem, uint32_t bits) {
    6a38:	b410      	push	{r4}
    6a3a:	b083      	sub	sp, #12
    6a3c:	9001      	str	r0, [sp, #4]
    6a3e:	9100      	str	r1, [sp, #0]
  __ASM volatile (
    6a40:	9b01      	ldr	r3, [sp, #4]
    6a42:	9a00      	ldr	r2, [sp, #0]
    6a44:	e853 1f00 	ldrex	r1, [r3]
    6a48:	ea01 0002 	and.w	r0, r1, r2
    6a4c:	4290      	cmp	r0, r2
    6a4e:	d003      	beq.n	6a58 <atomic_chk32_all+0x20>
    6a50:	f3bf 8f2f 	clrex
    6a54:	2100      	movs	r1, #0
    6a56:	e005      	b.n	6a64 <atomic_chk32_all+0x2c>
    6a58:	ea21 0002 	bic.w	r0, r1, r2
    6a5c:	e843 0400 	strex	r4, r0, [r3]
    6a60:	b104      	cbz	r4, 6a64 <atomic_chk32_all+0x2c>
    6a62:	e7ef      	b.n	6a44 <atomic_chk32_all+0xc>
    6a64:	460c      	mov	r4, r1
  return ret;
    6a66:	4623      	mov	r3, r4
}
    6a68:	4618      	mov	r0, r3
    6a6a:	b003      	add	sp, #12
    6a6c:	f85d 4b04 	ldr.w	r4, [sp], #4
    6a70:	4770      	bx	lr

00006a72 <atomic_chk32_any>:
__STATIC_INLINE uint32_t atomic_chk32_any (uint32_t *mem, uint32_t bits) {
    6a72:	b410      	push	{r4}
    6a74:	b083      	sub	sp, #12
    6a76:	9001      	str	r0, [sp, #4]
    6a78:	9100      	str	r1, [sp, #0]
  __ASM volatile (
    6a7a:	9b01      	ldr	r3, [sp, #4]
    6a7c:	9a00      	ldr	r2, [sp, #0]
    6a7e:	e853 1f00 	ldrex	r1, [r3]
    6a82:	4211      	tst	r1, r2
    6a84:	d103      	bne.n	6a8e <atomic_chk32_any+0x1c>
    6a86:	f3bf 8f2f 	clrex
    6a8a:	2100      	movs	r1, #0
    6a8c:	e005      	b.n	6a9a <atomic_chk32_any+0x28>
    6a8e:	ea21 0002 	bic.w	r0, r1, r2
    6a92:	e843 0400 	strex	r4, r0, [r3]
    6a96:	b104      	cbz	r4, 6a9a <atomic_chk32_any+0x28>
    6a98:	e7f1      	b.n	6a7e <atomic_chk32_any+0xc>
    6a9a:	460c      	mov	r4, r1
  return ret;
    6a9c:	4623      	mov	r3, r4
}
    6a9e:	4618      	mov	r0, r3
    6aa0:	b003      	add	sp, #12
    6aa2:	f85d 4b04 	ldr.w	r4, [sp], #4
    6aa6:	4770      	bx	lr

00006aa8 <osRtxThreadId>:
__STATIC_INLINE os_thread_t *osRtxThreadId (osThreadId_t thread_id) {
    6aa8:	b082      	sub	sp, #8
    6aaa:	9001      	str	r0, [sp, #4]
  return ((os_thread_t *)thread_id);
    6aac:	9b01      	ldr	r3, [sp, #4]
}
    6aae:	4618      	mov	r0, r3
    6ab0:	b002      	add	sp, #8
    6ab2:	4770      	bx	lr

00006ab4 <osRtxObject>:
__STATIC_INLINE os_object_t *osRtxObject (void *object) {
    6ab4:	b082      	sub	sp, #8
    6ab6:	9001      	str	r0, [sp, #4]
  return ((os_object_t *)object);
    6ab8:	9b01      	ldr	r3, [sp, #4]
}
    6aba:	4618      	mov	r0, r3
    6abc:	b002      	add	sp, #8
    6abe:	4770      	bx	lr

00006ac0 <osRtxThreadObject>:
__STATIC_INLINE os_thread_t *osRtxThreadObject (os_object_t *object) {
    6ac0:	b082      	sub	sp, #8
    6ac2:	9001      	str	r0, [sp, #4]
  return ((os_thread_t *)object);
    6ac4:	9b01      	ldr	r3, [sp, #4]
}
    6ac6:	4618      	mov	r0, r3
    6ac8:	b002      	add	sp, #8
    6aca:	4770      	bx	lr

00006acc <osRtxKernelGetState>:
  return osRtxInfo.kernel.state;
    6acc:	4b01      	ldr	r3, [pc, #4]	; (6ad4 <osRtxKernelGetState+0x8>)
    6ace:	7a1b      	ldrb	r3, [r3, #8]
}
    6ad0:	4618      	mov	r0, r3
    6ad2:	4770      	bx	lr
    6ad4:	20000110 	.word	0x20000110

00006ad8 <osRtxThreadGetRunning>:
  return osRtxInfo.thread.run.curr;
    6ad8:	4b01      	ldr	r3, [pc, #4]	; (6ae0 <osRtxThreadGetRunning+0x8>)
    6ada:	695b      	ldr	r3, [r3, #20]
}
    6adc:	4618      	mov	r0, r3
    6ade:	4770      	bx	lr
    6ae0:	20000110 	.word	0x20000110

00006ae4 <osRtxThreadSetRunning>:
__STATIC_INLINE void osRtxThreadSetRunning (os_thread_t *thread) {
    6ae4:	b082      	sub	sp, #8
    6ae6:	9001      	str	r0, [sp, #4]
  osRtxInfo.thread.run.curr = thread;
    6ae8:	4a02      	ldr	r2, [pc, #8]	; (6af4 <osRtxThreadSetRunning+0x10>)
    6aea:	9b01      	ldr	r3, [sp, #4]
    6aec:	6153      	str	r3, [r2, #20]
}
    6aee:	bf00      	nop
    6af0:	b002      	add	sp, #8
    6af2:	4770      	bx	lr
    6af4:	20000110 	.word	0x20000110

00006af8 <ThreadFlagsCheck>:
/// Check Thread Flags.
/// \param[in]  thread          thread object.
/// \param[in]  flags           specifies the flags to check.
/// \param[in]  options         specifies flags options (osFlagsXxxx).
/// \return thread flags before clearing or 0 if specified flags have not been set.
static uint32_t ThreadFlagsCheck (os_thread_t *thread, uint32_t flags, uint32_t options) {
    6af8:	b500      	push	{lr}
    6afa:	b087      	sub	sp, #28
    6afc:	9003      	str	r0, [sp, #12]
    6afe:	9102      	str	r1, [sp, #8]
    6b00:	9201      	str	r2, [sp, #4]
#if (EXCLUSIVE_ACCESS == 0)
  uint32_t primask;
#endif
  uint32_t thread_flags;

  if ((options & osFlagsNoClear) == 0U) {
    6b02:	9b01      	ldr	r3, [sp, #4]
    6b04:	f003 0302 	and.w	r3, r3, #2
    6b08:	2b00      	cmp	r3, #0
    6b0a:	d114      	bne.n	6b36 <ThreadFlagsCheck+0x3e>

    if (primask == 0U) {
      __enable_irq();
    }
#else
    if ((options & osFlagsWaitAll) != 0U) {
    6b0c:	9b01      	ldr	r3, [sp, #4]
    6b0e:	f003 0301 	and.w	r3, r3, #1
    6b12:	2b00      	cmp	r3, #0
    6b14:	d007      	beq.n	6b26 <ThreadFlagsCheck+0x2e>
      thread_flags = atomic_chk32_all(&thread->thread_flags, flags);
    6b16:	9b03      	ldr	r3, [sp, #12]
    6b18:	3328      	adds	r3, #40	; 0x28
    6b1a:	9902      	ldr	r1, [sp, #8]
    6b1c:	4618      	mov	r0, r3
    6b1e:	f7ff ff8b 	bl	6a38 <atomic_chk32_all>
    6b22:	9005      	str	r0, [sp, #20]
    6b24:	e021      	b.n	6b6a <ThreadFlagsCheck+0x72>
    } else {
      thread_flags = atomic_chk32_any(&thread->thread_flags, flags);
    6b26:	9b03      	ldr	r3, [sp, #12]
    6b28:	3328      	adds	r3, #40	; 0x28
    6b2a:	9902      	ldr	r1, [sp, #8]
    6b2c:	4618      	mov	r0, r3
    6b2e:	f7ff ffa0 	bl	6a72 <atomic_chk32_any>
    6b32:	9005      	str	r0, [sp, #20]
    6b34:	e019      	b.n	6b6a <ThreadFlagsCheck+0x72>
    }
#endif
  } else {
    thread_flags = thread->thread_flags;
    6b36:	9b03      	ldr	r3, [sp, #12]
    6b38:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6b3a:	9305      	str	r3, [sp, #20]
    if ((((options & osFlagsWaitAll) != 0U) && ((thread_flags & flags) != flags)) ||
    6b3c:	9b01      	ldr	r3, [sp, #4]
    6b3e:	f003 0301 	and.w	r3, r3, #1
    6b42:	2b00      	cmp	r3, #0
    6b44:	d005      	beq.n	6b52 <ThreadFlagsCheck+0x5a>
    6b46:	9a05      	ldr	r2, [sp, #20]
    6b48:	9b02      	ldr	r3, [sp, #8]
    6b4a:	401a      	ands	r2, r3
    6b4c:	9b02      	ldr	r3, [sp, #8]
    6b4e:	429a      	cmp	r2, r3
    6b50:	d109      	bne.n	6b66 <ThreadFlagsCheck+0x6e>
        (((options & osFlagsWaitAll) == 0U) && ((thread_flags & flags) == 0U))) {
    6b52:	9b01      	ldr	r3, [sp, #4]
    6b54:	f003 0301 	and.w	r3, r3, #1
    if ((((options & osFlagsWaitAll) != 0U) && ((thread_flags & flags) != flags)) ||
    6b58:	2b00      	cmp	r3, #0
    6b5a:	d106      	bne.n	6b6a <ThreadFlagsCheck+0x72>
        (((options & osFlagsWaitAll) == 0U) && ((thread_flags & flags) == 0U))) {
    6b5c:	9a05      	ldr	r2, [sp, #20]
    6b5e:	9b02      	ldr	r3, [sp, #8]
    6b60:	4013      	ands	r3, r2
    6b62:	2b00      	cmp	r3, #0
    6b64:	d101      	bne.n	6b6a <ThreadFlagsCheck+0x72>
      thread_flags = 0U;
    6b66:	2300      	movs	r3, #0
    6b68:	9305      	str	r3, [sp, #20]
    }
  }

  return thread_flags;
    6b6a:	9b05      	ldr	r3, [sp, #20]
}
    6b6c:	4618      	mov	r0, r3
    6b6e:	b007      	add	sp, #28
    6b70:	f85d fb04 	ldr.w	pc, [sp], #4

00006b74 <osRtxThreadListPut>:
//  ==== Library functions ====

/// Put a Thread into specified Object list sorted by Priority (Highest at Head).
/// \param[in]  object          generic object.
/// \param[in]  thread          thread object.
void osRtxThreadListPut (os_object_t *object, os_thread_t *thread) {
    6b74:	b500      	push	{lr}
    6b76:	b087      	sub	sp, #28
    6b78:	9001      	str	r0, [sp, #4]
    6b7a:	9100      	str	r1, [sp, #0]
  os_thread_t *prev, *next;
  int32_t      priority;

  if (thread == NULL) {
    6b7c:	9b00      	ldr	r3, [sp, #0]
    6b7e:	2b00      	cmp	r3, #0
    6b80:	d02a      	beq.n	6bd8 <osRtxThreadListPut+0x64>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }

  priority = thread->priority;
    6b82:	9b00      	ldr	r3, [sp, #0]
    6b84:	f993 3020 	ldrsb.w	r3, [r3, #32]
    6b88:	9303      	str	r3, [sp, #12]

  prev = osRtxThreadObject(object);
    6b8a:	9801      	ldr	r0, [sp, #4]
    6b8c:	f7ff ff98 	bl	6ac0 <osRtxThreadObject>
    6b90:	9005      	str	r0, [sp, #20]
  next = object->thread_list;
    6b92:	9b01      	ldr	r3, [sp, #4]
    6b94:	689b      	ldr	r3, [r3, #8]
    6b96:	9304      	str	r3, [sp, #16]
  while ((next != NULL) && (next->priority >= priority)) {
    6b98:	e004      	b.n	6ba4 <osRtxThreadListPut+0x30>
    prev = next;
    6b9a:	9b04      	ldr	r3, [sp, #16]
    6b9c:	9305      	str	r3, [sp, #20]
    next = next->thread_next;
    6b9e:	9b04      	ldr	r3, [sp, #16]
    6ba0:	689b      	ldr	r3, [r3, #8]
    6ba2:	9304      	str	r3, [sp, #16]
  while ((next != NULL) && (next->priority >= priority)) {
    6ba4:	9b04      	ldr	r3, [sp, #16]
    6ba6:	2b00      	cmp	r3, #0
    6ba8:	d006      	beq.n	6bb8 <osRtxThreadListPut+0x44>
    6baa:	9b04      	ldr	r3, [sp, #16]
    6bac:	f993 3020 	ldrsb.w	r3, [r3, #32]
    6bb0:	461a      	mov	r2, r3
    6bb2:	9b03      	ldr	r3, [sp, #12]
    6bb4:	429a      	cmp	r2, r3
    6bb6:	daf0      	bge.n	6b9a <osRtxThreadListPut+0x26>
  }
  thread->thread_prev = prev;
    6bb8:	9b00      	ldr	r3, [sp, #0]
    6bba:	9a05      	ldr	r2, [sp, #20]
    6bbc:	60da      	str	r2, [r3, #12]
  thread->thread_next = next;
    6bbe:	9b00      	ldr	r3, [sp, #0]
    6bc0:	9a04      	ldr	r2, [sp, #16]
    6bc2:	609a      	str	r2, [r3, #8]
  prev->thread_next = thread;
    6bc4:	9b05      	ldr	r3, [sp, #20]
    6bc6:	9a00      	ldr	r2, [sp, #0]
    6bc8:	609a      	str	r2, [r3, #8]
  if (next != NULL) {
    6bca:	9b04      	ldr	r3, [sp, #16]
    6bcc:	2b00      	cmp	r3, #0
    6bce:	d004      	beq.n	6bda <osRtxThreadListPut+0x66>
    next->thread_prev = thread;
    6bd0:	9b04      	ldr	r3, [sp, #16]
    6bd2:	9a00      	ldr	r2, [sp, #0]
    6bd4:	60da      	str	r2, [r3, #12]
    6bd6:	e000      	b.n	6bda <osRtxThreadListPut+0x66>
    return;
    6bd8:	bf00      	nop
  }
}
    6bda:	b007      	add	sp, #28
    6bdc:	f85d fb04 	ldr.w	pc, [sp], #4

00006be0 <osRtxThreadListGet>:

/// Get a Thread with Highest Priority from specified Object list and remove it.
/// \param[in]  object          generic object.
/// \return thread object.
os_thread_t *osRtxThreadListGet (os_object_t *object) {
    6be0:	b510      	push	{r4, lr}
    6be2:	b084      	sub	sp, #16
    6be4:	9001      	str	r0, [sp, #4]
  os_thread_t *thread;

  thread = object->thread_list;
    6be6:	9b01      	ldr	r3, [sp, #4]
    6be8:	689b      	ldr	r3, [r3, #8]
    6bea:	9303      	str	r3, [sp, #12]
  if (thread != NULL) {
    6bec:	9b03      	ldr	r3, [sp, #12]
    6bee:	2b00      	cmp	r3, #0
    6bf0:	d011      	beq.n	6c16 <osRtxThreadListGet+0x36>
    object->thread_list = thread->thread_next;
    6bf2:	9b03      	ldr	r3, [sp, #12]
    6bf4:	689a      	ldr	r2, [r3, #8]
    6bf6:	9b01      	ldr	r3, [sp, #4]
    6bf8:	609a      	str	r2, [r3, #8]
    if (thread->thread_next != NULL) {
    6bfa:	9b03      	ldr	r3, [sp, #12]
    6bfc:	689b      	ldr	r3, [r3, #8]
    6bfe:	2b00      	cmp	r3, #0
    6c00:	d006      	beq.n	6c10 <osRtxThreadListGet+0x30>
      thread->thread_next->thread_prev = osRtxThreadObject(object);
    6c02:	9b03      	ldr	r3, [sp, #12]
    6c04:	689c      	ldr	r4, [r3, #8]
    6c06:	9801      	ldr	r0, [sp, #4]
    6c08:	f7ff ff5a 	bl	6ac0 <osRtxThreadObject>
    6c0c:	4603      	mov	r3, r0
    6c0e:	60e3      	str	r3, [r4, #12]
    }
    thread->thread_prev = NULL;
    6c10:	9b03      	ldr	r3, [sp, #12]
    6c12:	2200      	movs	r2, #0
    6c14:	60da      	str	r2, [r3, #12]
  }

  return thread;
    6c16:	9b03      	ldr	r3, [sp, #12]
}
    6c18:	4618      	mov	r0, r3
    6c1a:	b004      	add	sp, #16
    6c1c:	bd10      	pop	{r4, pc}

00006c1e <osRtxThreadListRoot>:

/// Retrieve Thread list root.
/// \param[in]  thread          thread object.
#ifndef EVR_RTX_DISABLE
static void *osRtxThreadListRoot (os_thread_t *thread) {
    6c1e:	b084      	sub	sp, #16
    6c20:	9001      	str	r0, [sp, #4]
  os_thread_t *thread0;

  thread0 = thread;
    6c22:	9b01      	ldr	r3, [sp, #4]
    6c24:	9303      	str	r3, [sp, #12]
  while ((thread0 != NULL) && (thread0->id == osRtxIdThread)) {
    6c26:	e002      	b.n	6c2e <osRtxThreadListRoot+0x10>
    thread0 = thread0->thread_prev;
    6c28:	9b03      	ldr	r3, [sp, #12]
    6c2a:	68db      	ldr	r3, [r3, #12]
    6c2c:	9303      	str	r3, [sp, #12]
  while ((thread0 != NULL) && (thread0->id == osRtxIdThread)) {
    6c2e:	9b03      	ldr	r3, [sp, #12]
    6c30:	2b00      	cmp	r3, #0
    6c32:	d003      	beq.n	6c3c <osRtxThreadListRoot+0x1e>
    6c34:	9b03      	ldr	r3, [sp, #12]
    6c36:	781b      	ldrb	r3, [r3, #0]
    6c38:	2b01      	cmp	r3, #1
    6c3a:	d0f5      	beq.n	6c28 <osRtxThreadListRoot+0xa>
  }
  return thread0;
    6c3c:	9b03      	ldr	r3, [sp, #12]
}
    6c3e:	4618      	mov	r0, r3
    6c40:	b004      	add	sp, #16
    6c42:	4770      	bx	lr

00006c44 <osRtxThreadListSort>:
#endif

/// Re-sort a Thread in linked Object list by Priority (Highest at Head).
/// \param[in]  thread          thread object.
void osRtxThreadListSort (os_thread_t *thread) {
    6c44:	b500      	push	{lr}
    6c46:	b085      	sub	sp, #20
    6c48:	9001      	str	r0, [sp, #4]
  os_object_t *object;
  os_thread_t *thread0;

  // Search for object
  thread0 = thread;
    6c4a:	9b01      	ldr	r3, [sp, #4]
    6c4c:	9303      	str	r3, [sp, #12]
  while ((thread0 != NULL) && (thread0->id == osRtxIdThread)) {
    6c4e:	e002      	b.n	6c56 <osRtxThreadListSort+0x12>
    thread0 = thread0->thread_prev;
    6c50:	9b03      	ldr	r3, [sp, #12]
    6c52:	68db      	ldr	r3, [r3, #12]
    6c54:	9303      	str	r3, [sp, #12]
  while ((thread0 != NULL) && (thread0->id == osRtxIdThread)) {
    6c56:	9b03      	ldr	r3, [sp, #12]
    6c58:	2b00      	cmp	r3, #0
    6c5a:	d003      	beq.n	6c64 <osRtxThreadListSort+0x20>
    6c5c:	9b03      	ldr	r3, [sp, #12]
    6c5e:	781b      	ldrb	r3, [r3, #0]
    6c60:	2b01      	cmp	r3, #1
    6c62:	d0f5      	beq.n	6c50 <osRtxThreadListSort+0xc>
  }
  object = osRtxObject(thread0);
    6c64:	9803      	ldr	r0, [sp, #12]
    6c66:	f7ff ff25 	bl	6ab4 <osRtxObject>
    6c6a:	9002      	str	r0, [sp, #8]

  if (object != NULL) {
    6c6c:	9b02      	ldr	r3, [sp, #8]
    6c6e:	2b00      	cmp	r3, #0
    6c70:	d006      	beq.n	6c80 <osRtxThreadListSort+0x3c>
    osRtxThreadListRemove(thread);
    6c72:	9801      	ldr	r0, [sp, #4]
    6c74:	f000 f808 	bl	6c88 <osRtxThreadListRemove>
    osRtxThreadListPut(object, thread);
    6c78:	9901      	ldr	r1, [sp, #4]
    6c7a:	9802      	ldr	r0, [sp, #8]
    6c7c:	f7ff ff7a 	bl	6b74 <osRtxThreadListPut>
  }
}
    6c80:	bf00      	nop
    6c82:	b005      	add	sp, #20
    6c84:	f85d fb04 	ldr.w	pc, [sp], #4

00006c88 <osRtxThreadListRemove>:

/// Remove a Thread from linked Object list.
/// \param[in]  thread          thread object.
void osRtxThreadListRemove (os_thread_t *thread) {
    6c88:	b082      	sub	sp, #8
    6c8a:	9001      	str	r0, [sp, #4]

  if (thread->thread_prev != NULL) {
    6c8c:	9b01      	ldr	r3, [sp, #4]
    6c8e:	68db      	ldr	r3, [r3, #12]
    6c90:	2b00      	cmp	r3, #0
    6c92:	d010      	beq.n	6cb6 <osRtxThreadListRemove+0x2e>
    thread->thread_prev->thread_next = thread->thread_next;
    6c94:	9b01      	ldr	r3, [sp, #4]
    6c96:	68db      	ldr	r3, [r3, #12]
    6c98:	9a01      	ldr	r2, [sp, #4]
    6c9a:	6892      	ldr	r2, [r2, #8]
    6c9c:	609a      	str	r2, [r3, #8]
    if (thread->thread_next != NULL) {
    6c9e:	9b01      	ldr	r3, [sp, #4]
    6ca0:	689b      	ldr	r3, [r3, #8]
    6ca2:	2b00      	cmp	r3, #0
    6ca4:	d004      	beq.n	6cb0 <osRtxThreadListRemove+0x28>
      thread->thread_next->thread_prev = thread->thread_prev;
    6ca6:	9b01      	ldr	r3, [sp, #4]
    6ca8:	689b      	ldr	r3, [r3, #8]
    6caa:	9a01      	ldr	r2, [sp, #4]
    6cac:	68d2      	ldr	r2, [r2, #12]
    6cae:	60da      	str	r2, [r3, #12]
    }
    thread->thread_prev = NULL;
    6cb0:	9b01      	ldr	r3, [sp, #4]
    6cb2:	2200      	movs	r2, #0
    6cb4:	60da      	str	r2, [r3, #12]
  }
}
    6cb6:	bf00      	nop
    6cb8:	b002      	add	sp, #8
    6cba:	4770      	bx	lr

00006cbc <osRtxThreadReadyPut>:
  }
}

/// Mark a Thread as Ready and put it into Ready list (sorted by Priority).
/// \param[in]  thread          thread object.
void osRtxThreadReadyPut (os_thread_t *thread) {
    6cbc:	b500      	push	{lr}
    6cbe:	b083      	sub	sp, #12
    6cc0:	9001      	str	r0, [sp, #4]

  thread->state = osRtxThreadReady;
    6cc2:	9b01      	ldr	r3, [sp, #4]
    6cc4:	2201      	movs	r2, #1
    6cc6:	705a      	strb	r2, [r3, #1]
  osRtxThreadListPut(&osRtxInfo.thread.ready, thread);
    6cc8:	9901      	ldr	r1, [sp, #4]
    6cca:	4803      	ldr	r0, [pc, #12]	; (6cd8 <osRtxThreadReadyPut+0x1c>)
    6ccc:	f7ff ff52 	bl	6b74 <osRtxThreadListPut>
}
    6cd0:	bf00      	nop
    6cd2:	b003      	add	sp, #12
    6cd4:	f85d fb04 	ldr.w	pc, [sp], #4
    6cd8:	2000012c 	.word	0x2000012c

00006cdc <osRtxThreadDelayInsert>:

/// Insert a Thread into the Delay list sorted by Delay (Lowest at Head).
/// \param[in]  thread          thread object.
/// \param[in]  delay           delay value.
static void osRtxThreadDelayInsert (os_thread_t *thread, uint32_t delay) {
    6cdc:	b084      	sub	sp, #16
    6cde:	9001      	str	r0, [sp, #4]
    6ce0:	9100      	str	r1, [sp, #0]
  os_thread_t *prev, *next;

  if (delay == osWaitForever) {
    6ce2:	9b00      	ldr	r3, [sp, #0]
    6ce4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    6ce8:	d121      	bne.n	6d2e <osRtxThreadDelayInsert+0x52>
    prev = NULL;
    6cea:	2300      	movs	r3, #0
    6cec:	9303      	str	r3, [sp, #12]
    next = osRtxInfo.thread.wait_list;
    6cee:	4b2d      	ldr	r3, [pc, #180]	; (6da4 <osRtxThreadDelayInsert+0xc8>)
    6cf0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    6cf2:	9302      	str	r3, [sp, #8]
    while (next != NULL)  {
    6cf4:	e004      	b.n	6d00 <osRtxThreadDelayInsert+0x24>
      prev = next;
    6cf6:	9b02      	ldr	r3, [sp, #8]
    6cf8:	9303      	str	r3, [sp, #12]
      next = next->delay_next;
    6cfa:	9b02      	ldr	r3, [sp, #8]
    6cfc:	691b      	ldr	r3, [r3, #16]
    6cfe:	9302      	str	r3, [sp, #8]
    while (next != NULL)  {
    6d00:	9b02      	ldr	r3, [sp, #8]
    6d02:	2b00      	cmp	r3, #0
    6d04:	d1f7      	bne.n	6cf6 <osRtxThreadDelayInsert+0x1a>
    }
    thread->delay = delay;
    6d06:	9b01      	ldr	r3, [sp, #4]
    6d08:	9a00      	ldr	r2, [sp, #0]
    6d0a:	61da      	str	r2, [r3, #28]
    thread->delay_prev = prev;
    6d0c:	9b01      	ldr	r3, [sp, #4]
    6d0e:	9a03      	ldr	r2, [sp, #12]
    6d10:	615a      	str	r2, [r3, #20]
    thread->delay_next = NULL;
    6d12:	9b01      	ldr	r3, [sp, #4]
    6d14:	2200      	movs	r2, #0
    6d16:	611a      	str	r2, [r3, #16]
    if (prev != NULL) {
    6d18:	9b03      	ldr	r3, [sp, #12]
    6d1a:	2b00      	cmp	r3, #0
    6d1c:	d003      	beq.n	6d26 <osRtxThreadDelayInsert+0x4a>
      prev->delay_next = thread;
    6d1e:	9b03      	ldr	r3, [sp, #12]
    6d20:	9a01      	ldr	r2, [sp, #4]
    6d22:	611a      	str	r2, [r3, #16]
    if (next != NULL) {
      next->delay -= delay;
      next->delay_prev = thread;
    }
  }
}
    6d24:	e03a      	b.n	6d9c <osRtxThreadDelayInsert+0xc0>
      osRtxInfo.thread.wait_list = thread;
    6d26:	4a1f      	ldr	r2, [pc, #124]	; (6da4 <osRtxThreadDelayInsert+0xc8>)
    6d28:	9b01      	ldr	r3, [sp, #4]
    6d2a:	6313      	str	r3, [r2, #48]	; 0x30
}
    6d2c:	e036      	b.n	6d9c <osRtxThreadDelayInsert+0xc0>
    prev = NULL;
    6d2e:	2300      	movs	r3, #0
    6d30:	9303      	str	r3, [sp, #12]
    next = osRtxInfo.thread.delay_list;
    6d32:	4b1c      	ldr	r3, [pc, #112]	; (6da4 <osRtxThreadDelayInsert+0xc8>)
    6d34:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6d36:	9302      	str	r3, [sp, #8]
    while ((next != NULL) && (next->delay <= delay)) {
    6d38:	e009      	b.n	6d4e <osRtxThreadDelayInsert+0x72>
      delay -= next->delay;
    6d3a:	9b02      	ldr	r3, [sp, #8]
    6d3c:	69db      	ldr	r3, [r3, #28]
    6d3e:	9a00      	ldr	r2, [sp, #0]
    6d40:	1ad3      	subs	r3, r2, r3
    6d42:	9300      	str	r3, [sp, #0]
      prev = next;
    6d44:	9b02      	ldr	r3, [sp, #8]
    6d46:	9303      	str	r3, [sp, #12]
      next = next->delay_next;
    6d48:	9b02      	ldr	r3, [sp, #8]
    6d4a:	691b      	ldr	r3, [r3, #16]
    6d4c:	9302      	str	r3, [sp, #8]
    while ((next != NULL) && (next->delay <= delay)) {
    6d4e:	9b02      	ldr	r3, [sp, #8]
    6d50:	2b00      	cmp	r3, #0
    6d52:	d004      	beq.n	6d5e <osRtxThreadDelayInsert+0x82>
    6d54:	9b02      	ldr	r3, [sp, #8]
    6d56:	69da      	ldr	r2, [r3, #28]
    6d58:	9b00      	ldr	r3, [sp, #0]
    6d5a:	429a      	cmp	r2, r3
    6d5c:	d9ed      	bls.n	6d3a <osRtxThreadDelayInsert+0x5e>
    thread->delay = delay;
    6d5e:	9b01      	ldr	r3, [sp, #4]
    6d60:	9a00      	ldr	r2, [sp, #0]
    6d62:	61da      	str	r2, [r3, #28]
    thread->delay_prev = prev;
    6d64:	9b01      	ldr	r3, [sp, #4]
    6d66:	9a03      	ldr	r2, [sp, #12]
    6d68:	615a      	str	r2, [r3, #20]
    thread->delay_next = next;
    6d6a:	9b01      	ldr	r3, [sp, #4]
    6d6c:	9a02      	ldr	r2, [sp, #8]
    6d6e:	611a      	str	r2, [r3, #16]
    if (prev != NULL) {
    6d70:	9b03      	ldr	r3, [sp, #12]
    6d72:	2b00      	cmp	r3, #0
    6d74:	d003      	beq.n	6d7e <osRtxThreadDelayInsert+0xa2>
      prev->delay_next = thread;
    6d76:	9b03      	ldr	r3, [sp, #12]
    6d78:	9a01      	ldr	r2, [sp, #4]
    6d7a:	611a      	str	r2, [r3, #16]
    6d7c:	e002      	b.n	6d84 <osRtxThreadDelayInsert+0xa8>
      osRtxInfo.thread.delay_list = thread;
    6d7e:	4a09      	ldr	r2, [pc, #36]	; (6da4 <osRtxThreadDelayInsert+0xc8>)
    6d80:	9b01      	ldr	r3, [sp, #4]
    6d82:	62d3      	str	r3, [r2, #44]	; 0x2c
    if (next != NULL) {
    6d84:	9b02      	ldr	r3, [sp, #8]
    6d86:	2b00      	cmp	r3, #0
    6d88:	d008      	beq.n	6d9c <osRtxThreadDelayInsert+0xc0>
      next->delay -= delay;
    6d8a:	9b02      	ldr	r3, [sp, #8]
    6d8c:	69da      	ldr	r2, [r3, #28]
    6d8e:	9b00      	ldr	r3, [sp, #0]
    6d90:	1ad2      	subs	r2, r2, r3
    6d92:	9b02      	ldr	r3, [sp, #8]
    6d94:	61da      	str	r2, [r3, #28]
      next->delay_prev = thread;
    6d96:	9b02      	ldr	r3, [sp, #8]
    6d98:	9a01      	ldr	r2, [sp, #4]
    6d9a:	615a      	str	r2, [r3, #20]
}
    6d9c:	bf00      	nop
    6d9e:	b004      	add	sp, #16
    6da0:	4770      	bx	lr
    6da2:	bf00      	nop
    6da4:	20000110 	.word	0x20000110

00006da8 <osRtxThreadDelayRemove>:

/// Remove a Thread from the Delay list.
/// \param[in]  thread          thread object.
static void osRtxThreadDelayRemove (os_thread_t *thread) {
    6da8:	b082      	sub	sp, #8
    6daa:	9001      	str	r0, [sp, #4]

  if (thread->delay == osWaitForever) {
    6dac:	9b01      	ldr	r3, [sp, #4]
    6dae:	69db      	ldr	r3, [r3, #28]
    6db0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    6db4:	d123      	bne.n	6dfe <osRtxThreadDelayRemove+0x56>
    if ((thread->delay_prev != NULL) || (osRtxInfo.thread.wait_list == thread)) {
    6db6:	9b01      	ldr	r3, [sp, #4]
    6db8:	695b      	ldr	r3, [r3, #20]
    6dba:	2b00      	cmp	r3, #0
    6dbc:	d104      	bne.n	6dc8 <osRtxThreadDelayRemove+0x20>
    6dbe:	4b27      	ldr	r3, [pc, #156]	; (6e5c <osRtxThreadDelayRemove+0xb4>)
    6dc0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    6dc2:	9b01      	ldr	r3, [sp, #4]
    6dc4:	429a      	cmp	r2, r3
    6dc6:	d146      	bne.n	6e56 <osRtxThreadDelayRemove+0xae>
      if (thread->delay_next != NULL) {
    6dc8:	9b01      	ldr	r3, [sp, #4]
    6dca:	691b      	ldr	r3, [r3, #16]
    6dcc:	2b00      	cmp	r3, #0
    6dce:	d004      	beq.n	6dda <osRtxThreadDelayRemove+0x32>
        thread->delay_next->delay_prev = thread->delay_prev;
    6dd0:	9b01      	ldr	r3, [sp, #4]
    6dd2:	691b      	ldr	r3, [r3, #16]
    6dd4:	9a01      	ldr	r2, [sp, #4]
    6dd6:	6952      	ldr	r2, [r2, #20]
    6dd8:	615a      	str	r2, [r3, #20]
      }
      if (thread->delay_prev != NULL) {
    6dda:	9b01      	ldr	r3, [sp, #4]
    6ddc:	695b      	ldr	r3, [r3, #20]
    6dde:	2b00      	cmp	r3, #0
    6de0:	d008      	beq.n	6df4 <osRtxThreadDelayRemove+0x4c>
        thread->delay_prev->delay_next = thread->delay_next;
    6de2:	9b01      	ldr	r3, [sp, #4]
    6de4:	695b      	ldr	r3, [r3, #20]
    6de6:	9a01      	ldr	r2, [sp, #4]
    6de8:	6912      	ldr	r2, [r2, #16]
    6dea:	611a      	str	r2, [r3, #16]
        thread->delay_prev = NULL;
    6dec:	9b01      	ldr	r3, [sp, #4]
    6dee:	2200      	movs	r2, #0
    6df0:	615a      	str	r2, [r3, #20]
      } else {
        osRtxInfo.thread.delay_list = thread->delay_next;
      }
    }
  }
}
    6df2:	e030      	b.n	6e56 <osRtxThreadDelayRemove+0xae>
        osRtxInfo.thread.wait_list = thread->delay_next;
    6df4:	9b01      	ldr	r3, [sp, #4]
    6df6:	691b      	ldr	r3, [r3, #16]
    6df8:	4a18      	ldr	r2, [pc, #96]	; (6e5c <osRtxThreadDelayRemove+0xb4>)
    6dfa:	6313      	str	r3, [r2, #48]	; 0x30
}
    6dfc:	e02b      	b.n	6e56 <osRtxThreadDelayRemove+0xae>
    if ((thread->delay_prev != NULL) || (osRtxInfo.thread.delay_list == thread)) {
    6dfe:	9b01      	ldr	r3, [sp, #4]
    6e00:	695b      	ldr	r3, [r3, #20]
    6e02:	2b00      	cmp	r3, #0
    6e04:	d104      	bne.n	6e10 <osRtxThreadDelayRemove+0x68>
    6e06:	4b15      	ldr	r3, [pc, #84]	; (6e5c <osRtxThreadDelayRemove+0xb4>)
    6e08:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    6e0a:	9b01      	ldr	r3, [sp, #4]
    6e0c:	429a      	cmp	r2, r3
    6e0e:	d122      	bne.n	6e56 <osRtxThreadDelayRemove+0xae>
      if (thread->delay_next != NULL) {
    6e10:	9b01      	ldr	r3, [sp, #4]
    6e12:	691b      	ldr	r3, [r3, #16]
    6e14:	2b00      	cmp	r3, #0
    6e16:	d00d      	beq.n	6e34 <osRtxThreadDelayRemove+0x8c>
        thread->delay_next->delay += thread->delay;
    6e18:	9b01      	ldr	r3, [sp, #4]
    6e1a:	691b      	ldr	r3, [r3, #16]
    6e1c:	9a01      	ldr	r2, [sp, #4]
    6e1e:	6912      	ldr	r2, [r2, #16]
    6e20:	69d1      	ldr	r1, [r2, #28]
    6e22:	9a01      	ldr	r2, [sp, #4]
    6e24:	69d2      	ldr	r2, [r2, #28]
    6e26:	440a      	add	r2, r1
    6e28:	61da      	str	r2, [r3, #28]
        thread->delay_next->delay_prev = thread->delay_prev;
    6e2a:	9b01      	ldr	r3, [sp, #4]
    6e2c:	691b      	ldr	r3, [r3, #16]
    6e2e:	9a01      	ldr	r2, [sp, #4]
    6e30:	6952      	ldr	r2, [r2, #20]
    6e32:	615a      	str	r2, [r3, #20]
      if (thread->delay_prev != NULL) {
    6e34:	9b01      	ldr	r3, [sp, #4]
    6e36:	695b      	ldr	r3, [r3, #20]
    6e38:	2b00      	cmp	r3, #0
    6e3a:	d008      	beq.n	6e4e <osRtxThreadDelayRemove+0xa6>
        thread->delay_prev->delay_next = thread->delay_next;
    6e3c:	9b01      	ldr	r3, [sp, #4]
    6e3e:	695b      	ldr	r3, [r3, #20]
    6e40:	9a01      	ldr	r2, [sp, #4]
    6e42:	6912      	ldr	r2, [r2, #16]
    6e44:	611a      	str	r2, [r3, #16]
        thread->delay_prev = NULL;
    6e46:	9b01      	ldr	r3, [sp, #4]
    6e48:	2200      	movs	r2, #0
    6e4a:	615a      	str	r2, [r3, #20]
}
    6e4c:	e003      	b.n	6e56 <osRtxThreadDelayRemove+0xae>
        osRtxInfo.thread.delay_list = thread->delay_next;
    6e4e:	9b01      	ldr	r3, [sp, #4]
    6e50:	691b      	ldr	r3, [r3, #16]
    6e52:	4a02      	ldr	r2, [pc, #8]	; (6e5c <osRtxThreadDelayRemove+0xb4>)
    6e54:	62d3      	str	r3, [r2, #44]	; 0x2c
}
    6e56:	bf00      	nop
    6e58:	b002      	add	sp, #8
    6e5a:	4770      	bx	lr
    6e5c:	20000110 	.word	0x20000110

00006e60 <osRtxThreadDelayTick>:

/// Process Thread Delay Tick (executed each System Tick).
void osRtxThreadDelayTick (void) {
    6e60:	b500      	push	{lr}
    6e62:	b083      	sub	sp, #12
  os_thread_t *thread;

  thread = osRtxInfo.thread.delay_list;
    6e64:	4b42      	ldr	r3, [pc, #264]	; (6f70 <osRtxThreadDelayTick+0x110>)
    6e66:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6e68:	9301      	str	r3, [sp, #4]
  if (thread == NULL) {
    6e6a:	9b01      	ldr	r3, [sp, #4]
    6e6c:	2b00      	cmp	r3, #0
    6e6e:	d07a      	beq.n	6f66 <osRtxThreadDelayTick+0x106>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }

  thread->delay--;
    6e70:	9b01      	ldr	r3, [sp, #4]
    6e72:	69db      	ldr	r3, [r3, #28]
    6e74:	1e5a      	subs	r2, r3, #1
    6e76:	9b01      	ldr	r3, [sp, #4]
    6e78:	61da      	str	r2, [r3, #28]

  if (thread->delay == 0U) {
    6e7a:	9b01      	ldr	r3, [sp, #4]
    6e7c:	69db      	ldr	r3, [r3, #28]
    6e7e:	2b00      	cmp	r3, #0
    6e80:	d172      	bne.n	6f68 <osRtxThreadDelayTick+0x108>
    do {
      switch (thread->state) {
    6e82:	9b01      	ldr	r3, [sp, #4]
    6e84:	785b      	ldrb	r3, [r3, #1]
    6e86:	2b53      	cmp	r3, #83	; 0x53
    6e88:	d022      	beq.n	6ed0 <osRtxThreadDelayTick+0x70>
    6e8a:	2b53      	cmp	r3, #83	; 0x53
    6e8c:	dc06      	bgt.n	6e9c <osRtxThreadDelayTick+0x3c>
    6e8e:	2b33      	cmp	r3, #51	; 0x33
    6e90:	d013      	beq.n	6eba <osRtxThreadDelayTick+0x5a>
    6e92:	2b43      	cmp	r3, #67	; 0x43
    6e94:	d014      	beq.n	6ec0 <osRtxThreadDelayTick+0x60>
    6e96:	2b13      	cmp	r3, #19
    6e98:	d00c      	beq.n	6eb4 <osRtxThreadDelayTick+0x54>
        case osRtxThreadWaitingMessagePut:
          EvrRtxMessageQueuePutTimeout((osMessageQueueId_t)osRtxThreadListRoot(thread));
          break;
        default:
          // Invalid
          break;
    6e9a:	e041      	b.n	6f20 <osRtxThreadDelayTick+0xc0>
      switch (thread->state) {
    6e9c:	2b73      	cmp	r3, #115	; 0x73
    6e9e:	d027      	beq.n	6ef0 <osRtxThreadDelayTick+0x90>
    6ea0:	2b73      	cmp	r3, #115	; 0x73
    6ea2:	dc02      	bgt.n	6eaa <osRtxThreadDelayTick+0x4a>
    6ea4:	2b63      	cmp	r3, #99	; 0x63
    6ea6:	d01b      	beq.n	6ee0 <osRtxThreadDelayTick+0x80>
          break;
    6ea8:	e03a      	b.n	6f20 <osRtxThreadDelayTick+0xc0>
      switch (thread->state) {
    6eaa:	2b83      	cmp	r3, #131	; 0x83
    6eac:	d028      	beq.n	6f00 <osRtxThreadDelayTick+0xa0>
    6eae:	2b93      	cmp	r3, #147	; 0x93
    6eb0:	d02e      	beq.n	6f10 <osRtxThreadDelayTick+0xb0>
          break;
    6eb2:	e035      	b.n	6f20 <osRtxThreadDelayTick+0xc0>
          EvrRtxThreadDelayCompleted();
    6eb4:	f7fd fc5a 	bl	476c <EvrRtxThreadDelayCompleted>
          break;
    6eb8:	e032      	b.n	6f20 <osRtxThreadDelayTick+0xc0>
          EvrRtxThreadFlagsWaitTimeout();
    6eba:	f7fd fc49 	bl	4750 <EvrRtxThreadFlagsWaitTimeout>
          break;
    6ebe:	e02f      	b.n	6f20 <osRtxThreadDelayTick+0xc0>
          EvrRtxEventFlagsWaitTimeout((osEventFlagsId_t)osRtxThreadListRoot(thread));
    6ec0:	9801      	ldr	r0, [sp, #4]
    6ec2:	f7ff feac 	bl	6c1e <osRtxThreadListRoot>
    6ec6:	4603      	mov	r3, r0
    6ec8:	4618      	mov	r0, r3
    6eca:	f7fd fc57 	bl	477c <EvrRtxEventFlagsWaitTimeout>
          break;
    6ece:	e027      	b.n	6f20 <osRtxThreadDelayTick+0xc0>
          EvrRtxMutexAcquireTimeout((osMutexId_t)osRtxThreadListRoot(thread));
    6ed0:	9801      	ldr	r0, [sp, #4]
    6ed2:	f7ff fea4 	bl	6c1e <osRtxThreadListRoot>
    6ed6:	4603      	mov	r3, r0
    6ed8:	4618      	mov	r0, r3
    6eda:	f7fd fc6b 	bl	47b4 <EvrRtxMutexAcquireTimeout>
          break;
    6ede:	e01f      	b.n	6f20 <osRtxThreadDelayTick+0xc0>
          EvrRtxSemaphoreAcquireTimeout((osSemaphoreId_t)osRtxThreadListRoot(thread));
    6ee0:	9801      	ldr	r0, [sp, #4]
    6ee2:	f7ff fe9c 	bl	6c1e <osRtxThreadListRoot>
    6ee6:	4603      	mov	r3, r0
    6ee8:	4618      	mov	r0, r3
    6eea:	f7fd fc7e 	bl	47ea <EvrRtxSemaphoreAcquireTimeout>
          break;
    6eee:	e017      	b.n	6f20 <osRtxThreadDelayTick+0xc0>
          EvrRtxMemoryPoolAllocTimeout((osMemoryPoolId_t)osRtxThreadListRoot(thread));
    6ef0:	9801      	ldr	r0, [sp, #4]
    6ef2:	f7ff fe94 	bl	6c1e <osRtxThreadListRoot>
    6ef6:	4603      	mov	r3, r0
    6ef8:	4618      	mov	r0, r3
    6efa:	f7fd fc7b 	bl	47f4 <EvrRtxMemoryPoolAllocTimeout>
          break;
    6efe:	e00f      	b.n	6f20 <osRtxThreadDelayTick+0xc0>
          EvrRtxMessageQueueGetTimeout((osMessageQueueId_t)osRtxThreadListRoot(thread));
    6f00:	9801      	ldr	r0, [sp, #4]
    6f02:	f7ff fe8c 	bl	6c1e <osRtxThreadListRoot>
    6f06:	4603      	mov	r3, r0
    6f08:	4618      	mov	r0, r3
    6f0a:	f7fd fcbc 	bl	4886 <EvrRtxMessageQueueGetTimeout>
          break;
    6f0e:	e007      	b.n	6f20 <osRtxThreadDelayTick+0xc0>
          EvrRtxMessageQueuePutTimeout((osMessageQueueId_t)osRtxThreadListRoot(thread));
    6f10:	9801      	ldr	r0, [sp, #4]
    6f12:	f7ff fe84 	bl	6c1e <osRtxThreadListRoot>
    6f16:	4603      	mov	r3, r0
    6f18:	4618      	mov	r0, r3
    6f1a:	f7fd fc8e 	bl	483a <EvrRtxMessageQueuePutTimeout>
          break;
    6f1e:	bf00      	nop
      }
      EvrRtxThreadUnblocked(thread, (osRtxThreadRegPtr(thread))[0]);
    6f20:	9801      	ldr	r0, [sp, #4]
    6f22:	f000 f827 	bl	6f74 <osRtxThreadRegPtr>
    6f26:	4603      	mov	r3, r0
    6f28:	681b      	ldr	r3, [r3, #0]
    6f2a:	4619      	mov	r1, r3
    6f2c:	9801      	ldr	r0, [sp, #4]
    6f2e:	f7fd fbee 	bl	470e <EvrRtxThreadUnblocked>
      osRtxThreadListRemove(thread);
    6f32:	9801      	ldr	r0, [sp, #4]
    6f34:	f7ff fea8 	bl	6c88 <osRtxThreadListRemove>
      osRtxThreadReadyPut(thread);
    6f38:	9801      	ldr	r0, [sp, #4]
    6f3a:	f7ff febf 	bl	6cbc <osRtxThreadReadyPut>
      thread = thread->delay_next;
    6f3e:	9b01      	ldr	r3, [sp, #4]
    6f40:	691b      	ldr	r3, [r3, #16]
    6f42:	9301      	str	r3, [sp, #4]
    } while ((thread != NULL) && (thread->delay == 0U));
    6f44:	9b01      	ldr	r3, [sp, #4]
    6f46:	2b00      	cmp	r3, #0
    6f48:	d003      	beq.n	6f52 <osRtxThreadDelayTick+0xf2>
    6f4a:	9b01      	ldr	r3, [sp, #4]
    6f4c:	69db      	ldr	r3, [r3, #28]
    6f4e:	2b00      	cmp	r3, #0
    6f50:	d097      	beq.n	6e82 <osRtxThreadDelayTick+0x22>
    if (thread != NULL) {
    6f52:	9b01      	ldr	r3, [sp, #4]
    6f54:	2b00      	cmp	r3, #0
    6f56:	d002      	beq.n	6f5e <osRtxThreadDelayTick+0xfe>
      thread->delay_prev = NULL;
    6f58:	9b01      	ldr	r3, [sp, #4]
    6f5a:	2200      	movs	r2, #0
    6f5c:	615a      	str	r2, [r3, #20]
    }
    osRtxInfo.thread.delay_list = thread;
    6f5e:	4a04      	ldr	r2, [pc, #16]	; (6f70 <osRtxThreadDelayTick+0x110>)
    6f60:	9b01      	ldr	r3, [sp, #4]
    6f62:	62d3      	str	r3, [r2, #44]	; 0x2c
    6f64:	e000      	b.n	6f68 <osRtxThreadDelayTick+0x108>
    return;
    6f66:	bf00      	nop
  }
}
    6f68:	b003      	add	sp, #12
    6f6a:	f85d fb04 	ldr.w	pc, [sp], #4
    6f6e:	bf00      	nop
    6f70:	20000110 	.word	0x20000110

00006f74 <osRtxThreadRegPtr>:

/// Get pointer to Thread registers (R0..R3)
/// \param[in]  thread          thread object.
/// \return pointer to registers R0-R3.
uint32_t *osRtxThreadRegPtr (const os_thread_t *thread) {
    6f74:	b510      	push	{r4, lr}
    6f76:	b084      	sub	sp, #16
    6f78:	9001      	str	r0, [sp, #4]
  uint32_t addr = thread->sp + StackOffsetR0(thread->stack_frame);
    6f7a:	9b01      	ldr	r3, [sp, #4]
    6f7c:	6b9c      	ldr	r4, [r3, #56]	; 0x38
    6f7e:	9b01      	ldr	r3, [sp, #4]
    6f80:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    6f84:	4618      	mov	r0, r3
    6f86:	f7ff fd24 	bl	69d2 <StackOffsetR0>
    6f8a:	4603      	mov	r3, r0
    6f8c:	4423      	add	r3, r4
    6f8e:	9303      	str	r3, [sp, #12]
  //lint -e{923} -e{9078} "cast from unsigned int to pointer"
  return ((uint32_t *)addr);
    6f90:	9b03      	ldr	r3, [sp, #12]
}
    6f92:	4618      	mov	r0, r3
    6f94:	b004      	add	sp, #16
    6f96:	bd10      	pop	{r4, pc}

00006f98 <osRtxThreadBlock>:

/// Block running Thread execution and register it as Ready to Run.
/// \param[in]  thread          running thread object.
static void osRtxThreadBlock (os_thread_t *thread) {
    6f98:	b500      	push	{lr}
    6f9a:	b087      	sub	sp, #28
    6f9c:	9001      	str	r0, [sp, #4]
  os_thread_t *prev, *next;
  int32_t      priority;

  thread->state = osRtxThreadReady;
    6f9e:	9b01      	ldr	r3, [sp, #4]
    6fa0:	2201      	movs	r2, #1
    6fa2:	705a      	strb	r2, [r3, #1]

  priority = thread->priority;
    6fa4:	9b01      	ldr	r3, [sp, #4]
    6fa6:	f993 3020 	ldrsb.w	r3, [r3, #32]
    6faa:	9303      	str	r3, [sp, #12]

  prev = osRtxThreadObject(&osRtxInfo.thread.ready);
    6fac:	4816      	ldr	r0, [pc, #88]	; (7008 <osRtxThreadBlock+0x70>)
    6fae:	f7ff fd87 	bl	6ac0 <osRtxThreadObject>
    6fb2:	9005      	str	r0, [sp, #20]
  next = prev->thread_next;
    6fb4:	9b05      	ldr	r3, [sp, #20]
    6fb6:	689b      	ldr	r3, [r3, #8]
    6fb8:	9304      	str	r3, [sp, #16]

  while ((next != NULL) && (next->priority > priority)) {
    6fba:	e004      	b.n	6fc6 <osRtxThreadBlock+0x2e>
    prev = next;
    6fbc:	9b04      	ldr	r3, [sp, #16]
    6fbe:	9305      	str	r3, [sp, #20]
    next = next->thread_next;
    6fc0:	9b04      	ldr	r3, [sp, #16]
    6fc2:	689b      	ldr	r3, [r3, #8]
    6fc4:	9304      	str	r3, [sp, #16]
  while ((next != NULL) && (next->priority > priority)) {
    6fc6:	9b04      	ldr	r3, [sp, #16]
    6fc8:	2b00      	cmp	r3, #0
    6fca:	d006      	beq.n	6fda <osRtxThreadBlock+0x42>
    6fcc:	9b04      	ldr	r3, [sp, #16]
    6fce:	f993 3020 	ldrsb.w	r3, [r3, #32]
    6fd2:	461a      	mov	r2, r3
    6fd4:	9b03      	ldr	r3, [sp, #12]
    6fd6:	429a      	cmp	r2, r3
    6fd8:	dcf0      	bgt.n	6fbc <osRtxThreadBlock+0x24>
  }
  thread->thread_prev = prev;
    6fda:	9b01      	ldr	r3, [sp, #4]
    6fdc:	9a05      	ldr	r2, [sp, #20]
    6fde:	60da      	str	r2, [r3, #12]
  thread->thread_next = next;
    6fe0:	9b01      	ldr	r3, [sp, #4]
    6fe2:	9a04      	ldr	r2, [sp, #16]
    6fe4:	609a      	str	r2, [r3, #8]
  prev->thread_next = thread;
    6fe6:	9b05      	ldr	r3, [sp, #20]
    6fe8:	9a01      	ldr	r2, [sp, #4]
    6fea:	609a      	str	r2, [r3, #8]
  if (next != NULL) {
    6fec:	9b04      	ldr	r3, [sp, #16]
    6fee:	2b00      	cmp	r3, #0
    6ff0:	d002      	beq.n	6ff8 <osRtxThreadBlock+0x60>
    next->thread_prev = thread;
    6ff2:	9b04      	ldr	r3, [sp, #16]
    6ff4:	9a01      	ldr	r2, [sp, #4]
    6ff6:	60da      	str	r2, [r3, #12]
  }

  EvrRtxThreadPreempted(thread);
    6ff8:	9801      	ldr	r0, [sp, #4]
    6ffa:	f7fd fb8e 	bl	471a <EvrRtxThreadPreempted>
}
    6ffe:	bf00      	nop
    7000:	b007      	add	sp, #28
    7002:	f85d fb04 	ldr.w	pc, [sp], #4
    7006:	bf00      	nop
    7008:	2000012c 	.word	0x2000012c

0000700c <osRtxThreadSwitch>:

/// Switch to specified Thread.
/// \param[in]  thread          thread object.
void osRtxThreadSwitch (os_thread_t *thread) {
    700c:	b500      	push	{lr}
    700e:	b083      	sub	sp, #12
    7010:	9001      	str	r0, [sp, #4]

  thread->state = osRtxThreadRunning;
    7012:	9b01      	ldr	r3, [sp, #4]
    7014:	2202      	movs	r2, #2
    7016:	705a      	strb	r2, [r3, #1]
  osRtxInfo.thread.run.next = thread;
    7018:	4a0d      	ldr	r2, [pc, #52]	; (7050 <osRtxThreadSwitch+0x44>)
    701a:	9b01      	ldr	r3, [sp, #4]
    701c:	6193      	str	r3, [r2, #24]
  osRtxThreadStackCheck();
    701e:	f000 f8db 	bl	71d8 <osRtxThreadStackCheck>
  EvrRtxThreadSwitched(thread);
    7022:	9801      	ldr	r0, [sp, #4]
    7024:	f7fd fb7e 	bl	4724 <EvrRtxThreadSwitched>

  if (osEventObs && osEventObs->thread_switch) {
    7028:	4b0a      	ldr	r3, [pc, #40]	; (7054 <osRtxThreadSwitch+0x48>)
    702a:	681b      	ldr	r3, [r3, #0]
    702c:	2b00      	cmp	r3, #0
    702e:	d00b      	beq.n	7048 <osRtxThreadSwitch+0x3c>
    7030:	4b08      	ldr	r3, [pc, #32]	; (7054 <osRtxThreadSwitch+0x48>)
    7032:	681b      	ldr	r3, [r3, #0]
    7034:	691b      	ldr	r3, [r3, #16]
    7036:	2b00      	cmp	r3, #0
    7038:	d006      	beq.n	7048 <osRtxThreadSwitch+0x3c>
    osEventObs->thread_switch(thread->context);
    703a:	4b06      	ldr	r3, [pc, #24]	; (7054 <osRtxThreadSwitch+0x48>)
    703c:	681b      	ldr	r3, [r3, #0]
    703e:	691b      	ldr	r3, [r3, #16]
    7040:	9a01      	ldr	r2, [sp, #4]
    7042:	6c52      	ldr	r2, [r2, #68]	; 0x44
    7044:	4610      	mov	r0, r2
    7046:	4798      	blx	r3
  }
}
    7048:	bf00      	nop
    704a:	b003      	add	sp, #12
    704c:	f85d fb04 	ldr.w	pc, [sp], #4
    7050:	20000110 	.word	0x20000110
    7054:	20002f58 	.word	0x20002f58

00007058 <thread_switch_helper>:

/// Notify the OS event observer of an imminent thread switch.
void thread_switch_helper(void) {
    7058:	b508      	push	{r3, lr}
  if (osEventObs && osEventObs->thread_switch) {
    705a:	4b09      	ldr	r3, [pc, #36]	; (7080 <thread_switch_helper+0x28>)
    705c:	681b      	ldr	r3, [r3, #0]
    705e:	2b00      	cmp	r3, #0
    7060:	d00c      	beq.n	707c <thread_switch_helper+0x24>
    7062:	4b07      	ldr	r3, [pc, #28]	; (7080 <thread_switch_helper+0x28>)
    7064:	681b      	ldr	r3, [r3, #0]
    7066:	691b      	ldr	r3, [r3, #16]
    7068:	2b00      	cmp	r3, #0
    706a:	d007      	beq.n	707c <thread_switch_helper+0x24>
    osEventObs->thread_switch(osRtxInfo.thread.run.next->context);
    706c:	4b04      	ldr	r3, [pc, #16]	; (7080 <thread_switch_helper+0x28>)
    706e:	681b      	ldr	r3, [r3, #0]
    7070:	691b      	ldr	r3, [r3, #16]
    7072:	4a04      	ldr	r2, [pc, #16]	; (7084 <thread_switch_helper+0x2c>)
    7074:	6992      	ldr	r2, [r2, #24]
    7076:	6c52      	ldr	r2, [r2, #68]	; 0x44
    7078:	4610      	mov	r0, r2
    707a:	4798      	blx	r3
  }
}
    707c:	bf00      	nop
    707e:	bd08      	pop	{r3, pc}
    7080:	20002f58 	.word	0x20002f58
    7084:	20000110 	.word	0x20000110

00007088 <osRtxThreadDispatch>:

/// Dispatch specified Thread or Ready Thread with Highest Priority.
/// \param[in]  thread          thread object or NULL.
void osRtxThreadDispatch (os_thread_t *thread) {
    7088:	b500      	push	{lr}
    708a:	b087      	sub	sp, #28
    708c:	9001      	str	r0, [sp, #4]
  uint8_t      kernel_state;
  os_thread_t *thread_running;
  os_thread_t *thread_ready;

  kernel_state   = osRtxKernelGetState();
    708e:	f7ff fd1d 	bl	6acc <osRtxKernelGetState>
    7092:	4603      	mov	r3, r0
    7094:	f88d 3017 	strb.w	r3, [sp, #23]
  thread_running = osRtxThreadGetRunning();
    7098:	f7ff fd1e 	bl	6ad8 <osRtxThreadGetRunning>
    709c:	9004      	str	r0, [sp, #16]

  if (thread == NULL) {
    709e:	9b01      	ldr	r3, [sp, #4]
    70a0:	2b00      	cmp	r3, #0
    70a2:	d11e      	bne.n	70e2 <osRtxThreadDispatch+0x5a>
    thread_ready = osRtxInfo.thread.ready.thread_list;
    70a4:	4b1d      	ldr	r3, [pc, #116]	; (711c <osRtxThreadDispatch+0x94>)
    70a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    70a8:	9303      	str	r3, [sp, #12]
    if ((kernel_state == osRtxKernelRunning) &&
    70aa:	f89d 3017 	ldrb.w	r3, [sp, #23]
    70ae:	2b02      	cmp	r3, #2
    70b0:	d130      	bne.n	7114 <osRtxThreadDispatch+0x8c>
    70b2:	9b04      	ldr	r3, [sp, #16]
    70b4:	2b00      	cmp	r3, #0
    70b6:	d02d      	beq.n	7114 <osRtxThreadDispatch+0x8c>
        (thread_running != NULL) && (thread_ready != NULL) &&
    70b8:	9b03      	ldr	r3, [sp, #12]
    70ba:	2b00      	cmp	r3, #0
    70bc:	d02a      	beq.n	7114 <osRtxThreadDispatch+0x8c>
        (thread_ready->priority > thread_running->priority)) {
    70be:	9b03      	ldr	r3, [sp, #12]
    70c0:	f993 2020 	ldrsb.w	r2, [r3, #32]
    70c4:	9b04      	ldr	r3, [sp, #16]
    70c6:	f993 3020 	ldrsb.w	r3, [r3, #32]
        (thread_running != NULL) && (thread_ready != NULL) &&
    70ca:	429a      	cmp	r2, r3
    70cc:	dd22      	ble.n	7114 <osRtxThreadDispatch+0x8c>
      // Preempt running Thread
      osRtxThreadListRemove(thread_ready);
    70ce:	9803      	ldr	r0, [sp, #12]
    70d0:	f7ff fdda 	bl	6c88 <osRtxThreadListRemove>
      osRtxThreadBlock(thread_running);
    70d4:	9804      	ldr	r0, [sp, #16]
    70d6:	f7ff ff5f 	bl	6f98 <osRtxThreadBlock>
      osRtxThreadSwitch(thread_ready);
    70da:	9803      	ldr	r0, [sp, #12]
    70dc:	f7ff ff96 	bl	700c <osRtxThreadSwitch>
    } else {
      // Put Thread into Ready list
      osRtxThreadReadyPut(thread);
    }
  }
}
    70e0:	e018      	b.n	7114 <osRtxThreadDispatch+0x8c>
    if ((kernel_state == osRtxKernelRunning) &&
    70e2:	f89d 3017 	ldrb.w	r3, [sp, #23]
    70e6:	2b02      	cmp	r3, #2
    70e8:	d111      	bne.n	710e <osRtxThreadDispatch+0x86>
    70ea:	9b04      	ldr	r3, [sp, #16]
    70ec:	2b00      	cmp	r3, #0
    70ee:	d00e      	beq.n	710e <osRtxThreadDispatch+0x86>
        (thread->priority > thread_running->priority)) {
    70f0:	9b01      	ldr	r3, [sp, #4]
    70f2:	f993 2020 	ldrsb.w	r2, [r3, #32]
    70f6:	9b04      	ldr	r3, [sp, #16]
    70f8:	f993 3020 	ldrsb.w	r3, [r3, #32]
        (thread_running != NULL) &&
    70fc:	429a      	cmp	r2, r3
    70fe:	dd06      	ble.n	710e <osRtxThreadDispatch+0x86>
      osRtxThreadBlock(thread_running);
    7100:	9804      	ldr	r0, [sp, #16]
    7102:	f7ff ff49 	bl	6f98 <osRtxThreadBlock>
      osRtxThreadSwitch(thread);
    7106:	9801      	ldr	r0, [sp, #4]
    7108:	f7ff ff80 	bl	700c <osRtxThreadSwitch>
}
    710c:	e002      	b.n	7114 <osRtxThreadDispatch+0x8c>
      osRtxThreadReadyPut(thread);
    710e:	9801      	ldr	r0, [sp, #4]
    7110:	f7ff fdd4 	bl	6cbc <osRtxThreadReadyPut>
}
    7114:	bf00      	nop
    7116:	b007      	add	sp, #28
    7118:	f85d fb04 	ldr.w	pc, [sp], #4
    711c:	20000110 	.word	0x20000110

00007120 <osRtxThreadWaitExit>:

/// Exit Thread wait state.
/// \param[in]  thread          thread object.
/// \param[in]  ret_val         return value.
/// \param[in]  dispatch        dispatch flag.
void osRtxThreadWaitExit (os_thread_t *thread, uint32_t ret_val, bool_t dispatch) {
    7120:	b500      	push	{lr}
    7122:	b087      	sub	sp, #28
    7124:	9003      	str	r0, [sp, #12]
    7126:	9102      	str	r1, [sp, #8]
    7128:	4613      	mov	r3, r2
    712a:	f88d 3007 	strb.w	r3, [sp, #7]
  uint32_t *reg;

  EvrRtxThreadUnblocked(thread, ret_val);
    712e:	9902      	ldr	r1, [sp, #8]
    7130:	9803      	ldr	r0, [sp, #12]
    7132:	f7fd faec 	bl	470e <EvrRtxThreadUnblocked>

  reg = osRtxThreadRegPtr(thread);
    7136:	9803      	ldr	r0, [sp, #12]
    7138:	f7ff ff1c 	bl	6f74 <osRtxThreadRegPtr>
    713c:	9005      	str	r0, [sp, #20]
  reg[0] = ret_val;
    713e:	9b05      	ldr	r3, [sp, #20]
    7140:	9a02      	ldr	r2, [sp, #8]
    7142:	601a      	str	r2, [r3, #0]

  osRtxThreadDelayRemove(thread);
    7144:	9803      	ldr	r0, [sp, #12]
    7146:	f7ff fe2f 	bl	6da8 <osRtxThreadDelayRemove>
  if (dispatch) {
    714a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    714e:	2b00      	cmp	r3, #0
    7150:	d003      	beq.n	715a <osRtxThreadWaitExit+0x3a>
    osRtxThreadDispatch(thread);
    7152:	9803      	ldr	r0, [sp, #12]
    7154:	f7ff ff98 	bl	7088 <osRtxThreadDispatch>
  } else {
    osRtxThreadReadyPut(thread);
  }
}
    7158:	e002      	b.n	7160 <osRtxThreadWaitExit+0x40>
    osRtxThreadReadyPut(thread);
    715a:	9803      	ldr	r0, [sp, #12]
    715c:	f7ff fdae 	bl	6cbc <osRtxThreadReadyPut>
}
    7160:	bf00      	nop
    7162:	b007      	add	sp, #28
    7164:	f85d fb04 	ldr.w	pc, [sp], #4

00007168 <osRtxThreadWaitEnter>:

/// Enter Thread wait state.
/// \param[in]  state           new thread state.
/// \param[in]  timeout         timeout.
/// \return true - success, false - failure.
bool_t osRtxThreadWaitEnter (uint8_t state, uint32_t timeout) {
    7168:	b500      	push	{lr}
    716a:	b085      	sub	sp, #20
    716c:	4603      	mov	r3, r0
    716e:	9100      	str	r1, [sp, #0]
    7170:	f88d 3007 	strb.w	r3, [sp, #7]
  os_thread_t *thread;

  // Check if Kernel is running
  if (osRtxKernelGetState() != osRtxKernelRunning) {
    7174:	f7ff fcaa 	bl	6acc <osRtxKernelGetState>
    7178:	4603      	mov	r3, r0
    717a:	2b02      	cmp	r3, #2
    717c:	d001      	beq.n	7182 <osRtxThreadWaitEnter+0x1a>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return FALSE;
    717e:	2300      	movs	r3, #0
    7180:	e021      	b.n	71c6 <osRtxThreadWaitEnter+0x5e>
  }

  // Check running thread
  thread = osRtxThreadGetRunning();
    7182:	f7ff fca9 	bl	6ad8 <osRtxThreadGetRunning>
    7186:	9003      	str	r0, [sp, #12]
  if (thread == NULL) {
    7188:	9b03      	ldr	r3, [sp, #12]
    718a:	2b00      	cmp	r3, #0
    718c:	d101      	bne.n	7192 <osRtxThreadWaitEnter+0x2a>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return FALSE;
    718e:	2300      	movs	r3, #0
    7190:	e019      	b.n	71c6 <osRtxThreadWaitEnter+0x5e>
  }

  // Check if any thread is ready
  if (osRtxInfo.thread.ready.thread_list == NULL) {
    7192:	4b0f      	ldr	r3, [pc, #60]	; (71d0 <osRtxThreadWaitEnter+0x68>)
    7194:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7196:	2b00      	cmp	r3, #0
    7198:	d101      	bne.n	719e <osRtxThreadWaitEnter+0x36>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return FALSE;
    719a:	2300      	movs	r3, #0
    719c:	e013      	b.n	71c6 <osRtxThreadWaitEnter+0x5e>
  }

  EvrRtxThreadBlocked(thread, timeout);
    719e:	9900      	ldr	r1, [sp, #0]
    71a0:	9803      	ldr	r0, [sp, #12]
    71a2:	f7fd faae 	bl	4702 <EvrRtxThreadBlocked>

  thread->state = state;
    71a6:	9b03      	ldr	r3, [sp, #12]
    71a8:	f89d 2007 	ldrb.w	r2, [sp, #7]
    71ac:	705a      	strb	r2, [r3, #1]
  osRtxThreadDelayInsert(thread, timeout);
    71ae:	9900      	ldr	r1, [sp, #0]
    71b0:	9803      	ldr	r0, [sp, #12]
    71b2:	f7ff fd93 	bl	6cdc <osRtxThreadDelayInsert>
  thread = osRtxThreadListGet(&osRtxInfo.thread.ready);
    71b6:	4807      	ldr	r0, [pc, #28]	; (71d4 <osRtxThreadWaitEnter+0x6c>)
    71b8:	f7ff fd12 	bl	6be0 <osRtxThreadListGet>
    71bc:	9003      	str	r0, [sp, #12]
  osRtxThreadSwitch(thread);
    71be:	9803      	ldr	r0, [sp, #12]
    71c0:	f7ff ff24 	bl	700c <osRtxThreadSwitch>

  return TRUE;
    71c4:	2301      	movs	r3, #1
}
    71c6:	4618      	mov	r0, r3
    71c8:	b005      	add	sp, #20
    71ca:	f85d fb04 	ldr.w	pc, [sp], #4
    71ce:	bf00      	nop
    71d0:	20000110 	.word	0x20000110
    71d4:	2000012c 	.word	0x2000012c

000071d8 <osRtxThreadStackCheck>:

/// Check current running Thread Stack.
//lint -esym(759,osRtxThreadStackCheck) "Prototype in header"
//lint -esym(765,osRtxThreadStackCheck) "Global scope (can be overridden)"
__WEAK void osRtxThreadStackCheck (void) {
    71d8:	b500      	push	{lr}
    71da:	b083      	sub	sp, #12
  os_thread_t *thread;

  thread = osRtxThreadGetRunning();
    71dc:	f7ff fc7c 	bl	6ad8 <osRtxThreadGetRunning>
    71e0:	9001      	str	r0, [sp, #4]
  if (thread != NULL) {
    71e2:	9b01      	ldr	r3, [sp, #4]
    71e4:	2b00      	cmp	r3, #0
    71e6:	d00f      	beq.n	7208 <osRtxThreadStackCheck+0x30>
    //lint -e{923} "cast from pointer to unsigned int"
    //lint -e{9079} -e{9087} "cast between pointers to different object types"
    if ((thread->sp <= (uint32_t)thread->stack_mem) ||
    71e8:	9b01      	ldr	r3, [sp, #4]
    71ea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    71ec:	9a01      	ldr	r2, [sp, #4]
    71ee:	6b12      	ldr	r2, [r2, #48]	; 0x30
    71f0:	4293      	cmp	r3, r2
    71f2:	d905      	bls.n	7200 <osRtxThreadStackCheck+0x28>
        (*((uint32_t *)thread->stack_mem) != osRtxStackMagicWord)) {
    71f4:	9b01      	ldr	r3, [sp, #4]
    71f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    71f8:	681b      	ldr	r3, [r3, #0]
    if ((thread->sp <= (uint32_t)thread->stack_mem) ||
    71fa:	4a05      	ldr	r2, [pc, #20]	; (7210 <osRtxThreadStackCheck+0x38>)
    71fc:	4293      	cmp	r3, r2
    71fe:	d003      	beq.n	7208 <osRtxThreadStackCheck+0x30>
      (void)osRtxErrorNotify(osRtxErrorStackUnderflow, thread);
    7200:	9901      	ldr	r1, [sp, #4]
    7202:	2001      	movs	r0, #1
    7204:	f7fd f89a 	bl	433c <osRtxErrorNotify>
    }
  }
}
    7208:	bf00      	nop
    720a:	b003      	add	sp, #12
    720c:	f85d fb04 	ldr.w	pc, [sp], #4
    7210:	e25a2ea5 	.word	0xe25a2ea5

00007214 <osRtxThreadPostProcess>:

//  ==== Post ISR processing ====

/// Thread post ISR processing.
/// \param[in]  thread          thread object.
static void osRtxThreadPostProcess (os_thread_t *thread) {
    7214:	b500      	push	{lr}
    7216:	b085      	sub	sp, #20
    7218:	9001      	str	r0, [sp, #4]
  uint32_t thread_flags;

  // Check thread state
  if ((thread->state == osRtxThreadInactive) ||
    721a:	9b01      	ldr	r3, [sp, #4]
    721c:	785b      	ldrb	r3, [r3, #1]
    721e:	2b00      	cmp	r3, #0
    7220:	d023      	beq.n	726a <osRtxThreadPostProcess+0x56>
      (thread->state == osRtxThreadTerminated)) {
    7222:	9b01      	ldr	r3, [sp, #4]
    7224:	785b      	ldrb	r3, [r3, #1]
  if ((thread->state == osRtxThreadInactive) ||
    7226:	2b04      	cmp	r3, #4
    7228:	d01f      	beq.n	726a <osRtxThreadPostProcess+0x56>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }

  // Check if Thread is waiting for Thread Flags
  if (thread->state == osRtxThreadWaitingThreadFlags) {
    722a:	9b01      	ldr	r3, [sp, #4]
    722c:	785b      	ldrb	r3, [r3, #1]
    722e:	2b33      	cmp	r3, #51	; 0x33
    7230:	d11c      	bne.n	726c <osRtxThreadPostProcess+0x58>
    thread_flags = ThreadFlagsCheck(thread, thread->wait_flags, thread->flags_options);
    7232:	9b01      	ldr	r3, [sp, #4]
    7234:	6a59      	ldr	r1, [r3, #36]	; 0x24
    7236:	9b01      	ldr	r3, [sp, #4]
    7238:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
    723c:	461a      	mov	r2, r3
    723e:	9801      	ldr	r0, [sp, #4]
    7240:	f7ff fc5a 	bl	6af8 <ThreadFlagsCheck>
    7244:	9003      	str	r0, [sp, #12]
    if (thread_flags != 0U) {
    7246:	9b03      	ldr	r3, [sp, #12]
    7248:	2b00      	cmp	r3, #0
    724a:	d00f      	beq.n	726c <osRtxThreadPostProcess+0x58>
      osRtxThreadWaitExit(thread, thread_flags, FALSE);
    724c:	2200      	movs	r2, #0
    724e:	9903      	ldr	r1, [sp, #12]
    7250:	9801      	ldr	r0, [sp, #4]
    7252:	f7ff ff65 	bl	7120 <osRtxThreadWaitExit>
      EvrRtxThreadFlagsWaitCompleted(thread->wait_flags, thread->flags_options, thread_flags);
    7256:	9b01      	ldr	r3, [sp, #4]
    7258:	6a58      	ldr	r0, [r3, #36]	; 0x24
    725a:	9b01      	ldr	r3, [sp, #4]
    725c:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
    7260:	9a03      	ldr	r2, [sp, #12]
    7262:	4619      	mov	r1, r3
    7264:	f7fd fa76 	bl	4754 <EvrRtxThreadFlagsWaitCompleted>
    7268:	e000      	b.n	726c <osRtxThreadPostProcess+0x58>
    return;
    726a:	bf00      	nop
    }
  }
}
    726c:	b005      	add	sp, #20
    726e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00007274 <svcRtxThreadNew>:

//  ==== Service Calls ====

/// Create a thread and add it to Active Threads.
/// \note API identical to osThreadContextNew
osThreadId_t svcRtxThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr, void *context) {
    7274:	b510      	push	{r4, lr}
    7276:	b08e      	sub	sp, #56	; 0x38
    7278:	9003      	str	r0, [sp, #12]
    727a:	9102      	str	r1, [sp, #8]
    727c:	9201      	str	r2, [sp, #4]
    727e:	9300      	str	r3, [sp, #0]
  TZ_ModuleId_t tz_module;
  TZ_MemoryId_t tz_memory;
#endif

  // Check parameters
  if (func == NULL) {
    7280:	9b03      	ldr	r3, [sp, #12]
    7282:	2b00      	cmp	r3, #0
    7284:	d106      	bne.n	7294 <svcRtxThreadNew+0x20>
    EvrRtxThreadError(NULL, (int32_t)osErrorParameter);
    7286:	f06f 0103 	mvn.w	r1, #3
    728a:	2000      	movs	r0, #0
    728c:	f7fd f906 	bl	449c <EvrRtxThreadError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return NULL;
    7290:	2300      	movs	r3, #0
    7292:	e1cd      	b.n	7630 <svcRtxThreadNew+0x3bc>
  }

  // Process attributes
  if (attr != NULL) {
    7294:	9b01      	ldr	r3, [sp, #4]
    7296:	2b00      	cmp	r3, #0
    7298:	d054      	beq.n	7344 <svcRtxThreadNew+0xd0>
    name       = attr->name;
    729a:	9b01      	ldr	r3, [sp, #4]
    729c:	681b      	ldr	r3, [r3, #0]
    729e:	9307      	str	r3, [sp, #28]
    attr_bits  = attr->attr_bits;
    72a0:	9b01      	ldr	r3, [sp, #4]
    72a2:	685b      	ldr	r3, [r3, #4]
    72a4:	930c      	str	r3, [sp, #48]	; 0x30
    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
    thread     = attr->cb_mem;
    72a6:	9b01      	ldr	r3, [sp, #4]
    72a8:	689b      	ldr	r3, [r3, #8]
    72aa:	930d      	str	r3, [sp, #52]	; 0x34
    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
    stack_mem  = attr->stack_mem;
    72ac:	9b01      	ldr	r3, [sp, #4]
    72ae:	691b      	ldr	r3, [r3, #16]
    72b0:	930b      	str	r3, [sp, #44]	; 0x2c
    stack_size = attr->stack_size;
    72b2:	9b01      	ldr	r3, [sp, #4]
    72b4:	695b      	ldr	r3, [r3, #20]
    72b6:	930a      	str	r3, [sp, #40]	; 0x28
    priority   = attr->priority;
    72b8:	9b01      	ldr	r3, [sp, #4]
    72ba:	699b      	ldr	r3, [r3, #24]
    72bc:	9309      	str	r3, [sp, #36]	; 0x24
#if (DOMAIN_NS == 1)
    tz_module  = attr->tz_module;
#endif
    if (thread != NULL) {
    72be:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    72c0:	2b00      	cmp	r3, #0
    72c2:	d00f      	beq.n	72e4 <svcRtxThreadNew+0x70>
      //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
      if ((((uint32_t)thread & 3U) != 0U) || (attr->cb_size < sizeof(os_thread_t))) {
    72c4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    72c6:	f003 0303 	and.w	r3, r3, #3
    72ca:	2b00      	cmp	r3, #0
    72cc:	d103      	bne.n	72d6 <svcRtxThreadNew+0x62>
    72ce:	9b01      	ldr	r3, [sp, #4]
    72d0:	68db      	ldr	r3, [r3, #12]
    72d2:	2b47      	cmp	r3, #71	; 0x47
    72d4:	d811      	bhi.n	72fa <svcRtxThreadNew+0x86>
        EvrRtxThreadError(NULL, osRtxErrorInvalidControlBlock);
    72d6:	f06f 0108 	mvn.w	r1, #8
    72da:	2000      	movs	r0, #0
    72dc:	f7fd f8de 	bl	449c <EvrRtxThreadError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    72e0:	2300      	movs	r3, #0
    72e2:	e1a5      	b.n	7630 <svcRtxThreadNew+0x3bc>
      }
    } else {
      if (attr->cb_size != 0U) {
    72e4:	9b01      	ldr	r3, [sp, #4]
    72e6:	68db      	ldr	r3, [r3, #12]
    72e8:	2b00      	cmp	r3, #0
    72ea:	d006      	beq.n	72fa <svcRtxThreadNew+0x86>
        EvrRtxThreadError(NULL, osRtxErrorInvalidControlBlock);
    72ec:	f06f 0108 	mvn.w	r1, #8
    72f0:	2000      	movs	r0, #0
    72f2:	f7fd f8d3 	bl	449c <EvrRtxThreadError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    72f6:	2300      	movs	r3, #0
    72f8:	e19a      	b.n	7630 <svcRtxThreadNew+0x3bc>
      }
    }
    if (stack_mem != NULL) {
    72fa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    72fc:	2b00      	cmp	r3, #0
    72fe:	d00e      	beq.n	731e <svcRtxThreadNew+0xaa>
      //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
      if ((((uint32_t)stack_mem & 7U) != 0U) || (stack_size == 0U)) {
    7300:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    7302:	f003 0307 	and.w	r3, r3, #7
    7306:	2b00      	cmp	r3, #0
    7308:	d102      	bne.n	7310 <svcRtxThreadNew+0x9c>
    730a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    730c:	2b00      	cmp	r3, #0
    730e:	d106      	bne.n	731e <svcRtxThreadNew+0xaa>
        EvrRtxThreadError(NULL, osRtxErrorInvalidThreadStack);
    7310:	f06f 010a 	mvn.w	r1, #10
    7314:	2000      	movs	r0, #0
    7316:	f7fd f8c1 	bl	449c <EvrRtxThreadError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    731a:	2300      	movs	r3, #0
    731c:	e188      	b.n	7630 <svcRtxThreadNew+0x3bc>
      }
    }
    if (priority == osPriorityNone) {
    731e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    7320:	2b00      	cmp	r3, #0
    7322:	d102      	bne.n	732a <svcRtxThreadNew+0xb6>
      priority = osPriorityNormal;
    7324:	2318      	movs	r3, #24
    7326:	9309      	str	r3, [sp, #36]	; 0x24
    7328:	e018      	b.n	735c <svcRtxThreadNew+0xe8>
    } else {
      if ((priority < osPriorityIdle) || (priority > osPriorityISR)) {
    732a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    732c:	2b00      	cmp	r3, #0
    732e:	dd02      	ble.n	7336 <svcRtxThreadNew+0xc2>
    7330:	9b09      	ldr	r3, [sp, #36]	; 0x24
    7332:	2b38      	cmp	r3, #56	; 0x38
    7334:	dd12      	ble.n	735c <svcRtxThreadNew+0xe8>
        EvrRtxThreadError(NULL, osRtxErrorInvalidPriority);
    7336:	f06f 010b 	mvn.w	r1, #11
    733a:	2000      	movs	r0, #0
    733c:	f7fd f8ae 	bl	449c <EvrRtxThreadError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    7340:	2300      	movs	r3, #0
    7342:	e175      	b.n	7630 <svcRtxThreadNew+0x3bc>
      }
    }
  } else {
    name       = NULL;
    7344:	2300      	movs	r3, #0
    7346:	9307      	str	r3, [sp, #28]
    attr_bits  = 0U;
    7348:	2300      	movs	r3, #0
    734a:	930c      	str	r3, [sp, #48]	; 0x30
    thread     = NULL;
    734c:	2300      	movs	r3, #0
    734e:	930d      	str	r3, [sp, #52]	; 0x34
    stack_mem  = NULL;
    7350:	2300      	movs	r3, #0
    7352:	930b      	str	r3, [sp, #44]	; 0x2c
    stack_size = 0U;
    7354:	2300      	movs	r3, #0
    7356:	930a      	str	r3, [sp, #40]	; 0x28
    priority   = osPriorityNormal;
    7358:	2318      	movs	r3, #24
    735a:	9309      	str	r3, [sp, #36]	; 0x24
    tz_module  = 0U;
#endif
  }

  // Check stack size
  if ((stack_size != 0U) && (((stack_size & 7U) != 0U) || (stack_size < (64U + 8U)))) {
    735c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    735e:	2b00      	cmp	r3, #0
    7360:	d00e      	beq.n	7380 <svcRtxThreadNew+0x10c>
    7362:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    7364:	f003 0307 	and.w	r3, r3, #7
    7368:	2b00      	cmp	r3, #0
    736a:	d102      	bne.n	7372 <svcRtxThreadNew+0xfe>
    736c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    736e:	2b47      	cmp	r3, #71	; 0x47
    7370:	d806      	bhi.n	7380 <svcRtxThreadNew+0x10c>
    EvrRtxThreadError(NULL, osRtxErrorInvalidThreadStack);
    7372:	f06f 010a 	mvn.w	r1, #10
    7376:	2000      	movs	r0, #0
    7378:	f7fd f890 	bl	449c <EvrRtxThreadError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return NULL;
    737c:	2300      	movs	r3, #0
    737e:	e157      	b.n	7630 <svcRtxThreadNew+0x3bc>
  }

  // Allocate object memory if not provided
  if (thread == NULL) {
    7380:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7382:	2b00      	cmp	r3, #0
    7384:	d119      	bne.n	73ba <svcRtxThreadNew+0x146>
    if (osRtxInfo.mpi.thread != NULL) {
    7386:	4b9f      	ldr	r3, [pc, #636]	; (7604 <svcRtxThreadNew+0x390>)
    7388:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    738c:	2b00      	cmp	r3, #0
    738e:	d007      	beq.n	73a0 <svcRtxThreadNew+0x12c>
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      thread = osRtxMemoryPoolAlloc(osRtxInfo.mpi.thread);
    7390:	4b9c      	ldr	r3, [pc, #624]	; (7604 <svcRtxThreadNew+0x390>)
    7392:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    7396:	4618      	mov	r0, r3
    7398:	f7fd ffd5 	bl	5346 <osRtxMemoryPoolAlloc>
    739c:	900d      	str	r0, [sp, #52]	; 0x34
    739e:	e008      	b.n	73b2 <svcRtxThreadNew+0x13e>
    } else {
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      thread = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_thread_t), 1U);
    73a0:	4b98      	ldr	r3, [pc, #608]	; (7604 <svcRtxThreadNew+0x390>)
    73a2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    73a6:	2201      	movs	r2, #1
    73a8:	2148      	movs	r1, #72	; 0x48
    73aa:	4618      	mov	r0, r3
    73ac:	f7fd fe33 	bl	5016 <osRtxMemoryAlloc>
    73b0:	900d      	str	r0, [sp, #52]	; 0x34
      if (osRtxThreadMemUsage.max_used < used) {
        osRtxThreadMemUsage.max_used = used;
      }
    }
#endif
    flags = osRtxFlagSystemObject;
    73b2:	2301      	movs	r3, #1
    73b4:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    73b8:	e002      	b.n	73c0 <svcRtxThreadNew+0x14c>
  } else {
    flags = 0U;
    73ba:	2300      	movs	r3, #0
    73bc:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
  }

  // Allocate stack memory if not provided
  if ((thread != NULL) && (stack_mem == NULL)) {
    73c0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    73c2:	2b00      	cmp	r3, #0
    73c4:	d054      	beq.n	7470 <svcRtxThreadNew+0x1fc>
    73c6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    73c8:	2b00      	cmp	r3, #0
    73ca:	d151      	bne.n	7470 <svcRtxThreadNew+0x1fc>
    if (stack_size == 0U) {
    73cc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    73ce:	2b00      	cmp	r3, #0
    73d0:	d121      	bne.n	7416 <svcRtxThreadNew+0x1a2>
      stack_size = osRtxConfig.thread_stack_size;
    73d2:	4b8d      	ldr	r3, [pc, #564]	; (7608 <svcRtxThreadNew+0x394>)
    73d4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    73d6:	930a      	str	r3, [sp, #40]	; 0x28
      if (osRtxInfo.mpi.stack != NULL) {
    73d8:	4b8a      	ldr	r3, [pc, #552]	; (7604 <svcRtxThreadNew+0x390>)
    73da:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
    73de:	2b00      	cmp	r3, #0
    73e0:	d010      	beq.n	7404 <svcRtxThreadNew+0x190>
        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
        stack_mem = osRtxMemoryPoolAlloc(osRtxInfo.mpi.stack);
    73e2:	4b88      	ldr	r3, [pc, #544]	; (7604 <svcRtxThreadNew+0x390>)
    73e4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
    73e8:	4618      	mov	r0, r3
    73ea:	f7fd ffac 	bl	5346 <osRtxMemoryPoolAlloc>
    73ee:	900b      	str	r0, [sp, #44]	; 0x2c
        if (stack_mem != NULL) {
    73f0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    73f2:	2b00      	cmp	r3, #0
    73f4:	d017      	beq.n	7426 <svcRtxThreadNew+0x1b2>
          flags |= osRtxThreadFlagDefStack;
    73f6:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    73fa:	f043 0310 	orr.w	r3, r3, #16
    73fe:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    7402:	e010      	b.n	7426 <svcRtxThreadNew+0x1b2>
        }
      } else {
        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
        stack_mem = osRtxMemoryAlloc(osRtxInfo.mem.stack, stack_size, 0U);
    7404:	4b7f      	ldr	r3, [pc, #508]	; (7604 <svcRtxThreadNew+0x390>)
    7406:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    7408:	2200      	movs	r2, #0
    740a:	990a      	ldr	r1, [sp, #40]	; 0x28
    740c:	4618      	mov	r0, r3
    740e:	f7fd fe02 	bl	5016 <osRtxMemoryAlloc>
    7412:	900b      	str	r0, [sp, #44]	; 0x2c
    7414:	e007      	b.n	7426 <svcRtxThreadNew+0x1b2>
      }
    } else {
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      stack_mem = osRtxMemoryAlloc(osRtxInfo.mem.stack, stack_size, 0U);
    7416:	4b7b      	ldr	r3, [pc, #492]	; (7604 <svcRtxThreadNew+0x390>)
    7418:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    741a:	2200      	movs	r2, #0
    741c:	990a      	ldr	r1, [sp, #40]	; 0x28
    741e:	4618      	mov	r0, r3
    7420:	f7fd fdf9 	bl	5016 <osRtxMemoryAlloc>
    7424:	900b      	str	r0, [sp, #44]	; 0x2c
    }
    if (stack_mem == NULL) {
    7426:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    7428:	2b00      	cmp	r3, #0
    742a:	d11b      	bne.n	7464 <svcRtxThreadNew+0x1f0>
      if ((flags & osRtxFlagSystemObject) != 0U) {
    742c:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    7430:	f003 0301 	and.w	r3, r3, #1
    7434:	2b00      	cmp	r3, #0
    7436:	d013      	beq.n	7460 <svcRtxThreadNew+0x1ec>
        if (osRtxInfo.mpi.thread != NULL) {
    7438:	4b72      	ldr	r3, [pc, #456]	; (7604 <svcRtxThreadNew+0x390>)
    743a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    743e:	2b00      	cmp	r3, #0
    7440:	d007      	beq.n	7452 <svcRtxThreadNew+0x1de>
          (void)osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
    7442:	4b70      	ldr	r3, [pc, #448]	; (7604 <svcRtxThreadNew+0x390>)
    7444:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    7448:	990d      	ldr	r1, [sp, #52]	; 0x34
    744a:	4618      	mov	r0, r3
    744c:	f7fd ffa6 	bl	539c <osRtxMemoryPoolFree>
    7450:	e006      	b.n	7460 <svcRtxThreadNew+0x1ec>
        } else {
          (void)osRtxMemoryFree(osRtxInfo.mem.common, thread);
    7452:	4b6c      	ldr	r3, [pc, #432]	; (7604 <svcRtxThreadNew+0x390>)
    7454:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    7458:	990d      	ldr	r1, [sp, #52]	; 0x34
    745a:	4618      	mov	r0, r3
    745c:	f7fd fe77 	bl	514e <osRtxMemoryFree>
        }
#if (defined(OS_OBJ_MEM_USAGE) && (OS_OBJ_MEM_USAGE != 0))
        osRtxThreadMemUsage.cnt_free++;
#endif
      }
      thread = NULL;
    7460:	2300      	movs	r3, #0
    7462:	930d      	str	r3, [sp, #52]	; 0x34
    }
    flags |= osRtxFlagSystemMemory;
    7464:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    7468:	f043 0302 	orr.w	r3, r3, #2
    746c:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
  } else {
    tz_memory = 0U;
  }
#endif

  if (thread != NULL) {
    7470:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7472:	2b00      	cmp	r3, #0
    7474:	f000 80ad 	beq.w	75d2 <svcRtxThreadNew+0x35e>
    // Initialize control block
    //lint --e{923}  --e{9078} "cast between pointers and unsigned int"
    //lint --e{9079} --e{9087} "cast between pointers to different object types"
    //lint --e{9074} "conversion between a pointer to function and another type"
    thread->id            = osRtxIdThread;
    7478:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    747a:	2201      	movs	r2, #1
    747c:	701a      	strb	r2, [r3, #0]
    thread->state         = osRtxThreadReady;
    747e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7480:	2201      	movs	r2, #1
    7482:	705a      	strb	r2, [r3, #1]
    thread->flags         = flags;
    7484:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7486:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
    748a:	709a      	strb	r2, [r3, #2]
    thread->attr          = (uint8_t)attr_bits;
    748c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    748e:	b2da      	uxtb	r2, r3
    7490:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7492:	70da      	strb	r2, [r3, #3]
    thread->name          = name;
    7494:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7496:	9a07      	ldr	r2, [sp, #28]
    7498:	605a      	str	r2, [r3, #4]
    thread->thread_next   = NULL;
    749a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    749c:	2200      	movs	r2, #0
    749e:	609a      	str	r2, [r3, #8]
    thread->thread_prev   = NULL;
    74a0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74a2:	2200      	movs	r2, #0
    74a4:	60da      	str	r2, [r3, #12]
    thread->delay_next    = NULL;
    74a6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74a8:	2200      	movs	r2, #0
    74aa:	611a      	str	r2, [r3, #16]
    thread->delay_prev    = NULL;
    74ac:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74ae:	2200      	movs	r2, #0
    74b0:	615a      	str	r2, [r3, #20]
    thread->thread_join   = NULL;
    74b2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74b4:	2200      	movs	r2, #0
    74b6:	619a      	str	r2, [r3, #24]
    thread->delay         = 0U;
    74b8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74ba:	2200      	movs	r2, #0
    74bc:	61da      	str	r2, [r3, #28]
    thread->priority      = (int8_t)priority;
    74be:	9b09      	ldr	r3, [sp, #36]	; 0x24
    74c0:	b25a      	sxtb	r2, r3
    74c2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74c4:	f883 2020 	strb.w	r2, [r3, #32]
    thread->priority_base = (int8_t)priority;
    74c8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    74ca:	b25a      	sxtb	r2, r3
    74cc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74ce:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
    thread->stack_frame   = STACK_FRAME_INIT_VAL;
    74d2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74d4:	22fd      	movs	r2, #253	; 0xfd
    74d6:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    thread->flags_options = 0U;
    74da:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74dc:	2200      	movs	r2, #0
    74de:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
    thread->wait_flags    = 0U;
    74e2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74e4:	2200      	movs	r2, #0
    74e6:	625a      	str	r2, [r3, #36]	; 0x24
    thread->thread_flags  = 0U;
    74e8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74ea:	2200      	movs	r2, #0
    74ec:	629a      	str	r2, [r3, #40]	; 0x28
    thread->mutex_list    = NULL;
    74ee:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74f0:	2200      	movs	r2, #0
    74f2:	62da      	str	r2, [r3, #44]	; 0x2c
    thread->stack_mem     = stack_mem;
    74f4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74f6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    74f8:	631a      	str	r2, [r3, #48]	; 0x30
    thread->stack_size    = stack_size;
    74fa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74fc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    74fe:	635a      	str	r2, [r3, #52]	; 0x34
    thread->sp            = (uint32_t)stack_mem + stack_size - 64U;
    7500:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    7502:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    7504:	4413      	add	r3, r2
    7506:	f1a3 0240 	sub.w	r2, r3, #64	; 0x40
    750a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    750c:	639a      	str	r2, [r3, #56]	; 0x38
    thread->thread_addr   = (uint32_t)func;
    750e:	9a03      	ldr	r2, [sp, #12]
    7510:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7512:	63da      	str	r2, [r3, #60]	; 0x3c
    thread->tz_memory     = tz_memory;
  #endif

    // Initialize stack
    //lint --e{613} false detection: "Possible use of null pointer"
    ptr = (uint32_t *)stack_mem;
    7514:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    7516:	9306      	str	r3, [sp, #24]
    ptr[0] = osRtxStackMagicWord;
    7518:	9b06      	ldr	r3, [sp, #24]
    751a:	4a3c      	ldr	r2, [pc, #240]	; (760c <svcRtxThreadNew+0x398>)
    751c:	601a      	str	r2, [r3, #0]
    if ((osRtxConfig.flags & osRtxConfigStackWatermark) != 0U) {
    751e:	4b3a      	ldr	r3, [pc, #232]	; (7608 <svcRtxThreadNew+0x394>)
    7520:	681b      	ldr	r3, [r3, #0]
    7522:	f003 0304 	and.w	r3, r3, #4
    7526:	2b00      	cmp	r3, #0
    7528:	d011      	beq.n	754e <svcRtxThreadNew+0x2da>
      for (n = (stack_size/4U) - (16U + 1U); n != 0U; n--) {
    752a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    752c:	089b      	lsrs	r3, r3, #2
    752e:	3b11      	subs	r3, #17
    7530:	9305      	str	r3, [sp, #20]
    7532:	e009      	b.n	7548 <svcRtxThreadNew+0x2d4>
         ptr++;
    7534:	9b06      	ldr	r3, [sp, #24]
    7536:	3304      	adds	r3, #4
    7538:	9306      	str	r3, [sp, #24]
        *ptr = osRtxStackFillPattern;
    753a:	9b06      	ldr	r3, [sp, #24]
    753c:	f04f 32cc 	mov.w	r2, #3435973836	; 0xcccccccc
    7540:	601a      	str	r2, [r3, #0]
      for (n = (stack_size/4U) - (16U + 1U); n != 0U; n--) {
    7542:	9b05      	ldr	r3, [sp, #20]
    7544:	3b01      	subs	r3, #1
    7546:	9305      	str	r3, [sp, #20]
    7548:	9b05      	ldr	r3, [sp, #20]
    754a:	2b00      	cmp	r3, #0
    754c:	d1f2      	bne.n	7534 <svcRtxThreadNew+0x2c0>
      }
    }
    ptr = (uint32_t *)thread->sp;
    754e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7550:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    7552:	9306      	str	r3, [sp, #24]
    for (n = 0U; n != 13U; n++) {
    7554:	2300      	movs	r3, #0
    7556:	9305      	str	r3, [sp, #20]
    7558:	e008      	b.n	756c <svcRtxThreadNew+0x2f8>
      ptr[n] = 0U;                      // R4..R11, R0..R3, R12
    755a:	9b05      	ldr	r3, [sp, #20]
    755c:	009b      	lsls	r3, r3, #2
    755e:	9a06      	ldr	r2, [sp, #24]
    7560:	4413      	add	r3, r2
    7562:	2200      	movs	r2, #0
    7564:	601a      	str	r2, [r3, #0]
    for (n = 0U; n != 13U; n++) {
    7566:	9b05      	ldr	r3, [sp, #20]
    7568:	3301      	adds	r3, #1
    756a:	9305      	str	r3, [sp, #20]
    756c:	9b05      	ldr	r3, [sp, #20]
    756e:	2b0d      	cmp	r3, #13
    7570:	d1f3      	bne.n	755a <svcRtxThreadNew+0x2e6>
    }
    ptr[13] = (uint32_t)osThreadExit;   // LR
    7572:	9b06      	ldr	r3, [sp, #24]
    7574:	3334      	adds	r3, #52	; 0x34
    7576:	4a26      	ldr	r2, [pc, #152]	; (7610 <svcRtxThreadNew+0x39c>)
    7578:	601a      	str	r2, [r3, #0]
    ptr[14] = (uint32_t)func;           // PC
    757a:	9b06      	ldr	r3, [sp, #24]
    757c:	3338      	adds	r3, #56	; 0x38
    757e:	9a03      	ldr	r2, [sp, #12]
    7580:	601a      	str	r2, [r3, #0]
    ptr[15] = xPSR_InitVal(
    7582:	9b06      	ldr	r3, [sp, #24]
    7584:	f103 043c 	add.w	r4, r3, #60	; 0x3c
                (bool_t)((osRtxConfig.flags & osRtxConfigPrivilegedMode) != 0U),
    7588:	4b1f      	ldr	r3, [pc, #124]	; (7608 <svcRtxThreadNew+0x394>)
    758a:	681b      	ldr	r3, [r3, #0]
    758c:	f003 0301 	and.w	r3, r3, #1
    ptr[15] = xPSR_InitVal(
    7590:	2b00      	cmp	r3, #0
    7592:	bf14      	ite	ne
    7594:	2301      	movne	r3, #1
    7596:	2300      	moveq	r3, #0
    7598:	b2da      	uxtb	r2, r3
                (bool_t)(((uint32_t)func & 1U) != 0U)
    759a:	9b03      	ldr	r3, [sp, #12]
    759c:	f003 0301 	and.w	r3, r3, #1
    ptr[15] = xPSR_InitVal(
    75a0:	2b00      	cmp	r3, #0
    75a2:	bf14      	ite	ne
    75a4:	2301      	movne	r3, #1
    75a6:	2300      	moveq	r3, #0
    75a8:	b2db      	uxtb	r3, r3
    75aa:	4619      	mov	r1, r3
    75ac:	4610      	mov	r0, r2
    75ae:	f7ff fa03 	bl	69b8 <xPSR_InitVal>
    75b2:	4603      	mov	r3, r0
    75b4:	6023      	str	r3, [r4, #0]
              );                        // xPSR
    ptr[8]  = (uint32_t)argument;       // R0
    75b6:	9b06      	ldr	r3, [sp, #24]
    75b8:	3320      	adds	r3, #32
    75ba:	9a02      	ldr	r2, [sp, #8]
    75bc:	601a      	str	r2, [r3, #0]

    // Register post ISR processing function
    osRtxInfo.post_process.thread = osRtxThreadPostProcess;
    75be:	4b11      	ldr	r3, [pc, #68]	; (7604 <svcRtxThreadNew+0x390>)
    75c0:	4a14      	ldr	r2, [pc, #80]	; (7614 <svcRtxThreadNew+0x3a0>)
    75c2:	661a      	str	r2, [r3, #96]	; 0x60

    EvrRtxThreadCreated(thread, thread->thread_addr);
    75c4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    75c6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    75c8:	4619      	mov	r1, r3
    75ca:	980d      	ldr	r0, [sp, #52]	; 0x34
    75cc:	f7fd f87d 	bl	46ca <EvrRtxThreadCreated>
    75d0:	e004      	b.n	75dc <svcRtxThreadNew+0x368>
  } else {
    EvrRtxThreadError(NULL, (int32_t)osErrorNoMemory);
    75d2:	f06f 0104 	mvn.w	r1, #4
    75d6:	2000      	movs	r0, #0
    75d8:	f7fc ff60 	bl	449c <EvrRtxThreadError>
  }

  /* Notify the OS event observer of a new thread. */
  if (osEventObs && osEventObs->thread_create) {
    75dc:	4b0e      	ldr	r3, [pc, #56]	; (7618 <svcRtxThreadNew+0x3a4>)
    75de:	681b      	ldr	r3, [r3, #0]
    75e0:	2b00      	cmp	r3, #0
    75e2:	d01b      	beq.n	761c <svcRtxThreadNew+0x3a8>
    75e4:	4b0c      	ldr	r3, [pc, #48]	; (7618 <svcRtxThreadNew+0x3a4>)
    75e6:	681b      	ldr	r3, [r3, #0]
    75e8:	689b      	ldr	r3, [r3, #8]
    75ea:	2b00      	cmp	r3, #0
    75ec:	d016      	beq.n	761c <svcRtxThreadNew+0x3a8>
    thread->context = osEventObs->thread_create((int)thread, context);
    75ee:	4b0a      	ldr	r3, [pc, #40]	; (7618 <svcRtxThreadNew+0x3a4>)
    75f0:	681b      	ldr	r3, [r3, #0]
    75f2:	689b      	ldr	r3, [r3, #8]
    75f4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    75f6:	9900      	ldr	r1, [sp, #0]
    75f8:	4610      	mov	r0, r2
    75fa:	4798      	blx	r3
    75fc:	4602      	mov	r2, r0
    75fe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7600:	645a      	str	r2, [r3, #68]	; 0x44
    7602:	e00e      	b.n	7622 <svcRtxThreadNew+0x3ae>
    7604:	20000110 	.word	0x20000110
    7608:	0001148c 	.word	0x0001148c
    760c:	e25a2ea5 	.word	0xe25a2ea5
    7610:	00007bed 	.word	0x00007bed
    7614:	00007215 	.word	0x00007215
    7618:	20002f58 	.word	0x20002f58
  } else {
    thread->context = context;
    761c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    761e:	9a00      	ldr	r2, [sp, #0]
    7620:	645a      	str	r2, [r3, #68]	; 0x44
  }

  if (thread != NULL) {
    7622:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7624:	2b00      	cmp	r3, #0
    7626:	d002      	beq.n	762e <svcRtxThreadNew+0x3ba>
    osRtxThreadDispatch(thread);
    7628:	980d      	ldr	r0, [sp, #52]	; 0x34
    762a:	f7ff fd2d 	bl	7088 <osRtxThreadDispatch>
  }

  return thread;
    762e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
}
    7630:	4618      	mov	r0, r3
    7632:	b00e      	add	sp, #56	; 0x38
    7634:	bd10      	pop	{r4, pc}
    7636:	bf00      	nop

00007638 <svcRtxThreadGetId>:
  return thread->name;
}

/// Return the thread ID of the current running thread.
/// \note API identical to osThreadGetId
static osThreadId_t svcRtxThreadGetId (void) {
    7638:	b500      	push	{lr}
    763a:	b083      	sub	sp, #12
  os_thread_t *thread;

  thread = osRtxThreadGetRunning();
    763c:	f7ff fa4c 	bl	6ad8 <osRtxThreadGetRunning>
    7640:	9001      	str	r0, [sp, #4]
  EvrRtxThreadGetId(thread);
    7642:	9801      	ldr	r0, [sp, #4]
    7644:	f7fd f847 	bl	46d6 <EvrRtxThreadGetId>
  return thread;
    7648:	9b01      	ldr	r3, [sp, #4]
}
    764a:	4618      	mov	r0, r3
    764c:	b003      	add	sp, #12
    764e:	f85d fb04 	ldr.w	pc, [sp], #4

00007652 <svcRtxThreadGetStackSize>:
  return state;
}

/// Get stack size of a thread.
/// \note API identical to osThreadGetStackSize
static uint32_t svcRtxThreadGetStackSize (osThreadId_t thread_id) {
    7652:	b500      	push	{lr}
    7654:	b085      	sub	sp, #20
    7656:	9001      	str	r0, [sp, #4]
  os_thread_t *thread = osRtxThreadId(thread_id);
    7658:	9801      	ldr	r0, [sp, #4]
    765a:	f7ff fa25 	bl	6aa8 <osRtxThreadId>
    765e:	9003      	str	r0, [sp, #12]

  // Check parameters
  if ((thread == NULL) || (thread->id != osRtxIdThread)) {
    7660:	9b03      	ldr	r3, [sp, #12]
    7662:	2b00      	cmp	r3, #0
    7664:	d003      	beq.n	766e <svcRtxThreadGetStackSize+0x1c>
    7666:	9b03      	ldr	r3, [sp, #12]
    7668:	781b      	ldrb	r3, [r3, #0]
    766a:	2b01      	cmp	r3, #1
    766c:	d005      	beq.n	767a <svcRtxThreadGetStackSize+0x28>
    EvrRtxThreadGetStackSize(thread, 0U);
    766e:	2100      	movs	r1, #0
    7670:	9803      	ldr	r0, [sp, #12]
    7672:	f7fd f835 	bl	46e0 <EvrRtxThreadGetStackSize>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    7676:	2300      	movs	r3, #0
    7678:	e011      	b.n	769e <svcRtxThreadGetStackSize+0x4c>
  }

  // Check object state
  if (thread->state == osRtxObjectInactive) {
    767a:	9b03      	ldr	r3, [sp, #12]
    767c:	785b      	ldrb	r3, [r3, #1]
    767e:	2b00      	cmp	r3, #0
    7680:	d105      	bne.n	768e <svcRtxThreadGetStackSize+0x3c>
    EvrRtxThreadGetStackSize(thread, 0U);
    7682:	2100      	movs	r1, #0
    7684:	9803      	ldr	r0, [sp, #12]
    7686:	f7fd f82b 	bl	46e0 <EvrRtxThreadGetStackSize>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    768a:	2300      	movs	r3, #0
    768c:	e007      	b.n	769e <svcRtxThreadGetStackSize+0x4c>
  }

  EvrRtxThreadGetStackSize(thread, thread->stack_size);
    768e:	9b03      	ldr	r3, [sp, #12]
    7690:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    7692:	4619      	mov	r1, r3
    7694:	9803      	ldr	r0, [sp, #12]
    7696:	f7fd f823 	bl	46e0 <EvrRtxThreadGetStackSize>

  return thread->stack_size;
    769a:	9b03      	ldr	r3, [sp, #12]
    769c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
    769e:	4618      	mov	r0, r3
    76a0:	b005      	add	sp, #20
    76a2:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000076a8 <svcRtxThreadGetStackSpace>:

/// Get available stack space of a thread based on stack watermark recording during execution.
/// \note API identical to osThreadGetStackSpace
static uint32_t svcRtxThreadGetStackSpace (osThreadId_t thread_id) {
    76a8:	b500      	push	{lr}
    76aa:	b087      	sub	sp, #28
    76ac:	9001      	str	r0, [sp, #4]
  os_thread_t    *thread = osRtxThreadId(thread_id);
    76ae:	9801      	ldr	r0, [sp, #4]
    76b0:	f7ff f9fa 	bl	6aa8 <osRtxThreadId>
    76b4:	9003      	str	r0, [sp, #12]
  const uint32_t *stack;
        uint32_t  space;

  // Check parameters
  if ((thread == NULL) || (thread->id != osRtxIdThread)) {
    76b6:	9b03      	ldr	r3, [sp, #12]
    76b8:	2b00      	cmp	r3, #0
    76ba:	d003      	beq.n	76c4 <svcRtxThreadGetStackSpace+0x1c>
    76bc:	9b03      	ldr	r3, [sp, #12]
    76be:	781b      	ldrb	r3, [r3, #0]
    76c0:	2b01      	cmp	r3, #1
    76c2:	d005      	beq.n	76d0 <svcRtxThreadGetStackSpace+0x28>
    EvrRtxThreadGetStackSpace(thread, 0U);
    76c4:	2100      	movs	r1, #0
    76c6:	9803      	ldr	r0, [sp, #12]
    76c8:	f7fd f810 	bl	46ec <EvrRtxThreadGetStackSpace>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    76cc:	2300      	movs	r3, #0
    76ce:	e03b      	b.n	7748 <svcRtxThreadGetStackSpace+0xa0>
  }

  // Check object state
  if (thread->state == osRtxObjectInactive) {
    76d0:	9b03      	ldr	r3, [sp, #12]
    76d2:	785b      	ldrb	r3, [r3, #1]
    76d4:	2b00      	cmp	r3, #0
    76d6:	d105      	bne.n	76e4 <svcRtxThreadGetStackSpace+0x3c>
    EvrRtxThreadGetStackSpace(thread, 0U);
    76d8:	2100      	movs	r1, #0
    76da:	9803      	ldr	r0, [sp, #12]
    76dc:	f7fd f806 	bl	46ec <EvrRtxThreadGetStackSpace>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    76e0:	2300      	movs	r3, #0
    76e2:	e031      	b.n	7748 <svcRtxThreadGetStackSpace+0xa0>
  }

  // Check if stack watermark is not enabled
  if ((osRtxConfig.flags & osRtxConfigStackWatermark) == 0U) {
    76e4:	4b1a      	ldr	r3, [pc, #104]	; (7750 <svcRtxThreadGetStackSpace+0xa8>)
    76e6:	681b      	ldr	r3, [r3, #0]
    76e8:	f003 0304 	and.w	r3, r3, #4
    76ec:	2b00      	cmp	r3, #0
    76ee:	d105      	bne.n	76fc <svcRtxThreadGetStackSpace+0x54>
    EvrRtxThreadGetStackSpace(thread, 0U);
    76f0:	2100      	movs	r1, #0
    76f2:	9803      	ldr	r0, [sp, #12]
    76f4:	f7fc fffa 	bl	46ec <EvrRtxThreadGetStackSpace>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    76f8:	2300      	movs	r3, #0
    76fa:	e025      	b.n	7748 <svcRtxThreadGetStackSpace+0xa0>
  }

  //lint -e{9079} "conversion from pointer to void to pointer to other type"
  stack = thread->stack_mem;
    76fc:	9b03      	ldr	r3, [sp, #12]
    76fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    7700:	9305      	str	r3, [sp, #20]
  if (*stack++ == osRtxStackMagicWord) {
    7702:	9b05      	ldr	r3, [sp, #20]
    7704:	1d1a      	adds	r2, r3, #4
    7706:	9205      	str	r2, [sp, #20]
    7708:	681b      	ldr	r3, [r3, #0]
    770a:	4a12      	ldr	r2, [pc, #72]	; (7754 <svcRtxThreadGetStackSpace+0xac>)
    770c:	4293      	cmp	r3, r2
    770e:	d112      	bne.n	7736 <svcRtxThreadGetStackSpace+0x8e>
    for (space = 4U; space < thread->stack_size; space += 4U) {
    7710:	2304      	movs	r3, #4
    7712:	9304      	str	r3, [sp, #16]
    7714:	e009      	b.n	772a <svcRtxThreadGetStackSpace+0x82>
      if (*stack++ != osRtxStackFillPattern) {
    7716:	9b05      	ldr	r3, [sp, #20]
    7718:	1d1a      	adds	r2, r3, #4
    771a:	9205      	str	r2, [sp, #20]
    771c:	681b      	ldr	r3, [r3, #0]
    771e:	f1b3 3fcc 	cmp.w	r3, #3435973836	; 0xcccccccc
    7722:	d10b      	bne.n	773c <svcRtxThreadGetStackSpace+0x94>
    for (space = 4U; space < thread->stack_size; space += 4U) {
    7724:	9b04      	ldr	r3, [sp, #16]
    7726:	3304      	adds	r3, #4
    7728:	9304      	str	r3, [sp, #16]
    772a:	9b03      	ldr	r3, [sp, #12]
    772c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    772e:	9b04      	ldr	r3, [sp, #16]
    7730:	429a      	cmp	r2, r3
    7732:	d8f0      	bhi.n	7716 <svcRtxThreadGetStackSpace+0x6e>
    7734:	e003      	b.n	773e <svcRtxThreadGetStackSpace+0x96>
        break;
      }
    }
  } else {
    space = 0U;
    7736:	2300      	movs	r3, #0
    7738:	9304      	str	r3, [sp, #16]
    773a:	e000      	b.n	773e <svcRtxThreadGetStackSpace+0x96>
        break;
    773c:	bf00      	nop
  }

  EvrRtxThreadGetStackSpace(thread, space);
    773e:	9904      	ldr	r1, [sp, #16]
    7740:	9803      	ldr	r0, [sp, #12]
    7742:	f7fc ffd3 	bl	46ec <EvrRtxThreadGetStackSpace>

  return space;
    7746:	9b04      	ldr	r3, [sp, #16]
}
    7748:	4618      	mov	r0, r3
    774a:	b007      	add	sp, #28
    774c:	f85d fb04 	ldr.w	pc, [sp], #4
    7750:	0001148c 	.word	0x0001148c
    7754:	e25a2ea5 	.word	0xe25a2ea5

00007758 <osRtxThreadFree>:
  return osOK;
}

/// Free Thread resources.
/// \param[in]  thread          thread object.
static void osRtxThreadFree (os_thread_t *thread) {
    7758:	b500      	push	{lr}
    775a:	b083      	sub	sp, #12
    775c:	9001      	str	r0, [sp, #4]

  // Mark object as inactive
  thread->state = osRtxThreadInactive;
    775e:	9b01      	ldr	r3, [sp, #4]
    7760:	2200      	movs	r2, #0
    7762:	705a      	strb	r2, [r3, #1]
    (void)TZ_FreeModuleContext_S(thread->tz_memory);
  }
#endif

  // Free stack memory
  if ((thread->flags & osRtxFlagSystemMemory) != 0U) {
    7764:	9b01      	ldr	r3, [sp, #4]
    7766:	789b      	ldrb	r3, [r3, #2]
    7768:	f003 0302 	and.w	r3, r3, #2
    776c:	2b00      	cmp	r3, #0
    776e:	d017      	beq.n	77a0 <osRtxThreadFree+0x48>
    if ((thread->flags & osRtxThreadFlagDefStack) != 0U) {
    7770:	9b01      	ldr	r3, [sp, #4]
    7772:	789b      	ldrb	r3, [r3, #2]
    7774:	f003 0310 	and.w	r3, r3, #16
    7778:	2b00      	cmp	r3, #0
    777a:	d009      	beq.n	7790 <osRtxThreadFree+0x38>
      (void)osRtxMemoryPoolFree(osRtxInfo.mpi.stack, thread->stack_mem);
    777c:	4b17      	ldr	r3, [pc, #92]	; (77dc <osRtxThreadFree+0x84>)
    777e:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
    7782:	9b01      	ldr	r3, [sp, #4]
    7784:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    7786:	4619      	mov	r1, r3
    7788:	4610      	mov	r0, r2
    778a:	f7fd fe07 	bl	539c <osRtxMemoryPoolFree>
    778e:	e007      	b.n	77a0 <osRtxThreadFree+0x48>
    } else {
      (void)osRtxMemoryFree(osRtxInfo.mem.stack, thread->stack_mem);
    7790:	4b12      	ldr	r3, [pc, #72]	; (77dc <osRtxThreadFree+0x84>)
    7792:	6f5a      	ldr	r2, [r3, #116]	; 0x74
    7794:	9b01      	ldr	r3, [sp, #4]
    7796:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    7798:	4619      	mov	r1, r3
    779a:	4610      	mov	r0, r2
    779c:	f7fd fcd7 	bl	514e <osRtxMemoryFree>
    }
  }

  // Free object memory
  if ((thread->flags & osRtxFlagSystemObject) != 0U) {
    77a0:	9b01      	ldr	r3, [sp, #4]
    77a2:	789b      	ldrb	r3, [r3, #2]
    77a4:	f003 0301 	and.w	r3, r3, #1
    77a8:	2b00      	cmp	r3, #0
    77aa:	d013      	beq.n	77d4 <osRtxThreadFree+0x7c>
    if (osRtxInfo.mpi.thread != NULL) {
    77ac:	4b0b      	ldr	r3, [pc, #44]	; (77dc <osRtxThreadFree+0x84>)
    77ae:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    77b2:	2b00      	cmp	r3, #0
    77b4:	d007      	beq.n	77c6 <osRtxThreadFree+0x6e>
      (void)osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
    77b6:	4b09      	ldr	r3, [pc, #36]	; (77dc <osRtxThreadFree+0x84>)
    77b8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    77bc:	9901      	ldr	r1, [sp, #4]
    77be:	4618      	mov	r0, r3
    77c0:	f7fd fdec 	bl	539c <osRtxMemoryPoolFree>
    }
#if (defined(OS_OBJ_MEM_USAGE) && (OS_OBJ_MEM_USAGE != 0))
    osRtxThreadMemUsage.cnt_free++;
#endif
  }
}
    77c4:	e006      	b.n	77d4 <osRtxThreadFree+0x7c>
      (void)osRtxMemoryFree(osRtxInfo.mem.common, thread);
    77c6:	4b05      	ldr	r3, [pc, #20]	; (77dc <osRtxThreadFree+0x84>)
    77c8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    77cc:	9901      	ldr	r1, [sp, #4]
    77ce:	4618      	mov	r0, r3
    77d0:	f7fd fcbd 	bl	514e <osRtxMemoryFree>
}
    77d4:	bf00      	nop
    77d6:	b003      	add	sp, #12
    77d8:	f85d fb04 	ldr.w	pc, [sp], #4
    77dc:	20000110 	.word	0x20000110

000077e0 <svcRtxThreadExit>:
  return status;
}

/// Terminate execution of current running thread.
/// \note API identical to osThreadExit
static void svcRtxThreadExit (void) {
    77e0:	b510      	push	{r4, lr}
    77e2:	b082      	sub	sp, #8
  os_thread_t *thread;

  // Check running thread
  thread = osRtxThreadGetRunning();
    77e4:	f7ff f978 	bl	6ad8 <osRtxThreadGetRunning>
    77e8:	9001      	str	r0, [sp, #4]
  if (thread == NULL) {
    77ea:	9b01      	ldr	r3, [sp, #4]
    77ec:	2b00      	cmp	r3, #0
    77ee:	d054      	beq.n	789a <svcRtxThreadExit+0xba>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }

  // Check if switch to next Ready Thread is possible
  if ((osRtxKernelGetState() != osRtxKernelRunning) ||
    77f0:	f7ff f96c 	bl	6acc <osRtxKernelGetState>
    77f4:	4603      	mov	r3, r0
    77f6:	2b02      	cmp	r3, #2
    77f8:	d151      	bne.n	789e <svcRtxThreadExit+0xbe>
      (osRtxInfo.thread.ready.thread_list == NULL)) {
    77fa:	4b2a      	ldr	r3, [pc, #168]	; (78a4 <svcRtxThreadExit+0xc4>)
    77fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  if ((osRtxKernelGetState() != osRtxKernelRunning) ||
    77fe:	2b00      	cmp	r3, #0
    7800:	d04d      	beq.n	789e <svcRtxThreadExit+0xbe>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }

  // Release owned Mutexes
  osRtxMutexOwnerRelease(thread->mutex_list);
    7802:	9b01      	ldr	r3, [sp, #4]
    7804:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    7806:	4618      	mov	r0, r3
    7808:	f7fe fc42 	bl	6090 <osRtxMutexOwnerRelease>

  // Wakeup Thread waiting to Join
  if (thread->thread_join != NULL) {
    780c:	9b01      	ldr	r3, [sp, #4]
    780e:	699b      	ldr	r3, [r3, #24]
    7810:	2b00      	cmp	r3, #0
    7812:	d00b      	beq.n	782c <svcRtxThreadExit+0x4c>
    osRtxThreadWaitExit(thread->thread_join, (uint32_t)osOK, FALSE);
    7814:	9b01      	ldr	r3, [sp, #4]
    7816:	699b      	ldr	r3, [r3, #24]
    7818:	2200      	movs	r2, #0
    781a:	2100      	movs	r1, #0
    781c:	4618      	mov	r0, r3
    781e:	f7ff fc7f 	bl	7120 <osRtxThreadWaitExit>
    EvrRtxThreadJoined(thread->thread_join);
    7822:	9b01      	ldr	r3, [sp, #4]
    7824:	699b      	ldr	r3, [r3, #24]
    7826:	4618      	mov	r0, r3
    7828:	f7fc ff66 	bl	46f8 <EvrRtxThreadJoined>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
    782c:	f3ef 8309 	mrs	r3, PSP
    7830:	461c      	mov	r4, r3
  return(result);
    7832:	4622      	mov	r2, r4
  }

  // Switch to next Ready Thread
  thread->sp = __get_PSP();
    7834:	9b01      	ldr	r3, [sp, #4]
    7836:	639a      	str	r2, [r3, #56]	; 0x38
  osRtxThreadSwitch(osRtxThreadListGet(&osRtxInfo.thread.ready));
    7838:	481b      	ldr	r0, [pc, #108]	; (78a8 <svcRtxThreadExit+0xc8>)
    783a:	f7ff f9d1 	bl	6be0 <osRtxThreadListGet>
    783e:	4603      	mov	r3, r0
    7840:	4618      	mov	r0, r3
    7842:	f7ff fbe3 	bl	700c <osRtxThreadSwitch>
  osRtxThreadSetRunning(NULL);
    7846:	2000      	movs	r0, #0
    7848:	f7ff f94c 	bl	6ae4 <osRtxThreadSetRunning>

  if (((thread->attr & osThreadJoinable) == 0U) || (thread->thread_join != NULL)) {
    784c:	9b01      	ldr	r3, [sp, #4]
    784e:	78db      	ldrb	r3, [r3, #3]
    7850:	f003 0301 	and.w	r3, r3, #1
    7854:	2b00      	cmp	r3, #0
    7856:	d003      	beq.n	7860 <svcRtxThreadExit+0x80>
    7858:	9b01      	ldr	r3, [sp, #4]
    785a:	699b      	ldr	r3, [r3, #24]
    785c:	2b00      	cmp	r3, #0
    785e:	d003      	beq.n	7868 <svcRtxThreadExit+0x88>
    osRtxThreadFree(thread);
    7860:	9801      	ldr	r0, [sp, #4]
    7862:	f7ff ff79 	bl	7758 <osRtxThreadFree>
    7866:	e014      	b.n	7892 <svcRtxThreadExit+0xb2>
  } else {
    // Update Thread State and put it into Terminate Thread list
    thread->state = osRtxThreadTerminated;
    7868:	9b01      	ldr	r3, [sp, #4]
    786a:	2204      	movs	r2, #4
    786c:	705a      	strb	r2, [r3, #1]
    thread->thread_prev = NULL;
    786e:	9b01      	ldr	r3, [sp, #4]
    7870:	2200      	movs	r2, #0
    7872:	60da      	str	r2, [r3, #12]
    thread->thread_next = osRtxInfo.thread.terminate_list;
    7874:	4b0b      	ldr	r3, [pc, #44]	; (78a4 <svcRtxThreadExit+0xc4>)
    7876:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    7878:	9b01      	ldr	r3, [sp, #4]
    787a:	609a      	str	r2, [r3, #8]
    if (osRtxInfo.thread.terminate_list != NULL) {
    787c:	4b09      	ldr	r3, [pc, #36]	; (78a4 <svcRtxThreadExit+0xc4>)
    787e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    7880:	2b00      	cmp	r3, #0
    7882:	d003      	beq.n	788c <svcRtxThreadExit+0xac>
      osRtxInfo.thread.terminate_list->thread_prev = thread;
    7884:	4b07      	ldr	r3, [pc, #28]	; (78a4 <svcRtxThreadExit+0xc4>)
    7886:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    7888:	9a01      	ldr	r2, [sp, #4]
    788a:	60da      	str	r2, [r3, #12]
    }
    osRtxInfo.thread.terminate_list = thread;
    788c:	4a05      	ldr	r2, [pc, #20]	; (78a4 <svcRtxThreadExit+0xc4>)
    788e:	9b01      	ldr	r3, [sp, #4]
    7890:	6353      	str	r3, [r2, #52]	; 0x34
  }

  EvrRtxThreadDestroyed(thread);
    7892:	9801      	ldr	r0, [sp, #4]
    7894:	f7fc ff4b 	bl	472e <EvrRtxThreadDestroyed>
    7898:	e002      	b.n	78a0 <svcRtxThreadExit+0xc0>
    return;
    789a:	bf00      	nop
    789c:	e000      	b.n	78a0 <svcRtxThreadExit+0xc0>
    return;
    789e:	bf00      	nop
}
    78a0:	b002      	add	sp, #8
    78a2:	bd10      	pop	{r4, pc}
    78a4:	20000110 	.word	0x20000110
    78a8:	2000012c 	.word	0x2000012c

000078ac <svcRtxThreadGetCount>:
  return status;
}

/// Get number of active threads.
/// \note API identical to osThreadGetCount
static uint32_t svcRtxThreadGetCount (void) {
    78ac:	b500      	push	{lr}
    78ae:	b083      	sub	sp, #12
  const os_thread_t *thread;
        uint32_t     count;

  // Running Thread
  count = 1U;
    78b0:	2301      	movs	r3, #1
    78b2:	9300      	str	r3, [sp, #0]

  // Ready List
  for (thread = osRtxInfo.thread.ready.thread_list;
    78b4:	4b17      	ldr	r3, [pc, #92]	; (7914 <svcRtxThreadGetCount+0x68>)
    78b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    78b8:	9301      	str	r3, [sp, #4]
    78ba:	e005      	b.n	78c8 <svcRtxThreadGetCount+0x1c>
       thread != NULL; thread = thread->thread_next) {
    count++;
    78bc:	9b00      	ldr	r3, [sp, #0]
    78be:	3301      	adds	r3, #1
    78c0:	9300      	str	r3, [sp, #0]
       thread != NULL; thread = thread->thread_next) {
    78c2:	9b01      	ldr	r3, [sp, #4]
    78c4:	689b      	ldr	r3, [r3, #8]
    78c6:	9301      	str	r3, [sp, #4]
  for (thread = osRtxInfo.thread.ready.thread_list;
    78c8:	9b01      	ldr	r3, [sp, #4]
    78ca:	2b00      	cmp	r3, #0
    78cc:	d1f6      	bne.n	78bc <svcRtxThreadGetCount+0x10>
  }

  // Delay List
  for (thread = osRtxInfo.thread.delay_list;
    78ce:	4b11      	ldr	r3, [pc, #68]	; (7914 <svcRtxThreadGetCount+0x68>)
    78d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    78d2:	9301      	str	r3, [sp, #4]
    78d4:	e005      	b.n	78e2 <svcRtxThreadGetCount+0x36>
       thread != NULL; thread = thread->delay_next) {
    count++;
    78d6:	9b00      	ldr	r3, [sp, #0]
    78d8:	3301      	adds	r3, #1
    78da:	9300      	str	r3, [sp, #0]
       thread != NULL; thread = thread->delay_next) {
    78dc:	9b01      	ldr	r3, [sp, #4]
    78de:	691b      	ldr	r3, [r3, #16]
    78e0:	9301      	str	r3, [sp, #4]
  for (thread = osRtxInfo.thread.delay_list;
    78e2:	9b01      	ldr	r3, [sp, #4]
    78e4:	2b00      	cmp	r3, #0
    78e6:	d1f6      	bne.n	78d6 <svcRtxThreadGetCount+0x2a>
  }

  // Wait List
  for (thread = osRtxInfo.thread.wait_list;
    78e8:	4b0a      	ldr	r3, [pc, #40]	; (7914 <svcRtxThreadGetCount+0x68>)
    78ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    78ec:	9301      	str	r3, [sp, #4]
    78ee:	e005      	b.n	78fc <svcRtxThreadGetCount+0x50>
       thread != NULL; thread = thread->delay_next) {
    count++;
    78f0:	9b00      	ldr	r3, [sp, #0]
    78f2:	3301      	adds	r3, #1
    78f4:	9300      	str	r3, [sp, #0]
       thread != NULL; thread = thread->delay_next) {
    78f6:	9b01      	ldr	r3, [sp, #4]
    78f8:	691b      	ldr	r3, [r3, #16]
    78fa:	9301      	str	r3, [sp, #4]
  for (thread = osRtxInfo.thread.wait_list;
    78fc:	9b01      	ldr	r3, [sp, #4]
    78fe:	2b00      	cmp	r3, #0
    7900:	d1f6      	bne.n	78f0 <svcRtxThreadGetCount+0x44>
  }

  EvrRtxThreadGetCount(count);
    7902:	9800      	ldr	r0, [sp, #0]
    7904:	f7fc ff18 	bl	4738 <EvrRtxThreadGetCount>

  return count;
    7908:	9b00      	ldr	r3, [sp, #0]
}
    790a:	4618      	mov	r0, r3
    790c:	b003      	add	sp, #12
    790e:	f85d fb04 	ldr.w	pc, [sp], #4
    7912:	bf00      	nop
    7914:	20000110 	.word	0x20000110

00007918 <svcRtxThreadEnumerate>:

/// Enumerate active threads.
/// \note API identical to osThreadEnumerate
static uint32_t svcRtxThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items) {
    7918:	b500      	push	{lr}
    791a:	b085      	sub	sp, #20
    791c:	9001      	str	r0, [sp, #4]
    791e:	9100      	str	r1, [sp, #0]
  os_thread_t *thread;
  uint32_t     count;

  // Check parameters
  if ((thread_array == NULL) || (array_items == 0U)) {
    7920:	9b01      	ldr	r3, [sp, #4]
    7922:	2b00      	cmp	r3, #0
    7924:	d002      	beq.n	792c <svcRtxThreadEnumerate+0x14>
    7926:	9b00      	ldr	r3, [sp, #0]
    7928:	2b00      	cmp	r3, #0
    792a:	d106      	bne.n	793a <svcRtxThreadEnumerate+0x22>
    EvrRtxThreadEnumerate(thread_array, array_items, 0U);
    792c:	2200      	movs	r2, #0
    792e:	9900      	ldr	r1, [sp, #0]
    7930:	9801      	ldr	r0, [sp, #4]
    7932:	f7fc ff06 	bl	4742 <EvrRtxThreadEnumerate>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    7936:	2300      	movs	r3, #0
    7938:	e059      	b.n	79ee <svcRtxThreadEnumerate+0xd6>
  }

  // Running Thread
  *thread_array = osRtxThreadGetRunning();
    793a:	f7ff f8cd 	bl	6ad8 <osRtxThreadGetRunning>
    793e:	4602      	mov	r2, r0
    7940:	9b01      	ldr	r3, [sp, #4]
    7942:	601a      	str	r2, [r3, #0]
   thread_array++;
    7944:	9b01      	ldr	r3, [sp, #4]
    7946:	3304      	adds	r3, #4
    7948:	9301      	str	r3, [sp, #4]
   count = 1U;
    794a:	2301      	movs	r3, #1
    794c:	9302      	str	r3, [sp, #8]

  // Ready List
  for (thread = osRtxInfo.thread.ready.thread_list;
    794e:	4b2a      	ldr	r3, [pc, #168]	; (79f8 <svcRtxThreadEnumerate+0xe0>)
    7950:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7952:	9303      	str	r3, [sp, #12]
    7954:	e00b      	b.n	796e <svcRtxThreadEnumerate+0x56>
       (thread != NULL) && (count < array_items); thread = thread->thread_next) {
    *thread_array = thread;
    7956:	9b01      	ldr	r3, [sp, #4]
    7958:	9a03      	ldr	r2, [sp, #12]
    795a:	601a      	str	r2, [r3, #0]
     thread_array++;
    795c:	9b01      	ldr	r3, [sp, #4]
    795e:	3304      	adds	r3, #4
    7960:	9301      	str	r3, [sp, #4]
     count++;
    7962:	9b02      	ldr	r3, [sp, #8]
    7964:	3301      	adds	r3, #1
    7966:	9302      	str	r3, [sp, #8]
       (thread != NULL) && (count < array_items); thread = thread->thread_next) {
    7968:	9b03      	ldr	r3, [sp, #12]
    796a:	689b      	ldr	r3, [r3, #8]
    796c:	9303      	str	r3, [sp, #12]
  for (thread = osRtxInfo.thread.ready.thread_list;
    796e:	9b03      	ldr	r3, [sp, #12]
    7970:	2b00      	cmp	r3, #0
    7972:	d003      	beq.n	797c <svcRtxThreadEnumerate+0x64>
       (thread != NULL) && (count < array_items); thread = thread->thread_next) {
    7974:	9a02      	ldr	r2, [sp, #8]
    7976:	9b00      	ldr	r3, [sp, #0]
    7978:	429a      	cmp	r2, r3
    797a:	d3ec      	bcc.n	7956 <svcRtxThreadEnumerate+0x3e>
  }

  // Delay List
  for (thread = osRtxInfo.thread.delay_list;
    797c:	4b1e      	ldr	r3, [pc, #120]	; (79f8 <svcRtxThreadEnumerate+0xe0>)
    797e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    7980:	9303      	str	r3, [sp, #12]
    7982:	e00b      	b.n	799c <svcRtxThreadEnumerate+0x84>
       (thread != NULL) && (count < array_items); thread = thread->delay_next) {
    *thread_array = thread;
    7984:	9b01      	ldr	r3, [sp, #4]
    7986:	9a03      	ldr	r2, [sp, #12]
    7988:	601a      	str	r2, [r3, #0]
     thread_array++;
    798a:	9b01      	ldr	r3, [sp, #4]
    798c:	3304      	adds	r3, #4
    798e:	9301      	str	r3, [sp, #4]
     count++;
    7990:	9b02      	ldr	r3, [sp, #8]
    7992:	3301      	adds	r3, #1
    7994:	9302      	str	r3, [sp, #8]
       (thread != NULL) && (count < array_items); thread = thread->delay_next) {
    7996:	9b03      	ldr	r3, [sp, #12]
    7998:	691b      	ldr	r3, [r3, #16]
    799a:	9303      	str	r3, [sp, #12]
  for (thread = osRtxInfo.thread.delay_list;
    799c:	9b03      	ldr	r3, [sp, #12]
    799e:	2b00      	cmp	r3, #0
    79a0:	d003      	beq.n	79aa <svcRtxThreadEnumerate+0x92>
       (thread != NULL) && (count < array_items); thread = thread->delay_next) {
    79a2:	9a02      	ldr	r2, [sp, #8]
    79a4:	9b00      	ldr	r3, [sp, #0]
    79a6:	429a      	cmp	r2, r3
    79a8:	d3ec      	bcc.n	7984 <svcRtxThreadEnumerate+0x6c>
  }

  // Wait List
  for (thread = osRtxInfo.thread.wait_list;
    79aa:	4b13      	ldr	r3, [pc, #76]	; (79f8 <svcRtxThreadEnumerate+0xe0>)
    79ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    79ae:	9303      	str	r3, [sp, #12]
    79b0:	e00b      	b.n	79ca <svcRtxThreadEnumerate+0xb2>
       (thread != NULL) && (count < array_items); thread = thread->delay_next) {
    *thread_array = thread;
    79b2:	9b01      	ldr	r3, [sp, #4]
    79b4:	9a03      	ldr	r2, [sp, #12]
    79b6:	601a      	str	r2, [r3, #0]
     thread_array++;
    79b8:	9b01      	ldr	r3, [sp, #4]
    79ba:	3304      	adds	r3, #4
    79bc:	9301      	str	r3, [sp, #4]
     count++;
    79be:	9b02      	ldr	r3, [sp, #8]
    79c0:	3301      	adds	r3, #1
    79c2:	9302      	str	r3, [sp, #8]
       (thread != NULL) && (count < array_items); thread = thread->delay_next) {
    79c4:	9b03      	ldr	r3, [sp, #12]
    79c6:	691b      	ldr	r3, [r3, #16]
    79c8:	9303      	str	r3, [sp, #12]
  for (thread = osRtxInfo.thread.wait_list;
    79ca:	9b03      	ldr	r3, [sp, #12]
    79cc:	2b00      	cmp	r3, #0
    79ce:	d003      	beq.n	79d8 <svcRtxThreadEnumerate+0xc0>
       (thread != NULL) && (count < array_items); thread = thread->delay_next) {
    79d0:	9a02      	ldr	r2, [sp, #8]
    79d2:	9b00      	ldr	r3, [sp, #0]
    79d4:	429a      	cmp	r2, r3
    79d6:	d3ec      	bcc.n	79b2 <svcRtxThreadEnumerate+0x9a>
  }

  EvrRtxThreadEnumerate(thread_array - count, array_items, count);
    79d8:	9b02      	ldr	r3, [sp, #8]
    79da:	009b      	lsls	r3, r3, #2
    79dc:	425b      	negs	r3, r3
    79de:	9a01      	ldr	r2, [sp, #4]
    79e0:	4413      	add	r3, r2
    79e2:	9a02      	ldr	r2, [sp, #8]
    79e4:	9900      	ldr	r1, [sp, #0]
    79e6:	4618      	mov	r0, r3
    79e8:	f7fc feab 	bl	4742 <EvrRtxThreadEnumerate>

  return count;
    79ec:	9b02      	ldr	r3, [sp, #8]
}
    79ee:	4618      	mov	r0, r3
    79f0:	b005      	add	sp, #20
    79f2:	f85d fb04 	ldr.w	pc, [sp], #4
    79f6:	bf00      	nop
    79f8:	20000110 	.word	0x20000110

000079fc <osRtxThreadStartup>:

//  ==== Library functions ====

/// Thread startup (Idle and Timer Thread).
/// \return true - success, false - failure.
bool_t osRtxThreadStartup (void) {
    79fc:	b500      	push	{lr}
    79fe:	b083      	sub	sp, #12
  bool_t ret = TRUE;
    7a00:	2301      	movs	r3, #1
    7a02:	f88d 3007 	strb.w	r3, [sp, #7]

  // Create Idle Thread
  if (osRtxInfo.thread.idle == NULL) {
    7a06:	4b1e      	ldr	r3, [pc, #120]	; (7a80 <osRtxThreadStartup+0x84>)
    7a08:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    7a0a:	2b00      	cmp	r3, #0
    7a0c:	d114      	bne.n	7a38 <osRtxThreadStartup+0x3c>
    osRtxInfo.thread.idle = osRtxThreadId(
    7a0e:	4b1d      	ldr	r3, [pc, #116]	; (7a84 <osRtxThreadStartup+0x88>)
    7a10:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    7a12:	2300      	movs	r3, #0
    7a14:	2100      	movs	r1, #0
    7a16:	481c      	ldr	r0, [pc, #112]	; (7a88 <osRtxThreadStartup+0x8c>)
    7a18:	f7ff fc2c 	bl	7274 <svcRtxThreadNew>
    7a1c:	4603      	mov	r3, r0
    7a1e:	4618      	mov	r0, r3
    7a20:	f7ff f842 	bl	6aa8 <osRtxThreadId>
    7a24:	4602      	mov	r2, r0
    7a26:	4b16      	ldr	r3, [pc, #88]	; (7a80 <osRtxThreadStartup+0x84>)
    7a28:	629a      	str	r2, [r3, #40]	; 0x28
      svcRtxThreadNew(osRtxIdleThread, NULL, osRtxConfig.idle_thread_attr, NULL)
    );
    if (osRtxInfo.thread.idle == NULL) {
    7a2a:	4b15      	ldr	r3, [pc, #84]	; (7a80 <osRtxThreadStartup+0x84>)
    7a2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    7a2e:	2b00      	cmp	r3, #0
    7a30:	d102      	bne.n	7a38 <osRtxThreadStartup+0x3c>
      ret = FALSE;
    7a32:	2300      	movs	r3, #0
    7a34:	f88d 3007 	strb.w	r3, [sp, #7]
    }
  }

  // Create Timer Thread
  if (osRtxConfig.timer_mq_mcnt != 0U) {
    7a38:	4b12      	ldr	r3, [pc, #72]	; (7a84 <osRtxThreadStartup+0x88>)
    7a3a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    7a3c:	2b00      	cmp	r3, #0
    7a3e:	d018      	beq.n	7a72 <osRtxThreadStartup+0x76>
    if (osRtxInfo.timer.thread == NULL) {
    7a40:	4b0f      	ldr	r3, [pc, #60]	; (7a80 <osRtxThreadStartup+0x84>)
    7a42:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    7a44:	2b00      	cmp	r3, #0
    7a46:	d114      	bne.n	7a72 <osRtxThreadStartup+0x76>
      osRtxInfo.timer.thread = osRtxThreadId(
    7a48:	4b0e      	ldr	r3, [pc, #56]	; (7a84 <osRtxThreadStartup+0x88>)
    7a4a:	6dda      	ldr	r2, [r3, #92]	; 0x5c
    7a4c:	2300      	movs	r3, #0
    7a4e:	2100      	movs	r1, #0
    7a50:	480e      	ldr	r0, [pc, #56]	; (7a8c <osRtxThreadStartup+0x90>)
    7a52:	f7ff fc0f 	bl	7274 <svcRtxThreadNew>
    7a56:	4603      	mov	r3, r0
    7a58:	4618      	mov	r0, r3
    7a5a:	f7ff f825 	bl	6aa8 <osRtxThreadId>
    7a5e:	4602      	mov	r2, r0
    7a60:	4b07      	ldr	r3, [pc, #28]	; (7a80 <osRtxThreadStartup+0x84>)
    7a62:	649a      	str	r2, [r3, #72]	; 0x48
        svcRtxThreadNew(osRtxTimerThread, NULL, osRtxConfig.timer_thread_attr, NULL)
      );
      if (osRtxInfo.timer.thread == NULL) {
    7a64:	4b06      	ldr	r3, [pc, #24]	; (7a80 <osRtxThreadStartup+0x84>)
    7a66:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    7a68:	2b00      	cmp	r3, #0
    7a6a:	d102      	bne.n	7a72 <osRtxThreadStartup+0x76>
        ret = FALSE;
    7a6c:	2300      	movs	r3, #0
    7a6e:	f88d 3007 	strb.w	r3, [sp, #7]
      }
    }
  }

  return ret;
    7a72:	f89d 3007 	ldrb.w	r3, [sp, #7]
}
    7a76:	4618      	mov	r0, r3
    7a78:	b003      	add	sp, #12
    7a7a:	f85d fb04 	ldr.w	pc, [sp], #4
    7a7e:	bf00      	nop
    7a80:	20000110 	.word	0x20000110
    7a84:	0001148c 	.word	0x0001148c
    7a88:	00004331 	.word	0x00004331
    7a8c:	00007dd1 	.word	0x00007dd1

00007a90 <osThreadNew>:


//  ==== Public API ====

/// Create a thread and add it to Active Threads.
osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
    7a90:	b500      	push	{lr}
    7a92:	b085      	sub	sp, #20
    7a94:	9003      	str	r0, [sp, #12]
    7a96:	9102      	str	r1, [sp, #8]
    7a98:	9201      	str	r2, [sp, #4]
  return osThreadContextNew(func, argument, attr, NULL);
    7a9a:	2300      	movs	r3, #0
    7a9c:	9a01      	ldr	r2, [sp, #4]
    7a9e:	9902      	ldr	r1, [sp, #8]
    7aa0:	9803      	ldr	r0, [sp, #12]
    7aa2:	f000 f805 	bl	7ab0 <osThreadContextNew>
    7aa6:	4603      	mov	r3, r0
}
    7aa8:	4618      	mov	r0, r3
    7aaa:	b005      	add	sp, #20
    7aac:	f85d fb04 	ldr.w	pc, [sp], #4

00007ab0 <osThreadContextNew>:

osThreadId_t osThreadContextNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr, void *context) {
    7ab0:	b510      	push	{r4, lr}
    7ab2:	b08a      	sub	sp, #40	; 0x28
    7ab4:	9003      	str	r0, [sp, #12]
    7ab6:	9102      	str	r1, [sp, #8]
    7ab8:	9201      	str	r2, [sp, #4]
    7aba:	9300      	str	r3, [sp, #0]
  osThreadId_t thread_id;
  EvrRtxThreadNew(func, argument, attr);
    7abc:	9a01      	ldr	r2, [sp, #4]
    7abe:	9902      	ldr	r1, [sp, #8]
    7ac0:	9803      	ldr	r0, [sp, #12]
    7ac2:	f7fc fdfb 	bl	46bc <EvrRtxThreadNew>
  if (IsIrqMode() || IsIrqMasked()) {
    7ac6:	f7fe ff94 	bl	69f2 <IsIrqMode>
    7aca:	4603      	mov	r3, r0
    7acc:	2b00      	cmp	r3, #0
    7ace:	d104      	bne.n	7ada <osThreadContextNew+0x2a>
    7ad0:	f7fe ff9c 	bl	6a0c <IsIrqMasked>
    7ad4:	4603      	mov	r3, r0
    7ad6:	2b00      	cmp	r3, #0
    7ad8:	d007      	beq.n	7aea <osThreadContextNew+0x3a>
    EvrRtxThreadError(NULL, (int32_t)osErrorISR);
    7ada:	f06f 0105 	mvn.w	r1, #5
    7ade:	2000      	movs	r0, #0
    7ae0:	f7fc fcdc 	bl	449c <EvrRtxThreadError>
    thread_id = NULL;
    7ae4:	2300      	movs	r3, #0
    7ae6:	9309      	str	r3, [sp, #36]	; 0x24
    7ae8:	e013      	b.n	7b12 <osThreadContextNew+0x62>
    7aea:	9b03      	ldr	r3, [sp, #12]
    7aec:	9308      	str	r3, [sp, #32]
    7aee:	9b02      	ldr	r3, [sp, #8]
    7af0:	9307      	str	r3, [sp, #28]
    7af2:	9b01      	ldr	r3, [sp, #4]
    7af4:	9306      	str	r3, [sp, #24]
    7af6:	9b00      	ldr	r3, [sp, #0]
    7af8:	9305      	str	r3, [sp, #20]
SVC0_4 (ThreadNew,           osThreadId_t,    osThreadFunc_t, void *, const osThreadAttr_t *, void *)
    7afa:	9b08      	ldr	r3, [sp, #32]
    7afc:	4618      	mov	r0, r3
    7afe:	9b07      	ldr	r3, [sp, #28]
    7b00:	4619      	mov	r1, r3
    7b02:	9b06      	ldr	r3, [sp, #24]
    7b04:	461a      	mov	r2, r3
    7b06:	9b05      	ldr	r3, [sp, #20]
    7b08:	4c04      	ldr	r4, [pc, #16]	; (7b1c <osThreadContextNew+0x6c>)
    7b0a:	46a4      	mov	ip, r4
    7b0c:	df00      	svc	0
    7b0e:	4603      	mov	r3, r0
  } else {
    thread_id = __svcThreadNew(func, argument, attr, context);
    7b10:	9309      	str	r3, [sp, #36]	; 0x24
  }
  return thread_id;
    7b12:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    7b14:	4618      	mov	r0, r3
    7b16:	b00a      	add	sp, #40	; 0x28
    7b18:	bd10      	pop	{r4, pc}
    7b1a:	bf00      	nop
    7b1c:	00007275 	.word	0x00007275

00007b20 <osThreadGetId>:
  }
  return name;
}

/// Return the thread ID of the current running thread.
osThreadId_t osThreadGetId (void) {
    7b20:	b500      	push	{lr}
    7b22:	b083      	sub	sp, #12
  osThreadId_t thread_id;

  if (IsIrqMode() || IsIrqMasked()) {
    7b24:	f7fe ff65 	bl	69f2 <IsIrqMode>
    7b28:	4603      	mov	r3, r0
    7b2a:	2b00      	cmp	r3, #0
    7b2c:	d104      	bne.n	7b38 <osThreadGetId+0x18>
    7b2e:	f7fe ff6d 	bl	6a0c <IsIrqMasked>
    7b32:	4603      	mov	r3, r0
    7b34:	2b00      	cmp	r3, #0
    7b36:	d005      	beq.n	7b44 <osThreadGetId+0x24>
    EvrRtxThreadGetId(NULL);
    7b38:	2000      	movs	r0, #0
    7b3a:	f7fc fdcc 	bl	46d6 <EvrRtxThreadGetId>
    thread_id = NULL;
    7b3e:	2300      	movs	r3, #0
    7b40:	9301      	str	r3, [sp, #4]
    7b42:	e004      	b.n	7b4e <osThreadGetId+0x2e>
SVC0_0 (ThreadGetId,         osThreadId_t)
    7b44:	4b04      	ldr	r3, [pc, #16]	; (7b58 <osThreadGetId+0x38>)
    7b46:	469c      	mov	ip, r3
    7b48:	df00      	svc	0
    7b4a:	4603      	mov	r3, r0
  } else {
    thread_id = __svcThreadGetId();
    7b4c:	9301      	str	r3, [sp, #4]
  }
  return thread_id;
    7b4e:	9b01      	ldr	r3, [sp, #4]
}
    7b50:	4618      	mov	r0, r3
    7b52:	b003      	add	sp, #12
    7b54:	f85d fb04 	ldr.w	pc, [sp], #4
    7b58:	00007639 	.word	0x00007639

00007b5c <osThreadGetStackSize>:
  }
  return state;
}

/// Get stack size of a thread.
uint32_t osThreadGetStackSize (osThreadId_t thread_id) {
    7b5c:	b500      	push	{lr}
    7b5e:	b085      	sub	sp, #20
    7b60:	9001      	str	r0, [sp, #4]
  uint32_t stack_size;

  if (IsIrqMode() || IsIrqMasked()) {
    7b62:	f7fe ff46 	bl	69f2 <IsIrqMode>
    7b66:	4603      	mov	r3, r0
    7b68:	2b00      	cmp	r3, #0
    7b6a:	d104      	bne.n	7b76 <osThreadGetStackSize+0x1a>
    7b6c:	f7fe ff4e 	bl	6a0c <IsIrqMasked>
    7b70:	4603      	mov	r3, r0
    7b72:	2b00      	cmp	r3, #0
    7b74:	d006      	beq.n	7b84 <osThreadGetStackSize+0x28>
    EvrRtxThreadGetStackSize(thread_id, 0U);
    7b76:	2100      	movs	r1, #0
    7b78:	9801      	ldr	r0, [sp, #4]
    7b7a:	f7fc fdb1 	bl	46e0 <EvrRtxThreadGetStackSize>
    stack_size = 0U;
    7b7e:	2300      	movs	r3, #0
    7b80:	9303      	str	r3, [sp, #12]
    7b82:	e008      	b.n	7b96 <osThreadGetStackSize+0x3a>
    7b84:	9b01      	ldr	r3, [sp, #4]
    7b86:	9302      	str	r3, [sp, #8]
SVC0_1 (ThreadGetStackSize,  uint32_t, osThreadId_t)
    7b88:	9b02      	ldr	r3, [sp, #8]
    7b8a:	4618      	mov	r0, r3
    7b8c:	4b04      	ldr	r3, [pc, #16]	; (7ba0 <osThreadGetStackSize+0x44>)
    7b8e:	469c      	mov	ip, r3
    7b90:	df00      	svc	0
    7b92:	4603      	mov	r3, r0
  } else {
    stack_size = __svcThreadGetStackSize(thread_id);
    7b94:	9303      	str	r3, [sp, #12]
  }
  return stack_size;
    7b96:	9b03      	ldr	r3, [sp, #12]
}
    7b98:	4618      	mov	r0, r3
    7b9a:	b005      	add	sp, #20
    7b9c:	f85d fb04 	ldr.w	pc, [sp], #4
    7ba0:	00007653 	.word	0x00007653

00007ba4 <osThreadGetStackSpace>:

/// Get available stack space of a thread based on stack watermark recording during execution.
uint32_t osThreadGetStackSpace (osThreadId_t thread_id) {
    7ba4:	b500      	push	{lr}
    7ba6:	b085      	sub	sp, #20
    7ba8:	9001      	str	r0, [sp, #4]
  uint32_t stack_space;

  if (IsIrqMode() || IsIrqMasked()) {
    7baa:	f7fe ff22 	bl	69f2 <IsIrqMode>
    7bae:	4603      	mov	r3, r0
    7bb0:	2b00      	cmp	r3, #0
    7bb2:	d104      	bne.n	7bbe <osThreadGetStackSpace+0x1a>
    7bb4:	f7fe ff2a 	bl	6a0c <IsIrqMasked>
    7bb8:	4603      	mov	r3, r0
    7bba:	2b00      	cmp	r3, #0
    7bbc:	d006      	beq.n	7bcc <osThreadGetStackSpace+0x28>
    EvrRtxThreadGetStackSpace(thread_id, 0U);
    7bbe:	2100      	movs	r1, #0
    7bc0:	9801      	ldr	r0, [sp, #4]
    7bc2:	f7fc fd93 	bl	46ec <EvrRtxThreadGetStackSpace>
    stack_space = 0U;
    7bc6:	2300      	movs	r3, #0
    7bc8:	9303      	str	r3, [sp, #12]
    7bca:	e008      	b.n	7bde <osThreadGetStackSpace+0x3a>
    7bcc:	9b01      	ldr	r3, [sp, #4]
    7bce:	9302      	str	r3, [sp, #8]
SVC0_1 (ThreadGetStackSpace, uint32_t, osThreadId_t)
    7bd0:	9b02      	ldr	r3, [sp, #8]
    7bd2:	4618      	mov	r0, r3
    7bd4:	4b04      	ldr	r3, [pc, #16]	; (7be8 <osThreadGetStackSpace+0x44>)
    7bd6:	469c      	mov	ip, r3
    7bd8:	df00      	svc	0
    7bda:	4603      	mov	r3, r0
  } else {
    stack_space = __svcThreadGetStackSpace(thread_id);
    7bdc:	9303      	str	r3, [sp, #12]
  }
  return stack_space;
    7bde:	9b03      	ldr	r3, [sp, #12]
}
    7be0:	4618      	mov	r0, r3
    7be2:	b005      	add	sp, #20
    7be4:	f85d fb04 	ldr.w	pc, [sp], #4
    7be8:	000076a9 	.word	0x000076a9

00007bec <osThreadExit>:
  }
  return status;
}

/// Terminate execution of current running thread.
__NO_RETURN void osThreadExit (void) {
    7bec:	b508      	push	{r3, lr}
  EvrRtxThreadExit();
    7bee:	f7fc fc97 	bl	4520 <EvrRtxThreadExit>
SVC0_0N(ThreadExit,          void)
    7bf2:	4b04      	ldr	r3, [pc, #16]	; (7c04 <osThreadExit+0x18>)
    7bf4:	469c      	mov	ip, r3
    7bf6:	df00      	svc	0
  __svcThreadExit();
  EvrRtxThreadError(NULL, (int32_t)osError);
    7bf8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    7bfc:	2000      	movs	r0, #0
    7bfe:	f7fc fc4d 	bl	449c <EvrRtxThreadError>
  for (;;) {}
    7c02:	e7fe      	b.n	7c02 <osThreadExit+0x16>
    7c04:	000077e1 	.word	0x000077e1

00007c08 <osThreadGetCount>:
  }
  return status;
}

/// Get number of active threads.
uint32_t osThreadGetCount (void) {
    7c08:	b500      	push	{lr}
    7c0a:	b083      	sub	sp, #12
  uint32_t count;

  if (IsIrqMode() || IsIrqMasked()) {
    7c0c:	f7fe fef1 	bl	69f2 <IsIrqMode>
    7c10:	4603      	mov	r3, r0
    7c12:	2b00      	cmp	r3, #0
    7c14:	d104      	bne.n	7c20 <osThreadGetCount+0x18>
    7c16:	f7fe fef9 	bl	6a0c <IsIrqMasked>
    7c1a:	4603      	mov	r3, r0
    7c1c:	2b00      	cmp	r3, #0
    7c1e:	d005      	beq.n	7c2c <osThreadGetCount+0x24>
    EvrRtxThreadGetCount(0U);
    7c20:	2000      	movs	r0, #0
    7c22:	f7fc fd89 	bl	4738 <EvrRtxThreadGetCount>
    count = 0U;
    7c26:	2300      	movs	r3, #0
    7c28:	9301      	str	r3, [sp, #4]
    7c2a:	e004      	b.n	7c36 <osThreadGetCount+0x2e>
SVC0_0 (ThreadGetCount,      uint32_t)
    7c2c:	4b04      	ldr	r3, [pc, #16]	; (7c40 <osThreadGetCount+0x38>)
    7c2e:	469c      	mov	ip, r3
    7c30:	df00      	svc	0
    7c32:	4603      	mov	r3, r0
  } else {
    count = __svcThreadGetCount();
    7c34:	9301      	str	r3, [sp, #4]
  }
  return count;
    7c36:	9b01      	ldr	r3, [sp, #4]
}
    7c38:	4618      	mov	r0, r3
    7c3a:	b003      	add	sp, #12
    7c3c:	f85d fb04 	ldr.w	pc, [sp], #4
    7c40:	000078ad 	.word	0x000078ad

00007c44 <osThreadEnumerate>:

/// Enumerate active threads.
uint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items) {
    7c44:	b500      	push	{lr}
    7c46:	b087      	sub	sp, #28
    7c48:	9001      	str	r0, [sp, #4]
    7c4a:	9100      	str	r1, [sp, #0]
  uint32_t count;

  if (IsIrqMode() || IsIrqMasked()) {
    7c4c:	f7fe fed1 	bl	69f2 <IsIrqMode>
    7c50:	4603      	mov	r3, r0
    7c52:	2b00      	cmp	r3, #0
    7c54:	d104      	bne.n	7c60 <osThreadEnumerate+0x1c>
    7c56:	f7fe fed9 	bl	6a0c <IsIrqMasked>
    7c5a:	4603      	mov	r3, r0
    7c5c:	2b00      	cmp	r3, #0
    7c5e:	d007      	beq.n	7c70 <osThreadEnumerate+0x2c>
    EvrRtxThreadEnumerate(thread_array, array_items, 0U);
    7c60:	2200      	movs	r2, #0
    7c62:	9900      	ldr	r1, [sp, #0]
    7c64:	9801      	ldr	r0, [sp, #4]
    7c66:	f7fc fd6c 	bl	4742 <EvrRtxThreadEnumerate>
    count = 0U;
    7c6a:	2300      	movs	r3, #0
    7c6c:	9305      	str	r3, [sp, #20]
    7c6e:	e00b      	b.n	7c88 <osThreadEnumerate+0x44>
    7c70:	9b01      	ldr	r3, [sp, #4]
    7c72:	9304      	str	r3, [sp, #16]
    7c74:	9b00      	ldr	r3, [sp, #0]
    7c76:	9303      	str	r3, [sp, #12]
SVC0_2 (ThreadEnumerate,     uint32_t,        osThreadId_t *, uint32_t)
    7c78:	9b04      	ldr	r3, [sp, #16]
    7c7a:	4618      	mov	r0, r3
    7c7c:	9903      	ldr	r1, [sp, #12]
    7c7e:	4b05      	ldr	r3, [pc, #20]	; (7c94 <osThreadEnumerate+0x50>)
    7c80:	469c      	mov	ip, r3
    7c82:	df00      	svc	0
    7c84:	4603      	mov	r3, r0
  } else {
    count = __svcThreadEnumerate(thread_array, array_items);
    7c86:	9305      	str	r3, [sp, #20]
  }
  return count;
    7c88:	9b05      	ldr	r3, [sp, #20]
}
    7c8a:	4618      	mov	r0, r3
    7c8c:	b007      	add	sp, #28
    7c8e:	f85d fb04 	ldr.w	pc, [sp], #4
    7c92:	bf00      	nop
    7c94:	00007919 	.word	0x00007919

00007c98 <osRtxMessageQueueId>:
__STATIC_INLINE os_message_queue_t *osRtxMessageQueueId (osMessageQueueId_t mq_id) {
    7c98:	b082      	sub	sp, #8
    7c9a:	9001      	str	r0, [sp, #4]
  return ((os_message_queue_t *)mq_id);
    7c9c:	9b01      	ldr	r3, [sp, #4]
}
    7c9e:	4618      	mov	r0, r3
    7ca0:	b002      	add	sp, #8
    7ca2:	4770      	bx	lr

00007ca4 <TimerInsert>:
//  ==== Helper functions ====

/// Insert Timer into the Timer List sorted by Time.
/// \param[in]  timer           timer object.
/// \param[in]  tick            timer tick.
static void TimerInsert (os_timer_t *timer, uint32_t tick) {
    7ca4:	b084      	sub	sp, #16
    7ca6:	9001      	str	r0, [sp, #4]
    7ca8:	9100      	str	r1, [sp, #0]
  os_timer_t *prev, *next;

  prev = NULL;
    7caa:	2300      	movs	r3, #0
    7cac:	9303      	str	r3, [sp, #12]
  next = osRtxInfo.timer.list;
    7cae:	4b1c      	ldr	r3, [pc, #112]	; (7d20 <TimerInsert+0x7c>)
    7cb0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    7cb2:	9302      	str	r3, [sp, #8]
  while ((next != NULL) && (next->tick <= tick)) {
    7cb4:	e009      	b.n	7cca <TimerInsert+0x26>
    tick -= next->tick;
    7cb6:	9b02      	ldr	r3, [sp, #8]
    7cb8:	691b      	ldr	r3, [r3, #16]
    7cba:	9a00      	ldr	r2, [sp, #0]
    7cbc:	1ad3      	subs	r3, r2, r3
    7cbe:	9300      	str	r3, [sp, #0]
    prev  = next;
    7cc0:	9b02      	ldr	r3, [sp, #8]
    7cc2:	9303      	str	r3, [sp, #12]
    next  = next->next;
    7cc4:	9b02      	ldr	r3, [sp, #8]
    7cc6:	68db      	ldr	r3, [r3, #12]
    7cc8:	9302      	str	r3, [sp, #8]
  while ((next != NULL) && (next->tick <= tick)) {
    7cca:	9b02      	ldr	r3, [sp, #8]
    7ccc:	2b00      	cmp	r3, #0
    7cce:	d004      	beq.n	7cda <TimerInsert+0x36>
    7cd0:	9b02      	ldr	r3, [sp, #8]
    7cd2:	691a      	ldr	r2, [r3, #16]
    7cd4:	9b00      	ldr	r3, [sp, #0]
    7cd6:	429a      	cmp	r2, r3
    7cd8:	d9ed      	bls.n	7cb6 <TimerInsert+0x12>
  }
  timer->tick = tick;
    7cda:	9b01      	ldr	r3, [sp, #4]
    7cdc:	9a00      	ldr	r2, [sp, #0]
    7cde:	611a      	str	r2, [r3, #16]
  timer->prev = prev;
    7ce0:	9b01      	ldr	r3, [sp, #4]
    7ce2:	9a03      	ldr	r2, [sp, #12]
    7ce4:	609a      	str	r2, [r3, #8]
  timer->next = next;
    7ce6:	9b01      	ldr	r3, [sp, #4]
    7ce8:	9a02      	ldr	r2, [sp, #8]
    7cea:	60da      	str	r2, [r3, #12]
  if (next != NULL) {
    7cec:	9b02      	ldr	r3, [sp, #8]
    7cee:	2b00      	cmp	r3, #0
    7cf0:	d009      	beq.n	7d06 <TimerInsert+0x62>
    next->tick -= timer->tick;
    7cf2:	9b02      	ldr	r3, [sp, #8]
    7cf4:	691a      	ldr	r2, [r3, #16]
    7cf6:	9b01      	ldr	r3, [sp, #4]
    7cf8:	691b      	ldr	r3, [r3, #16]
    7cfa:	1ad2      	subs	r2, r2, r3
    7cfc:	9b02      	ldr	r3, [sp, #8]
    7cfe:	611a      	str	r2, [r3, #16]
    next->prev  = timer;
    7d00:	9b02      	ldr	r3, [sp, #8]
    7d02:	9a01      	ldr	r2, [sp, #4]
    7d04:	609a      	str	r2, [r3, #8]
  }
  if (prev != NULL) {
    7d06:	9b03      	ldr	r3, [sp, #12]
    7d08:	2b00      	cmp	r3, #0
    7d0a:	d003      	beq.n	7d14 <TimerInsert+0x70>
    prev->next = timer;
    7d0c:	9b03      	ldr	r3, [sp, #12]
    7d0e:	9a01      	ldr	r2, [sp, #4]
    7d10:	60da      	str	r2, [r3, #12]
  } else {
    osRtxInfo.timer.list = timer;
  }
}
    7d12:	e002      	b.n	7d1a <TimerInsert+0x76>
    osRtxInfo.timer.list = timer;
    7d14:	4a02      	ldr	r2, [pc, #8]	; (7d20 <TimerInsert+0x7c>)
    7d16:	9b01      	ldr	r3, [sp, #4]
    7d18:	6453      	str	r3, [r2, #68]	; 0x44
}
    7d1a:	bf00      	nop
    7d1c:	b004      	add	sp, #16
    7d1e:	4770      	bx	lr
    7d20:	20000110 	.word	0x20000110

00007d24 <TimerUnlink>:
  }
}

/// Unlink Timer from the Timer List Head.
/// \param[in]  timer           timer object.
static void TimerUnlink (const os_timer_t *timer) {
    7d24:	b082      	sub	sp, #8
    7d26:	9001      	str	r0, [sp, #4]

  if (timer->next != NULL) {
    7d28:	9b01      	ldr	r3, [sp, #4]
    7d2a:	68db      	ldr	r3, [r3, #12]
    7d2c:	2b00      	cmp	r3, #0
    7d2e:	d004      	beq.n	7d3a <TimerUnlink+0x16>
    timer->next->prev = timer->prev;
    7d30:	9b01      	ldr	r3, [sp, #4]
    7d32:	68db      	ldr	r3, [r3, #12]
    7d34:	9a01      	ldr	r2, [sp, #4]
    7d36:	6892      	ldr	r2, [r2, #8]
    7d38:	609a      	str	r2, [r3, #8]
  }
  osRtxInfo.timer.list = timer->next;
    7d3a:	9b01      	ldr	r3, [sp, #4]
    7d3c:	68db      	ldr	r3, [r3, #12]
    7d3e:	4a02      	ldr	r2, [pc, #8]	; (7d48 <TimerUnlink+0x24>)
    7d40:	6453      	str	r3, [r2, #68]	; 0x44
}
    7d42:	bf00      	nop
    7d44:	b002      	add	sp, #8
    7d46:	4770      	bx	lr
    7d48:	20000110 	.word	0x20000110

00007d4c <osRtxTimerTick>:


//  ==== Library functions ====

/// Timer Tick (called each SysTick).
static void osRtxTimerTick (void) {
    7d4c:	b500      	push	{lr}
    7d4e:	b083      	sub	sp, #12
  os_timer_t *timer;
  osStatus_t  status;

  timer = osRtxInfo.timer.list;
    7d50:	4b1e      	ldr	r3, [pc, #120]	; (7dcc <osRtxTimerTick+0x80>)
    7d52:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    7d54:	9301      	str	r3, [sp, #4]
  if (timer == NULL) {
    7d56:	9b01      	ldr	r3, [sp, #4]
    7d58:	2b00      	cmp	r3, #0
    7d5a:	d032      	beq.n	7dc2 <osRtxTimerTick+0x76>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }

  timer->tick--;
    7d5c:	9b01      	ldr	r3, [sp, #4]
    7d5e:	691b      	ldr	r3, [r3, #16]
    7d60:	1e5a      	subs	r2, r3, #1
    7d62:	9b01      	ldr	r3, [sp, #4]
    7d64:	611a      	str	r2, [r3, #16]
  while ((timer != NULL) && (timer->tick == 0U)) {
    7d66:	e024      	b.n	7db2 <osRtxTimerTick+0x66>
    TimerUnlink(timer);
    7d68:	9801      	ldr	r0, [sp, #4]
    7d6a:	f7ff ffdb 	bl	7d24 <TimerUnlink>
    status = osMessageQueuePut(osRtxInfo.timer.mq, &timer->finfo, 0U, 0U);
    7d6e:	4b17      	ldr	r3, [pc, #92]	; (7dcc <osRtxTimerTick+0x80>)
    7d70:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
    7d72:	9b01      	ldr	r3, [sp, #4]
    7d74:	f103 0118 	add.w	r1, r3, #24
    7d78:	2300      	movs	r3, #0
    7d7a:	2200      	movs	r2, #0
    7d7c:	f7fe f8da 	bl	5f34 <osMessageQueuePut>
    7d80:	9000      	str	r0, [sp, #0]
    if (status != osOK) {
    7d82:	9b00      	ldr	r3, [sp, #0]
    7d84:	2b00      	cmp	r3, #0
    7d86:	d003      	beq.n	7d90 <osRtxTimerTick+0x44>
      (void)osRtxErrorNotify(osRtxErrorTimerQueueOverflow, timer);
    7d88:	9901      	ldr	r1, [sp, #4]
    7d8a:	2003      	movs	r0, #3
    7d8c:	f7fc fad6 	bl	433c <osRtxErrorNotify>
    }
    if (timer->type == osRtxTimerPeriodic) {
    7d90:	9b01      	ldr	r3, [sp, #4]
    7d92:	78db      	ldrb	r3, [r3, #3]
    7d94:	2b01      	cmp	r3, #1
    7d96:	d106      	bne.n	7da6 <osRtxTimerTick+0x5a>
      TimerInsert(timer, timer->load);
    7d98:	9b01      	ldr	r3, [sp, #4]
    7d9a:	695b      	ldr	r3, [r3, #20]
    7d9c:	4619      	mov	r1, r3
    7d9e:	9801      	ldr	r0, [sp, #4]
    7da0:	f7ff ff80 	bl	7ca4 <TimerInsert>
    7da4:	e002      	b.n	7dac <osRtxTimerTick+0x60>
    } else {
      timer->state = osRtxTimerStopped;
    7da6:	9b01      	ldr	r3, [sp, #4]
    7da8:	2201      	movs	r2, #1
    7daa:	705a      	strb	r2, [r3, #1]
    }
    timer = osRtxInfo.timer.list;
    7dac:	4b07      	ldr	r3, [pc, #28]	; (7dcc <osRtxTimerTick+0x80>)
    7dae:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    7db0:	9301      	str	r3, [sp, #4]
  while ((timer != NULL) && (timer->tick == 0U)) {
    7db2:	9b01      	ldr	r3, [sp, #4]
    7db4:	2b00      	cmp	r3, #0
    7db6:	d005      	beq.n	7dc4 <osRtxTimerTick+0x78>
    7db8:	9b01      	ldr	r3, [sp, #4]
    7dba:	691b      	ldr	r3, [r3, #16]
    7dbc:	2b00      	cmp	r3, #0
    7dbe:	d0d3      	beq.n	7d68 <osRtxTimerTick+0x1c>
    7dc0:	e000      	b.n	7dc4 <osRtxTimerTick+0x78>
    return;
    7dc2:	bf00      	nop
  }
}
    7dc4:	b003      	add	sp, #12
    7dc6:	f85d fb04 	ldr.w	pc, [sp], #4
    7dca:	bf00      	nop
    7dcc:	20000110 	.word	0x20000110

00007dd0 <osRtxTimerThread>:

/// Timer Thread
__WEAK void osRtxTimerThread (void *argument) {
    7dd0:	b500      	push	{lr}
    7dd2:	b087      	sub	sp, #28
    7dd4:	9001      	str	r0, [sp, #4]
  os_timer_finfo_t finfo;
  osStatus_t       status;
  (void)           argument;

  osRtxInfo.timer.mq = osRtxMessageQueueId(
    7dd6:	4b18      	ldr	r3, [pc, #96]	; (7e38 <osRtxTimerThread+0x68>)
    7dd8:	6e58      	ldr	r0, [r3, #100]	; 0x64
    7dda:	4b17      	ldr	r3, [pc, #92]	; (7e38 <osRtxTimerThread+0x68>)
    7ddc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    7dde:	461a      	mov	r2, r3
    7de0:	2108      	movs	r1, #8
    7de2:	f7fe f875 	bl	5ed0 <osMessageQueueNew>
    7de6:	4603      	mov	r3, r0
    7de8:	4618      	mov	r0, r3
    7dea:	f7ff ff55 	bl	7c98 <osRtxMessageQueueId>
    7dee:	4602      	mov	r2, r0
    7df0:	4b12      	ldr	r3, [pc, #72]	; (7e3c <osRtxTimerThread+0x6c>)
    7df2:	64da      	str	r2, [r3, #76]	; 0x4c
    osMessageQueueNew(osRtxConfig.timer_mq_mcnt, sizeof(os_timer_finfo_t), osRtxConfig.timer_mq_attr)
  );
  if (osRtxInfo.timer.mq == NULL) {
    7df4:	4b11      	ldr	r3, [pc, #68]	; (7e3c <osRtxTimerThread+0x6c>)
    7df6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    7df8:	2b00      	cmp	r3, #0
    7dfa:	d019      	beq.n	7e30 <osRtxTimerThread+0x60>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }
  osRtxInfo.timer.tick = osRtxTimerTick;
    7dfc:	4b0f      	ldr	r3, [pc, #60]	; (7e3c <osRtxTimerThread+0x6c>)
    7dfe:	4a10      	ldr	r2, [pc, #64]	; (7e40 <osRtxTimerThread+0x70>)
    7e00:	651a      	str	r2, [r3, #80]	; 0x50
  for (;;) {
    //lint -e{934} "Taking address of near auto variable"
    status = osMessageQueueGet(osRtxInfo.timer.mq, &finfo, NULL, osWaitForever);
    7e02:	4b0e      	ldr	r3, [pc, #56]	; (7e3c <osRtxTimerThread+0x6c>)
    7e04:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
    7e06:	a903      	add	r1, sp, #12
    7e08:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    7e0c:	2200      	movs	r2, #0
    7e0e:	f7fe f8d1 	bl	5fb4 <osMessageQueueGet>
    7e12:	9005      	str	r0, [sp, #20]
    if (status == osOK) {
    7e14:	9b05      	ldr	r3, [sp, #20]
    7e16:	2b00      	cmp	r3, #0
    7e18:	d1f3      	bne.n	7e02 <osRtxTimerThread+0x32>
      EvrRtxTimerCallback(finfo.func, finfo.arg);
    7e1a:	9b03      	ldr	r3, [sp, #12]
    7e1c:	9a04      	ldr	r2, [sp, #16]
    7e1e:	4611      	mov	r1, r2
    7e20:	4618      	mov	r0, r3
    7e22:	f7fc fca5 	bl	4770 <EvrRtxTimerCallback>
      (finfo.func)(finfo.arg);
    7e26:	9b03      	ldr	r3, [sp, #12]
    7e28:	9a04      	ldr	r2, [sp, #16]
    7e2a:	4610      	mov	r0, r2
    7e2c:	4798      	blx	r3
    status = osMessageQueueGet(osRtxInfo.timer.mq, &finfo, NULL, osWaitForever);
    7e2e:	e7e8      	b.n	7e02 <osRtxTimerThread+0x32>
    return;
    7e30:	bf00      	nop
    }
  }
}
    7e32:	b007      	add	sp, #28
    7e34:	f85d fb04 	ldr.w	pc, [sp], #4
    7e38:	0001148c 	.word	0x0001148c
    7e3c:	20000110 	.word	0x20000110
    7e40:	00007d4d 	.word	0x00007d4d

00007e44 <OS_Tick_Setup>:
#endif

static uint8_t PendST;

// Setup OS Tick.
__WEAK int32_t OS_Tick_Setup (uint32_t freq, IRQHandler_t handler) {
    7e44:	b084      	sub	sp, #16
    7e46:	9001      	str	r0, [sp, #4]
    7e48:	9100      	str	r1, [sp, #0]
  uint32_t load;
  (void)handler;

  if (freq == 0U) {
    7e4a:	9b01      	ldr	r3, [sp, #4]
    7e4c:	2b00      	cmp	r3, #0
    7e4e:	d102      	bne.n	7e56 <OS_Tick_Setup+0x12>
    //lint -e{904} "Return statement before end of function"
    return (-1);
    7e50:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    7e54:	e01e      	b.n	7e94 <OS_Tick_Setup+0x50>
  }

  load = (SystemCoreClock / freq) - 1U;
    7e56:	4b11      	ldr	r3, [pc, #68]	; (7e9c <OS_Tick_Setup+0x58>)
    7e58:	681a      	ldr	r2, [r3, #0]
    7e5a:	9b01      	ldr	r3, [sp, #4]
    7e5c:	fbb2 f3f3 	udiv	r3, r2, r3
    7e60:	3b01      	subs	r3, #1
    7e62:	9303      	str	r3, [sp, #12]
  if (load > 0x00FFFFFFU) {
    7e64:	9b03      	ldr	r3, [sp, #12]
    7e66:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
    7e6a:	d302      	bcc.n	7e72 <OS_Tick_Setup+0x2e>
    //lint -e{904} "Return statement before end of function"
    return (-1);
    7e6c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    7e70:	e010      	b.n	7e94 <OS_Tick_Setup+0x50>
  SCB->SHPR[11] = SYSTICK_IRQ_PRIORITY;
#elif  (defined(__ARM_ARCH_8M_BASE__) && (__ARM_ARCH_8M_BASE__ != 0))
  SCB->SHPR[1] |= ((uint32_t)SYSTICK_IRQ_PRIORITY << 24);
#elif ((defined(__ARM_ARCH_7M__)      && (__ARM_ARCH_7M__      != 0)) || \
       (defined(__ARM_ARCH_7EM__)     && (__ARM_ARCH_7EM__     != 0)))
  SCB->SHP[11]  = SYSTICK_IRQ_PRIORITY;
    7e72:	4b0b      	ldr	r3, [pc, #44]	; (7ea0 <OS_Tick_Setup+0x5c>)
    7e74:	22ff      	movs	r2, #255	; 0xff
    7e76:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
  SCB->SHP[1]  |= ((uint32_t)SYSTICK_IRQ_PRIORITY << 24);
#else
#error "Unknown ARM Core!"
#endif

  SysTick->CTRL =  SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk;
    7e7a:	4b0a      	ldr	r3, [pc, #40]	; (7ea4 <OS_Tick_Setup+0x60>)
    7e7c:	2206      	movs	r2, #6
    7e7e:	601a      	str	r2, [r3, #0]
  SysTick->LOAD =  load;
    7e80:	4a08      	ldr	r2, [pc, #32]	; (7ea4 <OS_Tick_Setup+0x60>)
    7e82:	9b03      	ldr	r3, [sp, #12]
    7e84:	6053      	str	r3, [r2, #4]
  SysTick->VAL  =  0U;
    7e86:	4b07      	ldr	r3, [pc, #28]	; (7ea4 <OS_Tick_Setup+0x60>)
    7e88:	2200      	movs	r2, #0
    7e8a:	609a      	str	r2, [r3, #8]

  PendST = 0U;
    7e8c:	4b06      	ldr	r3, [pc, #24]	; (7ea8 <OS_Tick_Setup+0x64>)
    7e8e:	2200      	movs	r2, #0
    7e90:	701a      	strb	r2, [r3, #0]

  return (0);
    7e92:	2300      	movs	r3, #0
}
    7e94:	4618      	mov	r0, r3
    7e96:	b004      	add	sp, #16
    7e98:	4770      	bx	lr
    7e9a:	bf00      	nop
    7e9c:	200001b4 	.word	0x200001b4
    7ea0:	e000ed00 	.word	0xe000ed00
    7ea4:	e000e010 	.word	0xe000e010
    7ea8:	20001484 	.word	0x20001484

00007eac <OS_Tick_Enable>:

/// Enable OS Tick.
__WEAK void OS_Tick_Enable (void) {

  if (PendST != 0U) {
    7eac:	4b09      	ldr	r3, [pc, #36]	; (7ed4 <OS_Tick_Enable+0x28>)
    7eae:	781b      	ldrb	r3, [r3, #0]
    7eb0:	2b00      	cmp	r3, #0
    7eb2:	d006      	beq.n	7ec2 <OS_Tick_Enable+0x16>
    PendST = 0U;
    7eb4:	4b07      	ldr	r3, [pc, #28]	; (7ed4 <OS_Tick_Enable+0x28>)
    7eb6:	2200      	movs	r2, #0
    7eb8:	701a      	strb	r2, [r3, #0]
    SCB->ICSR = SCB_ICSR_PENDSTSET_Msk;
    7eba:	4b07      	ldr	r3, [pc, #28]	; (7ed8 <OS_Tick_Enable+0x2c>)
    7ebc:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
    7ec0:	605a      	str	r2, [r3, #4]
  }

  SysTick->CTRL |=  SysTick_CTRL_ENABLE_Msk;
    7ec2:	4a06      	ldr	r2, [pc, #24]	; (7edc <OS_Tick_Enable+0x30>)
    7ec4:	4b05      	ldr	r3, [pc, #20]	; (7edc <OS_Tick_Enable+0x30>)
    7ec6:	681b      	ldr	r3, [r3, #0]
    7ec8:	f043 0301 	orr.w	r3, r3, #1
    7ecc:	6013      	str	r3, [r2, #0]
}
    7ece:	bf00      	nop
    7ed0:	4770      	bx	lr
    7ed2:	bf00      	nop
    7ed4:	20001484 	.word	0x20001484
    7ed8:	e000ed00 	.word	0xe000ed00
    7edc:	e000e010 	.word	0xe000e010

00007ee0 <OS_Tick_AcknowledgeIRQ>:
  }
}

// Acknowledge OS Tick IRQ.
__WEAK void OS_Tick_AcknowledgeIRQ (void) {
  (void)SysTick->CTRL;
    7ee0:	4b01      	ldr	r3, [pc, #4]	; (7ee8 <OS_Tick_AcknowledgeIRQ+0x8>)
    7ee2:	681b      	ldr	r3, [r3, #0]
}
    7ee4:	bf00      	nop
    7ee6:	4770      	bx	lr
    7ee8:	e000e010 	.word	0xe000e010

00007eec <OS_Tick_GetIRQn>:

// Get OS Tick IRQ number.
__WEAK int32_t  OS_Tick_GetIRQn (void) {
  return ((int32_t)SysTick_IRQn);
    7eec:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
    7ef0:	4618      	mov	r0, r3
    7ef2:	4770      	bx	lr

00007ef4 <thread_terminate_hook>:
MBED_STATIC_ASSERT(ALIGN_DOWN(7, 8) == 0, "ALIGN_DOWN macro error");
MBED_STATIC_ASSERT(ALIGN_DOWN(8, 8) == 8, "ALIGN_DOWN macro error");

static void (*terminate_hook)(osThreadId_t id) = 0;
extern "C" void thread_terminate_hook(osThreadId_t id)
{
    7ef4:	b500      	push	{lr}
    7ef6:	b083      	sub	sp, #12
    7ef8:	9001      	str	r0, [sp, #4]
    if (terminate_hook != (void (*)(osThreadId_t))NULL) {
    7efa:	4b06      	ldr	r3, [pc, #24]	; (7f14 <thread_terminate_hook+0x20>)
    7efc:	681b      	ldr	r3, [r3, #0]
    7efe:	2b00      	cmp	r3, #0
    7f00:	d003      	beq.n	7f0a <thread_terminate_hook+0x16>
        terminate_hook(id);
    7f02:	4b04      	ldr	r3, [pc, #16]	; (7f14 <thread_terminate_hook+0x20>)
    7f04:	681b      	ldr	r3, [r3, #0]
    7f06:	9801      	ldr	r0, [sp, #4]
    7f08:	4798      	blx	r3
    }
}
    7f0a:	bf00      	nop
    7f0c:	b003      	add	sp, #12
    7f0e:	f85d fb04 	ldr.w	pc, [sp], #4
    7f12:	bf00      	nop
    7f14:	20001488 	.word	0x20001488

00007f18 <_ZN4rtos6Thread4waitEm>:
    }

    return evt;
}

osStatus Thread::wait(uint32_t millisec) {
    7f18:	b500      	push	{lr}
    7f1a:	b083      	sub	sp, #12
    7f1c:	9001      	str	r0, [sp, #4]
    return osDelay(millisec);
    7f1e:	9801      	ldr	r0, [sp, #4]
    7f20:	f7fc fb5e 	bl	45e0 <osDelay>
    7f24:	4603      	mov	r3, r0
}
    7f26:	4618      	mov	r0, r3
    7f28:	b003      	add	sp, #12
    7f2a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00007f30 <CLOCK_SetSimSafeDivs>:
 *
 * @param config Pointer to the configure structure.
 */
static inline void CLOCK_SetSimSafeDivs(void)
{
    __FSL_CLOCK_SECURE_WRITE(&SIM->CLKDIV1, 0x01240000UL);
    7f30:	4b02      	ldr	r3, [pc, #8]	; (7f3c <CLOCK_SetSimSafeDivs+0xc>)
    7f32:	f04f 7292 	mov.w	r2, #19136512	; 0x1240000
    7f36:	601a      	str	r2, [r3, #0]
}
    7f38:	bf00      	nop
    7f3a:	4770      	bx	lr
    7f3c:	40048044 	.word	0x40048044

00007f40 <CLOCK_SetXtal0Freq>:
 * @brief Sets the XTAL0 frequency based on board settings.
 *
 * @param freq The XTAL0/EXTAL0 input clock frequency in Hz.
 */
static inline void CLOCK_SetXtal0Freq(uint32_t freq)
{
    7f40:	b082      	sub	sp, #8
    7f42:	9001      	str	r0, [sp, #4]
    g_xtal0Freq = freq;
    7f44:	4a02      	ldr	r2, [pc, #8]	; (7f50 <CLOCK_SetXtal0Freq+0x10>)
    7f46:	9b01      	ldr	r3, [sp, #4]
    7f48:	6013      	str	r3, [r2, #0]
}
    7f4a:	bf00      	nop
    7f4c:	b002      	add	sp, #8
    7f4e:	4770      	bx	lr
    7f50:	20002f60 	.word	0x20002f60

00007f54 <BOARD_BootClockRUN>:
    {
    }
}

void BOARD_BootClockRUN(void)
{
    7f54:	b508      	push	{r3, lr}
    CLOCK_SetSimSafeDivs();
    7f56:	f7ff ffeb 	bl	7f30 <CLOCK_SetSimSafeDivs>

    CLOCK_InitOsc0(&g_defaultClockConfigRun.oscConfig);
    7f5a:	480d      	ldr	r0, [pc, #52]	; (7f90 <BOARD_BootClockRUN+0x3c>)
    7f5c:	f000 fcfc 	bl	8958 <CLOCK_InitOsc0>
    CLOCK_SetXtal0Freq(BOARD_XTAL0_CLK_HZ);
    7f60:	480c      	ldr	r0, [pc, #48]	; (7f94 <BOARD_BootClockRUN+0x40>)
    7f62:	f7ff ffed 	bl	7f40 <CLOCK_SetXtal0Freq>

    CLOCK_BootToPeeMode(g_defaultClockConfigRun.mcgConfig.oscsel, kMCG_PllClkSelPll0,
    7f66:	2300      	movs	r3, #0
    7f68:	4a0b      	ldr	r2, [pc, #44]	; (7f98 <BOARD_BootClockRUN+0x44>)
    7f6a:	2100      	movs	r1, #0
    7f6c:	4618      	mov	r0, r3
    7f6e:	f000 fd9f 	bl	8ab0 <CLOCK_BootToPeeMode>
                        &g_defaultClockConfigRun.mcgConfig.pll0Config);

    CLOCK_SetInternalRefClkConfig(g_defaultClockConfigRun.mcgConfig.irclkEnableMode,
    7f72:	2302      	movs	r3, #2
    7f74:	2100      	movs	r1, #0
    7f76:	2200      	movs	r2, #0
    7f78:	4618      	mov	r0, r3
    7f7a:	f000 fc09 	bl	8790 <CLOCK_SetInternalRefClkConfig>
                                  g_defaultClockConfigRun.mcgConfig.ircs, g_defaultClockConfigRun.mcgConfig.fcrdiv);

    CLOCK_SetSimConfig(&g_defaultClockConfigRun.simConfig);
    7f7e:	4807      	ldr	r0, [pc, #28]	; (7f9c <BOARD_BootClockRUN+0x48>)
    7f80:	f000 fac4 	bl	850c <CLOCK_SetSimConfig>

    SystemCoreClock = g_defaultClockConfigRun.coreClock;
    7f84:	4a06      	ldr	r2, [pc, #24]	; (7fa0 <BOARD_BootClockRUN+0x4c>)
    7f86:	4b07      	ldr	r3, [pc, #28]	; (7fa4 <BOARD_BootClockRUN+0x50>)
    7f88:	601a      	str	r2, [r3, #0]
}
    7f8a:	bf00      	nop
    7f8c:	bd08      	pop	{r3, pc}
    7f8e:	bf00      	nop
    7f90:	00012764 	.word	0x00012764
    7f94:	02faf080 	.word	0x02faf080
    7f98:	00012758 	.word	0x00012758
    7f9c:	0001275c 	.word	0x0001275c
    7fa0:	07270e00 	.word	0x07270e00
    7fa4:	200001b4 	.word	0x200001b4

00007fa8 <mbed_sdk_init>:
#include "crc.h"
#include "fsl_clock_config.h"

// called before main
void mbed_sdk_init()
{
    7fa8:	b508      	push	{r3, lr}
    BOARD_BootClockRUN();
    7faa:	f7ff ffd3 	bl	7f54 <BOARD_BootClockRUN>
}
    7fae:	bf00      	nop
    7fb0:	bd08      	pop	{r3, pc}

00007fb2 <NMI_Handler>:

// Change the NMI pin to an input. This allows NMI pin to
//  be used as a low power mode wakeup.  The application will
//  need to change the pin back to NMI_b or wakeup only occurs once!
void NMI_Handler(void)
{
    7fb2:	b500      	push	{lr}
    7fb4:	b083      	sub	sp, #12
    gpio_t gpio;
    gpio_init_in(&gpio, PTA4);
    7fb6:	ab01      	add	r3, sp, #4
    7fb8:	2104      	movs	r1, #4
    7fba:	4618      	mov	r0, r3
    7fbc:	f7f9 fe7d 	bl	1cba <gpio_init_in>
}
    7fc0:	bf00      	nop
    7fc2:	b003      	add	sp, #12
    7fc4:	f85d fb04 	ldr.w	pc, [sp], #4

00007fc8 <SystemInit>:
   -- SystemInit()
   ---------------------------------------------------------------------------- */

void SystemInit (void) {
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) | (3UL << 11*2));    /* set CP10, CP11 Full Access */
    7fc8:	4a0a      	ldr	r2, [pc, #40]	; (7ff4 <SystemInit+0x2c>)
    7fca:	4b0a      	ldr	r3, [pc, #40]	; (7ff4 <SystemInit+0x2c>)
    7fcc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    7fd0:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
    7fd4:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
#endif /* ((__FPU_PRESENT == 1) && (__FPU_USED == 1)) */
#if (DISABLE_WDOG)
  /* WDOG->UNLOCK: WDOGUNLOCK=0xC520 */
  WDOG->UNLOCK = WDOG_UNLOCK_WDOGUNLOCK(0xC520); /* Key 1 */
    7fd8:	4b07      	ldr	r3, [pc, #28]	; (7ff8 <SystemInit+0x30>)
    7fda:	f24c 5220 	movw	r2, #50464	; 0xc520
    7fde:	81da      	strh	r2, [r3, #14]
  /* WDOG->UNLOCK: WDOGUNLOCK=0xD928 */
  WDOG->UNLOCK = WDOG_UNLOCK_WDOGUNLOCK(0xD928); /* Key 2 */
    7fe0:	4b05      	ldr	r3, [pc, #20]	; (7ff8 <SystemInit+0x30>)
    7fe2:	f64d 1228 	movw	r2, #55592	; 0xd928
    7fe6:	81da      	strh	r2, [r3, #14]
  /* WDOG->STCTRLH: ?=0,DISTESTWDOG=0,BYTESEL=0,TESTSEL=0,TESTWDOG=0,?=0,?=1,WAITEN=1,STOPEN=1,DBGEN=0,ALLOWUPDATE=1,WINEN=0,IRQRSTEN=0,CLKSRC=1,WDOGEN=0 */
  WDOG->STCTRLH = WDOG_STCTRLH_BYTESEL(0x00) |
    7fe8:	4b03      	ldr	r3, [pc, #12]	; (7ff8 <SystemInit+0x30>)
    7fea:	f44f 72e9 	mov.w	r2, #466	; 0x1d2
    7fee:	801a      	strh	r2, [r3, #0]
                 WDOG_STCTRLH_ALLOWUPDATE_MASK |
                 WDOG_STCTRLH_CLKSRC_MASK |
                 0x0100U;
#endif /* (DISABLE_WDOG) */

}
    7ff0:	bf00      	nop
    7ff2:	4770      	bx	lr
    7ff4:	e000ed00 	.word	0xe000ed00
    7ff8:	40052000 	.word	0x40052000

00007ffc <CLOCK_SetEr32kClock>:
{
    7ffc:	b082      	sub	sp, #8
    7ffe:	9001      	str	r0, [sp, #4]
    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&SIM->SOPT1, SIM_SOPT1_OSC32KSEL_MASK, SIM_SOPT1_OSC32KSEL(src));
    8000:	4906      	ldr	r1, [pc, #24]	; (801c <CLOCK_SetEr32kClock+0x20>)
    8002:	4b06      	ldr	r3, [pc, #24]	; (801c <CLOCK_SetEr32kClock+0x20>)
    8004:	681b      	ldr	r3, [r3, #0]
    8006:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
    800a:	9b01      	ldr	r3, [sp, #4]
    800c:	049b      	lsls	r3, r3, #18
    800e:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
    8012:	4313      	orrs	r3, r2
    8014:	600b      	str	r3, [r1, #0]
}
    8016:	bf00      	nop
    8018:	b002      	add	sp, #8
    801a:	4770      	bx	lr
    801c:	40047000 	.word	0x40047000

00008020 <CLOCK_SetPllFllSelClock>:
{
    8020:	b082      	sub	sp, #8
    8022:	9001      	str	r0, [sp, #4]
    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&SIM->SOPT2, SIM_SOPT2_PLLFLLSEL_MASK, SIM_SOPT2_PLLFLLSEL(src));
    8024:	4906      	ldr	r1, [pc, #24]	; (8040 <CLOCK_SetPllFllSelClock+0x20>)
    8026:	4b06      	ldr	r3, [pc, #24]	; (8040 <CLOCK_SetPllFllSelClock+0x20>)
    8028:	681b      	ldr	r3, [r3, #0]
    802a:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
    802e:	9b01      	ldr	r3, [sp, #4]
    8030:	041b      	lsls	r3, r3, #16
    8032:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
    8036:	4313      	orrs	r3, r2
    8038:	600b      	str	r3, [r1, #0]
}
    803a:	bf00      	nop
    803c:	b002      	add	sp, #8
    803e:	4770      	bx	lr
    8040:	40048004 	.word	0x40048004

00008044 <OSC_SetExtRefClkConfig>:
{
    8044:	b084      	sub	sp, #16
    8046:	9001      	str	r0, [sp, #4]
    8048:	9100      	str	r1, [sp, #0]
    uint8_t reg = base->CR;
    804a:	9b01      	ldr	r3, [sp, #4]
    804c:	781b      	ldrb	r3, [r3, #0]
    804e:	f88d 300f 	strb.w	r3, [sp, #15]
    reg &= ~(OSC_CR_ERCLKEN_MASK | OSC_CR_EREFSTEN_MASK);
    8052:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8056:	f003 035f 	and.w	r3, r3, #95	; 0x5f
    805a:	f88d 300f 	strb.w	r3, [sp, #15]
    reg |= config->enableMode;
    805e:	9b00      	ldr	r3, [sp, #0]
    8060:	781a      	ldrb	r2, [r3, #0]
    8062:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8066:	4313      	orrs	r3, r2
    8068:	f88d 300f 	strb.w	r3, [sp, #15]
    base->CR = reg;
    806c:	9b01      	ldr	r3, [sp, #4]
    806e:	f89d 200f 	ldrb.w	r2, [sp, #15]
    8072:	701a      	strb	r2, [r3, #0]
}
    8074:	bf00      	nop
    8076:	b004      	add	sp, #16
    8078:	4770      	bx	lr

0000807a <OSC_SetCapLoad>:
{
    807a:	b084      	sub	sp, #16
    807c:	9001      	str	r0, [sp, #4]
    807e:	460b      	mov	r3, r1
    8080:	f88d 3003 	strb.w	r3, [sp, #3]
    uint8_t reg = base->CR;
    8084:	9b01      	ldr	r3, [sp, #4]
    8086:	781b      	ldrb	r3, [r3, #0]
    8088:	f88d 300f 	strb.w	r3, [sp, #15]
    reg &= ~(OSC_CR_SC2P_MASK | OSC_CR_SC4P_MASK | OSC_CR_SC8P_MASK | OSC_CR_SC16P_MASK);
    808c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8090:	f023 030f 	bic.w	r3, r3, #15
    8094:	f88d 300f 	strb.w	r3, [sp, #15]
    reg |= capLoad;
    8098:	f89d 200f 	ldrb.w	r2, [sp, #15]
    809c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    80a0:	4313      	orrs	r3, r2
    80a2:	f88d 300f 	strb.w	r3, [sp, #15]
    base->CR = reg;
    80a6:	9b01      	ldr	r3, [sp, #4]
    80a8:	f89d 200f 	ldrb.w	r2, [sp, #15]
    80ac:	701a      	strb	r2, [r3, #0]
}
    80ae:	bf00      	nop
    80b0:	b004      	add	sp, #16
    80b2:	4770      	bx	lr

000080b4 <CLOCK_GetMcgExtClkFreq>:
/*******************************************************************************
 * Code
 ******************************************************************************/

static uint32_t CLOCK_GetMcgExtClkFreq(void)
{
    80b4:	b500      	push	{lr}
    80b6:	b083      	sub	sp, #12
    uint32_t freq;

    switch (MCG_C7_OSCSEL_VAL)
    80b8:	4b19      	ldr	r3, [pc, #100]	; (8120 <CLOCK_GetMcgExtClkFreq+0x6c>)
    80ba:	781b      	ldrb	r3, [r3, #0]
    80bc:	b2db      	uxtb	r3, r3
    80be:	f003 0303 	and.w	r3, r3, #3
    80c2:	2b01      	cmp	r3, #1
    80c4:	d012      	beq.n	80ec <CLOCK_GetMcgExtClkFreq+0x38>
    80c6:	2b01      	cmp	r3, #1
    80c8:	d302      	bcc.n	80d0 <CLOCK_GetMcgExtClkFreq+0x1c>
    80ca:	2b02      	cmp	r3, #2
    80cc:	d01c      	beq.n	8108 <CLOCK_GetMcgExtClkFreq+0x54>
    80ce:	e01e      	b.n	810e <CLOCK_GetMcgExtClkFreq+0x5a>
    {
        case 0U:
            /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
            assert(g_xtal0Freq);
    80d0:	4b14      	ldr	r3, [pc, #80]	; (8124 <CLOCK_GetMcgExtClkFreq+0x70>)
    80d2:	681b      	ldr	r3, [r3, #0]
    80d4:	2b00      	cmp	r3, #0
    80d6:	d105      	bne.n	80e4 <CLOCK_GetMcgExtClkFreq+0x30>
    80d8:	4b13      	ldr	r3, [pc, #76]	; (8128 <CLOCK_GetMcgExtClkFreq+0x74>)
    80da:	4a14      	ldr	r2, [pc, #80]	; (812c <CLOCK_GetMcgExtClkFreq+0x78>)
    80dc:	21d4      	movs	r1, #212	; 0xd4
    80de:	4814      	ldr	r0, [pc, #80]	; (8130 <CLOCK_GetMcgExtClkFreq+0x7c>)
    80e0:	f002 f920 	bl	a324 <__assert_func>
            freq = g_xtal0Freq;
    80e4:	4b0f      	ldr	r3, [pc, #60]	; (8124 <CLOCK_GetMcgExtClkFreq+0x70>)
    80e6:	681b      	ldr	r3, [r3, #0]
    80e8:	9301      	str	r3, [sp, #4]
            break;
    80ea:	e013      	b.n	8114 <CLOCK_GetMcgExtClkFreq+0x60>
        case 1U:
            /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN clock. */
            assert(g_xtal32Freq);
    80ec:	4b11      	ldr	r3, [pc, #68]	; (8134 <CLOCK_GetMcgExtClkFreq+0x80>)
    80ee:	681b      	ldr	r3, [r3, #0]
    80f0:	2b00      	cmp	r3, #0
    80f2:	d105      	bne.n	8100 <CLOCK_GetMcgExtClkFreq+0x4c>
    80f4:	4b10      	ldr	r3, [pc, #64]	; (8138 <CLOCK_GetMcgExtClkFreq+0x84>)
    80f6:	4a0d      	ldr	r2, [pc, #52]	; (812c <CLOCK_GetMcgExtClkFreq+0x78>)
    80f8:	21d9      	movs	r1, #217	; 0xd9
    80fa:	480d      	ldr	r0, [pc, #52]	; (8130 <CLOCK_GetMcgExtClkFreq+0x7c>)
    80fc:	f002 f912 	bl	a324 <__assert_func>
            freq = g_xtal32Freq;
    8100:	4b0c      	ldr	r3, [pc, #48]	; (8134 <CLOCK_GetMcgExtClkFreq+0x80>)
    8102:	681b      	ldr	r3, [r3, #0]
    8104:	9301      	str	r3, [sp, #4]
            break;
    8106:	e005      	b.n	8114 <CLOCK_GetMcgExtClkFreq+0x60>
        case 2U:
            freq = MCG_INTERNAL_IRC_48M;
    8108:	4b0c      	ldr	r3, [pc, #48]	; (813c <CLOCK_GetMcgExtClkFreq+0x88>)
    810a:	9301      	str	r3, [sp, #4]
            break;
    810c:	e002      	b.n	8114 <CLOCK_GetMcgExtClkFreq+0x60>
        default:
            freq = 0U;
    810e:	2300      	movs	r3, #0
    8110:	9301      	str	r3, [sp, #4]
            break;
    8112:	bf00      	nop
    }

    return freq;
    8114:	9b01      	ldr	r3, [sp, #4]
}
    8116:	4618      	mov	r0, r3
    8118:	b003      	add	sp, #12
    811a:	f85d fb04 	ldr.w	pc, [sp], #4
    811e:	bf00      	nop
    8120:	4006400c 	.word	0x4006400c
    8124:	20002f60 	.word	0x20002f60
    8128:	0001152c 	.word	0x0001152c
    812c:	00012770 	.word	0x00012770
    8130:	00011538 	.word	0x00011538
    8134:	20002f5c 	.word	0x20002f5c
    8138:	00011598 	.word	0x00011598
    813c:	02dc6c00 	.word	0x02dc6c00

00008140 <CLOCK_GetFllExtRefClkFreq>:

static uint32_t CLOCK_GetFllExtRefClkFreq(void)
{
    8140:	b500      	push	{lr}
    8142:	b083      	sub	sp, #12
    /* FllExtRef = McgExtRef / FllExtRefDiv */
    uint8_t frdiv;
    uint8_t range;
    uint8_t oscsel;

    uint32_t freq = CLOCK_GetMcgExtClkFreq();
    8144:	f7ff ffb6 	bl	80b4 <CLOCK_GetMcgExtClkFreq>
    8148:	9001      	str	r0, [sp, #4]

    if (!freq)
    814a:	9b01      	ldr	r3, [sp, #4]
    814c:	2b00      	cmp	r3, #0
    814e:	d101      	bne.n	8154 <CLOCK_GetFllExtRefClkFreq+0x14>
    {
        return freq;
    8150:	9b01      	ldr	r3, [sp, #4]
    8152:	e057      	b.n	8204 <CLOCK_GetFllExtRefClkFreq+0xc4>
    }

    frdiv = MCG_C1_FRDIV_VAL;
    8154:	4b2d      	ldr	r3, [pc, #180]	; (820c <CLOCK_GetFllExtRefClkFreq+0xcc>)
    8156:	781b      	ldrb	r3, [r3, #0]
    8158:	b2db      	uxtb	r3, r3
    815a:	08db      	lsrs	r3, r3, #3
    815c:	b2db      	uxtb	r3, r3
    815e:	f003 0307 	and.w	r3, r3, #7
    8162:	f88d 3003 	strb.w	r3, [sp, #3]
    freq >>= frdiv;
    8166:	f89d 3003 	ldrb.w	r3, [sp, #3]
    816a:	9a01      	ldr	r2, [sp, #4]
    816c:	fa22 f303 	lsr.w	r3, r2, r3
    8170:	9301      	str	r3, [sp, #4]

    range = MCG_C2_RANGE_VAL;
    8172:	4b27      	ldr	r3, [pc, #156]	; (8210 <CLOCK_GetFllExtRefClkFreq+0xd0>)
    8174:	781b      	ldrb	r3, [r3, #0]
    8176:	b2db      	uxtb	r3, r3
    8178:	091b      	lsrs	r3, r3, #4
    817a:	b2db      	uxtb	r3, r3
    817c:	f003 0303 	and.w	r3, r3, #3
    8180:	f88d 3002 	strb.w	r3, [sp, #2]
    oscsel = MCG_C7_OSCSEL_VAL;
    8184:	4b23      	ldr	r3, [pc, #140]	; (8214 <CLOCK_GetFllExtRefClkFreq+0xd4>)
    8186:	781b      	ldrb	r3, [r3, #0]
    8188:	b2db      	uxtb	r3, r3
    818a:	f003 0303 	and.w	r3, r3, #3
    818e:	f88d 3001 	strb.w	r3, [sp, #1]
    /*
       When should use divider 32, 64, 128, 256, 512, 1024, 1280, 1536.
       1. MCG_C7[OSCSEL] selects IRC48M.
       2. MCG_C7[OSCSEL] selects OSC0 and MCG_C2[RANGE] is not 0.
    */
    if (((0U != range) && (kMCG_OscselOsc == oscsel)) || (kMCG_OscselIrc == oscsel))
    8192:	f89d 3002 	ldrb.w	r3, [sp, #2]
    8196:	2b00      	cmp	r3, #0
    8198:	d003      	beq.n	81a2 <CLOCK_GetFllExtRefClkFreq+0x62>
    819a:	f89d 3001 	ldrb.w	r3, [sp, #1]
    819e:	2b00      	cmp	r3, #0
    81a0:	d003      	beq.n	81aa <CLOCK_GetFllExtRefClkFreq+0x6a>
    81a2:	f89d 3001 	ldrb.w	r3, [sp, #1]
    81a6:	2b02      	cmp	r3, #2
    81a8:	d12b      	bne.n	8202 <CLOCK_GetFllExtRefClkFreq+0xc2>
    {
        switch (frdiv)
    81aa:	f89d 3003 	ldrb.w	r3, [sp, #3]
    81ae:	2b07      	cmp	r3, #7
    81b0:	d824      	bhi.n	81fc <CLOCK_GetFllExtRefClkFreq+0xbc>
    81b2:	a201      	add	r2, pc, #4	; (adr r2, 81b8 <CLOCK_GetFllExtRefClkFreq+0x78>)
    81b4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    81b8:	000081d9 	.word	0x000081d9
    81bc:	000081d9 	.word	0x000081d9
    81c0:	000081d9 	.word	0x000081d9
    81c4:	000081d9 	.word	0x000081d9
    81c8:	000081d9 	.word	0x000081d9
    81cc:	000081d9 	.word	0x000081d9
    81d0:	000081e1 	.word	0x000081e1
    81d4:	000081ef 	.word	0x000081ef
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                freq >>= 5u;
    81d8:	9b01      	ldr	r3, [sp, #4]
    81da:	095b      	lsrs	r3, r3, #5
    81dc:	9301      	str	r3, [sp, #4]
                break;
    81de:	e010      	b.n	8202 <CLOCK_GetFllExtRefClkFreq+0xc2>
            case 6:
                /* 64*20=1280 */
                freq /= 20u;
    81e0:	9b01      	ldr	r3, [sp, #4]
    81e2:	4a0d      	ldr	r2, [pc, #52]	; (8218 <CLOCK_GetFllExtRefClkFreq+0xd8>)
    81e4:	fba2 2303 	umull	r2, r3, r2, r3
    81e8:	091b      	lsrs	r3, r3, #4
    81ea:	9301      	str	r3, [sp, #4]
                break;
    81ec:	e009      	b.n	8202 <CLOCK_GetFllExtRefClkFreq+0xc2>
            case 7:
                /* 128*12=1536 */
                freq /= 12u;
    81ee:	9b01      	ldr	r3, [sp, #4]
    81f0:	4a0a      	ldr	r2, [pc, #40]	; (821c <CLOCK_GetFllExtRefClkFreq+0xdc>)
    81f2:	fba2 2303 	umull	r2, r3, r2, r3
    81f6:	08db      	lsrs	r3, r3, #3
    81f8:	9301      	str	r3, [sp, #4]
                break;
    81fa:	e002      	b.n	8202 <CLOCK_GetFllExtRefClkFreq+0xc2>
            default:
                freq = 0u;
    81fc:	2300      	movs	r3, #0
    81fe:	9301      	str	r3, [sp, #4]
                break;
    8200:	bf00      	nop
        }
    }

    return freq;
    8202:	9b01      	ldr	r3, [sp, #4]
}
    8204:	4618      	mov	r0, r3
    8206:	b003      	add	sp, #12
    8208:	f85d fb04 	ldr.w	pc, [sp], #4
    820c:	40064000 	.word	0x40064000
    8210:	40064001 	.word	0x40064001
    8214:	4006400c 	.word	0x4006400c
    8218:	cccccccd 	.word	0xcccccccd
    821c:	aaaaaaab 	.word	0xaaaaaaab

00008220 <CLOCK_GetInternalRefClkSelectFreq>:

static uint32_t CLOCK_GetInternalRefClkSelectFreq(void)
{
    if (kMCG_IrcSlow == MCG_S_IRCST_VAL)
    8220:	4b0a      	ldr	r3, [pc, #40]	; (824c <CLOCK_GetInternalRefClkSelectFreq+0x2c>)
    8222:	799b      	ldrb	r3, [r3, #6]
    8224:	b2db      	uxtb	r3, r3
    8226:	f003 0301 	and.w	r3, r3, #1
    822a:	2b00      	cmp	r3, #0
    822c:	d102      	bne.n	8234 <CLOCK_GetInternalRefClkSelectFreq+0x14>
    {
        /* Slow internal reference clock selected*/
        return s_slowIrcFreq;
    822e:	4b08      	ldr	r3, [pc, #32]	; (8250 <CLOCK_GetInternalRefClkSelectFreq+0x30>)
    8230:	681b      	ldr	r3, [r3, #0]
    8232:	e009      	b.n	8248 <CLOCK_GetInternalRefClkSelectFreq+0x28>
    }
    else
    {
        /* Fast internal reference clock selected*/
        return s_fastIrcFreq >> MCG_SC_FCRDIV_VAL;
    8234:	4b07      	ldr	r3, [pc, #28]	; (8254 <CLOCK_GetInternalRefClkSelectFreq+0x34>)
    8236:	681a      	ldr	r2, [r3, #0]
    8238:	4b07      	ldr	r3, [pc, #28]	; (8258 <CLOCK_GetInternalRefClkSelectFreq+0x38>)
    823a:	781b      	ldrb	r3, [r3, #0]
    823c:	b2db      	uxtb	r3, r3
    823e:	085b      	lsrs	r3, r3, #1
    8240:	f003 0307 	and.w	r3, r3, #7
    8244:	fa22 f303 	lsr.w	r3, r2, r3
    }
}
    8248:	4618      	mov	r0, r3
    824a:	4770      	bx	lr
    824c:	40064000 	.word	0x40064000
    8250:	200001b8 	.word	0x200001b8
    8254:	200001bc 	.word	0x200001bc
    8258:	40064008 	.word	0x40064008

0000825c <CLOCK_GetFllRefClkFreq>:

static uint32_t CLOCK_GetFllRefClkFreq(void)
{
    825c:	b508      	push	{r3, lr}
    /* If use external reference clock. */
    if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
    825e:	4b07      	ldr	r3, [pc, #28]	; (827c <CLOCK_GetFllRefClkFreq+0x20>)
    8260:	799b      	ldrb	r3, [r3, #6]
    8262:	b2db      	uxtb	r3, r3
    8264:	f003 0310 	and.w	r3, r3, #16
    8268:	2b00      	cmp	r3, #0
    826a:	d103      	bne.n	8274 <CLOCK_GetFllRefClkFreq+0x18>
    {
        return CLOCK_GetFllExtRefClkFreq();
    826c:	f7ff ff68 	bl	8140 <CLOCK_GetFllExtRefClkFreq>
    8270:	4603      	mov	r3, r0
    8272:	e001      	b.n	8278 <CLOCK_GetFllRefClkFreq+0x1c>
    }
    /* If use internal reference clock. */
    else
    {
        return s_slowIrcFreq;
    8274:	4b02      	ldr	r3, [pc, #8]	; (8280 <CLOCK_GetFllRefClkFreq+0x24>)
    8276:	681b      	ldr	r3, [r3, #0]
    }
}
    8278:	4618      	mov	r0, r3
    827a:	bd08      	pop	{r3, pc}
    827c:	40064000 	.word	0x40064000
    8280:	200001b8 	.word	0x200001b8

00008284 <CLOCK_GetPll0RefFreq>:

static uint32_t CLOCK_GetPll0RefFreq(void)
{
    8284:	b508      	push	{r3, lr}
    /* MCG external reference clock. */
    return CLOCK_GetMcgExtClkFreq();
    8286:	f7ff ff15 	bl	80b4 <CLOCK_GetMcgExtClkFreq>
    828a:	4603      	mov	r3, r0
}
    828c:	4618      	mov	r0, r3
    828e:	bd08      	pop	{r3, pc}

00008290 <CLOCK_GetOscRangeFromFreq>:

static uint8_t CLOCK_GetOscRangeFromFreq(uint32_t freq)
{
    8290:	b084      	sub	sp, #16
    8292:	9001      	str	r0, [sp, #4]
    uint8_t range;

    if (freq <= 39063U)
    8294:	9b01      	ldr	r3, [sp, #4]
    8296:	f649 0297 	movw	r2, #39063	; 0x9897
    829a:	4293      	cmp	r3, r2
    829c:	d803      	bhi.n	82a6 <CLOCK_GetOscRangeFromFreq+0x16>
    {
        range = 0U;
    829e:	2300      	movs	r3, #0
    82a0:	f88d 300f 	strb.w	r3, [sp, #15]
    82a4:	e00a      	b.n	82bc <CLOCK_GetOscRangeFromFreq+0x2c>
    }
    else if (freq <= 8000000U)
    82a6:	9b01      	ldr	r3, [sp, #4]
    82a8:	4a07      	ldr	r2, [pc, #28]	; (82c8 <CLOCK_GetOscRangeFromFreq+0x38>)
    82aa:	4293      	cmp	r3, r2
    82ac:	d803      	bhi.n	82b6 <CLOCK_GetOscRangeFromFreq+0x26>
    {
        range = 1U;
    82ae:	2301      	movs	r3, #1
    82b0:	f88d 300f 	strb.w	r3, [sp, #15]
    82b4:	e002      	b.n	82bc <CLOCK_GetOscRangeFromFreq+0x2c>
    }
    else
    {
        range = 2U;
    82b6:	2302      	movs	r3, #2
    82b8:	f88d 300f 	strb.w	r3, [sp, #15]
    }

    return range;
    82bc:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    82c0:	4618      	mov	r0, r3
    82c2:	b004      	add	sp, #16
    82c4:	4770      	bx	lr
    82c6:	bf00      	nop
    82c8:	007a1200 	.word	0x007a1200

000082cc <CLOCK_GetOsc0ErClkFreq>:
        __NOP();
    }
}

uint32_t CLOCK_GetOsc0ErClkFreq(void)
{
    82cc:	b508      	push	{r3, lr}
    if (OSC0->CR & OSC_CR_ERCLKEN_MASK)
    82ce:	4b0b      	ldr	r3, [pc, #44]	; (82fc <CLOCK_GetOsc0ErClkFreq+0x30>)
    82d0:	781b      	ldrb	r3, [r3, #0]
    82d2:	b2db      	uxtb	r3, r3
    82d4:	b25b      	sxtb	r3, r3
    82d6:	2b00      	cmp	r3, #0
    82d8:	da0d      	bge.n	82f6 <CLOCK_GetOsc0ErClkFreq+0x2a>
    {
        /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
        assert(g_xtal0Freq);
    82da:	4b09      	ldr	r3, [pc, #36]	; (8300 <CLOCK_GetOsc0ErClkFreq+0x34>)
    82dc:	681b      	ldr	r3, [r3, #0]
    82de:	2b00      	cmp	r3, #0
    82e0:	d106      	bne.n	82f0 <CLOCK_GetOsc0ErClkFreq+0x24>
    82e2:	4b08      	ldr	r3, [pc, #32]	; (8304 <CLOCK_GetOsc0ErClkFreq+0x38>)
    82e4:	4a08      	ldr	r2, [pc, #32]	; (8308 <CLOCK_GetOsc0ErClkFreq+0x3c>)
    82e6:	f240 1165 	movw	r1, #357	; 0x165
    82ea:	4808      	ldr	r0, [pc, #32]	; (830c <CLOCK_GetOsc0ErClkFreq+0x40>)
    82ec:	f002 f81a 	bl	a324 <__assert_func>
        return g_xtal0Freq;
    82f0:	4b03      	ldr	r3, [pc, #12]	; (8300 <CLOCK_GetOsc0ErClkFreq+0x34>)
    82f2:	681b      	ldr	r3, [r3, #0]
    82f4:	e000      	b.n	82f8 <CLOCK_GetOsc0ErClkFreq+0x2c>
    }
    else
    {
        return 0U;
    82f6:	2300      	movs	r3, #0
    }
}
    82f8:	4618      	mov	r0, r3
    82fa:	bd08      	pop	{r3, pc}
    82fc:	40065000 	.word	0x40065000
    8300:	20002f60 	.word	0x20002f60
    8304:	0001152c 	.word	0x0001152c
    8308:	00012788 	.word	0x00012788
    830c:	00011538 	.word	0x00011538

00008310 <CLOCK_GetEr32kClkFreq>:

uint32_t CLOCK_GetEr32kClkFreq(void)
{
    8310:	b500      	push	{lr}
    8312:	b083      	sub	sp, #12
    uint32_t freq;

    switch (SIM_SOPT1_OSC32KSEL_VAL)
    8314:	4b18      	ldr	r3, [pc, #96]	; (8378 <CLOCK_GetEr32kClkFreq+0x68>)
    8316:	681b      	ldr	r3, [r3, #0]
    8318:	0c9b      	lsrs	r3, r3, #18
    831a:	f003 0303 	and.w	r3, r3, #3
    831e:	2b02      	cmp	r3, #2
    8320:	d00f      	beq.n	8342 <CLOCK_GetEr32kClkFreq+0x32>
    8322:	2b03      	cmp	r3, #3
    8324:	d01c      	beq.n	8360 <CLOCK_GetEr32kClkFreq+0x50>
    8326:	2b00      	cmp	r3, #0
    8328:	d11e      	bne.n	8368 <CLOCK_GetEr32kClkFreq+0x58>
    {
        case 0U: /* OSC 32k clock  */
            freq = (CLOCK_GetOsc0ErClkFreq() == 32768U) ? 32768U : 0U;
    832a:	f7ff ffcf 	bl	82cc <CLOCK_GetOsc0ErClkFreq>
    832e:	4603      	mov	r3, r0
    8330:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    8334:	d102      	bne.n	833c <CLOCK_GetEr32kClkFreq+0x2c>
    8336:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    833a:	e000      	b.n	833e <CLOCK_GetEr32kClkFreq+0x2e>
    833c:	2300      	movs	r3, #0
    833e:	9301      	str	r3, [sp, #4]
            break;
    8340:	e015      	b.n	836e <CLOCK_GetEr32kClkFreq+0x5e>
        case 2U: /* RTC 32k clock  */
            /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN clock. */
            assert(g_xtal32Freq);
    8342:	4b0e      	ldr	r3, [pc, #56]	; (837c <CLOCK_GetEr32kClkFreq+0x6c>)
    8344:	681b      	ldr	r3, [r3, #0]
    8346:	2b00      	cmp	r3, #0
    8348:	d106      	bne.n	8358 <CLOCK_GetEr32kClkFreq+0x48>
    834a:	4b0d      	ldr	r3, [pc, #52]	; (8380 <CLOCK_GetEr32kClkFreq+0x70>)
    834c:	4a0d      	ldr	r2, [pc, #52]	; (8384 <CLOCK_GetEr32kClkFreq+0x74>)
    834e:	f240 1179 	movw	r1, #377	; 0x179
    8352:	480d      	ldr	r0, [pc, #52]	; (8388 <CLOCK_GetEr32kClkFreq+0x78>)
    8354:	f001 ffe6 	bl	a324 <__assert_func>
            freq = g_xtal32Freq;
    8358:	4b08      	ldr	r3, [pc, #32]	; (837c <CLOCK_GetEr32kClkFreq+0x6c>)
    835a:	681b      	ldr	r3, [r3, #0]
    835c:	9301      	str	r3, [sp, #4]
            break;
    835e:	e006      	b.n	836e <CLOCK_GetEr32kClkFreq+0x5e>
        case 3U: /* LPO clock      */
            freq = LPO_CLK_FREQ;
    8360:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    8364:	9301      	str	r3, [sp, #4]
            break;
    8366:	e002      	b.n	836e <CLOCK_GetEr32kClkFreq+0x5e>
        default:
            freq = 0U;
    8368:	2300      	movs	r3, #0
    836a:	9301      	str	r3, [sp, #4]
            break;
    836c:	bf00      	nop
    }
    return freq;
    836e:	9b01      	ldr	r3, [sp, #4]
}
    8370:	4618      	mov	r0, r3
    8372:	b003      	add	sp, #12
    8374:	f85d fb04 	ldr.w	pc, [sp], #4
    8378:	40047000 	.word	0x40047000
    837c:	20002f5c 	.word	0x20002f5c
    8380:	00011598 	.word	0x00011598
    8384:	000127a0 	.word	0x000127a0
    8388:	00011538 	.word	0x00011538

0000838c <CLOCK_GetPllFllSelClkFreq>:

uint32_t CLOCK_GetPllFllSelClkFreq(void)
{
    838c:	b500      	push	{lr}
    838e:	b083      	sub	sp, #12
    uint32_t freq;

    switch (SIM_SOPT2_PLLFLLSEL_VAL)
    8390:	4b0f      	ldr	r3, [pc, #60]	; (83d0 <CLOCK_GetPllFllSelClkFreq+0x44>)
    8392:	681b      	ldr	r3, [r3, #0]
    8394:	0c1b      	lsrs	r3, r3, #16
    8396:	f003 0303 	and.w	r3, r3, #3
    839a:	2b01      	cmp	r3, #1
    839c:	d008      	beq.n	83b0 <CLOCK_GetPllFllSelClkFreq+0x24>
    839e:	2b01      	cmp	r3, #1
    83a0:	d302      	bcc.n	83a8 <CLOCK_GetPllFllSelClkFreq+0x1c>
    83a2:	2b03      	cmp	r3, #3
    83a4:	d008      	beq.n	83b8 <CLOCK_GetPllFllSelClkFreq+0x2c>
    83a6:	e00a      	b.n	83be <CLOCK_GetPllFllSelClkFreq+0x32>
    {
        case 0U: /* FLL. */
            freq = CLOCK_GetFllFreq();
    83a8:	f000 f8fa 	bl	85a0 <CLOCK_GetFllFreq>
    83ac:	9001      	str	r0, [sp, #4]
            break;
    83ae:	e009      	b.n	83c4 <CLOCK_GetPllFllSelClkFreq+0x38>
        case 1U: /* PLL. */
            freq = CLOCK_GetPll0Freq();
    83b0:	f000 f962 	bl	8678 <CLOCK_GetPll0Freq>
    83b4:	9001      	str	r0, [sp, #4]
            break;
    83b6:	e005      	b.n	83c4 <CLOCK_GetPllFllSelClkFreq+0x38>
        case 3U: /* MCG IRC48M. */
            freq = MCG_INTERNAL_IRC_48M;
    83b8:	4b06      	ldr	r3, [pc, #24]	; (83d4 <CLOCK_GetPllFllSelClkFreq+0x48>)
    83ba:	9301      	str	r3, [sp, #4]
            break;
    83bc:	e002      	b.n	83c4 <CLOCK_GetPllFllSelClkFreq+0x38>
        default:
            freq = 0U;
    83be:	2300      	movs	r3, #0
    83c0:	9301      	str	r3, [sp, #4]
            break;
    83c2:	bf00      	nop
    }

    return freq;
    83c4:	9b01      	ldr	r3, [sp, #4]
}
    83c6:	4618      	mov	r0, r3
    83c8:	b003      	add	sp, #12
    83ca:	f85d fb04 	ldr.w	pc, [sp], #4
    83ce:	bf00      	nop
    83d0:	40048004 	.word	0x40048004
    83d4:	02dc6c00 	.word	0x02dc6c00

000083d8 <CLOCK_GetFreq>:
{
    return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
}

uint32_t CLOCK_GetFreq(clock_name_t clockName)
{
    83d8:	b500      	push	{lr}
    83da:	b085      	sub	sp, #20
    83dc:	4603      	mov	r3, r0
    83de:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32_t freq;

    switch (clockName)
    83e2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    83e6:	2b13      	cmp	r3, #19
    83e8:	f200 8083 	bhi.w	84f2 <CLOCK_GetFreq+0x11a>
    83ec:	a201      	add	r2, pc, #4	; (adr r2, 83f4 <CLOCK_GetFreq+0x1c>)
    83ee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    83f2:	bf00      	nop
    83f4:	00008445 	.word	0x00008445
    83f8:	00008445 	.word	0x00008445
    83fc:	0000845f 	.word	0x0000845f
    8400:	00008479 	.word	0x00008479
    8404:	00008493 	.word	0x00008493
    8408:	000084f3 	.word	0x000084f3
    840c:	000084ad 	.word	0x000084ad
    8410:	000084b5 	.word	0x000084b5
    8414:	000084bd 	.word	0x000084bd
    8418:	000084f3 	.word	0x000084f3
    841c:	000084f3 	.word	0x000084f3
    8420:	000084c5 	.word	0x000084c5
    8424:	000084cd 	.word	0x000084cd
    8428:	000084d5 	.word	0x000084d5
    842c:	000084dd 	.word	0x000084dd
    8430:	000084f3 	.word	0x000084f3
    8434:	000084f3 	.word	0x000084f3
    8438:	000084f3 	.word	0x000084f3
    843c:	000084e5 	.word	0x000084e5
    8440:	000084eb 	.word	0x000084eb
    {
        case kCLOCK_CoreSysClk:
        case kCLOCK_PlatClk:
            freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
    8444:	f000 f87a 	bl	853c <CLOCK_GetOutClkFreq>
    8448:	4602      	mov	r2, r0
    844a:	4b2e      	ldr	r3, [pc, #184]	; (8504 <CLOCK_GetFreq+0x12c>)
    844c:	681b      	ldr	r3, [r3, #0]
    844e:	0f1b      	lsrs	r3, r3, #28
    8450:	f003 030f 	and.w	r3, r3, #15
    8454:	3301      	adds	r3, #1
    8456:	fbb2 f3f3 	udiv	r3, r2, r3
    845a:	9303      	str	r3, [sp, #12]
            break;
    845c:	e04c      	b.n	84f8 <CLOCK_GetFreq+0x120>
        case kCLOCK_BusClk:
            freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV2_VAL + 1);
    845e:	f000 f86d 	bl	853c <CLOCK_GetOutClkFreq>
    8462:	4602      	mov	r2, r0
    8464:	4b27      	ldr	r3, [pc, #156]	; (8504 <CLOCK_GetFreq+0x12c>)
    8466:	681b      	ldr	r3, [r3, #0]
    8468:	0e1b      	lsrs	r3, r3, #24
    846a:	f003 030f 	and.w	r3, r3, #15
    846e:	3301      	adds	r3, #1
    8470:	fbb2 f3f3 	udiv	r3, r2, r3
    8474:	9303      	str	r3, [sp, #12]
            break;
    8476:	e03f      	b.n	84f8 <CLOCK_GetFreq+0x120>
        case kCLOCK_FlexBusClk:
            freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV3_VAL + 1);
    8478:	f000 f860 	bl	853c <CLOCK_GetOutClkFreq>
    847c:	4602      	mov	r2, r0
    847e:	4b21      	ldr	r3, [pc, #132]	; (8504 <CLOCK_GetFreq+0x12c>)
    8480:	681b      	ldr	r3, [r3, #0]
    8482:	0d1b      	lsrs	r3, r3, #20
    8484:	f003 030f 	and.w	r3, r3, #15
    8488:	3301      	adds	r3, #1
    848a:	fbb2 f3f3 	udiv	r3, r2, r3
    848e:	9303      	str	r3, [sp, #12]
            break;
    8490:	e032      	b.n	84f8 <CLOCK_GetFreq+0x120>
        case kCLOCK_FlashClk:
            freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV4_VAL + 1);
    8492:	f000 f853 	bl	853c <CLOCK_GetOutClkFreq>
    8496:	4602      	mov	r2, r0
    8498:	4b1a      	ldr	r3, [pc, #104]	; (8504 <CLOCK_GetFreq+0x12c>)
    849a:	681b      	ldr	r3, [r3, #0]
    849c:	0c1b      	lsrs	r3, r3, #16
    849e:	f003 030f 	and.w	r3, r3, #15
    84a2:	3301      	adds	r3, #1
    84a4:	fbb2 f3f3 	udiv	r3, r2, r3
    84a8:	9303      	str	r3, [sp, #12]
            break;
    84aa:	e025      	b.n	84f8 <CLOCK_GetFreq+0x120>
        case kCLOCK_PllFllSelClk:
            freq = CLOCK_GetPllFllSelClkFreq();
    84ac:	f7ff ff6e 	bl	838c <CLOCK_GetPllFllSelClkFreq>
    84b0:	9003      	str	r0, [sp, #12]
            break;
    84b2:	e021      	b.n	84f8 <CLOCK_GetFreq+0x120>
        case kCLOCK_Er32kClk:
            freq = CLOCK_GetEr32kClkFreq();
    84b4:	f7ff ff2c 	bl	8310 <CLOCK_GetEr32kClkFreq>
    84b8:	9003      	str	r0, [sp, #12]
            break;
    84ba:	e01d      	b.n	84f8 <CLOCK_GetFreq+0x120>
        case kCLOCK_Osc0ErClk:
            freq = CLOCK_GetOsc0ErClkFreq();
    84bc:	f7ff ff06 	bl	82cc <CLOCK_GetOsc0ErClkFreq>
    84c0:	9003      	str	r0, [sp, #12]
            break;
    84c2:	e019      	b.n	84f8 <CLOCK_GetFreq+0x120>
        case kCLOCK_McgFixedFreqClk:
            freq = CLOCK_GetFixedFreqClkFreq();
    84c4:	f000 f8c2 	bl	864c <CLOCK_GetFixedFreqClkFreq>
    84c8:	9003      	str	r0, [sp, #12]
            break;
    84ca:	e015      	b.n	84f8 <CLOCK_GetFreq+0x120>
        case kCLOCK_McgInternalRefClk:
            freq = CLOCK_GetInternalRefClkFreq();
    84cc:	f000 f8ac 	bl	8628 <CLOCK_GetInternalRefClkFreq>
    84d0:	9003      	str	r0, [sp, #12]
            break;
    84d2:	e011      	b.n	84f8 <CLOCK_GetFreq+0x120>
        case kCLOCK_McgFllClk:
            freq = CLOCK_GetFllFreq();
    84d4:	f000 f864 	bl	85a0 <CLOCK_GetFllFreq>
    84d8:	9003      	str	r0, [sp, #12]
            break;
    84da:	e00d      	b.n	84f8 <CLOCK_GetFreq+0x120>
        case kCLOCK_McgPll0Clk:
            freq = CLOCK_GetPll0Freq();
    84dc:	f000 f8cc 	bl	8678 <CLOCK_GetPll0Freq>
    84e0:	9003      	str	r0, [sp, #12]
            break;
    84e2:	e009      	b.n	84f8 <CLOCK_GetFreq+0x120>
        case kCLOCK_McgIrc48MClk:
            freq = MCG_INTERNAL_IRC_48M;
    84e4:	4b08      	ldr	r3, [pc, #32]	; (8508 <CLOCK_GetFreq+0x130>)
    84e6:	9303      	str	r3, [sp, #12]
            break;
    84e8:	e006      	b.n	84f8 <CLOCK_GetFreq+0x120>
        case kCLOCK_LpoClk:
            freq = LPO_CLK_FREQ;
    84ea:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    84ee:	9303      	str	r3, [sp, #12]
            break;
    84f0:	e002      	b.n	84f8 <CLOCK_GetFreq+0x120>
        default:
            freq = 0U;
    84f2:	2300      	movs	r3, #0
    84f4:	9303      	str	r3, [sp, #12]
            break;
    84f6:	bf00      	nop
    }

    return freq;
    84f8:	9b03      	ldr	r3, [sp, #12]
}
    84fa:	4618      	mov	r0, r3
    84fc:	b005      	add	sp, #20
    84fe:	f85d fb04 	ldr.w	pc, [sp], #4
    8502:	bf00      	nop
    8504:	40048044 	.word	0x40048044
    8508:	02dc6c00 	.word	0x02dc6c00

0000850c <CLOCK_SetSimConfig>:

void CLOCK_SetSimConfig(sim_clock_config_t const *config)
{
    850c:	b500      	push	{lr}
    850e:	b083      	sub	sp, #12
    8510:	9001      	str	r0, [sp, #4]
    __FSL_CLOCK_SECURE_WRITE(&SIM->CLKDIV1, config->clkdiv1);
    8512:	4a09      	ldr	r2, [pc, #36]	; (8538 <CLOCK_SetSimConfig+0x2c>)
    8514:	9b01      	ldr	r3, [sp, #4]
    8516:	685b      	ldr	r3, [r3, #4]
    8518:	6013      	str	r3, [r2, #0]

    CLOCK_SetPllFllSelClock(config->pllFllSel);
    851a:	9b01      	ldr	r3, [sp, #4]
    851c:	781b      	ldrb	r3, [r3, #0]
    851e:	4618      	mov	r0, r3
    8520:	f7ff fd7e 	bl	8020 <CLOCK_SetPllFllSelClock>
    CLOCK_SetEr32kClock(config->er32kSrc);
    8524:	9b01      	ldr	r3, [sp, #4]
    8526:	785b      	ldrb	r3, [r3, #1]
    8528:	4618      	mov	r0, r3
    852a:	f7ff fd67 	bl	7ffc <CLOCK_SetEr32kClock>
}
    852e:	bf00      	nop
    8530:	b003      	add	sp, #12
    8532:	f85d fb04 	ldr.w	pc, [sp], #4
    8536:	bf00      	nop
    8538:	40048044 	.word	0x40048044

0000853c <CLOCK_GetOutClkFreq>:
    }
    return ret;
}

uint32_t CLOCK_GetOutClkFreq(void)
{
    853c:	b500      	push	{lr}
    853e:	b083      	sub	sp, #12
    uint32_t mcgoutclk;
    uint32_t clkst = MCG_S_CLKST_VAL;
    8540:	4b16      	ldr	r3, [pc, #88]	; (859c <CLOCK_GetOutClkFreq+0x60>)
    8542:	799b      	ldrb	r3, [r3, #6]
    8544:	b2db      	uxtb	r3, r3
    8546:	089b      	lsrs	r3, r3, #2
    8548:	f003 0303 	and.w	r3, r3, #3
    854c:	9300      	str	r3, [sp, #0]

    switch (clkst)
    854e:	9b00      	ldr	r3, [sp, #0]
    8550:	2b03      	cmp	r3, #3
    8552:	d81b      	bhi.n	858c <CLOCK_GetOutClkFreq+0x50>
    8554:	a201      	add	r2, pc, #4	; (adr r2, 855c <CLOCK_GetOutClkFreq+0x20>)
    8556:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    855a:	bf00      	nop
    855c:	00008575 	.word	0x00008575
    8560:	0000857d 	.word	0x0000857d
    8564:	00008585 	.word	0x00008585
    8568:	0000856d 	.word	0x0000856d
    {
        case kMCG_ClkOutStatPll:
            mcgoutclk = CLOCK_GetPll0Freq();
    856c:	f000 f884 	bl	8678 <CLOCK_GetPll0Freq>
    8570:	9001      	str	r0, [sp, #4]
            break;
    8572:	e00e      	b.n	8592 <CLOCK_GetOutClkFreq+0x56>
        case kMCG_ClkOutStatFll:
            mcgoutclk = CLOCK_GetFllFreq();
    8574:	f000 f814 	bl	85a0 <CLOCK_GetFllFreq>
    8578:	9001      	str	r0, [sp, #4]
            break;
    857a:	e00a      	b.n	8592 <CLOCK_GetOutClkFreq+0x56>
        case kMCG_ClkOutStatInt:
            mcgoutclk = CLOCK_GetInternalRefClkSelectFreq();
    857c:	f7ff fe50 	bl	8220 <CLOCK_GetInternalRefClkSelectFreq>
    8580:	9001      	str	r0, [sp, #4]
            break;
    8582:	e006      	b.n	8592 <CLOCK_GetOutClkFreq+0x56>
        case kMCG_ClkOutStatExt:
            mcgoutclk = CLOCK_GetMcgExtClkFreq();
    8584:	f7ff fd96 	bl	80b4 <CLOCK_GetMcgExtClkFreq>
    8588:	9001      	str	r0, [sp, #4]
            break;
    858a:	e002      	b.n	8592 <CLOCK_GetOutClkFreq+0x56>
        default:
            mcgoutclk = 0U;
    858c:	2300      	movs	r3, #0
    858e:	9301      	str	r3, [sp, #4]
            break;
    8590:	bf00      	nop
    }
    return mcgoutclk;
    8592:	9b01      	ldr	r3, [sp, #4]
}
    8594:	4618      	mov	r0, r3
    8596:	b003      	add	sp, #12
    8598:	f85d fb04 	ldr.w	pc, [sp], #4
    859c:	40064000 	.word	0x40064000

000085a0 <CLOCK_GetFllFreq>:

uint32_t CLOCK_GetFllFreq(void)
{
    85a0:	b500      	push	{lr}
    85a2:	b083      	sub	sp, #12

    uint8_t drs, dmx32;
    uint32_t freq;

    /* If FLL is not enabled currently, then return 0U. */
    if ((__FSL_CLOCK_SECURE_READ(&MCG->C2) & MCG_C2_LP_MASK) || (MCG->S & MCG_S_PLLST_MASK))
    85a4:	4b1d      	ldr	r3, [pc, #116]	; (861c <CLOCK_GetFllFreq+0x7c>)
    85a6:	781b      	ldrb	r3, [r3, #0]
    85a8:	b2db      	uxtb	r3, r3
    85aa:	f003 0302 	and.w	r3, r3, #2
    85ae:	2b00      	cmp	r3, #0
    85b0:	d106      	bne.n	85c0 <CLOCK_GetFllFreq+0x20>
    85b2:	4b1b      	ldr	r3, [pc, #108]	; (8620 <CLOCK_GetFllFreq+0x80>)
    85b4:	799b      	ldrb	r3, [r3, #6]
    85b6:	b2db      	uxtb	r3, r3
    85b8:	f003 0320 	and.w	r3, r3, #32
    85bc:	2b00      	cmp	r3, #0
    85be:	d001      	beq.n	85c4 <CLOCK_GetFllFreq+0x24>
    {
        return 0U;
    85c0:	2300      	movs	r3, #0
    85c2:	e026      	b.n	8612 <CLOCK_GetFllFreq+0x72>
    }

    /* Get FLL reference clock frequency. */
    freq = CLOCK_GetFllRefClkFreq();
    85c4:	f7ff fe4a 	bl	825c <CLOCK_GetFllRefClkFreq>
    85c8:	9001      	str	r0, [sp, #4]
    if (!freq)
    85ca:	9b01      	ldr	r3, [sp, #4]
    85cc:	2b00      	cmp	r3, #0
    85ce:	d101      	bne.n	85d4 <CLOCK_GetFllFreq+0x34>
    {
        return freq;
    85d0:	9b01      	ldr	r3, [sp, #4]
    85d2:	e01e      	b.n	8612 <CLOCK_GetFllFreq+0x72>
    }

    drs = MCG_C4_DRST_DRS_VAL;
    85d4:	4b12      	ldr	r3, [pc, #72]	; (8620 <CLOCK_GetFllFreq+0x80>)
    85d6:	78db      	ldrb	r3, [r3, #3]
    85d8:	b2db      	uxtb	r3, r3
    85da:	095b      	lsrs	r3, r3, #5
    85dc:	b2db      	uxtb	r3, r3
    85de:	f003 0303 	and.w	r3, r3, #3
    85e2:	f88d 3003 	strb.w	r3, [sp, #3]
    dmx32 = MCG_C4_DMX32_VAL;
    85e6:	4b0e      	ldr	r3, [pc, #56]	; (8620 <CLOCK_GetFllFreq+0x80>)
    85e8:	78db      	ldrb	r3, [r3, #3]
    85ea:	b2db      	uxtb	r3, r3
    85ec:	09db      	lsrs	r3, r3, #7
    85ee:	b2db      	uxtb	r3, r3
    85f0:	f003 0301 	and.w	r3, r3, #1
    85f4:	f88d 3002 	strb.w	r3, [sp, #2]

    return freq * fllFactorTable[drs][dmx32];
    85f8:	f89d 2003 	ldrb.w	r2, [sp, #3]
    85fc:	f89d 3002 	ldrb.w	r3, [sp, #2]
    8600:	4908      	ldr	r1, [pc, #32]	; (8624 <CLOCK_GetFllFreq+0x84>)
    8602:	0052      	lsls	r2, r2, #1
    8604:	4413      	add	r3, r2
    8606:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    860a:	461a      	mov	r2, r3
    860c:	9b01      	ldr	r3, [sp, #4]
    860e:	fb03 f302 	mul.w	r3, r3, r2
}
    8612:	4618      	mov	r0, r3
    8614:	b003      	add	sp, #12
    8616:	f85d fb04 	ldr.w	pc, [sp], #4
    861a:	bf00      	nop
    861c:	40064001 	.word	0x40064001
    8620:	40064000 	.word	0x40064000
    8624:	000127b8 	.word	0x000127b8

00008628 <CLOCK_GetInternalRefClkFreq>:

uint32_t CLOCK_GetInternalRefClkFreq(void)
{
    8628:	b508      	push	{r3, lr}
    /* If MCGIRCLK is gated. */
    if (!(__FSL_CLOCK_SECURE_READ(&MCG->C1) & MCG_C1_IRCLKEN_MASK))
    862a:	4b07      	ldr	r3, [pc, #28]	; (8648 <CLOCK_GetInternalRefClkFreq+0x20>)
    862c:	781b      	ldrb	r3, [r3, #0]
    862e:	b2db      	uxtb	r3, r3
    8630:	f003 0302 	and.w	r3, r3, #2
    8634:	2b00      	cmp	r3, #0
    8636:	d101      	bne.n	863c <CLOCK_GetInternalRefClkFreq+0x14>
    {
        return 0U;
    8638:	2300      	movs	r3, #0
    863a:	e002      	b.n	8642 <CLOCK_GetInternalRefClkFreq+0x1a>
    }

    return CLOCK_GetInternalRefClkSelectFreq();
    863c:	f7ff fdf0 	bl	8220 <CLOCK_GetInternalRefClkSelectFreq>
    8640:	4603      	mov	r3, r0
}
    8642:	4618      	mov	r0, r3
    8644:	bd08      	pop	{r3, pc}
    8646:	bf00      	nop
    8648:	40064000 	.word	0x40064000

0000864c <CLOCK_GetFixedFreqClkFreq>:

uint32_t CLOCK_GetFixedFreqClkFreq(void)
{
    864c:	b500      	push	{lr}
    864e:	b083      	sub	sp, #12
    uint32_t freq = CLOCK_GetFllRefClkFreq();
    8650:	f7ff fe04 	bl	825c <CLOCK_GetFllRefClkFreq>
    8654:	9001      	str	r0, [sp, #4]

    /* MCGFFCLK must be no more than MCGOUTCLK/8. */
    if ((freq) && (freq <= (CLOCK_GetOutClkFreq() / 8U)))
    8656:	9b01      	ldr	r3, [sp, #4]
    8658:	2b00      	cmp	r3, #0
    865a:	d008      	beq.n	866e <CLOCK_GetFixedFreqClkFreq+0x22>
    865c:	f7ff ff6e 	bl	853c <CLOCK_GetOutClkFreq>
    8660:	4603      	mov	r3, r0
    8662:	08da      	lsrs	r2, r3, #3
    8664:	9b01      	ldr	r3, [sp, #4]
    8666:	429a      	cmp	r2, r3
    8668:	d301      	bcc.n	866e <CLOCK_GetFixedFreqClkFreq+0x22>
    {
        return freq;
    866a:	9b01      	ldr	r3, [sp, #4]
    866c:	e000      	b.n	8670 <CLOCK_GetFixedFreqClkFreq+0x24>
    }
    else
    {
        return 0U;
    866e:	2300      	movs	r3, #0
    }
}
    8670:	4618      	mov	r0, r3
    8672:	b003      	add	sp, #12
    8674:	f85d fb04 	ldr.w	pc, [sp], #4

00008678 <CLOCK_GetPll0Freq>:

uint32_t CLOCK_GetPll0Freq(void)
{
    8678:	b500      	push	{lr}
    867a:	b083      	sub	sp, #12
    uint32_t mcgpll0clk;

    /* If PLL0 is not enabled, return 0. */
    if (!(MCG->S & MCG_S_LOCK0_MASK))
    867c:	4b17      	ldr	r3, [pc, #92]	; (86dc <CLOCK_GetPll0Freq+0x64>)
    867e:	799b      	ldrb	r3, [r3, #6]
    8680:	b2db      	uxtb	r3, r3
    8682:	f003 0340 	and.w	r3, r3, #64	; 0x40
    8686:	2b00      	cmp	r3, #0
    8688:	d101      	bne.n	868e <CLOCK_GetPll0Freq+0x16>
    {
        return 0U;
    868a:	2300      	movs	r3, #0
    868c:	e022      	b.n	86d4 <CLOCK_GetPll0Freq+0x5c>
    }

    mcgpll0clk = CLOCK_GetPll0RefFreq();
    868e:	f7ff fdf9 	bl	8284 <CLOCK_GetPll0RefFreq>
    8692:	9001      	str	r0, [sp, #4]

    /*
     * Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock.
     * Please call CLOCK_SetXtal1Freq base on board setting before using OSC1 clock.
     */
    assert(mcgpll0clk);
    8694:	9b01      	ldr	r3, [sp, #4]
    8696:	2b00      	cmp	r3, #0
    8698:	d106      	bne.n	86a8 <CLOCK_GetPll0Freq+0x30>
    869a:	4b11      	ldr	r3, [pc, #68]	; (86e0 <CLOCK_GetPll0Freq+0x68>)
    869c:	4a11      	ldr	r2, [pc, #68]	; (86e4 <CLOCK_GetPll0Freq+0x6c>)
    869e:	f240 217e 	movw	r1, #638	; 0x27e
    86a2:	4811      	ldr	r0, [pc, #68]	; (86e8 <CLOCK_GetPll0Freq+0x70>)
    86a4:	f001 fe3e 	bl	a324 <__assert_func>

    mcgpll0clk /= (FSL_FEATURE_MCG_PLL_PRDIV_BASE + MCG_C5_PRDIV0_VAL);
    86a8:	4b10      	ldr	r3, [pc, #64]	; (86ec <CLOCK_GetPll0Freq+0x74>)
    86aa:	781b      	ldrb	r3, [r3, #0]
    86ac:	b2db      	uxtb	r3, r3
    86ae:	f003 031f 	and.w	r3, r3, #31
    86b2:	3301      	adds	r3, #1
    86b4:	9a01      	ldr	r2, [sp, #4]
    86b6:	fbb2 f3f3 	udiv	r3, r2, r3
    86ba:	9301      	str	r3, [sp, #4]
    mcgpll0clk *= (FSL_FEATURE_MCG_PLL_VDIV_BASE + MCG_C6_VDIV0_VAL);
    86bc:	4b0c      	ldr	r3, [pc, #48]	; (86f0 <CLOCK_GetPll0Freq+0x78>)
    86be:	781b      	ldrb	r3, [r3, #0]
    86c0:	b2db      	uxtb	r3, r3
    86c2:	f003 031f 	and.w	r3, r3, #31
    86c6:	f103 0218 	add.w	r2, r3, #24
    86ca:	9b01      	ldr	r3, [sp, #4]
    86cc:	fb02 f303 	mul.w	r3, r2, r3
    86d0:	9301      	str	r3, [sp, #4]

    return mcgpll0clk;
    86d2:	9b01      	ldr	r3, [sp, #4]
}
    86d4:	4618      	mov	r0, r3
    86d6:	b003      	add	sp, #12
    86d8:	f85d fb04 	ldr.w	pc, [sp], #4
    86dc:	40064000 	.word	0x40064000
    86e0:	000115a8 	.word	0x000115a8
    86e4:	000127c8 	.word	0x000127c8
    86e8:	00011538 	.word	0x00011538
    86ec:	40064004 	.word	0x40064004
    86f0:	40064005 	.word	0x40064005

000086f4 <CLOCK_SetExternalRefClkConfig>:

status_t CLOCK_SetExternalRefClkConfig(mcg_oscsel_t oscsel)
{
    86f4:	b084      	sub	sp, #16
    86f6:	4603      	mov	r3, r0
    86f8:	f88d 3007 	strb.w	r3, [sp, #7]
    {
        return kStatus_MCG_SourceUsed;
    }
#endif /* MCG_CONFIG_CHECK_PARAM */

    if (MCG_C7_OSCSEL_VAL != oscsel)
    86fc:	4b21      	ldr	r3, [pc, #132]	; (8784 <CLOCK_SetExternalRefClkConfig+0x90>)
    86fe:	781b      	ldrb	r3, [r3, #0]
    8700:	b2db      	uxtb	r3, r3
    8702:	f003 0203 	and.w	r2, r3, #3
    8706:	f89d 3007 	ldrb.w	r3, [sp, #7]
    870a:	429a      	cmp	r2, r3
    870c:	d003      	beq.n	8716 <CLOCK_SetExternalRefClkConfig+0x22>
    {
        /* If change OSCSEL, need to delay, ERR009878. */
        needDelay = true;
    870e:	2301      	movs	r3, #1
    8710:	f88d 300f 	strb.w	r3, [sp, #15]
    8714:	e002      	b.n	871c <CLOCK_SetExternalRefClkConfig+0x28>
    }
    else
    {
        needDelay = false;
    8716:	2300      	movs	r3, #0
    8718:	f88d 300f 	strb.w	r3, [sp, #15]
    }

    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C7, MCG_C7_OSCSEL_MASK, MCG_C7_OSCSEL(oscsel));
    871c:	4919      	ldr	r1, [pc, #100]	; (8784 <CLOCK_SetExternalRefClkConfig+0x90>)
    871e:	4b19      	ldr	r3, [pc, #100]	; (8784 <CLOCK_SetExternalRefClkConfig+0x90>)
    8720:	781b      	ldrb	r3, [r3, #0]
    8722:	b2db      	uxtb	r3, r3
    8724:	f023 0303 	bic.w	r3, r3, #3
    8728:	b2da      	uxtb	r2, r3
    872a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    872e:	f003 0303 	and.w	r3, r3, #3
    8732:	b2db      	uxtb	r3, r3
    8734:	4313      	orrs	r3, r2
    8736:	b2db      	uxtb	r3, r3
    8738:	700b      	strb	r3, [r1, #0]
    if (kMCG_OscselOsc == oscsel)
    873a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    873e:	2b00      	cmp	r3, #0
    8740:	d10e      	bne.n	8760 <CLOCK_SetExternalRefClkConfig+0x6c>
    {
        if (__FSL_CLOCK_SECURE_READ(&MCG->C2) & MCG_C2_EREFS_MASK)
    8742:	4b11      	ldr	r3, [pc, #68]	; (8788 <CLOCK_SetExternalRefClkConfig+0x94>)
    8744:	781b      	ldrb	r3, [r3, #0]
    8746:	b2db      	uxtb	r3, r3
    8748:	f003 0304 	and.w	r3, r3, #4
    874c:	2b00      	cmp	r3, #0
    874e:	d007      	beq.n	8760 <CLOCK_SetExternalRefClkConfig+0x6c>
        {
            while (!(MCG->S & MCG_S_OSCINIT0_MASK))
    8750:	bf00      	nop
    8752:	4b0e      	ldr	r3, [pc, #56]	; (878c <CLOCK_SetExternalRefClkConfig+0x98>)
    8754:	799b      	ldrb	r3, [r3, #6]
    8756:	b2db      	uxtb	r3, r3
    8758:	f003 0302 	and.w	r3, r3, #2
    875c:	2b00      	cmp	r3, #0
    875e:	d0f8      	beq.n	8752 <CLOCK_SetExternalRefClkConfig+0x5e>
            {
            }
        }
    }

    if (needDelay)
    8760:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8764:	2b00      	cmp	r3, #0
    8766:	d009      	beq.n	877c <CLOCK_SetExternalRefClkConfig+0x88>
    {
        /* ERR009878 Delay at least 50 micro-seconds for external clock change valid. */
        i = 1500U;
    8768:	f240 53dc 	movw	r3, #1500	; 0x5dc
    876c:	9302      	str	r3, [sp, #8]
        while (i--)
    876e:	e000      	b.n	8772 <CLOCK_SetExternalRefClkConfig+0x7e>
        {
            __NOP();
    8770:	bf00      	nop
        while (i--)
    8772:	9b02      	ldr	r3, [sp, #8]
    8774:	1e5a      	subs	r2, r3, #1
    8776:	9202      	str	r2, [sp, #8]
    8778:	2b00      	cmp	r3, #0
    877a:	d1f9      	bne.n	8770 <CLOCK_SetExternalRefClkConfig+0x7c>
        }
    }

    return kStatus_Success;
    877c:	2300      	movs	r3, #0
}
    877e:	4618      	mov	r0, r3
    8780:	b004      	add	sp, #16
    8782:	4770      	bx	lr
    8784:	4006400c 	.word	0x4006400c
    8788:	40064001 	.word	0x40064001
    878c:	40064000 	.word	0x40064000

00008790 <CLOCK_SetInternalRefClkConfig>:

status_t CLOCK_SetInternalRefClkConfig(uint8_t enableMode, mcg_irc_mode_t ircs, uint8_t fcrdiv)
{
    8790:	b084      	sub	sp, #16
    8792:	4603      	mov	r3, r0
    8794:	f88d 3007 	strb.w	r3, [sp, #7]
    8798:	460b      	mov	r3, r1
    879a:	f88d 3006 	strb.w	r3, [sp, #6]
    879e:	4613      	mov	r3, r2
    87a0:	f88d 3005 	strb.w	r3, [sp, #5]
    uint32_t mcgOutClkState = MCG_S_CLKST_VAL;
    87a4:	4b40      	ldr	r3, [pc, #256]	; (88a8 <CLOCK_SetInternalRefClkConfig+0x118>)
    87a6:	799b      	ldrb	r3, [r3, #6]
    87a8:	b2db      	uxtb	r3, r3
    87aa:	089b      	lsrs	r3, r3, #2
    87ac:	f003 0303 	and.w	r3, r3, #3
    87b0:	9303      	str	r3, [sp, #12]
    mcg_irc_mode_t curIrcs = (mcg_irc_mode_t)MCG_S_IRCST_VAL;
    87b2:	4b3d      	ldr	r3, [pc, #244]	; (88a8 <CLOCK_SetInternalRefClkConfig+0x118>)
    87b4:	799b      	ldrb	r3, [r3, #6]
    87b6:	b2db      	uxtb	r3, r3
    87b8:	f003 0301 	and.w	r3, r3, #1
    87bc:	f88d 300b 	strb.w	r3, [sp, #11]
    uint8_t curFcrdiv = MCG_SC_FCRDIV_VAL;
    87c0:	4b3a      	ldr	r3, [pc, #232]	; (88ac <CLOCK_SetInternalRefClkConfig+0x11c>)
    87c2:	781b      	ldrb	r3, [r3, #0]
    87c4:	b2db      	uxtb	r3, r3
    87c6:	085b      	lsrs	r3, r3, #1
    87c8:	b2db      	uxtb	r3, r3
    87ca:	f003 0307 	and.w	r3, r3, #7
    87ce:	f88d 300a 	strb.w	r3, [sp, #10]
        }
    }
#endif

    /* If need to update the FCRDIV. */
    if (fcrdiv != curFcrdiv)
    87d2:	f89d 2005 	ldrb.w	r2, [sp, #5]
    87d6:	f89d 300a 	ldrb.w	r3, [sp, #10]
    87da:	429a      	cmp	r2, r3
    87dc:	d02e      	beq.n	883c <CLOCK_SetInternalRefClkConfig+0xac>
    {
        /* If fast IRC is in use currently, change to slow IRC. */
        if ((kMCG_IrcFast == curIrcs) && ((mcgOutClkState == kMCG_ClkOutStatInt) || (__FSL_CLOCK_SECURE_READ(&MCG->C1) & MCG_C1_IRCLKEN_MASK)))
    87de:	f89d 300b 	ldrb.w	r3, [sp, #11]
    87e2:	2b01      	cmp	r3, #1
    87e4:	d119      	bne.n	881a <CLOCK_SetInternalRefClkConfig+0x8a>
    87e6:	9b03      	ldr	r3, [sp, #12]
    87e8:	2b01      	cmp	r3, #1
    87ea:	d006      	beq.n	87fa <CLOCK_SetInternalRefClkConfig+0x6a>
    87ec:	4b2e      	ldr	r3, [pc, #184]	; (88a8 <CLOCK_SetInternalRefClkConfig+0x118>)
    87ee:	781b      	ldrb	r3, [r3, #0]
    87f0:	b2db      	uxtb	r3, r3
    87f2:	f003 0302 	and.w	r3, r3, #2
    87f6:	2b00      	cmp	r3, #0
    87f8:	d00f      	beq.n	881a <CLOCK_SetInternalRefClkConfig+0x8a>
        {
            __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C2, MCG_C2_IRCS_MASK, MCG_C2_IRCS(kMCG_IrcSlow));
    87fa:	4a2d      	ldr	r2, [pc, #180]	; (88b0 <CLOCK_SetInternalRefClkConfig+0x120>)
    87fc:	4b2c      	ldr	r3, [pc, #176]	; (88b0 <CLOCK_SetInternalRefClkConfig+0x120>)
    87fe:	781b      	ldrb	r3, [r3, #0]
    8800:	b2db      	uxtb	r3, r3
    8802:	f023 0301 	bic.w	r3, r3, #1
    8806:	b2db      	uxtb	r3, r3
    8808:	7013      	strb	r3, [r2, #0]
            while (MCG_S_IRCST_VAL != kMCG_IrcSlow)
    880a:	bf00      	nop
    880c:	4b26      	ldr	r3, [pc, #152]	; (88a8 <CLOCK_SetInternalRefClkConfig+0x118>)
    880e:	799b      	ldrb	r3, [r3, #6]
    8810:	b2db      	uxtb	r3, r3
    8812:	f003 0301 	and.w	r3, r3, #1
    8816:	2b00      	cmp	r3, #0
    8818:	d1f8      	bne.n	880c <CLOCK_SetInternalRefClkConfig+0x7c>
            {
            }
        }
        /* Update FCRDIV. */
        __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->SC, MCG_SC_FCRDIV_MASK | MCG_SC_ATMF_MASK | MCG_SC_LOCS0_MASK, MCG_SC_FCRDIV(fcrdiv));
    881a:	4924      	ldr	r1, [pc, #144]	; (88ac <CLOCK_SetInternalRefClkConfig+0x11c>)
    881c:	4b23      	ldr	r3, [pc, #140]	; (88ac <CLOCK_SetInternalRefClkConfig+0x11c>)
    881e:	781b      	ldrb	r3, [r3, #0]
    8820:	b2db      	uxtb	r3, r3
    8822:	f023 032f 	bic.w	r3, r3, #47	; 0x2f
    8826:	b2da      	uxtb	r2, r3
    8828:	f89d 3005 	ldrb.w	r3, [sp, #5]
    882c:	005b      	lsls	r3, r3, #1
    882e:	b2db      	uxtb	r3, r3
    8830:	f003 030e 	and.w	r3, r3, #14
    8834:	b2db      	uxtb	r3, r3
    8836:	4313      	orrs	r3, r2
    8838:	b2db      	uxtb	r3, r3
    883a:	700b      	strb	r3, [r1, #0]
    }

    /* Set internal reference clock selection. */
    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C2, MCG_C2_IRCS_MASK, MCG_C2_IRCS(ircs));
    883c:	491c      	ldr	r1, [pc, #112]	; (88b0 <CLOCK_SetInternalRefClkConfig+0x120>)
    883e:	4b1c      	ldr	r3, [pc, #112]	; (88b0 <CLOCK_SetInternalRefClkConfig+0x120>)
    8840:	781b      	ldrb	r3, [r3, #0]
    8842:	b2db      	uxtb	r3, r3
    8844:	f023 0301 	bic.w	r3, r3, #1
    8848:	b2da      	uxtb	r2, r3
    884a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    884e:	f003 0301 	and.w	r3, r3, #1
    8852:	b2db      	uxtb	r3, r3
    8854:	4313      	orrs	r3, r2
    8856:	b2db      	uxtb	r3, r3
    8858:	700b      	strb	r3, [r1, #0]
    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C1, MCG_C1_IRCLKEN_MASK | MCG_C1_IREFSTEN_MASK, (uint8_t)enableMode);
    885a:	4913      	ldr	r1, [pc, #76]	; (88a8 <CLOCK_SetInternalRefClkConfig+0x118>)
    885c:	4b12      	ldr	r3, [pc, #72]	; (88a8 <CLOCK_SetInternalRefClkConfig+0x118>)
    885e:	781b      	ldrb	r3, [r3, #0]
    8860:	b2db      	uxtb	r3, r3
    8862:	f023 0303 	bic.w	r3, r3, #3
    8866:	b2da      	uxtb	r2, r3
    8868:	f89d 3007 	ldrb.w	r3, [sp, #7]
    886c:	f003 0303 	and.w	r3, r3, #3
    8870:	b2db      	uxtb	r3, r3
    8872:	4313      	orrs	r3, r2
    8874:	b2db      	uxtb	r3, r3
    8876:	700b      	strb	r3, [r1, #0]

    /* If MCGIRCLK is used, need to wait for MCG_S_IRCST. */
    if ((mcgOutClkState == kMCG_ClkOutStatInt) || (enableMode & kMCG_IrclkEnable))
    8878:	9b03      	ldr	r3, [sp, #12]
    887a:	2b01      	cmp	r3, #1
    887c:	d005      	beq.n	888a <CLOCK_SetInternalRefClkConfig+0xfa>
    887e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8882:	f003 0302 	and.w	r3, r3, #2
    8886:	2b00      	cmp	r3, #0
    8888:	d009      	beq.n	889e <CLOCK_SetInternalRefClkConfig+0x10e>
    {
        while (MCG_S_IRCST_VAL != ircs)
    888a:	bf00      	nop
    888c:	4b06      	ldr	r3, [pc, #24]	; (88a8 <CLOCK_SetInternalRefClkConfig+0x118>)
    888e:	799b      	ldrb	r3, [r3, #6]
    8890:	b2db      	uxtb	r3, r3
    8892:	f003 0201 	and.w	r2, r3, #1
    8896:	f89d 3006 	ldrb.w	r3, [sp, #6]
    889a:	429a      	cmp	r2, r3
    889c:	d1f6      	bne.n	888c <CLOCK_SetInternalRefClkConfig+0xfc>
        {
        }
    }

    return kStatus_Success;
    889e:	2300      	movs	r3, #0
}
    88a0:	4618      	mov	r0, r3
    88a2:	b004      	add	sp, #16
    88a4:	4770      	bx	lr
    88a6:	bf00      	nop
    88a8:	40064000 	.word	0x40064000
    88ac:	40064008 	.word	0x40064008
    88b0:	40064001 	.word	0x40064001

000088b4 <CLOCK_EnablePll0>:
        return 0U;
    }
}

void CLOCK_EnablePll0(mcg_pll_config_t const *config)
{
    88b4:	b500      	push	{lr}
    88b6:	b085      	sub	sp, #20
    88b8:	9001      	str	r0, [sp, #4]
    assert(config);
    88ba:	9b01      	ldr	r3, [sp, #4]
    88bc:	2b00      	cmp	r3, #0
    88be:	d106      	bne.n	88ce <CLOCK_EnablePll0+0x1a>
    88c0:	4b1f      	ldr	r3, [pc, #124]	; (8940 <CLOCK_EnablePll0+0x8c>)
    88c2:	4a20      	ldr	r2, [pc, #128]	; (8944 <CLOCK_EnablePll0+0x90>)
    88c4:	f44f 7152 	mov.w	r1, #840	; 0x348
    88c8:	481f      	ldr	r0, [pc, #124]	; (8948 <CLOCK_EnablePll0+0x94>)
    88ca:	f001 fd2b 	bl	a324 <__assert_func>

    uint8_t mcg_c5 = 0U;
    88ce:	2300      	movs	r3, #0
    88d0:	f88d 300f 	strb.w	r3, [sp, #15]

    mcg_c5 |= MCG_C5_PRDIV0(config->prdiv);
    88d4:	9b01      	ldr	r3, [sp, #4]
    88d6:	785b      	ldrb	r3, [r3, #1]
    88d8:	f003 031f 	and.w	r3, r3, #31
    88dc:	b2da      	uxtb	r2, r3
    88de:	f89d 300f 	ldrb.w	r3, [sp, #15]
    88e2:	4313      	orrs	r3, r2
    88e4:	f88d 300f 	strb.w	r3, [sp, #15]
    __FSL_CLOCK_SECURE_WRITE(&MCG->C5, mcg_c5); /* Disable the PLL first. */
    88e8:	4a18      	ldr	r2, [pc, #96]	; (894c <CLOCK_EnablePll0+0x98>)
    88ea:	f89d 300f 	ldrb.w	r3, [sp, #15]
    88ee:	7013      	strb	r3, [r2, #0]

    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C6, MCG_C6_VDIV0_MASK, MCG_C6_VDIV0(config->vdiv));
    88f0:	4917      	ldr	r1, [pc, #92]	; (8950 <CLOCK_EnablePll0+0x9c>)
    88f2:	4b17      	ldr	r3, [pc, #92]	; (8950 <CLOCK_EnablePll0+0x9c>)
    88f4:	781b      	ldrb	r3, [r3, #0]
    88f6:	b2db      	uxtb	r3, r3
    88f8:	f023 031f 	bic.w	r3, r3, #31
    88fc:	b2da      	uxtb	r2, r3
    88fe:	9b01      	ldr	r3, [sp, #4]
    8900:	789b      	ldrb	r3, [r3, #2]
    8902:	f003 031f 	and.w	r3, r3, #31
    8906:	b2db      	uxtb	r3, r3
    8908:	4313      	orrs	r3, r2
    890a:	b2db      	uxtb	r3, r3
    890c:	700b      	strb	r3, [r1, #0]

    /* Set enable mode. */
    __FSL_CLOCK_SECURE_BITS_SET(&MCG->C5, ((uint32_t)kMCG_PllEnableIndependent | (uint32_t)config->enableMode));
    890e:	490f      	ldr	r1, [pc, #60]	; (894c <CLOCK_EnablePll0+0x98>)
    8910:	4b0e      	ldr	r3, [pc, #56]	; (894c <CLOCK_EnablePll0+0x98>)
    8912:	781b      	ldrb	r3, [r3, #0]
    8914:	b2da      	uxtb	r2, r3
    8916:	9b01      	ldr	r3, [sp, #4]
    8918:	781b      	ldrb	r3, [r3, #0]
    891a:	4313      	orrs	r3, r2
    891c:	b2db      	uxtb	r3, r3
    891e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    8922:	b2db      	uxtb	r3, r3
    8924:	700b      	strb	r3, [r1, #0]

    /* Wait for PLL lock. */
    while (!(MCG->S & MCG_S_LOCK0_MASK))
    8926:	bf00      	nop
    8928:	4b0a      	ldr	r3, [pc, #40]	; (8954 <CLOCK_EnablePll0+0xa0>)
    892a:	799b      	ldrb	r3, [r3, #6]
    892c:	b2db      	uxtb	r3, r3
    892e:	f003 0340 	and.w	r3, r3, #64	; 0x40
    8932:	2b00      	cmp	r3, #0
    8934:	d0f8      	beq.n	8928 <CLOCK_EnablePll0+0x74>
    {
    }
}
    8936:	bf00      	nop
    8938:	b005      	add	sp, #20
    893a:	f85d fb04 	ldr.w	pc, [sp], #4
    893e:	bf00      	nop
    8940:	000115b4 	.word	0x000115b4
    8944:	000127dc 	.word	0x000127dc
    8948:	00011538 	.word	0x00011538
    894c:	40064004 	.word	0x40064004
    8950:	40064005 	.word	0x40064005
    8954:	40064000 	.word	0x40064000

00008958 <CLOCK_InitOsc0>:
        MCG->S = MCG_S_LOLS0_MASK;
    }
}

void CLOCK_InitOsc0(osc_config_t const *config)
{
    8958:	b500      	push	{lr}
    895a:	b085      	sub	sp, #20
    895c:	9001      	str	r0, [sp, #4]
    uint8_t range = CLOCK_GetOscRangeFromFreq(config->freq);
    895e:	9b01      	ldr	r3, [sp, #4]
    8960:	681b      	ldr	r3, [r3, #0]
    8962:	4618      	mov	r0, r3
    8964:	f7ff fc94 	bl	8290 <CLOCK_GetOscRangeFromFreq>
    8968:	4603      	mov	r3, r0
    896a:	f88d 300f 	strb.w	r3, [sp, #15]

    OSC_SetCapLoad(OSC0, config->capLoad);
    896e:	9b01      	ldr	r3, [sp, #4]
    8970:	791b      	ldrb	r3, [r3, #4]
    8972:	4619      	mov	r1, r3
    8974:	481b      	ldr	r0, [pc, #108]	; (89e4 <CLOCK_InitOsc0+0x8c>)
    8976:	f7ff fb80 	bl	807a <OSC_SetCapLoad>
    OSC_SetExtRefClkConfig(OSC0, &config->oscerConfig);
    897a:	9b01      	ldr	r3, [sp, #4]
    897c:	3306      	adds	r3, #6
    897e:	4619      	mov	r1, r3
    8980:	4818      	ldr	r0, [pc, #96]	; (89e4 <CLOCK_InitOsc0+0x8c>)
    8982:	f7ff fb5f 	bl	8044 <OSC_SetExtRefClkConfig>

    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C2, OSC_MODE_MASK, MCG_C2_RANGE(range) | (uint8_t)config->workMode);
    8986:	4818      	ldr	r0, [pc, #96]	; (89e8 <CLOCK_InitOsc0+0x90>)
    8988:	4b17      	ldr	r3, [pc, #92]	; (89e8 <CLOCK_InitOsc0+0x90>)
    898a:	781b      	ldrb	r3, [r3, #0]
    898c:	b2db      	uxtb	r3, r3
    898e:	f023 033c 	bic.w	r3, r3, #60	; 0x3c
    8992:	b2da      	uxtb	r2, r3
    8994:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8998:	011b      	lsls	r3, r3, #4
    899a:	b2db      	uxtb	r3, r3
    899c:	f003 0330 	and.w	r3, r3, #48	; 0x30
    89a0:	b2d9      	uxtb	r1, r3
    89a2:	9b01      	ldr	r3, [sp, #4]
    89a4:	795b      	ldrb	r3, [r3, #5]
    89a6:	430b      	orrs	r3, r1
    89a8:	b2db      	uxtb	r3, r3
    89aa:	f003 033c 	and.w	r3, r3, #60	; 0x3c
    89ae:	b2db      	uxtb	r3, r3
    89b0:	4313      	orrs	r3, r2
    89b2:	b2db      	uxtb	r3, r3
    89b4:	7003      	strb	r3, [r0, #0]

    if ((kOSC_ModeExt != config->workMode) && (OSC0->CR & OSC_CR_ERCLKEN_MASK))
    89b6:	9b01      	ldr	r3, [sp, #4]
    89b8:	795b      	ldrb	r3, [r3, #5]
    89ba:	2b00      	cmp	r3, #0
    89bc:	d00d      	beq.n	89da <CLOCK_InitOsc0+0x82>
    89be:	4b09      	ldr	r3, [pc, #36]	; (89e4 <CLOCK_InitOsc0+0x8c>)
    89c0:	781b      	ldrb	r3, [r3, #0]
    89c2:	b2db      	uxtb	r3, r3
    89c4:	b25b      	sxtb	r3, r3
    89c6:	2b00      	cmp	r3, #0
    89c8:	da07      	bge.n	89da <CLOCK_InitOsc0+0x82>
    {
        /* Wait for stable. */
        while (!(MCG->S & MCG_S_OSCINIT0_MASK))
    89ca:	bf00      	nop
    89cc:	4b07      	ldr	r3, [pc, #28]	; (89ec <CLOCK_InitOsc0+0x94>)
    89ce:	799b      	ldrb	r3, [r3, #6]
    89d0:	b2db      	uxtb	r3, r3
    89d2:	f003 0302 	and.w	r3, r3, #2
    89d6:	2b00      	cmp	r3, #0
    89d8:	d0f8      	beq.n	89cc <CLOCK_InitOsc0+0x74>
        {
        }
    }
}
    89da:	bf00      	nop
    89dc:	b005      	add	sp, #20
    89de:	f85d fb04 	ldr.w	pc, [sp], #4
    89e2:	bf00      	nop
    89e4:	40065000 	.word	0x40065000
    89e8:	40064001 	.word	0x40064001
    89ec:	40064000 	.word	0x40064000

000089f0 <CLOCK_SetPbeMode>:

    return kStatus_Success;
}

status_t CLOCK_SetPbeMode(mcg_pll_clk_select_t pllcs, mcg_pll_config_t const *config)
{
    89f0:	b500      	push	{lr}
    89f2:	b083      	sub	sp, #12
    89f4:	4603      	mov	r3, r0
    89f6:	9100      	str	r1, [sp, #0]
    89f8:	f88d 3007 	strb.w	r3, [sp, #7]
    assert(config);
    89fc:	9b00      	ldr	r3, [sp, #0]
    89fe:	2b00      	cmp	r3, #0
    8a00:	d106      	bne.n	8a10 <CLOCK_SetPbeMode+0x20>
    8a02:	4b25      	ldr	r3, [pc, #148]	; (8a98 <CLOCK_SetPbeMode+0xa8>)
    8a04:	4a25      	ldr	r2, [pc, #148]	; (8a9c <CLOCK_SetPbeMode+0xac>)
    8a06:	f240 51be 	movw	r1, #1470	; 0x5be
    8a0a:	4825      	ldr	r0, [pc, #148]	; (8aa0 <CLOCK_SetPbeMode+0xb0>)
    8a0c:	f001 fc8a 	bl	a324 <__assert_func>

    /*
       This function is designed to change MCG to PBE mode from PEE/BLPE/FBE,
       but with this workflow, the source mode could be all modes except PEI/PBI.
     */
    __FSL_CLOCK_SECURE_BITS_CLEAR(&MCG->C2, MCG_C2_LP_MASK); /* Disable lowpower. */
    8a10:	4a24      	ldr	r2, [pc, #144]	; (8aa4 <CLOCK_SetPbeMode+0xb4>)
    8a12:	4b24      	ldr	r3, [pc, #144]	; (8aa4 <CLOCK_SetPbeMode+0xb4>)
    8a14:	781b      	ldrb	r3, [r3, #0]
    8a16:	b2db      	uxtb	r3, r3
    8a18:	f023 0302 	bic.w	r3, r3, #2
    8a1c:	b2db      	uxtb	r3, r3
    8a1e:	7013      	strb	r3, [r2, #0]

    /* Change to use external clock first. */
    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C1, MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK, MCG_C1_CLKS(kMCG_ClkOutSrcExternal));
    8a20:	4a21      	ldr	r2, [pc, #132]	; (8aa8 <CLOCK_SetPbeMode+0xb8>)
    8a22:	4b21      	ldr	r3, [pc, #132]	; (8aa8 <CLOCK_SetPbeMode+0xb8>)
    8a24:	781b      	ldrb	r3, [r3, #0]
    8a26:	b2db      	uxtb	r3, r3
    8a28:	f003 033b 	and.w	r3, r3, #59	; 0x3b
    8a2c:	b2db      	uxtb	r3, r3
    8a2e:	f063 037f 	orn	r3, r3, #127	; 0x7f
    8a32:	b2db      	uxtb	r3, r3
    8a34:	7013      	strb	r3, [r2, #0]

    /* Wait for CLKST clock status bits to show clock source is ext ref clk */
    while ((MCG->S & (MCG_S_IREFST_MASK | MCG_S_CLKST_MASK)) !=
    8a36:	bf00      	nop
    8a38:	4b1b      	ldr	r3, [pc, #108]	; (8aa8 <CLOCK_SetPbeMode+0xb8>)
    8a3a:	799b      	ldrb	r3, [r3, #6]
    8a3c:	b2db      	uxtb	r3, r3
    8a3e:	f003 031c 	and.w	r3, r3, #28
    8a42:	2b08      	cmp	r3, #8
    8a44:	d1f8      	bne.n	8a38 <CLOCK_SetPbeMode+0x48>
           (MCG_S_IREFST(kMCG_FllSrcExternal) | MCG_S_CLKST(kMCG_ClkOutStatExt)))
    {
    }

    /* Disable PLL first, then configure PLL. */
    __FSL_CLOCK_SECURE_BITS_CLEAR(&MCG->C6, MCG_C6_PLLS_MASK);
    8a46:	4a19      	ldr	r2, [pc, #100]	; (8aac <CLOCK_SetPbeMode+0xbc>)
    8a48:	4b18      	ldr	r3, [pc, #96]	; (8aac <CLOCK_SetPbeMode+0xbc>)
    8a4a:	781b      	ldrb	r3, [r3, #0]
    8a4c:	b2db      	uxtb	r3, r3
    8a4e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    8a52:	b2db      	uxtb	r3, r3
    8a54:	7013      	strb	r3, [r2, #0]
    while (MCG->S & MCG_S_PLLST_MASK)
    8a56:	bf00      	nop
    8a58:	4b13      	ldr	r3, [pc, #76]	; (8aa8 <CLOCK_SetPbeMode+0xb8>)
    8a5a:	799b      	ldrb	r3, [r3, #6]
    8a5c:	b2db      	uxtb	r3, r3
    8a5e:	f003 0320 	and.w	r3, r3, #32
    8a62:	2b00      	cmp	r3, #0
    8a64:	d1f8      	bne.n	8a58 <CLOCK_SetPbeMode+0x68>
    {
    }

    /* Configure the PLL. */
    {
        CLOCK_EnablePll0(config);
    8a66:	9800      	ldr	r0, [sp, #0]
    8a68:	f7ff ff24 	bl	88b4 <CLOCK_EnablePll0>
    }

    /* Change to PLL mode. */
    __FSL_CLOCK_SECURE_BITS_SET(&MCG->C6, MCG_C6_PLLS_MASK);
    8a6c:	4a0f      	ldr	r2, [pc, #60]	; (8aac <CLOCK_SetPbeMode+0xbc>)
    8a6e:	4b0f      	ldr	r3, [pc, #60]	; (8aac <CLOCK_SetPbeMode+0xbc>)
    8a70:	781b      	ldrb	r3, [r3, #0]
    8a72:	b2db      	uxtb	r3, r3
    8a74:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    8a78:	b2db      	uxtb	r3, r3
    8a7a:	7013      	strb	r3, [r2, #0]

    /* Wait for PLL mode changed. */
    while (!(MCG->S & MCG_S_PLLST_MASK))
    8a7c:	bf00      	nop
    8a7e:	4b0a      	ldr	r3, [pc, #40]	; (8aa8 <CLOCK_SetPbeMode+0xb8>)
    8a80:	799b      	ldrb	r3, [r3, #6]
    8a82:	b2db      	uxtb	r3, r3
    8a84:	f003 0320 	and.w	r3, r3, #32
    8a88:	2b00      	cmp	r3, #0
    8a8a:	d0f8      	beq.n	8a7e <CLOCK_SetPbeMode+0x8e>
    {
    }

    return kStatus_Success;
    8a8c:	2300      	movs	r3, #0
}
    8a8e:	4618      	mov	r0, r3
    8a90:	b003      	add	sp, #12
    8a92:	f85d fb04 	ldr.w	pc, [sp], #4
    8a96:	bf00      	nop
    8a98:	000115b4 	.word	0x000115b4
    8a9c:	000127f0 	.word	0x000127f0
    8aa0:	00011538 	.word	0x00011538
    8aa4:	40064001 	.word	0x40064001
    8aa8:	40064000 	.word	0x40064000
    8aac:	40064005 	.word	0x40064005

00008ab0 <CLOCK_BootToPeeMode>:

    return kStatus_Success;
}

status_t CLOCK_BootToPeeMode(mcg_oscsel_t oscsel, mcg_pll_clk_select_t pllcs, mcg_pll_config_t const *config)
{
    8ab0:	b500      	push	{lr}
    8ab2:	b083      	sub	sp, #12
    8ab4:	4603      	mov	r3, r0
    8ab6:	9200      	str	r2, [sp, #0]
    8ab8:	f88d 3007 	strb.w	r3, [sp, #7]
    8abc:	460b      	mov	r3, r1
    8abe:	f88d 3006 	strb.w	r3, [sp, #6]
    assert(config);
    8ac2:	9b00      	ldr	r3, [sp, #0]
    8ac4:	2b00      	cmp	r3, #0
    8ac6:	d106      	bne.n	8ad6 <CLOCK_BootToPeeMode+0x26>
    8ac8:	4b13      	ldr	r3, [pc, #76]	; (8b18 <CLOCK_BootToPeeMode+0x68>)
    8aca:	4a14      	ldr	r2, [pc, #80]	; (8b1c <CLOCK_BootToPeeMode+0x6c>)
    8acc:	f240 615d 	movw	r1, #1629	; 0x65d
    8ad0:	4813      	ldr	r0, [pc, #76]	; (8b20 <CLOCK_BootToPeeMode+0x70>)
    8ad2:	f001 fc27 	bl	a324 <__assert_func>

    CLOCK_SetExternalRefClkConfig(oscsel);
    8ad6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8ada:	4618      	mov	r0, r3
    8adc:	f7ff fe0a 	bl	86f4 <CLOCK_SetExternalRefClkConfig>

    CLOCK_SetPbeMode(pllcs, config);
    8ae0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8ae4:	9900      	ldr	r1, [sp, #0]
    8ae6:	4618      	mov	r0, r3
    8ae8:	f7ff ff82 	bl	89f0 <CLOCK_SetPbeMode>

    /* Change to use PLL output clock. */
    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C1, MCG_C1_CLKS_MASK, MCG_C1_CLKS(kMCG_ClkOutSrcOut));
    8aec:	4a0d      	ldr	r2, [pc, #52]	; (8b24 <CLOCK_BootToPeeMode+0x74>)
    8aee:	4b0d      	ldr	r3, [pc, #52]	; (8b24 <CLOCK_BootToPeeMode+0x74>)
    8af0:	781b      	ldrb	r3, [r3, #0]
    8af2:	b2db      	uxtb	r3, r3
    8af4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    8af8:	b2db      	uxtb	r3, r3
    8afa:	7013      	strb	r3, [r2, #0]
    while (MCG_S_CLKST_VAL != kMCG_ClkOutStatPll)
    8afc:	bf00      	nop
    8afe:	4b09      	ldr	r3, [pc, #36]	; (8b24 <CLOCK_BootToPeeMode+0x74>)
    8b00:	799b      	ldrb	r3, [r3, #6]
    8b02:	b2db      	uxtb	r3, r3
    8b04:	089b      	lsrs	r3, r3, #2
    8b06:	f003 0303 	and.w	r3, r3, #3
    8b0a:	2b03      	cmp	r3, #3
    8b0c:	d1f7      	bne.n	8afe <CLOCK_BootToPeeMode+0x4e>
    {
    }

    return kStatus_Success;
    8b0e:	2300      	movs	r3, #0
}
    8b10:	4618      	mov	r0, r3
    8b12:	b003      	add	sp, #12
    8b14:	f85d fb04 	ldr.w	pc, [sp], #4
    8b18:	000115b4 	.word	0x000115b4
    8b1c:	00012804 	.word	0x00012804
    8b20:	00011538 	.word	0x00011538
    8b24:	40064000 	.word	0x40064000

00008b28 <DSPI_IsMaster>:
 *
 * @param base DSPI peripheral address.
 * @return Returns true if the module is in master mode or false if the module is in slave mode.
 */
static inline bool DSPI_IsMaster(SPI_Type *base)
{
    8b28:	b082      	sub	sp, #8
    8b2a:	9001      	str	r0, [sp, #4]
    return (bool)((base->MCR) & SPI_MCR_MSTR_MASK);
    8b2c:	9b01      	ldr	r3, [sp, #4]
    8b2e:	681b      	ldr	r3, [r3, #0]
    8b30:	0fdb      	lsrs	r3, r3, #31
    8b32:	b2db      	uxtb	r3, r3
}
    8b34:	4618      	mov	r0, r3
    8b36:	b002      	add	sp, #8
    8b38:	4770      	bx	lr
	...

00008b3c <DSPI_CommonIRQHandler>:
        handle->errorCount++;
    }
}

static void DSPI_CommonIRQHandler(SPI_Type *base, void *param)
{
    8b3c:	b500      	push	{lr}
    8b3e:	b083      	sub	sp, #12
    8b40:	9001      	str	r0, [sp, #4]
    8b42:	9100      	str	r1, [sp, #0]
    if (DSPI_IsMaster(base))
    8b44:	9801      	ldr	r0, [sp, #4]
    8b46:	f7ff ffef 	bl	8b28 <DSPI_IsMaster>
    8b4a:	4603      	mov	r3, r0
    8b4c:	2b00      	cmp	r3, #0
    8b4e:	d005      	beq.n	8b5c <DSPI_CommonIRQHandler+0x20>
    {
        s_dspiMasterIsr(base, (dspi_master_handle_t *)param);
    8b50:	4b07      	ldr	r3, [pc, #28]	; (8b70 <DSPI_CommonIRQHandler+0x34>)
    8b52:	681b      	ldr	r3, [r3, #0]
    8b54:	9900      	ldr	r1, [sp, #0]
    8b56:	9801      	ldr	r0, [sp, #4]
    8b58:	4798      	blx	r3
    }
    else
    {
        s_dspiSlaveIsr(base, (dspi_slave_handle_t *)param);
    }
}
    8b5a:	e004      	b.n	8b66 <DSPI_CommonIRQHandler+0x2a>
        s_dspiSlaveIsr(base, (dspi_slave_handle_t *)param);
    8b5c:	4b05      	ldr	r3, [pc, #20]	; (8b74 <DSPI_CommonIRQHandler+0x38>)
    8b5e:	681b      	ldr	r3, [r3, #0]
    8b60:	9900      	ldr	r1, [sp, #0]
    8b62:	9801      	ldr	r0, [sp, #4]
    8b64:	4798      	blx	r3
}
    8b66:	bf00      	nop
    8b68:	b003      	add	sp, #12
    8b6a:	f85d fb04 	ldr.w	pc, [sp], #4
    8b6e:	bf00      	nop
    8b70:	20001498 	.word	0x20001498
    8b74:	2000149c 	.word	0x2000149c

00008b78 <SPI0_DriverIRQHandler>:

#if defined(SPI0)
void SPI0_DriverIRQHandler(void)
{
    8b78:	b508      	push	{r3, lr}
    assert(g_dspiHandle[0]);
    8b7a:	4b09      	ldr	r3, [pc, #36]	; (8ba0 <SPI0_DriverIRQHandler+0x28>)
    8b7c:	681b      	ldr	r3, [r3, #0]
    8b7e:	2b00      	cmp	r3, #0
    8b80:	d106      	bne.n	8b90 <SPI0_DriverIRQHandler+0x18>
    8b82:	4b08      	ldr	r3, [pc, #32]	; (8ba4 <SPI0_DriverIRQHandler+0x2c>)
    8b84:	4a08      	ldr	r2, [pc, #32]	; (8ba8 <SPI0_DriverIRQHandler+0x30>)
    8b86:	f240 6161 	movw	r1, #1633	; 0x661
    8b8a:	4808      	ldr	r0, [pc, #32]	; (8bac <SPI0_DriverIRQHandler+0x34>)
    8b8c:	f001 fbca 	bl	a324 <__assert_func>
    DSPI_CommonIRQHandler(SPI0, g_dspiHandle[0]);
    8b90:	4b03      	ldr	r3, [pc, #12]	; (8ba0 <SPI0_DriverIRQHandler+0x28>)
    8b92:	681b      	ldr	r3, [r3, #0]
    8b94:	4619      	mov	r1, r3
    8b96:	4806      	ldr	r0, [pc, #24]	; (8bb0 <SPI0_DriverIRQHandler+0x38>)
    8b98:	f7ff ffd0 	bl	8b3c <DSPI_CommonIRQHandler>
}
    8b9c:	bf00      	nop
    8b9e:	bd08      	pop	{r3, pc}
    8ba0:	2000148c 	.word	0x2000148c
    8ba4:	00011680 	.word	0x00011680
    8ba8:	00012818 	.word	0x00012818
    8bac:	000115e0 	.word	0x000115e0
    8bb0:	4002c000 	.word	0x4002c000

00008bb4 <SPI1_DriverIRQHandler>:
#endif

#if defined(SPI1)
void SPI1_DriverIRQHandler(void)
{
    8bb4:	b508      	push	{r3, lr}
    assert(g_dspiHandle[1]);
    8bb6:	4b09      	ldr	r3, [pc, #36]	; (8bdc <SPI1_DriverIRQHandler+0x28>)
    8bb8:	685b      	ldr	r3, [r3, #4]
    8bba:	2b00      	cmp	r3, #0
    8bbc:	d106      	bne.n	8bcc <SPI1_DriverIRQHandler+0x18>
    8bbe:	4b08      	ldr	r3, [pc, #32]	; (8be0 <SPI1_DriverIRQHandler+0x2c>)
    8bc0:	4a08      	ldr	r2, [pc, #32]	; (8be4 <SPI1_DriverIRQHandler+0x30>)
    8bc2:	f240 6169 	movw	r1, #1641	; 0x669
    8bc6:	4808      	ldr	r0, [pc, #32]	; (8be8 <SPI1_DriverIRQHandler+0x34>)
    8bc8:	f001 fbac 	bl	a324 <__assert_func>
    DSPI_CommonIRQHandler(SPI1, g_dspiHandle[1]);
    8bcc:	4b03      	ldr	r3, [pc, #12]	; (8bdc <SPI1_DriverIRQHandler+0x28>)
    8bce:	685b      	ldr	r3, [r3, #4]
    8bd0:	4619      	mov	r1, r3
    8bd2:	4806      	ldr	r0, [pc, #24]	; (8bec <SPI1_DriverIRQHandler+0x38>)
    8bd4:	f7ff ffb2 	bl	8b3c <DSPI_CommonIRQHandler>
}
    8bd8:	bf00      	nop
    8bda:	bd08      	pop	{r3, pc}
    8bdc:	2000148c 	.word	0x2000148c
    8be0:	00011690 	.word	0x00011690
    8be4:	00012830 	.word	0x00012830
    8be8:	000115e0 	.word	0x000115e0
    8bec:	4002d000 	.word	0x4002d000

00008bf0 <SPI2_DriverIRQHandler>:
#endif

#if defined(SPI2)
void SPI2_DriverIRQHandler(void)
{
    8bf0:	b508      	push	{r3, lr}
    assert(g_dspiHandle[2]);
    8bf2:	4b09      	ldr	r3, [pc, #36]	; (8c18 <SPI2_DriverIRQHandler+0x28>)
    8bf4:	689b      	ldr	r3, [r3, #8]
    8bf6:	2b00      	cmp	r3, #0
    8bf8:	d106      	bne.n	8c08 <SPI2_DriverIRQHandler+0x18>
    8bfa:	4b08      	ldr	r3, [pc, #32]	; (8c1c <SPI2_DriverIRQHandler+0x2c>)
    8bfc:	4a08      	ldr	r2, [pc, #32]	; (8c20 <SPI2_DriverIRQHandler+0x30>)
    8bfe:	f240 6171 	movw	r1, #1649	; 0x671
    8c02:	4808      	ldr	r0, [pc, #32]	; (8c24 <SPI2_DriverIRQHandler+0x34>)
    8c04:	f001 fb8e 	bl	a324 <__assert_func>
    DSPI_CommonIRQHandler(SPI2, g_dspiHandle[2]);
    8c08:	4b03      	ldr	r3, [pc, #12]	; (8c18 <SPI2_DriverIRQHandler+0x28>)
    8c0a:	689b      	ldr	r3, [r3, #8]
    8c0c:	4619      	mov	r1, r3
    8c0e:	4806      	ldr	r0, [pc, #24]	; (8c28 <SPI2_DriverIRQHandler+0x38>)
    8c10:	f7ff ff94 	bl	8b3c <DSPI_CommonIRQHandler>
}
    8c14:	bf00      	nop
    8c16:	bd08      	pop	{r3, pc}
    8c18:	2000148c 	.word	0x2000148c
    8c1c:	000116a0 	.word	0x000116a0
    8c20:	00012848 	.word	0x00012848
    8c24:	000115e0 	.word	0x000115e0
    8c28:	400ac000 	.word	0x400ac000

00008c2c <EDMA_HandleIRQ>:
    /* Cancel all next TCD transfer. */
    handle->base->TCD[handle->channel].DLAST_SGA = 0;
}

void EDMA_HandleIRQ(edma_handle_t *handle)
{
    8c2c:	b510      	push	{r4, lr}
    8c2e:	b088      	sub	sp, #32
    8c30:	9001      	str	r0, [sp, #4]
    assert(handle != NULL);
    8c32:	9b01      	ldr	r3, [sp, #4]
    8c34:	2b00      	cmp	r3, #0
    8c36:	d106      	bne.n	8c46 <EDMA_HandleIRQ+0x1a>
    8c38:	4b51      	ldr	r3, [pc, #324]	; (8d80 <EDMA_HandleIRQ+0x154>)
    8c3a:	4a52      	ldr	r2, [pc, #328]	; (8d84 <EDMA_HandleIRQ+0x158>)
    8c3c:	f240 313a 	movw	r1, #826	; 0x33a
    8c40:	4851      	ldr	r0, [pc, #324]	; (8d88 <EDMA_HandleIRQ+0x15c>)
    8c42:	f001 fb6f 	bl	a324 <__assert_func>

    /* Clear EDMA interrupt flag */
    handle->base->CINT = handle->channel;
    8c46:	9b01      	ldr	r3, [sp, #4]
    8c48:	689b      	ldr	r3, [r3, #8]
    8c4a:	9a01      	ldr	r2, [sp, #4]
    8c4c:	7c12      	ldrb	r2, [r2, #16]
    8c4e:	77da      	strb	r2, [r3, #31]
    if ((handle->tcdPool == NULL) && (handle->callback != NULL))
    8c50:	9b01      	ldr	r3, [sp, #4]
    8c52:	68db      	ldr	r3, [r3, #12]
    8c54:	2b00      	cmp	r3, #0
    8c56:	d10c      	bne.n	8c72 <EDMA_HandleIRQ+0x46>
    8c58:	9b01      	ldr	r3, [sp, #4]
    8c5a:	681b      	ldr	r3, [r3, #0]
    8c5c:	2b00      	cmp	r3, #0
    8c5e:	d008      	beq.n	8c72 <EDMA_HandleIRQ+0x46>
    {
        (handle->callback)(handle, handle->userData, true, 0);
    8c60:	9b01      	ldr	r3, [sp, #4]
    8c62:	681c      	ldr	r4, [r3, #0]
    8c64:	9b01      	ldr	r3, [sp, #4]
    8c66:	6859      	ldr	r1, [r3, #4]
    8c68:	2300      	movs	r3, #0
    8c6a:	2201      	movs	r2, #1
    8c6c:	9801      	ldr	r0, [sp, #4]
    8c6e:	47a0      	blx	r4
        if (handle->callback)
        {
            (handle->callback)(handle, handle->userData, transfer_done, tcds_done);
        }
    }
}
    8c70:	e082      	b.n	8d78 <EDMA_HandleIRQ+0x14c>
        uint32_t sga = handle->base->TCD[handle->channel].DLAST_SGA;
    8c72:	9b01      	ldr	r3, [sp, #4]
    8c74:	689a      	ldr	r2, [r3, #8]
    8c76:	9b01      	ldr	r3, [sp, #4]
    8c78:	7c1b      	ldrb	r3, [r3, #16]
    8c7a:	015b      	lsls	r3, r3, #5
    8c7c:	4413      	add	r3, r2
    8c7e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    8c82:	3318      	adds	r3, #24
    8c84:	681b      	ldr	r3, [r3, #0]
    8c86:	9305      	str	r3, [sp, #20]
        transfer_done = ((handle->base->TCD[handle->channel].CSR & DMA_CSR_DONE_MASK) != 0);
    8c88:	9b01      	ldr	r3, [sp, #4]
    8c8a:	689a      	ldr	r2, [r3, #8]
    8c8c:	9b01      	ldr	r3, [sp, #4]
    8c8e:	7c1b      	ldrb	r3, [r3, #16]
    8c90:	015b      	lsls	r3, r3, #5
    8c92:	4413      	add	r3, r2
    8c94:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    8c98:	331c      	adds	r3, #28
    8c9a:	881b      	ldrh	r3, [r3, #0]
    8c9c:	b29b      	uxth	r3, r3
    8c9e:	f003 0380 	and.w	r3, r3, #128	; 0x80
    8ca2:	2b00      	cmp	r3, #0
    8ca4:	bf14      	ite	ne
    8ca6:	2301      	movne	r3, #1
    8ca8:	2300      	moveq	r3, #0
    8caa:	f88d 3013 	strb.w	r3, [sp, #19]
        sga -= (uint32_t)handle->tcdPool;
    8cae:	9b01      	ldr	r3, [sp, #4]
    8cb0:	68db      	ldr	r3, [r3, #12]
    8cb2:	461a      	mov	r2, r3
    8cb4:	9b05      	ldr	r3, [sp, #20]
    8cb6:	1a9b      	subs	r3, r3, r2
    8cb8:	9305      	str	r3, [sp, #20]
        sga_index = sga / sizeof(edma_tcd_t);
    8cba:	9b05      	ldr	r3, [sp, #20]
    8cbc:	095b      	lsrs	r3, r3, #5
    8cbe:	9303      	str	r3, [sp, #12]
        if (transfer_done)
    8cc0:	f89d 3013 	ldrb.w	r3, [sp, #19]
    8cc4:	2b00      	cmp	r3, #0
    8cc6:	d003      	beq.n	8cd0 <EDMA_HandleIRQ+0xa4>
            new_header = sga_index;
    8cc8:	9b03      	ldr	r3, [sp, #12]
    8cca:	f88d 301b 	strb.w	r3, [sp, #27]
    8cce:	e00f      	b.n	8cf0 <EDMA_HandleIRQ+0xc4>
            new_header = sga_index ? sga_index - 1U : handle->tcdSize - 1U;
    8cd0:	9b03      	ldr	r3, [sp, #12]
    8cd2:	2b00      	cmp	r3, #0
    8cd4:	d004      	beq.n	8ce0 <EDMA_HandleIRQ+0xb4>
    8cd6:	9b03      	ldr	r3, [sp, #12]
    8cd8:	b2db      	uxtb	r3, r3
    8cda:	3b01      	subs	r3, #1
    8cdc:	b2db      	uxtb	r3, r3
    8cde:	e005      	b.n	8cec <EDMA_HandleIRQ+0xc0>
    8ce0:	9b01      	ldr	r3, [sp, #4]
    8ce2:	7d1b      	ldrb	r3, [r3, #20]
    8ce4:	b25b      	sxtb	r3, r3
    8ce6:	b2db      	uxtb	r3, r3
    8ce8:	3b01      	subs	r3, #1
    8cea:	b2db      	uxtb	r3, r3
    8cec:	f88d 301b 	strb.w	r3, [sp, #27]
        if (new_header == handle->header)
    8cf0:	f89d 301b 	ldrb.w	r3, [sp, #27]
    8cf4:	9a01      	ldr	r2, [sp, #4]
    8cf6:	7c52      	ldrb	r2, [r2, #17]
    8cf8:	b252      	sxtb	r2, r2
    8cfa:	4293      	cmp	r3, r2
    8cfc:	d10f      	bne.n	8d1e <EDMA_HandleIRQ+0xf2>
            if (handle->tcdUsed == handle->tcdSize)
    8cfe:	9b01      	ldr	r3, [sp, #4]
    8d00:	7cdb      	ldrb	r3, [r3, #19]
    8d02:	b25a      	sxtb	r2, r3
    8d04:	9b01      	ldr	r3, [sp, #4]
    8d06:	7d1b      	ldrb	r3, [r3, #20]
    8d08:	b25b      	sxtb	r3, r3
    8d0a:	429a      	cmp	r2, r3
    8d0c:	d104      	bne.n	8d18 <EDMA_HandleIRQ+0xec>
                tcds_done = handle->tcdUsed;
    8d0e:	9b01      	ldr	r3, [sp, #4]
    8d10:	7cdb      	ldrb	r3, [r3, #19]
    8d12:	b25b      	sxtb	r3, r3
    8d14:	9307      	str	r3, [sp, #28]
    8d16:	e013      	b.n	8d40 <EDMA_HandleIRQ+0x114>
                tcds_done = 0;
    8d18:	2300      	movs	r3, #0
    8d1a:	9307      	str	r3, [sp, #28]
    8d1c:	e010      	b.n	8d40 <EDMA_HandleIRQ+0x114>
            tcds_done = new_header - handle->header;
    8d1e:	f89d 301b 	ldrb.w	r3, [sp, #27]
    8d22:	9a01      	ldr	r2, [sp, #4]
    8d24:	7c52      	ldrb	r2, [r2, #17]
    8d26:	b252      	sxtb	r2, r2
    8d28:	1a9b      	subs	r3, r3, r2
    8d2a:	9307      	str	r3, [sp, #28]
            if (tcds_done < 0)
    8d2c:	9b07      	ldr	r3, [sp, #28]
    8d2e:	2b00      	cmp	r3, #0
    8d30:	da06      	bge.n	8d40 <EDMA_HandleIRQ+0x114>
                tcds_done += handle->tcdSize;
    8d32:	9b01      	ldr	r3, [sp, #4]
    8d34:	7d1b      	ldrb	r3, [r3, #20]
    8d36:	b25b      	sxtb	r3, r3
    8d38:	461a      	mov	r2, r3
    8d3a:	9b07      	ldr	r3, [sp, #28]
    8d3c:	4413      	add	r3, r2
    8d3e:	9307      	str	r3, [sp, #28]
        handle->header = new_header;
    8d40:	f99d 201b 	ldrsb.w	r2, [sp, #27]
    8d44:	9b01      	ldr	r3, [sp, #4]
    8d46:	745a      	strb	r2, [r3, #17]
        handle->tcdUsed -= tcds_done;
    8d48:	9b01      	ldr	r3, [sp, #4]
    8d4a:	7cdb      	ldrb	r3, [r3, #19]
    8d4c:	b25b      	sxtb	r3, r3
    8d4e:	b2da      	uxtb	r2, r3
    8d50:	9b07      	ldr	r3, [sp, #28]
    8d52:	b2db      	uxtb	r3, r3
    8d54:	1ad3      	subs	r3, r2, r3
    8d56:	b2db      	uxtb	r3, r3
    8d58:	b25a      	sxtb	r2, r3
    8d5a:	9b01      	ldr	r3, [sp, #4]
    8d5c:	74da      	strb	r2, [r3, #19]
        if (handle->callback)
    8d5e:	9b01      	ldr	r3, [sp, #4]
    8d60:	681b      	ldr	r3, [r3, #0]
    8d62:	2b00      	cmp	r3, #0
    8d64:	d008      	beq.n	8d78 <EDMA_HandleIRQ+0x14c>
            (handle->callback)(handle, handle->userData, transfer_done, tcds_done);
    8d66:	9b01      	ldr	r3, [sp, #4]
    8d68:	681c      	ldr	r4, [r3, #0]
    8d6a:	9b01      	ldr	r3, [sp, #4]
    8d6c:	6859      	ldr	r1, [r3, #4]
    8d6e:	9b07      	ldr	r3, [sp, #28]
    8d70:	f89d 2013 	ldrb.w	r2, [sp, #19]
    8d74:	9801      	ldr	r0, [sp, #4]
    8d76:	47a0      	blx	r4
}
    8d78:	bf00      	nop
    8d7a:	b008      	add	sp, #32
    8d7c:	bd10      	pop	{r4, pc}
    8d7e:	bf00      	nop
    8d80:	000117f4 	.word	0x000117f4
    8d84:	00012860 	.word	0x00012860
    8d88:	000116d8 	.word	0x000116d8

00008d8c <DMA0_DriverIRQHandler>:

/* 4 channels (No Shared): kv10  */
#if defined(FSL_FEATURE_EDMA_MODULE_CHANNEL) && FSL_FEATURE_EDMA_MODULE_CHANNEL > 0

void DMA0_DriverIRQHandler(void)
{
    8d8c:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[0]);
    8d8e:	4b03      	ldr	r3, [pc, #12]	; (8d9c <DMA0_DriverIRQHandler+0x10>)
    8d90:	681b      	ldr	r3, [r3, #0]
    8d92:	4618      	mov	r0, r3
    8d94:	f7ff ff4a 	bl	8c2c <EDMA_HandleIRQ>
}
    8d98:	bf00      	nop
    8d9a:	bd08      	pop	{r3, pc}
    8d9c:	200014a0 	.word	0x200014a0

00008da0 <DMA1_DriverIRQHandler>:

void DMA1_DriverIRQHandler(void)
{
    8da0:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[1]);
    8da2:	4b03      	ldr	r3, [pc, #12]	; (8db0 <DMA1_DriverIRQHandler+0x10>)
    8da4:	685b      	ldr	r3, [r3, #4]
    8da6:	4618      	mov	r0, r3
    8da8:	f7ff ff40 	bl	8c2c <EDMA_HandleIRQ>
}
    8dac:	bf00      	nop
    8dae:	bd08      	pop	{r3, pc}
    8db0:	200014a0 	.word	0x200014a0

00008db4 <DMA2_DriverIRQHandler>:

void DMA2_DriverIRQHandler(void)
{
    8db4:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[2]);
    8db6:	4b03      	ldr	r3, [pc, #12]	; (8dc4 <DMA2_DriverIRQHandler+0x10>)
    8db8:	689b      	ldr	r3, [r3, #8]
    8dba:	4618      	mov	r0, r3
    8dbc:	f7ff ff36 	bl	8c2c <EDMA_HandleIRQ>
}
    8dc0:	bf00      	nop
    8dc2:	bd08      	pop	{r3, pc}
    8dc4:	200014a0 	.word	0x200014a0

00008dc8 <DMA3_DriverIRQHandler>:

void DMA3_DriverIRQHandler(void)
{
    8dc8:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[3]);
    8dca:	4b03      	ldr	r3, [pc, #12]	; (8dd8 <DMA3_DriverIRQHandler+0x10>)
    8dcc:	68db      	ldr	r3, [r3, #12]
    8dce:	4618      	mov	r0, r3
    8dd0:	f7ff ff2c 	bl	8c2c <EDMA_HandleIRQ>
}
    8dd4:	bf00      	nop
    8dd6:	bd08      	pop	{r3, pc}
    8dd8:	200014a0 	.word	0x200014a0

00008ddc <DMA4_DriverIRQHandler>:

/* 8 channels (No Shared) */
#if defined(FSL_FEATURE_EDMA_MODULE_CHANNEL) && FSL_FEATURE_EDMA_MODULE_CHANNEL > 4U

void DMA4_DriverIRQHandler(void)
{
    8ddc:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[4]);
    8dde:	4b03      	ldr	r3, [pc, #12]	; (8dec <DMA4_DriverIRQHandler+0x10>)
    8de0:	691b      	ldr	r3, [r3, #16]
    8de2:	4618      	mov	r0, r3
    8de4:	f7ff ff22 	bl	8c2c <EDMA_HandleIRQ>
}
    8de8:	bf00      	nop
    8dea:	bd08      	pop	{r3, pc}
    8dec:	200014a0 	.word	0x200014a0

00008df0 <DMA5_DriverIRQHandler>:

void DMA5_DriverIRQHandler(void)
{
    8df0:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[5]);
    8df2:	4b03      	ldr	r3, [pc, #12]	; (8e00 <DMA5_DriverIRQHandler+0x10>)
    8df4:	695b      	ldr	r3, [r3, #20]
    8df6:	4618      	mov	r0, r3
    8df8:	f7ff ff18 	bl	8c2c <EDMA_HandleIRQ>
}
    8dfc:	bf00      	nop
    8dfe:	bd08      	pop	{r3, pc}
    8e00:	200014a0 	.word	0x200014a0

00008e04 <DMA6_DriverIRQHandler>:

void DMA6_DriverIRQHandler(void)
{
    8e04:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[6]);
    8e06:	4b03      	ldr	r3, [pc, #12]	; (8e14 <DMA6_DriverIRQHandler+0x10>)
    8e08:	699b      	ldr	r3, [r3, #24]
    8e0a:	4618      	mov	r0, r3
    8e0c:	f7ff ff0e 	bl	8c2c <EDMA_HandleIRQ>
}
    8e10:	bf00      	nop
    8e12:	bd08      	pop	{r3, pc}
    8e14:	200014a0 	.word	0x200014a0

00008e18 <DMA7_DriverIRQHandler>:

void DMA7_DriverIRQHandler(void)
{
    8e18:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[7]);
    8e1a:	4b03      	ldr	r3, [pc, #12]	; (8e28 <DMA7_DriverIRQHandler+0x10>)
    8e1c:	69db      	ldr	r3, [r3, #28]
    8e1e:	4618      	mov	r0, r3
    8e20:	f7ff ff04 	bl	8c2c <EDMA_HandleIRQ>
}
    8e24:	bf00      	nop
    8e26:	bd08      	pop	{r3, pc}
    8e28:	200014a0 	.word	0x200014a0

00008e2c <DMA8_DriverIRQHandler>:

/* 16 channels (No Shared) */
#if defined(FSL_FEATURE_EDMA_MODULE_CHANNEL) && FSL_FEATURE_EDMA_MODULE_CHANNEL > 8U

void DMA8_DriverIRQHandler(void)
{
    8e2c:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[8]);
    8e2e:	4b03      	ldr	r3, [pc, #12]	; (8e3c <DMA8_DriverIRQHandler+0x10>)
    8e30:	6a1b      	ldr	r3, [r3, #32]
    8e32:	4618      	mov	r0, r3
    8e34:	f7ff fefa 	bl	8c2c <EDMA_HandleIRQ>
}
    8e38:	bf00      	nop
    8e3a:	bd08      	pop	{r3, pc}
    8e3c:	200014a0 	.word	0x200014a0

00008e40 <DMA9_DriverIRQHandler>:

void DMA9_DriverIRQHandler(void)
{
    8e40:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[9]);
    8e42:	4b03      	ldr	r3, [pc, #12]	; (8e50 <DMA9_DriverIRQHandler+0x10>)
    8e44:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8e46:	4618      	mov	r0, r3
    8e48:	f7ff fef0 	bl	8c2c <EDMA_HandleIRQ>
}
    8e4c:	bf00      	nop
    8e4e:	bd08      	pop	{r3, pc}
    8e50:	200014a0 	.word	0x200014a0

00008e54 <DMA10_DriverIRQHandler>:

void DMA10_DriverIRQHandler(void)
{
    8e54:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[10]);
    8e56:	4b03      	ldr	r3, [pc, #12]	; (8e64 <DMA10_DriverIRQHandler+0x10>)
    8e58:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    8e5a:	4618      	mov	r0, r3
    8e5c:	f7ff fee6 	bl	8c2c <EDMA_HandleIRQ>
}
    8e60:	bf00      	nop
    8e62:	bd08      	pop	{r3, pc}
    8e64:	200014a0 	.word	0x200014a0

00008e68 <DMA11_DriverIRQHandler>:

void DMA11_DriverIRQHandler(void)
{
    8e68:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[11]);
    8e6a:	4b03      	ldr	r3, [pc, #12]	; (8e78 <DMA11_DriverIRQHandler+0x10>)
    8e6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    8e6e:	4618      	mov	r0, r3
    8e70:	f7ff fedc 	bl	8c2c <EDMA_HandleIRQ>
}
    8e74:	bf00      	nop
    8e76:	bd08      	pop	{r3, pc}
    8e78:	200014a0 	.word	0x200014a0

00008e7c <DMA12_DriverIRQHandler>:

void DMA12_DriverIRQHandler(void)
{
    8e7c:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[12]);
    8e7e:	4b03      	ldr	r3, [pc, #12]	; (8e8c <DMA12_DriverIRQHandler+0x10>)
    8e80:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    8e82:	4618      	mov	r0, r3
    8e84:	f7ff fed2 	bl	8c2c <EDMA_HandleIRQ>
}
    8e88:	bf00      	nop
    8e8a:	bd08      	pop	{r3, pc}
    8e8c:	200014a0 	.word	0x200014a0

00008e90 <DMA13_DriverIRQHandler>:

void DMA13_DriverIRQHandler(void)
{
    8e90:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[13]);
    8e92:	4b03      	ldr	r3, [pc, #12]	; (8ea0 <DMA13_DriverIRQHandler+0x10>)
    8e94:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    8e96:	4618      	mov	r0, r3
    8e98:	f7ff fec8 	bl	8c2c <EDMA_HandleIRQ>
}
    8e9c:	bf00      	nop
    8e9e:	bd08      	pop	{r3, pc}
    8ea0:	200014a0 	.word	0x200014a0

00008ea4 <DMA14_DriverIRQHandler>:

void DMA14_DriverIRQHandler(void)
{
    8ea4:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[14]);
    8ea6:	4b03      	ldr	r3, [pc, #12]	; (8eb4 <DMA14_DriverIRQHandler+0x10>)
    8ea8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    8eaa:	4618      	mov	r0, r3
    8eac:	f7ff febe 	bl	8c2c <EDMA_HandleIRQ>
}
    8eb0:	bf00      	nop
    8eb2:	bd08      	pop	{r3, pc}
    8eb4:	200014a0 	.word	0x200014a0

00008eb8 <DMA15_DriverIRQHandler>:

void DMA15_DriverIRQHandler(void)
{
    8eb8:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[15]);
    8eba:	4b03      	ldr	r3, [pc, #12]	; (8ec8 <DMA15_DriverIRQHandler+0x10>)
    8ebc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    8ebe:	4618      	mov	r0, r3
    8ec0:	f7ff feb4 	bl	8c2c <EDMA_HandleIRQ>
}
    8ec4:	bf00      	nop
    8ec6:	bd08      	pop	{r3, pc}
    8ec8:	200014a0 	.word	0x200014a0

00008ecc <ENET_Transmit_IRQHandler>:
    ENET_Ptp1588TimerIRQHandler(ENET, s_ENETHandle[0]);
}
#endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */

void ENET_Transmit_IRQHandler(void)
{
    8ecc:	b508      	push	{r3, lr}
    s_enetTxIsr(ENET, s_ENETHandle[0]);
    8ece:	4b04      	ldr	r3, [pc, #16]	; (8ee0 <ENET_Transmit_IRQHandler+0x14>)
    8ed0:	681b      	ldr	r3, [r3, #0]
    8ed2:	4a04      	ldr	r2, [pc, #16]	; (8ee4 <ENET_Transmit_IRQHandler+0x18>)
    8ed4:	6812      	ldr	r2, [r2, #0]
    8ed6:	4611      	mov	r1, r2
    8ed8:	4803      	ldr	r0, [pc, #12]	; (8ee8 <ENET_Transmit_IRQHandler+0x1c>)
    8eda:	4798      	blx	r3
}
    8edc:	bf00      	nop
    8ede:	bd08      	pop	{r3, pc}
    8ee0:	200014e4 	.word	0x200014e4
    8ee4:	200014e0 	.word	0x200014e0
    8ee8:	400c0000 	.word	0x400c0000

00008eec <ENET_Receive_IRQHandler>:

void ENET_Receive_IRQHandler(void)
{
    8eec:	b508      	push	{r3, lr}
    s_enetRxIsr(ENET, s_ENETHandle[0]);
    8eee:	4b04      	ldr	r3, [pc, #16]	; (8f00 <ENET_Receive_IRQHandler+0x14>)
    8ef0:	681b      	ldr	r3, [r3, #0]
    8ef2:	4a04      	ldr	r2, [pc, #16]	; (8f04 <ENET_Receive_IRQHandler+0x18>)
    8ef4:	6812      	ldr	r2, [r2, #0]
    8ef6:	4611      	mov	r1, r2
    8ef8:	4803      	ldr	r0, [pc, #12]	; (8f08 <ENET_Receive_IRQHandler+0x1c>)
    8efa:	4798      	blx	r3
}
    8efc:	bf00      	nop
    8efe:	bd08      	pop	{r3, pc}
    8f00:	200014e8 	.word	0x200014e8
    8f04:	200014e0 	.word	0x200014e0
    8f08:	400c0000 	.word	0x400c0000

00008f0c <ENET_Error_IRQHandler>:

void ENET_Error_IRQHandler(void)
{
    8f0c:	b508      	push	{r3, lr}
    s_enetErrIsr(ENET, s_ENETHandle[0]);
    8f0e:	4b04      	ldr	r3, [pc, #16]	; (8f20 <ENET_Error_IRQHandler+0x14>)
    8f10:	681b      	ldr	r3, [r3, #0]
    8f12:	4a04      	ldr	r2, [pc, #16]	; (8f24 <ENET_Error_IRQHandler+0x18>)
    8f14:	6812      	ldr	r2, [r2, #0]
    8f16:	4611      	mov	r1, r2
    8f18:	4803      	ldr	r0, [pc, #12]	; (8f28 <ENET_Error_IRQHandler+0x1c>)
    8f1a:	4798      	blx	r3
}
    8f1c:	bf00      	nop
    8f1e:	bd08      	pop	{r3, pc}
    8f20:	200014ec 	.word	0x200014ec
    8f24:	200014e0 	.word	0x200014e0
    8f28:	400c0000 	.word	0x400c0000

00008f2c <CAN0_DriverIRQHandler>:
#endif
}

#if (FSL_FEATURE_SOC_FLEXCAN_COUNT > 0)
void CAN0_DriverIRQHandler(void)
{
    8f2c:	b508      	push	{r3, lr}
    assert(s_flexcanHandle[0]);
    8f2e:	4b0a      	ldr	r3, [pc, #40]	; (8f58 <CAN0_DriverIRQHandler+0x2c>)
    8f30:	681b      	ldr	r3, [r3, #0]
    8f32:	2b00      	cmp	r3, #0
    8f34:	d106      	bne.n	8f44 <CAN0_DriverIRQHandler+0x18>
    8f36:	4b09      	ldr	r3, [pc, #36]	; (8f5c <CAN0_DriverIRQHandler+0x30>)
    8f38:	4a09      	ldr	r2, [pc, #36]	; (8f60 <CAN0_DriverIRQHandler+0x34>)
    8f3a:	f240 511f 	movw	r1, #1311	; 0x51f
    8f3e:	4809      	ldr	r0, [pc, #36]	; (8f64 <CAN0_DriverIRQHandler+0x38>)
    8f40:	f001 f9f0 	bl	a324 <__assert_func>

    s_flexcanIsr(CAN0, s_flexcanHandle[0]);
    8f44:	4b08      	ldr	r3, [pc, #32]	; (8f68 <CAN0_DriverIRQHandler+0x3c>)
    8f46:	681b      	ldr	r3, [r3, #0]
    8f48:	4a03      	ldr	r2, [pc, #12]	; (8f58 <CAN0_DriverIRQHandler+0x2c>)
    8f4a:	6812      	ldr	r2, [r2, #0]
    8f4c:	4611      	mov	r1, r2
    8f4e:	4807      	ldr	r0, [pc, #28]	; (8f6c <CAN0_DriverIRQHandler+0x40>)
    8f50:	4798      	blx	r3
}
    8f52:	bf00      	nop
    8f54:	bd08      	pop	{r3, pc}
    8f56:	bf00      	nop
    8f58:	200014f0 	.word	0x200014f0
    8f5c:	00011c70 	.word	0x00011c70
    8f60:	00012870 	.word	0x00012870
    8f64:	0001196c 	.word	0x0001196c
    8f68:	200014f4 	.word	0x200014f4
    8f6c:	40024000 	.word	0x40024000

00008f70 <I2C_TransferCommonIRQHandler>:

    return result;
}

static void I2C_TransferCommonIRQHandler(I2C_Type *base, void *handle)
{
    8f70:	b500      	push	{lr}
    8f72:	b083      	sub	sp, #12
    8f74:	9001      	str	r0, [sp, #4]
    8f76:	9100      	str	r1, [sp, #0]
    /* Check if master interrupt. */
    if ((base->S & kI2C_ArbitrationLostFlag) || (base->C1 & I2C_C1_MST_MASK))
    8f78:	9b01      	ldr	r3, [sp, #4]
    8f7a:	78db      	ldrb	r3, [r3, #3]
    8f7c:	b2db      	uxtb	r3, r3
    8f7e:	f003 0310 	and.w	r3, r3, #16
    8f82:	2b00      	cmp	r3, #0
    8f84:	d106      	bne.n	8f94 <I2C_TransferCommonIRQHandler+0x24>
    8f86:	9b01      	ldr	r3, [sp, #4]
    8f88:	789b      	ldrb	r3, [r3, #2]
    8f8a:	b2db      	uxtb	r3, r3
    8f8c:	f003 0320 	and.w	r3, r3, #32
    8f90:	2b00      	cmp	r3, #0
    8f92:	d005      	beq.n	8fa0 <I2C_TransferCommonIRQHandler+0x30>
    {
        s_i2cMasterIsr(base, handle);
    8f94:	4b08      	ldr	r3, [pc, #32]	; (8fb8 <I2C_TransferCommonIRQHandler+0x48>)
    8f96:	681b      	ldr	r3, [r3, #0]
    8f98:	9900      	ldr	r1, [sp, #0]
    8f9a:	9801      	ldr	r0, [sp, #4]
    8f9c:	4798      	blx	r3
    8f9e:	e004      	b.n	8faa <I2C_TransferCommonIRQHandler+0x3a>
    }
    else
    {
        s_i2cSlaveIsr(base, handle);
    8fa0:	4b06      	ldr	r3, [pc, #24]	; (8fbc <I2C_TransferCommonIRQHandler+0x4c>)
    8fa2:	681b      	ldr	r3, [r3, #0]
    8fa4:	9900      	ldr	r1, [sp, #0]
    8fa6:	9801      	ldr	r0, [sp, #4]
    8fa8:	4798      	blx	r3
  __ASM volatile ("dsb 0xF":::"memory");
    8faa:	f3bf 8f4f 	dsb	sy
    }
    __DSB();
}
    8fae:	bf00      	nop
    8fb0:	b003      	add	sp, #12
    8fb2:	f85d fb04 	ldr.w	pc, [sp], #4
    8fb6:	bf00      	nop
    8fb8:	20001504 	.word	0x20001504
    8fbc:	20001508 	.word	0x20001508

00008fc0 <I2C0_DriverIRQHandler>:
        }
    }
}

void I2C0_DriverIRQHandler(void)
{
    8fc0:	b508      	push	{r3, lr}
    I2C_TransferCommonIRQHandler(I2C0, s_i2cHandle[0]);
    8fc2:	4b04      	ldr	r3, [pc, #16]	; (8fd4 <I2C0_DriverIRQHandler+0x14>)
    8fc4:	681b      	ldr	r3, [r3, #0]
    8fc6:	4619      	mov	r1, r3
    8fc8:	4803      	ldr	r0, [pc, #12]	; (8fd8 <I2C0_DriverIRQHandler+0x18>)
    8fca:	f7ff ffd1 	bl	8f70 <I2C_TransferCommonIRQHandler>
}
    8fce:	bf00      	nop
    8fd0:	bd08      	pop	{r3, pc}
    8fd2:	bf00      	nop
    8fd4:	200014f8 	.word	0x200014f8
    8fd8:	40066000 	.word	0x40066000

00008fdc <I2C1_DriverIRQHandler>:

#if (FSL_FEATURE_SOC_I2C_COUNT > 1)
void I2C1_DriverIRQHandler(void)
{
    8fdc:	b508      	push	{r3, lr}
    I2C_TransferCommonIRQHandler(I2C1, s_i2cHandle[1]);
    8fde:	4b04      	ldr	r3, [pc, #16]	; (8ff0 <I2C1_DriverIRQHandler+0x14>)
    8fe0:	685b      	ldr	r3, [r3, #4]
    8fe2:	4619      	mov	r1, r3
    8fe4:	4803      	ldr	r0, [pc, #12]	; (8ff4 <I2C1_DriverIRQHandler+0x18>)
    8fe6:	f7ff ffc3 	bl	8f70 <I2C_TransferCommonIRQHandler>
}
    8fea:	bf00      	nop
    8fec:	bd08      	pop	{r3, pc}
    8fee:	bf00      	nop
    8ff0:	200014f8 	.word	0x200014f8
    8ff4:	40067000 	.word	0x40067000

00008ff8 <I2C2_DriverIRQHandler>:
#endif /* I2C COUNT > 1 */

#if (FSL_FEATURE_SOC_I2C_COUNT > 2)
void I2C2_DriverIRQHandler(void)
{
    8ff8:	b508      	push	{r3, lr}
    I2C_TransferCommonIRQHandler(I2C2, s_i2cHandle[2]);
    8ffa:	4b04      	ldr	r3, [pc, #16]	; (900c <I2C2_DriverIRQHandler+0x14>)
    8ffc:	689b      	ldr	r3, [r3, #8]
    8ffe:	4619      	mov	r1, r3
    9000:	4803      	ldr	r0, [pc, #12]	; (9010 <I2C2_DriverIRQHandler+0x18>)
    9002:	f7ff ffb5 	bl	8f70 <I2C_TransferCommonIRQHandler>
}
    9006:	bf00      	nop
    9008:	bd08      	pop	{r3, pc}
    900a:	bf00      	nop
    900c:	200014f8 	.word	0x200014f8
    9010:	400e6000 	.word	0x400e6000

00009014 <CLOCK_EnableClock>:
{
    9014:	b084      	sub	sp, #16
    9016:	9001      	str	r0, [sp, #4]
    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
    9018:	9b01      	ldr	r3, [sp, #4]
    901a:	0c1b      	lsrs	r3, r3, #16
    901c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    9020:	f503 238e 	add.w	r3, r3, #290816	; 0x47000
    9024:	9303      	str	r3, [sp, #12]
    __FSL_CLOCK_SECURE_BITS_SET((volatile uint32_t *) regAddr, (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name)));
    9026:	9b03      	ldr	r3, [sp, #12]
    9028:	9a03      	ldr	r2, [sp, #12]
    902a:	6811      	ldr	r1, [r2, #0]
    902c:	9a01      	ldr	r2, [sp, #4]
    902e:	b292      	uxth	r2, r2
    9030:	2001      	movs	r0, #1
    9032:	fa00 f202 	lsl.w	r2, r0, r2
    9036:	430a      	orrs	r2, r1
    9038:	601a      	str	r2, [r3, #0]
}
    903a:	bf00      	nop
    903c:	b004      	add	sp, #16
    903e:	4770      	bx	lr

00009040 <PIT_GetInstance>:

/*******************************************************************************
 * Code
 ******************************************************************************/
static uint32_t PIT_GetInstance(PIT_Type *base)
{
    9040:	b500      	push	{lr}
    9042:	b085      	sub	sp, #20
    9044:	9001      	str	r0, [sp, #4]
    uint32_t instance;

    /* Find the instance index from base address mappings. */
    for (instance = 0; instance < FSL_FEATURE_SOC_PIT_COUNT; instance++)
    9046:	2300      	movs	r3, #0
    9048:	9303      	str	r3, [sp, #12]
    904a:	e006      	b.n	905a <PIT_GetInstance+0x1a>
    {
        if (s_pitBases[instance] == base)
    904c:	4a0c      	ldr	r2, [pc, #48]	; (9080 <PIT_GetInstance+0x40>)
    904e:	9b01      	ldr	r3, [sp, #4]
    9050:	429a      	cmp	r2, r3
    9052:	d006      	beq.n	9062 <PIT_GetInstance+0x22>
    for (instance = 0; instance < FSL_FEATURE_SOC_PIT_COUNT; instance++)
    9054:	9b03      	ldr	r3, [sp, #12]
    9056:	3301      	adds	r3, #1
    9058:	9303      	str	r3, [sp, #12]
    905a:	9b03      	ldr	r3, [sp, #12]
    905c:	2b00      	cmp	r3, #0
    905e:	d0f5      	beq.n	904c <PIT_GetInstance+0xc>
    9060:	e000      	b.n	9064 <PIT_GetInstance+0x24>
        {
            break;
    9062:	bf00      	nop
        }
    }

    assert(instance < FSL_FEATURE_SOC_PIT_COUNT);
    9064:	9b03      	ldr	r3, [sp, #12]
    9066:	2b00      	cmp	r3, #0
    9068:	d005      	beq.n	9076 <PIT_GetInstance+0x36>
    906a:	4b06      	ldr	r3, [pc, #24]	; (9084 <PIT_GetInstance+0x44>)
    906c:	4a06      	ldr	r2, [pc, #24]	; (9088 <PIT_GetInstance+0x48>)
    906e:	2148      	movs	r1, #72	; 0x48
    9070:	4806      	ldr	r0, [pc, #24]	; (908c <PIT_GetInstance+0x4c>)
    9072:	f001 f957 	bl	a324 <__assert_func>

    return instance;
    9076:	9b03      	ldr	r3, [sp, #12]
}
    9078:	4618      	mov	r0, r3
    907a:	b005      	add	sp, #20
    907c:	f85d fb04 	ldr.w	pc, [sp], #4
    9080:	40037000 	.word	0x40037000
    9084:	00011c84 	.word	0x00011c84
    9088:	00012888 	.word	0x00012888
    908c:	00011cac 	.word	0x00011cac

00009090 <PIT_Init>:

void PIT_Init(PIT_Type *base, const pit_config_t *config)
{
    9090:	b500      	push	{lr}
    9092:	b083      	sub	sp, #12
    9094:	9001      	str	r0, [sp, #4]
    9096:	9100      	str	r1, [sp, #0]
    assert(config);
    9098:	9b00      	ldr	r3, [sp, #0]
    909a:	2b00      	cmp	r3, #0
    909c:	d105      	bne.n	90aa <PIT_Init+0x1a>
    909e:	4b14      	ldr	r3, [pc, #80]	; (90f0 <PIT_Init+0x60>)
    90a0:	4a14      	ldr	r2, [pc, #80]	; (90f4 <PIT_Init+0x64>)
    90a2:	214f      	movs	r1, #79	; 0x4f
    90a4:	4814      	ldr	r0, [pc, #80]	; (90f8 <PIT_Init+0x68>)
    90a6:	f001 f93d 	bl	a324 <__assert_func>

#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    /* Ungate the PIT clock*/
    CLOCK_EnableClock(s_pitClocks[PIT_GetInstance(base)]);
    90aa:	9801      	ldr	r0, [sp, #4]
    90ac:	f7ff ffc8 	bl	9040 <PIT_GetInstance>
    90b0:	4b12      	ldr	r3, [pc, #72]	; (90fc <PIT_Init+0x6c>)
    90b2:	4618      	mov	r0, r3
    90b4:	f7ff ffae 	bl	9014 <CLOCK_EnableClock>
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */

    /* Enable PIT timers */
    base->MCR &= ~PIT_MCR_MDIS_MASK;
    90b8:	9b01      	ldr	r3, [sp, #4]
    90ba:	681b      	ldr	r3, [r3, #0]
    90bc:	f023 0202 	bic.w	r2, r3, #2
    90c0:	9b01      	ldr	r3, [sp, #4]
    90c2:	601a      	str	r2, [r3, #0]

    /* Config timer operation when in debug mode */
    if (config->enableRunInDebug)
    90c4:	9b00      	ldr	r3, [sp, #0]
    90c6:	781b      	ldrb	r3, [r3, #0]
    90c8:	2b00      	cmp	r3, #0
    90ca:	d006      	beq.n	90da <PIT_Init+0x4a>
    {
        base->MCR &= ~PIT_MCR_FRZ_MASK;
    90cc:	9b01      	ldr	r3, [sp, #4]
    90ce:	681b      	ldr	r3, [r3, #0]
    90d0:	f023 0201 	bic.w	r2, r3, #1
    90d4:	9b01      	ldr	r3, [sp, #4]
    90d6:	601a      	str	r2, [r3, #0]
    }
    else
    {
        base->MCR |= PIT_MCR_FRZ_MASK;
    }
}
    90d8:	e005      	b.n	90e6 <PIT_Init+0x56>
        base->MCR |= PIT_MCR_FRZ_MASK;
    90da:	9b01      	ldr	r3, [sp, #4]
    90dc:	681b      	ldr	r3, [r3, #0]
    90de:	f043 0201 	orr.w	r2, r3, #1
    90e2:	9b01      	ldr	r3, [sp, #4]
    90e4:	601a      	str	r2, [r3, #0]
}
    90e6:	bf00      	nop
    90e8:	b003      	add	sp, #12
    90ea:	f85d fb04 	ldr.w	pc, [sp], #4
    90ee:	bf00      	nop
    90f0:	00011d08 	.word	0x00011d08
    90f4:	00012898 	.word	0x00012898
    90f8:	00011cac 	.word	0x00011cac
    90fc:	103c0017 	.word	0x103c0017

00009100 <I2S0_Tx_DriverIRQHandler>:
        s_saiTxIsr(I2S0, s_saiHandle[0][0]);
    }
}
#else
void I2S0_Tx_DriverIRQHandler(void)
{
    9100:	b508      	push	{r3, lr}
    assert(s_saiHandle[0][0]);
    9102:	4b0a      	ldr	r3, [pc, #40]	; (912c <I2S0_Tx_DriverIRQHandler+0x2c>)
    9104:	681b      	ldr	r3, [r3, #0]
    9106:	2b00      	cmp	r3, #0
    9108:	d106      	bne.n	9118 <I2S0_Tx_DriverIRQHandler+0x18>
    910a:	4b09      	ldr	r3, [pc, #36]	; (9130 <I2S0_Tx_DriverIRQHandler+0x30>)
    910c:	4a09      	ldr	r2, [pc, #36]	; (9134 <I2S0_Tx_DriverIRQHandler+0x34>)
    910e:	f240 411a 	movw	r1, #1050	; 0x41a
    9112:	4809      	ldr	r0, [pc, #36]	; (9138 <I2S0_Tx_DriverIRQHandler+0x38>)
    9114:	f001 f906 	bl	a324 <__assert_func>
    s_saiTxIsr(I2S0, s_saiHandle[0][0]);
    9118:	4b08      	ldr	r3, [pc, #32]	; (913c <I2S0_Tx_DriverIRQHandler+0x3c>)
    911a:	681b      	ldr	r3, [r3, #0]
    911c:	4a03      	ldr	r2, [pc, #12]	; (912c <I2S0_Tx_DriverIRQHandler+0x2c>)
    911e:	6812      	ldr	r2, [r2, #0]
    9120:	4611      	mov	r1, r2
    9122:	4807      	ldr	r0, [pc, #28]	; (9140 <I2S0_Tx_DriverIRQHandler+0x40>)
    9124:	4798      	blx	r3
}
    9126:	bf00      	nop
    9128:	bd08      	pop	{r3, pc}
    912a:	bf00      	nop
    912c:	20002f64 	.word	0x20002f64
    9130:	00011d9c 	.word	0x00011d9c
    9134:	000128a4 	.word	0x000128a4
    9138:	00011d38 	.word	0x00011d38
    913c:	2000150c 	.word	0x2000150c
    9140:	4002f000 	.word	0x4002f000

00009144 <I2S0_Rx_DriverIRQHandler>:

void I2S0_Rx_DriverIRQHandler(void)
{
    9144:	b508      	push	{r3, lr}
    assert(s_saiHandle[0][1]);
    9146:	4b0a      	ldr	r3, [pc, #40]	; (9170 <I2S0_Rx_DriverIRQHandler+0x2c>)
    9148:	685b      	ldr	r3, [r3, #4]
    914a:	2b00      	cmp	r3, #0
    914c:	d106      	bne.n	915c <I2S0_Rx_DriverIRQHandler+0x18>
    914e:	4b09      	ldr	r3, [pc, #36]	; (9174 <I2S0_Rx_DriverIRQHandler+0x30>)
    9150:	4a09      	ldr	r2, [pc, #36]	; (9178 <I2S0_Rx_DriverIRQHandler+0x34>)
    9152:	f44f 6184 	mov.w	r1, #1056	; 0x420
    9156:	4809      	ldr	r0, [pc, #36]	; (917c <I2S0_Rx_DriverIRQHandler+0x38>)
    9158:	f001 f8e4 	bl	a324 <__assert_func>
    s_saiRxIsr(I2S0, s_saiHandle[0][1]);
    915c:	4b08      	ldr	r3, [pc, #32]	; (9180 <I2S0_Rx_DriverIRQHandler+0x3c>)
    915e:	681b      	ldr	r3, [r3, #0]
    9160:	4a03      	ldr	r2, [pc, #12]	; (9170 <I2S0_Rx_DriverIRQHandler+0x2c>)
    9162:	6852      	ldr	r2, [r2, #4]
    9164:	4611      	mov	r1, r2
    9166:	4807      	ldr	r0, [pc, #28]	; (9184 <I2S0_Rx_DriverIRQHandler+0x40>)
    9168:	4798      	blx	r3
}
    916a:	bf00      	nop
    916c:	bd08      	pop	{r3, pc}
    916e:	bf00      	nop
    9170:	20002f64 	.word	0x20002f64
    9174:	00011db0 	.word	0x00011db0
    9178:	000128c0 	.word	0x000128c0
    917c:	00011d38 	.word	0x00011d38
    9180:	20001510 	.word	0x20001510
    9184:	4002f000 	.word	0x4002f000

00009188 <SDHC_DriverIRQHandler>:
    SDHC_ClearInterruptStatusFlags(base, interruptFlags);
}

#if defined(SDHC)
void SDHC_DriverIRQHandler(void)
{
    9188:	b508      	push	{r3, lr}
    assert(s_sdhcHandle[0]);
    918a:	4b0a      	ldr	r3, [pc, #40]	; (91b4 <SDHC_DriverIRQHandler+0x2c>)
    918c:	681b      	ldr	r3, [r3, #0]
    918e:	2b00      	cmp	r3, #0
    9190:	d106      	bne.n	91a0 <SDHC_DriverIRQHandler+0x18>
    9192:	4b09      	ldr	r3, [pc, #36]	; (91b8 <SDHC_DriverIRQHandler+0x30>)
    9194:	4a09      	ldr	r2, [pc, #36]	; (91bc <SDHC_DriverIRQHandler+0x34>)
    9196:	f44f 61a9 	mov.w	r1, #1352	; 0x548
    919a:	4809      	ldr	r0, [pc, #36]	; (91c0 <SDHC_DriverIRQHandler+0x38>)
    919c:	f001 f8c2 	bl	a324 <__assert_func>

    s_sdhcIsr(SDHC, s_sdhcHandle[0]);
    91a0:	4b08      	ldr	r3, [pc, #32]	; (91c4 <SDHC_DriverIRQHandler+0x3c>)
    91a2:	681b      	ldr	r3, [r3, #0]
    91a4:	4a03      	ldr	r2, [pc, #12]	; (91b4 <SDHC_DriverIRQHandler+0x2c>)
    91a6:	6812      	ldr	r2, [r2, #0]
    91a8:	4611      	mov	r1, r2
    91aa:	4807      	ldr	r0, [pc, #28]	; (91c8 <SDHC_DriverIRQHandler+0x40>)
    91ac:	4798      	blx	r3
}
    91ae:	bf00      	nop
    91b0:	bd08      	pop	{r3, pc}
    91b2:	bf00      	nop
    91b4:	20001514 	.word	0x20001514
    91b8:	00012170 	.word	0x00012170
    91bc:	000128dc 	.word	0x000128dc
    91c0:	00011e58 	.word	0x00011e58
    91c4:	20001518 	.word	0x20001518
    91c8:	400b1000 	.word	0x400b1000

000091cc <SMC_SetPowerModeWait>:
    return kStatus_Success;
}
#endif /* FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE */

status_t SMC_SetPowerModeWait(SMC_Type *base)
{
    91cc:	b082      	sub	sp, #8
    91ce:	9001      	str	r0, [sp, #4]
    /* configure Normal Wait mode */
    SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
    91d0:	4a07      	ldr	r2, [pc, #28]	; (91f0 <SMC_SetPowerModeWait+0x24>)
    91d2:	4b07      	ldr	r3, [pc, #28]	; (91f0 <SMC_SetPowerModeWait+0x24>)
    91d4:	691b      	ldr	r3, [r3, #16]
    91d6:	f023 0304 	bic.w	r3, r3, #4
    91da:	6113      	str	r3, [r2, #16]
    91dc:	f3bf 8f4f 	dsb	sy
    __DSB();
    __WFI();
    91e0:	bf30      	wfi
  __ASM volatile ("isb 0xF":::"memory");
    91e2:	f3bf 8f6f 	isb	sy
    __ISB();

    return kStatus_Success;
    91e6:	2300      	movs	r3, #0
}
    91e8:	4618      	mov	r0, r3
    91ea:	b002      	add	sp, #8
    91ec:	4770      	bx	lr
    91ee:	bf00      	nop
    91f0:	e000ed00 	.word	0xe000ed00

000091f4 <CLOCK_EnableClock>:
{
    91f4:	b084      	sub	sp, #16
    91f6:	9001      	str	r0, [sp, #4]
    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
    91f8:	9b01      	ldr	r3, [sp, #4]
    91fa:	0c1b      	lsrs	r3, r3, #16
    91fc:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    9200:	f503 238e 	add.w	r3, r3, #290816	; 0x47000
    9204:	9303      	str	r3, [sp, #12]
    __FSL_CLOCK_SECURE_BITS_SET((volatile uint32_t *) regAddr, (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name)));
    9206:	9b03      	ldr	r3, [sp, #12]
    9208:	9a03      	ldr	r2, [sp, #12]
    920a:	6811      	ldr	r1, [r2, #0]
    920c:	9a01      	ldr	r2, [sp, #4]
    920e:	b292      	uxth	r2, r2
    9210:	2001      	movs	r0, #1
    9212:	fa00 f202 	lsl.w	r2, r0, r2
    9216:	430a      	orrs	r2, r1
    9218:	601a      	str	r2, [r3, #0]
}
    921a:	bf00      	nop
    921c:	b004      	add	sp, #16
    921e:	4770      	bx	lr

00009220 <UART_GetInstance>:
/*******************************************************************************
 * Code
 ******************************************************************************/

uint32_t UART_GetInstance(UART_Type *base)
{
    9220:	b500      	push	{lr}
    9222:	b085      	sub	sp, #20
    9224:	9001      	str	r0, [sp, #4]
    uint32_t instance;
    uint32_t uartArrayCount = (sizeof(s_uartBases) / sizeof(s_uartBases[0]));
    9226:	2306      	movs	r3, #6
    9228:	9302      	str	r3, [sp, #8]

    /* Find the instance index from base address mappings. */
    for (instance = 0; instance < uartArrayCount; instance++)
    922a:	2300      	movs	r3, #0
    922c:	9303      	str	r3, [sp, #12]
    922e:	e009      	b.n	9244 <UART_GetInstance+0x24>
    {
        if (s_uartBases[instance] == base)
    9230:	4a0f      	ldr	r2, [pc, #60]	; (9270 <UART_GetInstance+0x50>)
    9232:	9b03      	ldr	r3, [sp, #12]
    9234:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    9238:	9b01      	ldr	r3, [sp, #4]
    923a:	429a      	cmp	r2, r3
    923c:	d007      	beq.n	924e <UART_GetInstance+0x2e>
    for (instance = 0; instance < uartArrayCount; instance++)
    923e:	9b03      	ldr	r3, [sp, #12]
    9240:	3301      	adds	r3, #1
    9242:	9303      	str	r3, [sp, #12]
    9244:	9a03      	ldr	r2, [sp, #12]
    9246:	9b02      	ldr	r3, [sp, #8]
    9248:	429a      	cmp	r2, r3
    924a:	d3f1      	bcc.n	9230 <UART_GetInstance+0x10>
    924c:	e000      	b.n	9250 <UART_GetInstance+0x30>
        {
            break;
    924e:	bf00      	nop
        }
    }

    assert(instance < uartArrayCount);
    9250:	9a03      	ldr	r2, [sp, #12]
    9252:	9b02      	ldr	r3, [sp, #8]
    9254:	429a      	cmp	r2, r3
    9256:	d305      	bcc.n	9264 <UART_GetInstance+0x44>
    9258:	4b06      	ldr	r3, [pc, #24]	; (9274 <UART_GetInstance+0x54>)
    925a:	4a07      	ldr	r2, [pc, #28]	; (9278 <UART_GetInstance+0x58>)
    925c:	21a9      	movs	r1, #169	; 0xa9
    925e:	4807      	ldr	r0, [pc, #28]	; (927c <UART_GetInstance+0x5c>)
    9260:	f001 f860 	bl	a324 <__assert_func>

    return instance;
    9264:	9b03      	ldr	r3, [sp, #12]
}
    9266:	4618      	mov	r0, r3
    9268:	b005      	add	sp, #20
    926a:	f85d fb04 	ldr.w	pc, [sp], #4
    926e:	bf00      	nop
    9270:	000128f4 	.word	0x000128f4
    9274:	00012180 	.word	0x00012180
    9278:	00012924 	.word	0x00012924
    927c:	0001219c 	.word	0x0001219c

00009280 <UART_Init>:

    return full;
}

status_t UART_Init(UART_Type *base, const uart_config_t *config, uint32_t srcClock_Hz)
{
    9280:	b500      	push	{lr}
    9282:	b089      	sub	sp, #36	; 0x24
    9284:	9003      	str	r0, [sp, #12]
    9286:	9102      	str	r1, [sp, #8]
    9288:	9201      	str	r2, [sp, #4]
    assert(config);
    928a:	9b02      	ldr	r3, [sp, #8]
    928c:	2b00      	cmp	r3, #0
    928e:	d105      	bne.n	929c <UART_Init+0x1c>
    9290:	4bac      	ldr	r3, [pc, #688]	; (9544 <UART_Init+0x2c4>)
    9292:	4aad      	ldr	r2, [pc, #692]	; (9548 <UART_Init+0x2c8>)
    9294:	21d4      	movs	r1, #212	; 0xd4
    9296:	48ad      	ldr	r0, [pc, #692]	; (954c <UART_Init+0x2cc>)
    9298:	f001 f844 	bl	a324 <__assert_func>
    assert(config->baudRate_Bps);
    929c:	9b02      	ldr	r3, [sp, #8]
    929e:	681b      	ldr	r3, [r3, #0]
    92a0:	2b00      	cmp	r3, #0
    92a2:	d105      	bne.n	92b0 <UART_Init+0x30>
    92a4:	4baa      	ldr	r3, [pc, #680]	; (9550 <UART_Init+0x2d0>)
    92a6:	4aa8      	ldr	r2, [pc, #672]	; (9548 <UART_Init+0x2c8>)
    92a8:	21d5      	movs	r1, #213	; 0xd5
    92aa:	48a8      	ldr	r0, [pc, #672]	; (954c <UART_Init+0x2cc>)
    92ac:	f001 f83a 	bl	a324 <__assert_func>
#if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    assert(FSL_FEATURE_UART_FIFO_SIZEn(base) >= config->txFifoWatermark);
    92b0:	9b03      	ldr	r3, [sp, #12]
    92b2:	4aa8      	ldr	r2, [pc, #672]	; (9554 <UART_Init+0x2d4>)
    92b4:	4293      	cmp	r3, r2
    92b6:	d020      	beq.n	92fa <UART_Init+0x7a>
    92b8:	9b03      	ldr	r3, [sp, #12]
    92ba:	4aa7      	ldr	r2, [pc, #668]	; (9558 <UART_Init+0x2d8>)
    92bc:	4293      	cmp	r3, r2
    92be:	d01a      	beq.n	92f6 <UART_Init+0x76>
    92c0:	9b03      	ldr	r3, [sp, #12]
    92c2:	4aa6      	ldr	r2, [pc, #664]	; (955c <UART_Init+0x2dc>)
    92c4:	4293      	cmp	r3, r2
    92c6:	d014      	beq.n	92f2 <UART_Init+0x72>
    92c8:	9b03      	ldr	r3, [sp, #12]
    92ca:	4aa5      	ldr	r2, [pc, #660]	; (9560 <UART_Init+0x2e0>)
    92cc:	4293      	cmp	r3, r2
    92ce:	d00e      	beq.n	92ee <UART_Init+0x6e>
    92d0:	9b03      	ldr	r3, [sp, #12]
    92d2:	4aa4      	ldr	r2, [pc, #656]	; (9564 <UART_Init+0x2e4>)
    92d4:	4293      	cmp	r3, r2
    92d6:	d008      	beq.n	92ea <UART_Init+0x6a>
    92d8:	9b03      	ldr	r3, [sp, #12]
    92da:	4aa3      	ldr	r2, [pc, #652]	; (9568 <UART_Init+0x2e8>)
    92dc:	4293      	cmp	r3, r2
    92de:	d101      	bne.n	92e4 <UART_Init+0x64>
    92e0:	2301      	movs	r3, #1
    92e2:	e00b      	b.n	92fc <UART_Init+0x7c>
    92e4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    92e8:	e008      	b.n	92fc <UART_Init+0x7c>
    92ea:	2301      	movs	r3, #1
    92ec:	e006      	b.n	92fc <UART_Init+0x7c>
    92ee:	2301      	movs	r3, #1
    92f0:	e004      	b.n	92fc <UART_Init+0x7c>
    92f2:	2301      	movs	r3, #1
    92f4:	e002      	b.n	92fc <UART_Init+0x7c>
    92f6:	2308      	movs	r3, #8
    92f8:	e000      	b.n	92fc <UART_Init+0x7c>
    92fa:	2308      	movs	r3, #8
    92fc:	9a02      	ldr	r2, [sp, #8]
    92fe:	7992      	ldrb	r2, [r2, #6]
    9300:	4293      	cmp	r3, r2
    9302:	da05      	bge.n	9310 <UART_Init+0x90>
    9304:	4b99      	ldr	r3, [pc, #612]	; (956c <UART_Init+0x2ec>)
    9306:	4a90      	ldr	r2, [pc, #576]	; (9548 <UART_Init+0x2c8>)
    9308:	21d7      	movs	r1, #215	; 0xd7
    930a:	4890      	ldr	r0, [pc, #576]	; (954c <UART_Init+0x2cc>)
    930c:	f001 f80a 	bl	a324 <__assert_func>
    assert(FSL_FEATURE_UART_FIFO_SIZEn(base) >= config->rxFifoWatermark);
    9310:	9b03      	ldr	r3, [sp, #12]
    9312:	4a90      	ldr	r2, [pc, #576]	; (9554 <UART_Init+0x2d4>)
    9314:	4293      	cmp	r3, r2
    9316:	d020      	beq.n	935a <UART_Init+0xda>
    9318:	9b03      	ldr	r3, [sp, #12]
    931a:	4a8f      	ldr	r2, [pc, #572]	; (9558 <UART_Init+0x2d8>)
    931c:	4293      	cmp	r3, r2
    931e:	d01a      	beq.n	9356 <UART_Init+0xd6>
    9320:	9b03      	ldr	r3, [sp, #12]
    9322:	4a8e      	ldr	r2, [pc, #568]	; (955c <UART_Init+0x2dc>)
    9324:	4293      	cmp	r3, r2
    9326:	d014      	beq.n	9352 <UART_Init+0xd2>
    9328:	9b03      	ldr	r3, [sp, #12]
    932a:	4a8d      	ldr	r2, [pc, #564]	; (9560 <UART_Init+0x2e0>)
    932c:	4293      	cmp	r3, r2
    932e:	d00e      	beq.n	934e <UART_Init+0xce>
    9330:	9b03      	ldr	r3, [sp, #12]
    9332:	4a8c      	ldr	r2, [pc, #560]	; (9564 <UART_Init+0x2e4>)
    9334:	4293      	cmp	r3, r2
    9336:	d008      	beq.n	934a <UART_Init+0xca>
    9338:	9b03      	ldr	r3, [sp, #12]
    933a:	4a8b      	ldr	r2, [pc, #556]	; (9568 <UART_Init+0x2e8>)
    933c:	4293      	cmp	r3, r2
    933e:	d101      	bne.n	9344 <UART_Init+0xc4>
    9340:	2301      	movs	r3, #1
    9342:	e00b      	b.n	935c <UART_Init+0xdc>
    9344:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    9348:	e008      	b.n	935c <UART_Init+0xdc>
    934a:	2301      	movs	r3, #1
    934c:	e006      	b.n	935c <UART_Init+0xdc>
    934e:	2301      	movs	r3, #1
    9350:	e004      	b.n	935c <UART_Init+0xdc>
    9352:	2301      	movs	r3, #1
    9354:	e002      	b.n	935c <UART_Init+0xdc>
    9356:	2308      	movs	r3, #8
    9358:	e000      	b.n	935c <UART_Init+0xdc>
    935a:	2308      	movs	r3, #8
    935c:	9a02      	ldr	r2, [sp, #8]
    935e:	79d2      	ldrb	r2, [r2, #7]
    9360:	4293      	cmp	r3, r2
    9362:	da05      	bge.n	9370 <UART_Init+0xf0>
    9364:	4b82      	ldr	r3, [pc, #520]	; (9570 <UART_Init+0x2f0>)
    9366:	4a78      	ldr	r2, [pc, #480]	; (9548 <UART_Init+0x2c8>)
    9368:	21d8      	movs	r1, #216	; 0xd8
    936a:	4878      	ldr	r0, [pc, #480]	; (954c <UART_Init+0x2cc>)
    936c:	f000 ffda 	bl	a324 <__assert_func>
#endif

    uint16_t sbr = 0;
    9370:	2300      	movs	r3, #0
    9372:	f8ad 301e 	strh.w	r3, [sp, #30]
    uint8_t temp = 0;
    9376:	2300      	movs	r3, #0
    9378:	f88d 301d 	strb.w	r3, [sp, #29]
    uint32_t baudDiff = 0;
    937c:	2300      	movs	r3, #0
    937e:	9306      	str	r3, [sp, #24]

    /* Calculate the baud rate modulo divisor, sbr*/
    sbr = srcClock_Hz / (config->baudRate_Bps * 16);
    9380:	9b02      	ldr	r3, [sp, #8]
    9382:	681b      	ldr	r3, [r3, #0]
    9384:	011b      	lsls	r3, r3, #4
    9386:	9a01      	ldr	r2, [sp, #4]
    9388:	fbb2 f3f3 	udiv	r3, r2, r3
    938c:	f8ad 301e 	strh.w	r3, [sp, #30]
    /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
    if (sbr == 0)
    9390:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    9394:	2b00      	cmp	r3, #0
    9396:	d102      	bne.n	939e <UART_Init+0x11e>
    {
        sbr = 1;
    9398:	2301      	movs	r3, #1
    939a:	f8ad 301e 	strh.w	r3, [sp, #30]
    }
#if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    /* Determine if a fractional divider is needed to fine tune closer to the
     * desired baud, each value of brfa is in 1/32 increments,
     * hence the multiply-by-32. */
    uint32_t tempBaud = 0;
    939e:	2300      	movs	r3, #0
    93a0:	9305      	str	r3, [sp, #20]

    uint16_t brfa = (2 * srcClock_Hz / (config->baudRate_Bps)) - 32 * sbr;
    93a2:	9b01      	ldr	r3, [sp, #4]
    93a4:	005a      	lsls	r2, r3, #1
    93a6:	9b02      	ldr	r3, [sp, #8]
    93a8:	681b      	ldr	r3, [r3, #0]
    93aa:	fbb2 f3f3 	udiv	r3, r2, r3
    93ae:	b29a      	uxth	r2, r3
    93b0:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    93b4:	015b      	lsls	r3, r3, #5
    93b6:	b29b      	uxth	r3, r3
    93b8:	1ad3      	subs	r3, r2, r3
    93ba:	f8ad 3012 	strh.w	r3, [sp, #18]

    /* Calculate the baud rate based on the temporary SBR values and BRFA */
    tempBaud = (srcClock_Hz * 2 / ((sbr * 32 + brfa)));
    93be:	9b01      	ldr	r3, [sp, #4]
    93c0:	005b      	lsls	r3, r3, #1
    93c2:	f8bd 201e 	ldrh.w	r2, [sp, #30]
    93c6:	0151      	lsls	r1, r2, #5
    93c8:	f8bd 2012 	ldrh.w	r2, [sp, #18]
    93cc:	440a      	add	r2, r1
    93ce:	fbb3 f3f2 	udiv	r3, r3, r2
    93d2:	9305      	str	r3, [sp, #20]
    baudDiff =
        (tempBaud > config->baudRate_Bps) ? (tempBaud - config->baudRate_Bps) : (config->baudRate_Bps - tempBaud);
    93d4:	9b02      	ldr	r3, [sp, #8]
    93d6:	681a      	ldr	r2, [r3, #0]
    93d8:	9b05      	ldr	r3, [sp, #20]
    93da:	429a      	cmp	r2, r3
    93dc:	d204      	bcs.n	93e8 <UART_Init+0x168>
    93de:	9b02      	ldr	r3, [sp, #8]
    93e0:	681b      	ldr	r3, [r3, #0]
    93e2:	9a05      	ldr	r2, [sp, #20]
    93e4:	1ad3      	subs	r3, r2, r3
    93e6:	e003      	b.n	93f0 <UART_Init+0x170>
    93e8:	9b02      	ldr	r3, [sp, #8]
    93ea:	681a      	ldr	r2, [r3, #0]
    93ec:	9b05      	ldr	r3, [sp, #20]
    93ee:	1ad3      	subs	r3, r2, r3
    baudDiff =
    93f0:	9306      	str	r3, [sp, #24]
    }
#endif

    /* next, check to see if actual baud rate is within 3% of desired baud rate
     * based on the calculate SBR value */
    if (baudDiff > ((config->baudRate_Bps / 100) * 3))
    93f2:	9b02      	ldr	r3, [sp, #8]
    93f4:	681b      	ldr	r3, [r3, #0]
    93f6:	4a5f      	ldr	r2, [pc, #380]	; (9574 <UART_Init+0x2f4>)
    93f8:	fba2 2303 	umull	r2, r3, r2, r3
    93fc:	095a      	lsrs	r2, r3, #5
    93fe:	4613      	mov	r3, r2
    9400:	005b      	lsls	r3, r3, #1
    9402:	441a      	add	r2, r3
    9404:	9b06      	ldr	r3, [sp, #24]
    9406:	429a      	cmp	r2, r3
    9408:	d202      	bcs.n	9410 <UART_Init+0x190>
    {
        /* Unacceptable baud rate difference of more than 3%*/
        return kStatus_UART_BaudrateNotSupport;
    940a:	f240 33f5 	movw	r3, #1013	; 0x3f5
    940e:	e094      	b.n	953a <UART_Init+0x2ba>
    }

#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    /* Enable uart clock */
    CLOCK_EnableClock(s_uartClock[UART_GetInstance(base)]);
    9410:	9803      	ldr	r0, [sp, #12]
    9412:	f7ff ff05 	bl	9220 <UART_GetInstance>
    9416:	4602      	mov	r2, r0
    9418:	4b57      	ldr	r3, [pc, #348]	; (9578 <UART_Init+0x2f8>)
    941a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    941e:	4618      	mov	r0, r3
    9420:	f7ff fee8 	bl	91f4 <CLOCK_EnableClock>
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */

    /* Disable UART TX RX before setting. */
    base->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK);
    9424:	9b03      	ldr	r3, [sp, #12]
    9426:	78db      	ldrb	r3, [r3, #3]
    9428:	b2db      	uxtb	r3, r3
    942a:	f023 030c 	bic.w	r3, r3, #12
    942e:	b2da      	uxtb	r2, r3
    9430:	9b03      	ldr	r3, [sp, #12]
    9432:	70da      	strb	r2, [r3, #3]

    /* Write the sbr value to the BDH and BDL registers*/
    base->BDH = (base->BDH & ~UART_BDH_SBR_MASK) | (uint8_t)(sbr >> 8);
    9434:	9b03      	ldr	r3, [sp, #12]
    9436:	781b      	ldrb	r3, [r3, #0]
    9438:	b2db      	uxtb	r3, r3
    943a:	f023 031f 	bic.w	r3, r3, #31
    943e:	b2da      	uxtb	r2, r3
    9440:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    9444:	0a1b      	lsrs	r3, r3, #8
    9446:	b29b      	uxth	r3, r3
    9448:	b2db      	uxtb	r3, r3
    944a:	4313      	orrs	r3, r2
    944c:	b2da      	uxtb	r2, r3
    944e:	9b03      	ldr	r3, [sp, #12]
    9450:	701a      	strb	r2, [r3, #0]
    base->BDL = (uint8_t)sbr;
    9452:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    9456:	b2da      	uxtb	r2, r3
    9458:	9b03      	ldr	r3, [sp, #12]
    945a:	705a      	strb	r2, [r3, #1]

#if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    /* Write the brfa value to the register*/
    base->C4 = (base->C4 & ~UART_C4_BRFA_MASK) | (brfa & UART_C4_BRFA_MASK);
    945c:	9b03      	ldr	r3, [sp, #12]
    945e:	7a9b      	ldrb	r3, [r3, #10]
    9460:	b2db      	uxtb	r3, r3
    9462:	f023 031f 	bic.w	r3, r3, #31
    9466:	b2da      	uxtb	r2, r3
    9468:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    946c:	b2db      	uxtb	r3, r3
    946e:	f003 031f 	and.w	r3, r3, #31
    9472:	b2db      	uxtb	r3, r3
    9474:	4313      	orrs	r3, r2
    9476:	b2da      	uxtb	r2, r3
    9478:	9b03      	ldr	r3, [sp, #12]
    947a:	729a      	strb	r2, [r3, #10]
#endif

    /* Set bit count and parity mode. */
    temp = base->C1 & ~(UART_C1_PE_MASK | UART_C1_PT_MASK | UART_C1_M_MASK);
    947c:	9b03      	ldr	r3, [sp, #12]
    947e:	789b      	ldrb	r3, [r3, #2]
    9480:	b2db      	uxtb	r3, r3
    9482:	f023 0313 	bic.w	r3, r3, #19
    9486:	f88d 301d 	strb.w	r3, [sp, #29]

    if (kUART_ParityDisabled != config->parityMode)
    948a:	9b02      	ldr	r3, [sp, #8]
    948c:	791b      	ldrb	r3, [r3, #4]
    948e:	2b00      	cmp	r3, #0
    9490:	d009      	beq.n	94a6 <UART_Init+0x226>
    {
        temp |= (UART_C1_M_MASK | (uint8_t)config->parityMode);
    9492:	9b02      	ldr	r3, [sp, #8]
    9494:	791a      	ldrb	r2, [r3, #4]
    9496:	f89d 301d 	ldrb.w	r3, [sp, #29]
    949a:	4313      	orrs	r3, r2
    949c:	b2db      	uxtb	r3, r3
    949e:	f043 0310 	orr.w	r3, r3, #16
    94a2:	f88d 301d 	strb.w	r3, [sp, #29]
    }

    base->C1 = temp;
    94a6:	9b03      	ldr	r3, [sp, #12]
    94a8:	f89d 201d 	ldrb.w	r2, [sp, #29]
    94ac:	709a      	strb	r2, [r3, #2]

#if defined(FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT
    /* Set stop bit per char */
    base->BDH = (base->BDH & ~UART_BDH_SBNS_MASK) | UART_BDH_SBNS((uint8_t)config->stopBitCount);
    94ae:	9b03      	ldr	r3, [sp, #12]
    94b0:	781b      	ldrb	r3, [r3, #0]
    94b2:	b2db      	uxtb	r3, r3
    94b4:	f023 0320 	bic.w	r3, r3, #32
    94b8:	b2da      	uxtb	r2, r3
    94ba:	9b02      	ldr	r3, [sp, #8]
    94bc:	795b      	ldrb	r3, [r3, #5]
    94be:	015b      	lsls	r3, r3, #5
    94c0:	b2db      	uxtb	r3, r3
    94c2:	f003 0320 	and.w	r3, r3, #32
    94c6:	b2db      	uxtb	r3, r3
    94c8:	4313      	orrs	r3, r2
    94ca:	b2da      	uxtb	r2, r3
    94cc:	9b03      	ldr	r3, [sp, #12]
    94ce:	701a      	strb	r2, [r3, #0]
#endif

#if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    /* Set tx/rx FIFO watermark */
    base->TWFIFO = config->txFifoWatermark;
    94d0:	9b02      	ldr	r3, [sp, #8]
    94d2:	799a      	ldrb	r2, [r3, #6]
    94d4:	9b03      	ldr	r3, [sp, #12]
    94d6:	74da      	strb	r2, [r3, #19]
    base->RWFIFO = config->rxFifoWatermark;
    94d8:	9b02      	ldr	r3, [sp, #8]
    94da:	79da      	ldrb	r2, [r3, #7]
    94dc:	9b03      	ldr	r3, [sp, #12]
    94de:	755a      	strb	r2, [r3, #21]

    /* Enable tx/rx FIFO */
    base->PFIFO |= (UART_PFIFO_TXFE_MASK | UART_PFIFO_RXFE_MASK);
    94e0:	9b03      	ldr	r3, [sp, #12]
    94e2:	7c1b      	ldrb	r3, [r3, #16]
    94e4:	b2db      	uxtb	r3, r3
    94e6:	f063 0377 	orn	r3, r3, #119	; 0x77
    94ea:	b2da      	uxtb	r2, r3
    94ec:	9b03      	ldr	r3, [sp, #12]
    94ee:	741a      	strb	r2, [r3, #16]

    /* Flush FIFO */
    base->CFIFO |= (UART_CFIFO_TXFLUSH_MASK | UART_CFIFO_RXFLUSH_MASK);
    94f0:	9b03      	ldr	r3, [sp, #12]
    94f2:	7c5b      	ldrb	r3, [r3, #17]
    94f4:	b2db      	uxtb	r3, r3
    94f6:	f063 033f 	orn	r3, r3, #63	; 0x3f
    94fa:	b2da      	uxtb	r2, r3
    94fc:	9b03      	ldr	r3, [sp, #12]
    94fe:	745a      	strb	r2, [r3, #17]
#endif

    /* Enable TX/RX base on configure structure. */
    temp = base->C2;
    9500:	9b03      	ldr	r3, [sp, #12]
    9502:	78db      	ldrb	r3, [r3, #3]
    9504:	f88d 301d 	strb.w	r3, [sp, #29]

    if (config->enableTx)
    9508:	9b02      	ldr	r3, [sp, #8]
    950a:	7a1b      	ldrb	r3, [r3, #8]
    950c:	2b00      	cmp	r3, #0
    950e:	d005      	beq.n	951c <UART_Init+0x29c>
    {
        temp |= UART_C2_TE_MASK;
    9510:	f89d 301d 	ldrb.w	r3, [sp, #29]
    9514:	f043 0308 	orr.w	r3, r3, #8
    9518:	f88d 301d 	strb.w	r3, [sp, #29]
    }

    if (config->enableRx)
    951c:	9b02      	ldr	r3, [sp, #8]
    951e:	7a5b      	ldrb	r3, [r3, #9]
    9520:	2b00      	cmp	r3, #0
    9522:	d005      	beq.n	9530 <UART_Init+0x2b0>
    {
        temp |= UART_C2_RE_MASK;
    9524:	f89d 301d 	ldrb.w	r3, [sp, #29]
    9528:	f043 0304 	orr.w	r3, r3, #4
    952c:	f88d 301d 	strb.w	r3, [sp, #29]
    }

    base->C2 = temp;
    9530:	9b03      	ldr	r3, [sp, #12]
    9532:	f89d 201d 	ldrb.w	r2, [sp, #29]
    9536:	70da      	strb	r2, [r3, #3]

    return kStatus_Success;
    9538:	2300      	movs	r3, #0
}
    953a:	4618      	mov	r0, r3
    953c:	b009      	add	sp, #36	; 0x24
    953e:	f85d fb04 	ldr.w	pc, [sp], #4
    9542:	bf00      	nop
    9544:	00012204 	.word	0x00012204
    9548:	00012938 	.word	0x00012938
    954c:	0001219c 	.word	0x0001219c
    9550:	0001220c 	.word	0x0001220c
    9554:	4006a000 	.word	0x4006a000
    9558:	4006b000 	.word	0x4006b000
    955c:	4006c000 	.word	0x4006c000
    9560:	4006d000 	.word	0x4006d000
    9564:	400ea000 	.word	0x400ea000
    9568:	400eb000 	.word	0x400eb000
    956c:	00012224 	.word	0x00012224
    9570:	00012264 	.word	0x00012264
    9574:	51eb851f 	.word	0x51eb851f
    9578:	0001290c 	.word	0x0001290c

0000957c <UART_GetDefaultConfig>:
    CLOCK_DisableClock(s_uartClock[UART_GetInstance(base)]);
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
}

void UART_GetDefaultConfig(uart_config_t *config)
{
    957c:	b500      	push	{lr}
    957e:	b083      	sub	sp, #12
    9580:	9001      	str	r0, [sp, #4]
    assert(config);
    9582:	9b01      	ldr	r3, [sp, #4]
    9584:	2b00      	cmp	r3, #0
    9586:	d106      	bne.n	9596 <UART_GetDefaultConfig+0x1a>
    9588:	4b10      	ldr	r3, [pc, #64]	; (95cc <UART_GetDefaultConfig+0x50>)
    958a:	4a11      	ldr	r2, [pc, #68]	; (95d0 <UART_GetDefaultConfig+0x54>)
    958c:	f240 115d 	movw	r1, #349	; 0x15d
    9590:	4810      	ldr	r0, [pc, #64]	; (95d4 <UART_GetDefaultConfig+0x58>)
    9592:	f000 fec7 	bl	a324 <__assert_func>

    config->baudRate_Bps = 115200U;
    9596:	9b01      	ldr	r3, [sp, #4]
    9598:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
    959c:	601a      	str	r2, [r3, #0]
    config->parityMode = kUART_ParityDisabled;
    959e:	9b01      	ldr	r3, [sp, #4]
    95a0:	2200      	movs	r2, #0
    95a2:	711a      	strb	r2, [r3, #4]
#if defined(FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT
    config->stopBitCount = kUART_OneStopBit;
    95a4:	9b01      	ldr	r3, [sp, #4]
    95a6:	2200      	movs	r2, #0
    95a8:	715a      	strb	r2, [r3, #5]
#endif
#if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    config->txFifoWatermark = 0;
    95aa:	9b01      	ldr	r3, [sp, #4]
    95ac:	2200      	movs	r2, #0
    95ae:	719a      	strb	r2, [r3, #6]
    config->rxFifoWatermark = 1;
    95b0:	9b01      	ldr	r3, [sp, #4]
    95b2:	2201      	movs	r2, #1
    95b4:	71da      	strb	r2, [r3, #7]
#endif
    config->enableTx = false;
    95b6:	9b01      	ldr	r3, [sp, #4]
    95b8:	2200      	movs	r2, #0
    95ba:	721a      	strb	r2, [r3, #8]
    config->enableRx = false;
    95bc:	9b01      	ldr	r3, [sp, #4]
    95be:	2200      	movs	r2, #0
    95c0:	725a      	strb	r2, [r3, #9]
}
    95c2:	bf00      	nop
    95c4:	b003      	add	sp, #12
    95c6:	f85d fb04 	ldr.w	pc, [sp], #4
    95ca:	bf00      	nop
    95cc:	00012204 	.word	0x00012204
    95d0:	00012944 	.word	0x00012944
    95d4:	0001219c 	.word	0x0001219c

000095d8 <UART_SetBaudRate>:

status_t UART_SetBaudRate(UART_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)
{
    95d8:	b500      	push	{lr}
    95da:	b089      	sub	sp, #36	; 0x24
    95dc:	9003      	str	r0, [sp, #12]
    95de:	9102      	str	r1, [sp, #8]
    95e0:	9201      	str	r2, [sp, #4]
    assert(baudRate_Bps);
    95e2:	9b02      	ldr	r3, [sp, #8]
    95e4:	2b00      	cmp	r3, #0
    95e6:	d106      	bne.n	95f6 <UART_SetBaudRate+0x1e>
    95e8:	4b43      	ldr	r3, [pc, #268]	; (96f8 <UART_SetBaudRate+0x120>)
    95ea:	4a44      	ldr	r2, [pc, #272]	; (96fc <UART_SetBaudRate+0x124>)
    95ec:	f44f 71b7 	mov.w	r1, #366	; 0x16e
    95f0:	4843      	ldr	r0, [pc, #268]	; (9700 <UART_SetBaudRate+0x128>)
    95f2:	f000 fe97 	bl	a324 <__assert_func>

    uint16_t sbr = 0;
    95f6:	2300      	movs	r3, #0
    95f8:	f8ad 301e 	strh.w	r3, [sp, #30]
    uint32_t baudDiff = 0;
    95fc:	2300      	movs	r3, #0
    95fe:	9306      	str	r3, [sp, #24]
    uint8_t oldCtrl;

    /* Calculate the baud rate modulo divisor, sbr*/
    sbr = srcClock_Hz / (baudRate_Bps * 16);
    9600:	9b02      	ldr	r3, [sp, #8]
    9602:	011b      	lsls	r3, r3, #4
    9604:	9a01      	ldr	r2, [sp, #4]
    9606:	fbb2 f3f3 	udiv	r3, r2, r3
    960a:	f8ad 301e 	strh.w	r3, [sp, #30]
    /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
    if (sbr == 0)
    960e:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    9612:	2b00      	cmp	r3, #0
    9614:	d102      	bne.n	961c <UART_SetBaudRate+0x44>
    {
        sbr = 1;
    9616:	2301      	movs	r3, #1
    9618:	f8ad 301e 	strh.w	r3, [sp, #30]
    }
#if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    /* Determine if a fractional divider is needed to fine tune closer to the
     * desired baud, each value of brfa is in 1/32 increments,
     * hence the multiply-by-32. */
    uint32_t tempBaud = 0;
    961c:	2300      	movs	r3, #0
    961e:	9305      	str	r3, [sp, #20]

    uint16_t brfa = (2 * srcClock_Hz / (baudRate_Bps)) - 32 * sbr;
    9620:	9b01      	ldr	r3, [sp, #4]
    9622:	005a      	lsls	r2, r3, #1
    9624:	9b02      	ldr	r3, [sp, #8]
    9626:	fbb2 f3f3 	udiv	r3, r2, r3
    962a:	b29a      	uxth	r2, r3
    962c:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    9630:	015b      	lsls	r3, r3, #5
    9632:	b29b      	uxth	r3, r3
    9634:	1ad3      	subs	r3, r2, r3
    9636:	f8ad 3012 	strh.w	r3, [sp, #18]

    /* Calculate the baud rate based on the temporary SBR values and BRFA */
    tempBaud = (srcClock_Hz * 2 / ((sbr * 32 + brfa)));
    963a:	9b01      	ldr	r3, [sp, #4]
    963c:	005b      	lsls	r3, r3, #1
    963e:	f8bd 201e 	ldrh.w	r2, [sp, #30]
    9642:	0151      	lsls	r1, r2, #5
    9644:	f8bd 2012 	ldrh.w	r2, [sp, #18]
    9648:	440a      	add	r2, r1
    964a:	fbb3 f3f2 	udiv	r3, r3, r2
    964e:	9305      	str	r3, [sp, #20]
    baudDiff = (tempBaud > baudRate_Bps) ? (tempBaud - baudRate_Bps) : (baudRate_Bps - tempBaud);
    9650:	9a05      	ldr	r2, [sp, #20]
    9652:	9b02      	ldr	r3, [sp, #8]
    9654:	429a      	cmp	r2, r3
    9656:	d903      	bls.n	9660 <UART_SetBaudRate+0x88>
    9658:	9a05      	ldr	r2, [sp, #20]
    965a:	9b02      	ldr	r3, [sp, #8]
    965c:	1ad3      	subs	r3, r2, r3
    965e:	e002      	b.n	9666 <UART_SetBaudRate+0x8e>
    9660:	9a02      	ldr	r2, [sp, #8]
    9662:	9b05      	ldr	r3, [sp, #20]
    9664:	1ad3      	subs	r3, r2, r3
    9666:	9306      	str	r3, [sp, #24]
    }
#endif

    /* next, check to see if actual baud rate is within 3% of desired baud rate
     * based on the calculate SBR value */
    if (baudDiff < ((baudRate_Bps / 100) * 3))
    9668:	9b02      	ldr	r3, [sp, #8]
    966a:	4a26      	ldr	r2, [pc, #152]	; (9704 <UART_SetBaudRate+0x12c>)
    966c:	fba2 2303 	umull	r2, r3, r2, r3
    9670:	095a      	lsrs	r2, r3, #5
    9672:	4613      	mov	r3, r2
    9674:	005b      	lsls	r3, r3, #1
    9676:	441a      	add	r2, r3
    9678:	9b06      	ldr	r3, [sp, #24]
    967a:	429a      	cmp	r2, r3
    967c:	d935      	bls.n	96ea <UART_SetBaudRate+0x112>
    {
        /* Store C2 before disable Tx and Rx */
        oldCtrl = base->C2;
    967e:	9b03      	ldr	r3, [sp, #12]
    9680:	78db      	ldrb	r3, [r3, #3]
    9682:	f88d 3011 	strb.w	r3, [sp, #17]

        /* Disable UART TX RX before setting. */
        base->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK);
    9686:	9b03      	ldr	r3, [sp, #12]
    9688:	78db      	ldrb	r3, [r3, #3]
    968a:	b2db      	uxtb	r3, r3
    968c:	f023 030c 	bic.w	r3, r3, #12
    9690:	b2da      	uxtb	r2, r3
    9692:	9b03      	ldr	r3, [sp, #12]
    9694:	70da      	strb	r2, [r3, #3]

        /* Write the sbr value to the BDH and BDL registers*/
        base->BDH = (base->BDH & ~UART_BDH_SBR_MASK) | (uint8_t)(sbr >> 8);
    9696:	9b03      	ldr	r3, [sp, #12]
    9698:	781b      	ldrb	r3, [r3, #0]
    969a:	b2db      	uxtb	r3, r3
    969c:	f023 031f 	bic.w	r3, r3, #31
    96a0:	b2da      	uxtb	r2, r3
    96a2:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    96a6:	0a1b      	lsrs	r3, r3, #8
    96a8:	b29b      	uxth	r3, r3
    96aa:	b2db      	uxtb	r3, r3
    96ac:	4313      	orrs	r3, r2
    96ae:	b2da      	uxtb	r2, r3
    96b0:	9b03      	ldr	r3, [sp, #12]
    96b2:	701a      	strb	r2, [r3, #0]
        base->BDL = (uint8_t)sbr;
    96b4:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    96b8:	b2da      	uxtb	r2, r3
    96ba:	9b03      	ldr	r3, [sp, #12]
    96bc:	705a      	strb	r2, [r3, #1]

#if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
        /* Write the brfa value to the register*/
        base->C4 = (base->C4 & ~UART_C4_BRFA_MASK) | (brfa & UART_C4_BRFA_MASK);
    96be:	9b03      	ldr	r3, [sp, #12]
    96c0:	7a9b      	ldrb	r3, [r3, #10]
    96c2:	b2db      	uxtb	r3, r3
    96c4:	f023 031f 	bic.w	r3, r3, #31
    96c8:	b2da      	uxtb	r2, r3
    96ca:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    96ce:	b2db      	uxtb	r3, r3
    96d0:	f003 031f 	and.w	r3, r3, #31
    96d4:	b2db      	uxtb	r3, r3
    96d6:	4313      	orrs	r3, r2
    96d8:	b2da      	uxtb	r2, r3
    96da:	9b03      	ldr	r3, [sp, #12]
    96dc:	729a      	strb	r2, [r3, #10]
#endif
        /* Restore C2. */
        base->C2 = oldCtrl;
    96de:	9b03      	ldr	r3, [sp, #12]
    96e0:	f89d 2011 	ldrb.w	r2, [sp, #17]
    96e4:	70da      	strb	r2, [r3, #3]

        return kStatus_Success;
    96e6:	2300      	movs	r3, #0
    96e8:	e001      	b.n	96ee <UART_SetBaudRate+0x116>
    }
    else
    {
        /* Unacceptable baud rate difference of more than 3%*/
        return kStatus_UART_BaudrateNotSupport;
    96ea:	f240 33f5 	movw	r3, #1013	; 0x3f5
    }
}
    96ee:	4618      	mov	r0, r3
    96f0:	b009      	add	sp, #36	; 0x24
    96f2:	f85d fb04 	ldr.w	pc, [sp], #4
    96f6:	bf00      	nop
    96f8:	000122a4 	.word	0x000122a4
    96fc:	0001295c 	.word	0x0001295c
    9700:	0001219c 	.word	0x0001219c
    9704:	51eb851f 	.word	0x51eb851f

00009708 <UART_GetStatusFlags>:

    return temp & kUART_AllInterruptsEnable;
}

uint32_t UART_GetStatusFlags(UART_Type *base)
{
    9708:	b084      	sub	sp, #16
    970a:	9001      	str	r0, [sp, #4]
    uint32_t status_flag;

    status_flag = base->S1 | ((uint32_t)(base->S2) << 8);
    970c:	9b01      	ldr	r3, [sp, #4]
    970e:	791b      	ldrb	r3, [r3, #4]
    9710:	b2db      	uxtb	r3, r3
    9712:	461a      	mov	r2, r3
    9714:	9b01      	ldr	r3, [sp, #4]
    9716:	795b      	ldrb	r3, [r3, #5]
    9718:	b2db      	uxtb	r3, r3
    971a:	021b      	lsls	r3, r3, #8
    971c:	4313      	orrs	r3, r2
    971e:	9303      	str	r3, [sp, #12]

#if defined(FSL_FEATURE_UART_HAS_EXTENDED_DATA_REGISTER_FLAGS) && FSL_FEATURE_UART_HAS_EXTENDED_DATA_REGISTER_FLAGS
    status_flag |= ((uint32_t)(base->ED) << 16);
    9720:	9b01      	ldr	r3, [sp, #4]
    9722:	7b1b      	ldrb	r3, [r3, #12]
    9724:	b2db      	uxtb	r3, r3
    9726:	041b      	lsls	r3, r3, #16
    9728:	9a03      	ldr	r2, [sp, #12]
    972a:	4313      	orrs	r3, r2
    972c:	9303      	str	r3, [sp, #12]
#endif

#if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    status_flag |= ((uint32_t)(base->SFIFO) << 24);
    972e:	9b01      	ldr	r3, [sp, #4]
    9730:	7c9b      	ldrb	r3, [r3, #18]
    9732:	b2db      	uxtb	r3, r3
    9734:	061b      	lsls	r3, r3, #24
    9736:	9a03      	ldr	r2, [sp, #12]
    9738:	4313      	orrs	r3, r2
    973a:	9303      	str	r3, [sp, #12]
#endif

    return status_flag;
    973c:	9b03      	ldr	r3, [sp, #12]
}
    973e:	4618      	mov	r0, r3
    9740:	b004      	add	sp, #16
    9742:	4770      	bx	lr

00009744 <UART_ClearStatusFlags>:

status_t UART_ClearStatusFlags(UART_Type *base, uint32_t mask)
{
    9744:	b500      	push	{lr}
    9746:	b085      	sub	sp, #20
    9748:	9001      	str	r0, [sp, #4]
    974a:	9100      	str	r1, [sp, #0]
    uint8_t reg = base->S2;
    974c:	9b01      	ldr	r3, [sp, #4]
    974e:	795b      	ldrb	r3, [r3, #5]
    9750:	f88d 300b 	strb.w	r3, [sp, #11]
    status_t status;

#if defined(FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT
    reg &= ~(UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK);
    9754:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9758:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    975c:	f88d 300b 	strb.w	r3, [sp, #11]
#else
    reg &= ~UART_S2_RXEDGIF_MASK;
#endif

    base->S2 = reg | (uint8_t)(mask >> 8);
    9760:	9b00      	ldr	r3, [sp, #0]
    9762:	0a1b      	lsrs	r3, r3, #8
    9764:	b2da      	uxtb	r2, r3
    9766:	f89d 300b 	ldrb.w	r3, [sp, #11]
    976a:	4313      	orrs	r3, r2
    976c:	b2da      	uxtb	r2, r3
    976e:	9b01      	ldr	r3, [sp, #4]
    9770:	715a      	strb	r2, [r3, #5]

#if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    base->SFIFO = (uint8_t)(mask >> 24);
    9772:	9b00      	ldr	r3, [sp, #0]
    9774:	0e1b      	lsrs	r3, r3, #24
    9776:	b2da      	uxtb	r2, r3
    9778:	9b01      	ldr	r3, [sp, #4]
    977a:	749a      	strb	r2, [r3, #18]
#endif

    if (mask & (kUART_IdleLineFlag | kUART_NoiseErrorFlag | kUART_FramingErrorFlag | kUART_ParityErrorFlag))
    977c:	9b00      	ldr	r3, [sp, #0]
    977e:	f003 0317 	and.w	r3, r3, #23
    9782:	2b00      	cmp	r3, #0
    9784:	d003      	beq.n	978e <UART_ClearStatusFlags+0x4a>
    {
        /* Read base->D to clear the flags. */
        (void)base->S1;
    9786:	9b01      	ldr	r3, [sp, #4]
    9788:	791b      	ldrb	r3, [r3, #4]
        (void)base->D;
    978a:	9b01      	ldr	r3, [sp, #4]
    978c:	79db      	ldrb	r3, [r3, #7]
    }

    if (mask & kUART_RxOverrunFlag)
    978e:	9b00      	ldr	r3, [sp, #0]
    9790:	f003 0308 	and.w	r3, r3, #8
    9794:	2b00      	cmp	r3, #0
    9796:	d00b      	beq.n	97b0 <UART_ClearStatusFlags+0x6c>
    {
        /* Read base->D to clear the flags and Flush all data in FIFO. */
        (void)base->S1;
    9798:	9b01      	ldr	r3, [sp, #4]
    979a:	791b      	ldrb	r3, [r3, #4]
        (void)base->D;
    979c:	9b01      	ldr	r3, [sp, #4]
    979e:	79db      	ldrb	r3, [r3, #7]
#if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
        /* Flush FIFO date, otherwise FIFO pointer will be in unknown state. */
        base->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
    97a0:	9b01      	ldr	r3, [sp, #4]
    97a2:	7c5b      	ldrb	r3, [r3, #17]
    97a4:	b2db      	uxtb	r3, r3
    97a6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    97aa:	b2da      	uxtb	r2, r3
    97ac:	9b01      	ldr	r3, [sp, #4]
    97ae:	745a      	strb	r2, [r3, #17]
#endif
    }

    /* If some flags still pending. */
    if (mask & UART_GetStatusFlags(base))
    97b0:	9801      	ldr	r0, [sp, #4]
    97b2:	f7ff ffa9 	bl	9708 <UART_GetStatusFlags>
    97b6:	4602      	mov	r2, r0
    97b8:	9b00      	ldr	r3, [sp, #0]
    97ba:	4013      	ands	r3, r2
    97bc:	2b00      	cmp	r3, #0
    97be:	d003      	beq.n	97c8 <UART_ClearStatusFlags+0x84>
    {
        /* Some flags can only clear or set by the hardware itself, these flags are: kUART_TxDataRegEmptyFlag,
        kUART_TransmissionCompleteFlag, kUART_RxDataRegFullFlag, kUART_RxActiveFlag, kUART_NoiseErrorInRxDataRegFlag,
        kUART_ParityErrorInRxDataRegFlag, kUART_TxFifoEmptyFlag, kUART_RxFifoEmptyFlag. */
        status = kStatus_UART_FlagCannotClearManually;
    97c0:	f240 33ee 	movw	r3, #1006	; 0x3ee
    97c4:	9303      	str	r3, [sp, #12]
    97c6:	e001      	b.n	97cc <UART_ClearStatusFlags+0x88>
    }
    else
    {
        status = kStatus_Success;
    97c8:	2300      	movs	r3, #0
    97ca:	9303      	str	r3, [sp, #12]
    }

    return status;
    97cc:	9b03      	ldr	r3, [sp, #12]
}
    97ce:	4618      	mov	r0, r3
    97d0:	b005      	add	sp, #20
    97d2:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000097d8 <UART0_DriverIRQHandler>:

#if defined(UART0)
#if ((!(defined(FSL_FEATURE_SOC_LPSCI_COUNT))) || \
     ((defined(FSL_FEATURE_SOC_LPSCI_COUNT)) && (FSL_FEATURE_SOC_LPSCI_COUNT == 0)))
void UART0_DriverIRQHandler(void)
{
    97d8:	b508      	push	{r3, lr}
    s_uartIsr(UART0, s_uartHandle[0]);
    97da:	4b04      	ldr	r3, [pc, #16]	; (97ec <UART0_DriverIRQHandler+0x14>)
    97dc:	681b      	ldr	r3, [r3, #0]
    97de:	4a04      	ldr	r2, [pc, #16]	; (97f0 <UART0_DriverIRQHandler+0x18>)
    97e0:	6812      	ldr	r2, [r2, #0]
    97e2:	4611      	mov	r1, r2
    97e4:	4803      	ldr	r0, [pc, #12]	; (97f4 <UART0_DriverIRQHandler+0x1c>)
    97e6:	4798      	blx	r3
}
    97e8:	bf00      	nop
    97ea:	bd08      	pop	{r3, pc}
    97ec:	20001534 	.word	0x20001534
    97f0:	2000151c 	.word	0x2000151c
    97f4:	4006a000 	.word	0x4006a000

000097f8 <UART0_RX_TX_DriverIRQHandler>:

void UART0_RX_TX_DriverIRQHandler(void)
{
    97f8:	b508      	push	{r3, lr}
    UART0_DriverIRQHandler();
    97fa:	f7ff ffed 	bl	97d8 <UART0_DriverIRQHandler>
}
    97fe:	bf00      	nop
    9800:	bd08      	pop	{r3, pc}
	...

00009804 <UART1_DriverIRQHandler>:
#endif
#endif

#if defined(UART1)
void UART1_DriverIRQHandler(void)
{
    9804:	b508      	push	{r3, lr}
    s_uartIsr(UART1, s_uartHandle[1]);
    9806:	4b04      	ldr	r3, [pc, #16]	; (9818 <UART1_DriverIRQHandler+0x14>)
    9808:	681b      	ldr	r3, [r3, #0]
    980a:	4a04      	ldr	r2, [pc, #16]	; (981c <UART1_DriverIRQHandler+0x18>)
    980c:	6852      	ldr	r2, [r2, #4]
    980e:	4611      	mov	r1, r2
    9810:	4803      	ldr	r0, [pc, #12]	; (9820 <UART1_DriverIRQHandler+0x1c>)
    9812:	4798      	blx	r3
}
    9814:	bf00      	nop
    9816:	bd08      	pop	{r3, pc}
    9818:	20001534 	.word	0x20001534
    981c:	2000151c 	.word	0x2000151c
    9820:	4006b000 	.word	0x4006b000

00009824 <UART1_RX_TX_DriverIRQHandler>:

void UART1_RX_TX_DriverIRQHandler(void)
{
    9824:	b508      	push	{r3, lr}
    UART1_DriverIRQHandler();
    9826:	f7ff ffed 	bl	9804 <UART1_DriverIRQHandler>
}
    982a:	bf00      	nop
    982c:	bd08      	pop	{r3, pc}
	...

00009830 <UART2_DriverIRQHandler>:
#endif

#if defined(UART2)
void UART2_DriverIRQHandler(void)
{
    9830:	b508      	push	{r3, lr}
    s_uartIsr(UART2, s_uartHandle[2]);
    9832:	4b04      	ldr	r3, [pc, #16]	; (9844 <UART2_DriverIRQHandler+0x14>)
    9834:	681b      	ldr	r3, [r3, #0]
    9836:	4a04      	ldr	r2, [pc, #16]	; (9848 <UART2_DriverIRQHandler+0x18>)
    9838:	6892      	ldr	r2, [r2, #8]
    983a:	4611      	mov	r1, r2
    983c:	4803      	ldr	r0, [pc, #12]	; (984c <UART2_DriverIRQHandler+0x1c>)
    983e:	4798      	blx	r3
}
    9840:	bf00      	nop
    9842:	bd08      	pop	{r3, pc}
    9844:	20001534 	.word	0x20001534
    9848:	2000151c 	.word	0x2000151c
    984c:	4006c000 	.word	0x4006c000

00009850 <UART2_RX_TX_DriverIRQHandler>:

void UART2_RX_TX_DriverIRQHandler(void)
{
    9850:	b508      	push	{r3, lr}
    UART2_DriverIRQHandler();
    9852:	f7ff ffed 	bl	9830 <UART2_DriverIRQHandler>
}
    9856:	bf00      	nop
    9858:	bd08      	pop	{r3, pc}
	...

0000985c <UART3_DriverIRQHandler>:
#endif

#if defined(UART3)
void UART3_DriverIRQHandler(void)
{
    985c:	b508      	push	{r3, lr}
    s_uartIsr(UART3, s_uartHandle[3]);
    985e:	4b04      	ldr	r3, [pc, #16]	; (9870 <UART3_DriverIRQHandler+0x14>)
    9860:	681b      	ldr	r3, [r3, #0]
    9862:	4a04      	ldr	r2, [pc, #16]	; (9874 <UART3_DriverIRQHandler+0x18>)
    9864:	68d2      	ldr	r2, [r2, #12]
    9866:	4611      	mov	r1, r2
    9868:	4803      	ldr	r0, [pc, #12]	; (9878 <UART3_DriverIRQHandler+0x1c>)
    986a:	4798      	blx	r3
}
    986c:	bf00      	nop
    986e:	bd08      	pop	{r3, pc}
    9870:	20001534 	.word	0x20001534
    9874:	2000151c 	.word	0x2000151c
    9878:	4006d000 	.word	0x4006d000

0000987c <UART3_RX_TX_DriverIRQHandler>:

void UART3_RX_TX_DriverIRQHandler(void)
{
    987c:	b508      	push	{r3, lr}
    UART3_DriverIRQHandler();
    987e:	f7ff ffed 	bl	985c <UART3_DriverIRQHandler>
}
    9882:	bf00      	nop
    9884:	bd08      	pop	{r3, pc}
	...

00009888 <UART4_DriverIRQHandler>:
#endif

#if defined(UART4)
void UART4_DriverIRQHandler(void)
{
    9888:	b508      	push	{r3, lr}
    s_uartIsr(UART4, s_uartHandle[4]);
    988a:	4b04      	ldr	r3, [pc, #16]	; (989c <UART4_DriverIRQHandler+0x14>)
    988c:	681b      	ldr	r3, [r3, #0]
    988e:	4a04      	ldr	r2, [pc, #16]	; (98a0 <UART4_DriverIRQHandler+0x18>)
    9890:	6912      	ldr	r2, [r2, #16]
    9892:	4611      	mov	r1, r2
    9894:	4803      	ldr	r0, [pc, #12]	; (98a4 <UART4_DriverIRQHandler+0x1c>)
    9896:	4798      	blx	r3
}
    9898:	bf00      	nop
    989a:	bd08      	pop	{r3, pc}
    989c:	20001534 	.word	0x20001534
    98a0:	2000151c 	.word	0x2000151c
    98a4:	400ea000 	.word	0x400ea000

000098a8 <UART4_RX_TX_DriverIRQHandler>:

void UART4_RX_TX_DriverIRQHandler(void)
{
    98a8:	b508      	push	{r3, lr}
    UART4_DriverIRQHandler();
    98aa:	f7ff ffed 	bl	9888 <UART4_DriverIRQHandler>
}
    98ae:	bf00      	nop
    98b0:	bd08      	pop	{r3, pc}
	...

000098b4 <UART5_DriverIRQHandler>:
#endif

#if defined(UART5)
void UART5_DriverIRQHandler(void)
{
    98b4:	b508      	push	{r3, lr}
    s_uartIsr(UART5, s_uartHandle[5]);
    98b6:	4b04      	ldr	r3, [pc, #16]	; (98c8 <UART5_DriverIRQHandler+0x14>)
    98b8:	681b      	ldr	r3, [r3, #0]
    98ba:	4a04      	ldr	r2, [pc, #16]	; (98cc <UART5_DriverIRQHandler+0x18>)
    98bc:	6952      	ldr	r2, [r2, #20]
    98be:	4611      	mov	r1, r2
    98c0:	4803      	ldr	r0, [pc, #12]	; (98d0 <UART5_DriverIRQHandler+0x1c>)
    98c2:	4798      	blx	r3
}
    98c4:	bf00      	nop
    98c6:	bd08      	pop	{r3, pc}
    98c8:	20001534 	.word	0x20001534
    98cc:	2000151c 	.word	0x2000151c
    98d0:	400eb000 	.word	0x400eb000

000098d4 <UART5_RX_TX_DriverIRQHandler>:

void UART5_RX_TX_DriverIRQHandler(void)
{
    98d4:	b508      	push	{r3, lr}
    UART5_DriverIRQHandler();
    98d6:	f7ff ffed 	bl	98b4 <UART5_DriverIRQHandler>
}
    98da:	bf00      	nop
    98dc:	bd08      	pop	{r3, pc}

000098de <UART_EnableTx>:
 *
 * @param base UART peripheral base address.
 * @param enable True to enable, false to disable.
 */
static inline void UART_EnableTx(UART_Type *base, bool enable)
{
    98de:	b082      	sub	sp, #8
    98e0:	9001      	str	r0, [sp, #4]
    98e2:	460b      	mov	r3, r1
    98e4:	f88d 3003 	strb.w	r3, [sp, #3]
    if (enable)
    98e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
    98ec:	2b00      	cmp	r3, #0
    98ee:	d008      	beq.n	9902 <UART_EnableTx+0x24>
    {
        base->C2 |= UART_C2_TE_MASK;
    98f0:	9b01      	ldr	r3, [sp, #4]
    98f2:	78db      	ldrb	r3, [r3, #3]
    98f4:	b2db      	uxtb	r3, r3
    98f6:	f043 0308 	orr.w	r3, r3, #8
    98fa:	b2da      	uxtb	r2, r3
    98fc:	9b01      	ldr	r3, [sp, #4]
    98fe:	70da      	strb	r2, [r3, #3]
    }
    else
    {
        base->C2 &= ~UART_C2_TE_MASK;
    }
}
    9900:	e007      	b.n	9912 <UART_EnableTx+0x34>
        base->C2 &= ~UART_C2_TE_MASK;
    9902:	9b01      	ldr	r3, [sp, #4]
    9904:	78db      	ldrb	r3, [r3, #3]
    9906:	b2db      	uxtb	r3, r3
    9908:	f023 0308 	bic.w	r3, r3, #8
    990c:	b2da      	uxtb	r2, r3
    990e:	9b01      	ldr	r3, [sp, #4]
    9910:	70da      	strb	r2, [r3, #3]
}
    9912:	bf00      	nop
    9914:	b002      	add	sp, #8
    9916:	4770      	bx	lr

00009918 <UART_EnableRx>:
 *
 * @param base UART peripheral base address.
 * @param enable True to enable, false to disable.
 */
static inline void UART_EnableRx(UART_Type *base, bool enable)
{
    9918:	b082      	sub	sp, #8
    991a:	9001      	str	r0, [sp, #4]
    991c:	460b      	mov	r3, r1
    991e:	f88d 3003 	strb.w	r3, [sp, #3]
    if (enable)
    9922:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9926:	2b00      	cmp	r3, #0
    9928:	d008      	beq.n	993c <UART_EnableRx+0x24>
    {
        base->C2 |= UART_C2_RE_MASK;
    992a:	9b01      	ldr	r3, [sp, #4]
    992c:	78db      	ldrb	r3, [r3, #3]
    992e:	b2db      	uxtb	r3, r3
    9930:	f043 0304 	orr.w	r3, r3, #4
    9934:	b2da      	uxtb	r2, r3
    9936:	9b01      	ldr	r3, [sp, #4]
    9938:	70da      	strb	r2, [r3, #3]
    }
    else
    {
        base->C2 &= ~UART_C2_RE_MASK;
    }
}
    993a:	e007      	b.n	994c <UART_EnableRx+0x34>
        base->C2 &= ~UART_C2_RE_MASK;
    993c:	9b01      	ldr	r3, [sp, #4]
    993e:	78db      	ldrb	r3, [r3, #3]
    9940:	b2db      	uxtb	r3, r3
    9942:	f023 0304 	bic.w	r3, r3, #4
    9946:	b2da      	uxtb	r2, r3
    9948:	9b01      	ldr	r3, [sp, #4]
    994a:	70da      	strb	r2, [r3, #3]
}
    994c:	bf00      	nop
    994e:	b002      	add	sp, #8
    9950:	4770      	bx	lr

00009952 <UART_WriteByte>:
 *
 * @param base UART peripheral base address.
 * @param data The byte to write.
 */
static inline void UART_WriteByte(UART_Type *base, uint8_t data)
{
    9952:	b082      	sub	sp, #8
    9954:	9001      	str	r0, [sp, #4]
    9956:	460b      	mov	r3, r1
    9958:	f88d 3003 	strb.w	r3, [sp, #3]
    base->D = data;
    995c:	9b01      	ldr	r3, [sp, #4]
    995e:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9962:	71da      	strb	r2, [r3, #7]
}
    9964:	bf00      	nop
    9966:	b002      	add	sp, #8
    9968:	4770      	bx	lr

0000996a <UART_ReadByte>:
 *
 * @param base UART peripheral base address.
 * @return The byte read from UART data register.
 */
static inline uint8_t UART_ReadByte(UART_Type *base)
{
    996a:	b082      	sub	sp, #8
    996c:	9001      	str	r0, [sp, #4]
    return base->D;
    996e:	9b01      	ldr	r3, [sp, #4]
    9970:	79db      	ldrb	r3, [r3, #7]
    9972:	b2db      	uxtb	r3, r3
}
    9974:	4618      	mov	r0, r3
    9976:	b002      	add	sp, #8
    9978:	4770      	bx	lr
	...

0000997c <serial_init>:

int stdio_uart_inited = 0;
serial_t stdio_uart;

void serial_init(serial_t *obj, PinName tx, PinName rx)
{
    997c:	b510      	push	{r4, lr}
    997e:	b08a      	sub	sp, #40	; 0x28
    9980:	9003      	str	r0, [sp, #12]
    9982:	9102      	str	r1, [sp, #8]
    9984:	9201      	str	r2, [sp, #4]
    uint32_t uart_tx = pinmap_peripheral(tx, PinMap_UART_TX);
    9986:	4942      	ldr	r1, [pc, #264]	; (9a90 <serial_init+0x114>)
    9988:	9802      	ldr	r0, [sp, #8]
    998a:	f7f8 fa45 	bl	1e18 <pinmap_peripheral>
    998e:	9009      	str	r0, [sp, #36]	; 0x24
    uint32_t uart_rx = pinmap_peripheral(rx, PinMap_UART_RX);
    9990:	4940      	ldr	r1, [pc, #256]	; (9a94 <serial_init+0x118>)
    9992:	9801      	ldr	r0, [sp, #4]
    9994:	f7f8 fa40 	bl	1e18 <pinmap_peripheral>
    9998:	9008      	str	r0, [sp, #32]
    obj->serial.index = pinmap_merge(uart_tx, uart_rx);
    999a:	9908      	ldr	r1, [sp, #32]
    999c:	9809      	ldr	r0, [sp, #36]	; 0x24
    999e:	f7f8 f9f9 	bl	1d94 <pinmap_merge>
    99a2:	4603      	mov	r3, r0
    99a4:	461a      	mov	r2, r3
    99a6:	9b03      	ldr	r3, [sp, #12]
    99a8:	601a      	str	r2, [r3, #0]
    MBED_ASSERT((int)obj->serial.index != NC);
    99aa:	9b03      	ldr	r3, [sp, #12]
    99ac:	681b      	ldr	r3, [r3, #0]
    99ae:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    99b2:	d104      	bne.n	99be <serial_init+0x42>
    99b4:	2237      	movs	r2, #55	; 0x37
    99b6:	4938      	ldr	r1, [pc, #224]	; (9a98 <serial_init+0x11c>)
    99b8:	4838      	ldr	r0, [pc, #224]	; (9a9c <serial_init+0x120>)
    99ba:	f7f9 f82b 	bl	2a14 <mbed_assert_internal>

    uart_config_t config;

    UART_GetDefaultConfig(&config);
    99be:	ab05      	add	r3, sp, #20
    99c0:	4618      	mov	r0, r3
    99c2:	f7ff fddb 	bl	957c <UART_GetDefaultConfig>
    config.baudRate_Bps = 9600;
    99c6:	f44f 5316 	mov.w	r3, #9600	; 0x2580
    99ca:	9305      	str	r3, [sp, #20]
    config.enableTx = false;
    99cc:	2300      	movs	r3, #0
    99ce:	f88d 301c 	strb.w	r3, [sp, #28]
    config.enableRx = false;
    99d2:	2300      	movs	r3, #0
    99d4:	f88d 301d 	strb.w	r3, [sp, #29]

    UART_Init(uart_addrs[obj->serial.index], &config, CLOCK_GetFreq(uart_clocks[obj->serial.index]));
    99d8:	9b03      	ldr	r3, [sp, #12]
    99da:	681b      	ldr	r3, [r3, #0]
    99dc:	4a30      	ldr	r2, [pc, #192]	; (9aa0 <serial_init+0x124>)
    99de:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    99e2:	9b03      	ldr	r3, [sp, #12]
    99e4:	681b      	ldr	r3, [r3, #0]
    99e6:	4a2f      	ldr	r2, [pc, #188]	; (9aa4 <serial_init+0x128>)
    99e8:	5cd3      	ldrb	r3, [r2, r3]
    99ea:	4618      	mov	r0, r3
    99ec:	f7fe fcf4 	bl	83d8 <CLOCK_GetFreq>
    99f0:	4602      	mov	r2, r0
    99f2:	ab05      	add	r3, sp, #20
    99f4:	4619      	mov	r1, r3
    99f6:	4620      	mov	r0, r4
    99f8:	f7ff fc42 	bl	9280 <UART_Init>

    pinmap_pinout(tx, PinMap_UART_TX);
    99fc:	4924      	ldr	r1, [pc, #144]	; (9a90 <serial_init+0x114>)
    99fe:	9802      	ldr	r0, [sp, #8]
    9a00:	f7f8 f996 	bl	1d30 <pinmap_pinout>
    pinmap_pinout(rx, PinMap_UART_RX);
    9a04:	4923      	ldr	r1, [pc, #140]	; (9a94 <serial_init+0x118>)
    9a06:	9801      	ldr	r0, [sp, #4]
    9a08:	f7f8 f992 	bl	1d30 <pinmap_pinout>

    if (tx != NC) {
    9a0c:	9b02      	ldr	r3, [sp, #8]
    9a0e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    9a12:	d00c      	beq.n	9a2e <serial_init+0xb2>
        UART_EnableTx(uart_addrs[obj->serial.index], true);
    9a14:	9b03      	ldr	r3, [sp, #12]
    9a16:	681b      	ldr	r3, [r3, #0]
    9a18:	4a21      	ldr	r2, [pc, #132]	; (9aa0 <serial_init+0x124>)
    9a1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a1e:	2101      	movs	r1, #1
    9a20:	4618      	mov	r0, r3
    9a22:	f7ff ff5c 	bl	98de <UART_EnableTx>
        pin_mode(tx, PullUp);
    9a26:	2102      	movs	r1, #2
    9a28:	9802      	ldr	r0, [sp, #8]
    9a2a:	f000 fc11 	bl	a250 <pin_mode>
    }
    if (rx != NC) {
    9a2e:	9b01      	ldr	r3, [sp, #4]
    9a30:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    9a34:	d00c      	beq.n	9a50 <serial_init+0xd4>
        UART_EnableRx(uart_addrs[obj->serial.index], true);
    9a36:	9b03      	ldr	r3, [sp, #12]
    9a38:	681b      	ldr	r3, [r3, #0]
    9a3a:	4a19      	ldr	r2, [pc, #100]	; (9aa0 <serial_init+0x124>)
    9a3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a40:	2101      	movs	r1, #1
    9a42:	4618      	mov	r0, r3
    9a44:	f7ff ff68 	bl	9918 <UART_EnableRx>
        pin_mode(rx, PullUp);
    9a48:	2102      	movs	r1, #2
    9a4a:	9801      	ldr	r0, [sp, #4]
    9a4c:	f000 fc00 	bl	a250 <pin_mode>
    }

    if (obj->serial.index == STDIO_UART) {
    9a50:	9b03      	ldr	r3, [sp, #12]
    9a52:	681b      	ldr	r3, [r3, #0]
    9a54:	2b00      	cmp	r3, #0
    9a56:	d107      	bne.n	9a68 <serial_init+0xec>
        stdio_uart_inited = 1;
    9a58:	4b13      	ldr	r3, [pc, #76]	; (9aa8 <serial_init+0x12c>)
    9a5a:	2201      	movs	r2, #1
    9a5c:	601a      	str	r2, [r3, #0]
        memcpy(&stdio_uart, obj, sizeof(serial_t));
    9a5e:	22bc      	movs	r2, #188	; 0xbc
    9a60:	9903      	ldr	r1, [sp, #12]
    9a62:	4812      	ldr	r0, [pc, #72]	; (9aac <serial_init+0x130>)
    9a64:	f7f6 ff5c 	bl	920 <memcpy>
    }

    obj->serial.uartDmaRx.dmaUsageState = DMA_USAGE_OPPORTUNISTIC;;
    9a68:	9b03      	ldr	r3, [sp, #12]
    9a6a:	2201      	movs	r2, #1
    9a6c:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
    obj->serial.txstate = kUART_TxIdle;
    9a70:	9b03      	ldr	r3, [sp, #12]
    9a72:	2200      	movs	r2, #0
    9a74:	711a      	strb	r2, [r3, #4]
    obj->serial.rxstate = kUART_RxIdle;
    9a76:	9b03      	ldr	r3, [sp, #12]
    9a78:	2202      	movs	r2, #2
    9a7a:	715a      	strb	r2, [r3, #5]

    /* Zero the handle. */
    memset(&(obj->serial.uart_transfer_handle), 0, sizeof(obj->serial.uart_transfer_handle));
    9a7c:	9b03      	ldr	r3, [sp, #12]
    9a7e:	330c      	adds	r3, #12
    9a80:	2230      	movs	r2, #48	; 0x30
    9a82:	2100      	movs	r1, #0
    9a84:	4618      	mov	r0, r3
    9a86:	f001 fd0d 	bl	b4a4 <memset>
}
    9a8a:	bf00      	nop
    9a8c:	b00a      	add	sp, #40	; 0x28
    9a8e:	bd10      	pop	{r4, pc}
    9a90:	00012630 	.word	0x00012630
    9a94:	000126c0 	.word	0x000126c0
    9a98:	000122f4 	.word	0x000122f4
    9a9c:	0001234c 	.word	0x0001234c
    9aa0:	00012970 	.word	0x00012970
    9aa4:	00012988 	.word	0x00012988
    9aa8:	20001538 	.word	0x20001538
    9aac:	20002f6c 	.word	0x20002f6c

00009ab0 <serial_baud>:
    UART_Deinit(uart_addrs[obj->serial.index]);
    serial_irq_ids[obj->serial.index] = 0;
}

void serial_baud(serial_t *obj, int baudrate)
{
    9ab0:	b530      	push	{r4, r5, lr}
    9ab2:	b083      	sub	sp, #12
    9ab4:	9001      	str	r0, [sp, #4]
    9ab6:	9100      	str	r1, [sp, #0]
    UART_SetBaudRate(uart_addrs[obj->serial.index], (uint32_t)baudrate, CLOCK_GetFreq(uart_clocks[obj->serial.index]));
    9ab8:	9b01      	ldr	r3, [sp, #4]
    9aba:	681b      	ldr	r3, [r3, #0]
    9abc:	4a09      	ldr	r2, [pc, #36]	; (9ae4 <serial_baud+0x34>)
    9abe:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    9ac2:	9d00      	ldr	r5, [sp, #0]
    9ac4:	9b01      	ldr	r3, [sp, #4]
    9ac6:	681b      	ldr	r3, [r3, #0]
    9ac8:	4a07      	ldr	r2, [pc, #28]	; (9ae8 <serial_baud+0x38>)
    9aca:	5cd3      	ldrb	r3, [r2, r3]
    9acc:	4618      	mov	r0, r3
    9ace:	f7fe fc83 	bl	83d8 <CLOCK_GetFreq>
    9ad2:	4603      	mov	r3, r0
    9ad4:	461a      	mov	r2, r3
    9ad6:	4629      	mov	r1, r5
    9ad8:	4620      	mov	r0, r4
    9ada:	f7ff fd7d 	bl	95d8 <UART_SetBaudRate>
}
    9ade:	bf00      	nop
    9ae0:	b003      	add	sp, #12
    9ae2:	bd30      	pop	{r4, r5, pc}
    9ae4:	00012970 	.word	0x00012970
    9ae8:	00012988 	.word	0x00012988

00009aec <serial_getc>:
            NVIC_DisableIRQ(uart_irqs[obj->serial.index]);
    }
}

int serial_getc(serial_t *obj)
{
    9aec:	b500      	push	{lr}
    9aee:	b085      	sub	sp, #20
    9af0:	9001      	str	r0, [sp, #4]
    while (!serial_readable(obj));
    9af2:	bf00      	nop
    9af4:	9801      	ldr	r0, [sp, #4]
    9af6:	f000 f833 	bl	9b60 <serial_readable>
    9afa:	4603      	mov	r3, r0
    9afc:	2b00      	cmp	r3, #0
    9afe:	d0f9      	beq.n	9af4 <serial_getc+0x8>
    uint8_t data;
    data = UART_ReadByte(uart_addrs[obj->serial.index]);
    9b00:	9b01      	ldr	r3, [sp, #4]
    9b02:	681b      	ldr	r3, [r3, #0]
    9b04:	4a07      	ldr	r2, [pc, #28]	; (9b24 <serial_getc+0x38>)
    9b06:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b0a:	4618      	mov	r0, r3
    9b0c:	f7ff ff2d 	bl	996a <UART_ReadByte>
    9b10:	4603      	mov	r3, r0
    9b12:	f88d 300f 	strb.w	r3, [sp, #15]

    return data;
    9b16:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    9b1a:	4618      	mov	r0, r3
    9b1c:	b005      	add	sp, #20
    9b1e:	f85d fb04 	ldr.w	pc, [sp], #4
    9b22:	bf00      	nop
    9b24:	00012970 	.word	0x00012970

00009b28 <serial_putc>:

void serial_putc(serial_t *obj, int c)
{
    9b28:	b500      	push	{lr}
    9b2a:	b083      	sub	sp, #12
    9b2c:	9001      	str	r0, [sp, #4]
    9b2e:	9100      	str	r1, [sp, #0]
    while (!serial_writable(obj));
    9b30:	bf00      	nop
    9b32:	9801      	ldr	r0, [sp, #4]
    9b34:	f000 f838 	bl	9ba8 <serial_writable>
    9b38:	4603      	mov	r3, r0
    9b3a:	2b00      	cmp	r3, #0
    9b3c:	d0f9      	beq.n	9b32 <serial_putc+0xa>
    UART_WriteByte(uart_addrs[obj->serial.index], (uint8_t)c);
    9b3e:	9b01      	ldr	r3, [sp, #4]
    9b40:	681b      	ldr	r3, [r3, #0]
    9b42:	4a06      	ldr	r2, [pc, #24]	; (9b5c <serial_putc+0x34>)
    9b44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b48:	9a00      	ldr	r2, [sp, #0]
    9b4a:	b2d2      	uxtb	r2, r2
    9b4c:	4611      	mov	r1, r2
    9b4e:	4618      	mov	r0, r3
    9b50:	f7ff feff 	bl	9952 <UART_WriteByte>
}
    9b54:	bf00      	nop
    9b56:	b003      	add	sp, #12
    9b58:	f85d fb04 	ldr.w	pc, [sp], #4
    9b5c:	00012970 	.word	0x00012970

00009b60 <serial_readable>:

int serial_readable(serial_t *obj)
{
    9b60:	b500      	push	{lr}
    9b62:	b085      	sub	sp, #20
    9b64:	9001      	str	r0, [sp, #4]
    uint32_t status_flags = UART_GetStatusFlags(uart_addrs[obj->serial.index]);
    9b66:	9b01      	ldr	r3, [sp, #4]
    9b68:	681b      	ldr	r3, [r3, #0]
    9b6a:	4a0e      	ldr	r2, [pc, #56]	; (9ba4 <serial_readable+0x44>)
    9b6c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b70:	4618      	mov	r0, r3
    9b72:	f7ff fdc9 	bl	9708 <UART_GetStatusFlags>
    9b76:	9003      	str	r0, [sp, #12]
    if (status_flags & kUART_RxOverrunFlag)
    9b78:	9b03      	ldr	r3, [sp, #12]
    9b7a:	f003 0308 	and.w	r3, r3, #8
    9b7e:	2b00      	cmp	r3, #0
    9b80:	d008      	beq.n	9b94 <serial_readable+0x34>
        UART_ClearStatusFlags(uart_addrs[obj->serial.index], kUART_RxOverrunFlag);
    9b82:	9b01      	ldr	r3, [sp, #4]
    9b84:	681b      	ldr	r3, [r3, #0]
    9b86:	4a07      	ldr	r2, [pc, #28]	; (9ba4 <serial_readable+0x44>)
    9b88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b8c:	2108      	movs	r1, #8
    9b8e:	4618      	mov	r0, r3
    9b90:	f7ff fdd8 	bl	9744 <UART_ClearStatusFlags>
    return (status_flags & kUART_RxDataRegFullFlag);
    9b94:	9b03      	ldr	r3, [sp, #12]
    9b96:	f003 0320 	and.w	r3, r3, #32
}
    9b9a:	4618      	mov	r0, r3
    9b9c:	b005      	add	sp, #20
    9b9e:	f85d fb04 	ldr.w	pc, [sp], #4
    9ba2:	bf00      	nop
    9ba4:	00012970 	.word	0x00012970

00009ba8 <serial_writable>:

int serial_writable(serial_t *obj)
{
    9ba8:	b500      	push	{lr}
    9baa:	b085      	sub	sp, #20
    9bac:	9001      	str	r0, [sp, #4]
    uint32_t status_flags = UART_GetStatusFlags(uart_addrs[obj->serial.index]);
    9bae:	9b01      	ldr	r3, [sp, #4]
    9bb0:	681b      	ldr	r3, [r3, #0]
    9bb2:	4a0e      	ldr	r2, [pc, #56]	; (9bec <serial_writable+0x44>)
    9bb4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9bb8:	4618      	mov	r0, r3
    9bba:	f7ff fda5 	bl	9708 <UART_GetStatusFlags>
    9bbe:	9003      	str	r0, [sp, #12]
    if (status_flags & kUART_RxOverrunFlag)
    9bc0:	9b03      	ldr	r3, [sp, #12]
    9bc2:	f003 0308 	and.w	r3, r3, #8
    9bc6:	2b00      	cmp	r3, #0
    9bc8:	d008      	beq.n	9bdc <serial_writable+0x34>
        UART_ClearStatusFlags(uart_addrs[obj->serial.index], kUART_RxOverrunFlag);
    9bca:	9b01      	ldr	r3, [sp, #4]
    9bcc:	681b      	ldr	r3, [r3, #0]
    9bce:	4a07      	ldr	r2, [pc, #28]	; (9bec <serial_writable+0x44>)
    9bd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9bd4:	2108      	movs	r1, #8
    9bd6:	4618      	mov	r0, r3
    9bd8:	f7ff fdb4 	bl	9744 <UART_ClearStatusFlags>
    return (status_flags & kUART_TxDataRegEmptyFlag);
    9bdc:	9b03      	ldr	r3, [sp, #12]
    9bde:	f003 0380 	and.w	r3, r3, #128	; 0x80
}
    9be2:	4618      	mov	r0, r3
    9be4:	b005      	add	sp, #20
    9be6:	f85d fb04 	ldr.w	pc, [sp], #4
    9bea:	bf00      	nop
    9bec:	00012970 	.word	0x00012970

00009bf0 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
    9bf0:	b082      	sub	sp, #8
    9bf2:	4603      	mov	r3, r0
    9bf4:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) >= 0)
    9bf8:	f99d 3007 	ldrsb.w	r3, [sp, #7]
    9bfc:	2b00      	cmp	r3, #0
    9bfe:	db0c      	blt.n	9c1a <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    9c00:	4907      	ldr	r1, [pc, #28]	; (9c20 <__NVIC_EnableIRQ+0x30>)
    9c02:	f99d 3007 	ldrsb.w	r3, [sp, #7]
    9c06:	095b      	lsrs	r3, r3, #5
    9c08:	f89d 2007 	ldrb.w	r2, [sp, #7]
    9c0c:	f002 021f 	and.w	r2, r2, #31
    9c10:	2001      	movs	r0, #1
    9c12:	fa00 f202 	lsl.w	r2, r0, r2
    9c16:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
    9c1a:	bf00      	nop
    9c1c:	b002      	add	sp, #8
    9c1e:	4770      	bx	lr
    9c20:	e000e100 	.word	0xe000e100

00009c24 <__NVIC_SetPendingIRQ>:
  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
    9c24:	b082      	sub	sp, #8
    9c26:	4603      	mov	r3, r0
    9c28:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) >= 0)
    9c2c:	f99d 3007 	ldrsb.w	r3, [sp, #7]
    9c30:	2b00      	cmp	r3, #0
    9c32:	db0d      	blt.n	9c50 <__NVIC_SetPendingIRQ+0x2c>
  {
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    9c34:	4908      	ldr	r1, [pc, #32]	; (9c58 <__NVIC_SetPendingIRQ+0x34>)
    9c36:	f99d 3007 	ldrsb.w	r3, [sp, #7]
    9c3a:	095b      	lsrs	r3, r3, #5
    9c3c:	f89d 2007 	ldrb.w	r2, [sp, #7]
    9c40:	f002 021f 	and.w	r2, r2, #31
    9c44:	2001      	movs	r0, #1
    9c46:	fa00 f202 	lsl.w	r2, r0, r2
    9c4a:	3340      	adds	r3, #64	; 0x40
    9c4c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
    9c50:	bf00      	nop
    9c52:	b002      	add	sp, #8
    9c54:	4770      	bx	lr
    9c56:	bf00      	nop
    9c58:	e000e100 	.word	0xe000e100

00009c5c <__NVIC_SetVector>:
           VTOR must been relocated to SRAM before.
  \param [in]   IRQn      Interrupt number
  \param [in]   vector    Address of interrupt handler function
 */
__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
{
    9c5c:	b084      	sub	sp, #16
    9c5e:	4603      	mov	r3, r0
    9c60:	9100      	str	r1, [sp, #0]
    9c62:	f88d 3007 	strb.w	r3, [sp, #7]
  uint32_t *vectors = (uint32_t *)SCB->VTOR;
    9c66:	4b07      	ldr	r3, [pc, #28]	; (9c84 <__NVIC_SetVector+0x28>)
    9c68:	689b      	ldr	r3, [r3, #8]
    9c6a:	9303      	str	r3, [sp, #12]
  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
    9c6c:	f99d 3007 	ldrsb.w	r3, [sp, #7]
    9c70:	3310      	adds	r3, #16
    9c72:	009b      	lsls	r3, r3, #2
    9c74:	9a03      	ldr	r2, [sp, #12]
    9c76:	4413      	add	r3, r2
    9c78:	9a00      	ldr	r2, [sp, #0]
    9c7a:	601a      	str	r2, [r3, #0]
}
    9c7c:	bf00      	nop
    9c7e:	b004      	add	sp, #16
    9c80:	4770      	bx	lr
    9c82:	bf00      	nop
    9c84:	e000ed00 	.word	0xe000ed00

00009c88 <PIT_GetDefaultConfig>:
 *     config->enableRunInDebug = false;
 * @endcode
 * @param config Pointer to the onfiguration structure.
 */
static inline void PIT_GetDefaultConfig(pit_config_t *config)
{
    9c88:	b500      	push	{lr}
    9c8a:	b083      	sub	sp, #12
    9c8c:	9001      	str	r0, [sp, #4]
    assert(config);
    9c8e:	9b01      	ldr	r3, [sp, #4]
    9c90:	2b00      	cmp	r3, #0
    9c92:	d105      	bne.n	9ca0 <PIT_GetDefaultConfig+0x18>
    9c94:	4b06      	ldr	r3, [pc, #24]	; (9cb0 <PIT_GetDefaultConfig+0x28>)
    9c96:	4a07      	ldr	r2, [pc, #28]	; (9cb4 <PIT_GetDefaultConfig+0x2c>)
    9c98:	2181      	movs	r1, #129	; 0x81
    9c9a:	4807      	ldr	r0, [pc, #28]	; (9cb8 <PIT_GetDefaultConfig+0x30>)
    9c9c:	f000 fb42 	bl	a324 <__assert_func>

    /* Timers are stopped in Debug mode */
    config->enableRunInDebug = false;
    9ca0:	9b01      	ldr	r3, [sp, #4]
    9ca2:	2200      	movs	r2, #0
    9ca4:	701a      	strb	r2, [r3, #0]
}
    9ca6:	bf00      	nop
    9ca8:	b003      	add	sp, #12
    9caa:	f85d fb04 	ldr.w	pc, [sp], #4
    9cae:	bf00      	nop
    9cb0:	000123bc 	.word	0x000123bc
    9cb4:	00012998 	.word	0x00012998
    9cb8:	000123c4 	.word	0x000123c4

00009cbc <PIT_SetTimerChainMode>:
 * @param enable  Enable or disable chain.
 *                true:  Current timer is chained with the previous timer.
 *                false: Timer doesn't chain with other timers.
 */
static inline void PIT_SetTimerChainMode(PIT_Type *base, pit_chnl_t channel, bool enable)
{
    9cbc:	b082      	sub	sp, #8
    9cbe:	9001      	str	r0, [sp, #4]
    9cc0:	460b      	mov	r3, r1
    9cc2:	f88d 3003 	strb.w	r3, [sp, #3]
    9cc6:	4613      	mov	r3, r2
    9cc8:	f88d 3002 	strb.w	r3, [sp, #2]
    if (enable)
    9ccc:	f89d 3002 	ldrb.w	r3, [sp, #2]
    9cd0:	2b00      	cmp	r3, #0
    9cd2:	d012      	beq.n	9cfa <PIT_SetTimerChainMode+0x3e>
    {
        base->CHANNEL[channel].TCTRL |= PIT_TCTRL_CHN_MASK;
    9cd4:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9cd8:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9cdc:	9901      	ldr	r1, [sp, #4]
    9cde:	0112      	lsls	r2, r2, #4
    9ce0:	440a      	add	r2, r1
    9ce2:	f502 7284 	add.w	r2, r2, #264	; 0x108
    9ce6:	6812      	ldr	r2, [r2, #0]
    9ce8:	f042 0204 	orr.w	r2, r2, #4
    9cec:	9901      	ldr	r1, [sp, #4]
    9cee:	011b      	lsls	r3, r3, #4
    9cf0:	440b      	add	r3, r1
    9cf2:	f503 7384 	add.w	r3, r3, #264	; 0x108
    9cf6:	601a      	str	r2, [r3, #0]
    }
    else
    {
        base->CHANNEL[channel].TCTRL &= ~PIT_TCTRL_CHN_MASK;
    }
}
    9cf8:	e011      	b.n	9d1e <PIT_SetTimerChainMode+0x62>
        base->CHANNEL[channel].TCTRL &= ~PIT_TCTRL_CHN_MASK;
    9cfa:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9cfe:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9d02:	9901      	ldr	r1, [sp, #4]
    9d04:	0112      	lsls	r2, r2, #4
    9d06:	440a      	add	r2, r1
    9d08:	f502 7284 	add.w	r2, r2, #264	; 0x108
    9d0c:	6812      	ldr	r2, [r2, #0]
    9d0e:	f022 0204 	bic.w	r2, r2, #4
    9d12:	9901      	ldr	r1, [sp, #4]
    9d14:	011b      	lsls	r3, r3, #4
    9d16:	440b      	add	r3, r1
    9d18:	f503 7384 	add.w	r3, r3, #264	; 0x108
    9d1c:	601a      	str	r2, [r3, #0]
}
    9d1e:	bf00      	nop
    9d20:	b002      	add	sp, #8
    9d22:	4770      	bx	lr

00009d24 <PIT_EnableInterrupts>:
 * @param channel Timer channel number
 * @param mask    The interrupts to enable. This is a logical OR of members of the
 *                enumeration ::pit_interrupt_enable_t
 */
static inline void PIT_EnableInterrupts(PIT_Type *base, pit_chnl_t channel, uint32_t mask)
{
    9d24:	b084      	sub	sp, #16
    9d26:	9003      	str	r0, [sp, #12]
    9d28:	460b      	mov	r3, r1
    9d2a:	9201      	str	r2, [sp, #4]
    9d2c:	f88d 300b 	strb.w	r3, [sp, #11]
    base->CHANNEL[channel].TCTRL |= mask;
    9d30:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9d34:	f89d 200b 	ldrb.w	r2, [sp, #11]
    9d38:	9903      	ldr	r1, [sp, #12]
    9d3a:	0112      	lsls	r2, r2, #4
    9d3c:	440a      	add	r2, r1
    9d3e:	f502 7284 	add.w	r2, r2, #264	; 0x108
    9d42:	6811      	ldr	r1, [r2, #0]
    9d44:	9a01      	ldr	r2, [sp, #4]
    9d46:	430a      	orrs	r2, r1
    9d48:	9903      	ldr	r1, [sp, #12]
    9d4a:	011b      	lsls	r3, r3, #4
    9d4c:	440b      	add	r3, r1
    9d4e:	f503 7384 	add.w	r3, r3, #264	; 0x108
    9d52:	601a      	str	r2, [r3, #0]
}
    9d54:	bf00      	nop
    9d56:	b004      	add	sp, #16
    9d58:	4770      	bx	lr

00009d5a <PIT_DisableInterrupts>:
 * @param channel Timer channel number
 * @param mask    The interrupts to disable. This is a logical OR of members of the
 *                enumeration ::pit_interrupt_enable_t
 */
static inline void PIT_DisableInterrupts(PIT_Type *base, pit_chnl_t channel, uint32_t mask)
{
    9d5a:	b084      	sub	sp, #16
    9d5c:	9003      	str	r0, [sp, #12]
    9d5e:	460b      	mov	r3, r1
    9d60:	9201      	str	r2, [sp, #4]
    9d62:	f88d 300b 	strb.w	r3, [sp, #11]
    base->CHANNEL[channel].TCTRL &= ~mask;
    9d66:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9d6a:	f89d 200b 	ldrb.w	r2, [sp, #11]
    9d6e:	9903      	ldr	r1, [sp, #12]
    9d70:	0112      	lsls	r2, r2, #4
    9d72:	440a      	add	r2, r1
    9d74:	f502 7284 	add.w	r2, r2, #264	; 0x108
    9d78:	6811      	ldr	r1, [r2, #0]
    9d7a:	9a01      	ldr	r2, [sp, #4]
    9d7c:	43d2      	mvns	r2, r2
    9d7e:	400a      	ands	r2, r1
    9d80:	9903      	ldr	r1, [sp, #12]
    9d82:	011b      	lsls	r3, r3, #4
    9d84:	440b      	add	r3, r1
    9d86:	f503 7384 	add.w	r3, r3, #264	; 0x108
    9d8a:	601a      	str	r2, [r3, #0]
}
    9d8c:	bf00      	nop
    9d8e:	b004      	add	sp, #16
    9d90:	4770      	bx	lr

00009d92 <PIT_ClearStatusFlags>:
 * @param channel Timer channel number
 * @param mask    The status flags to clear. This is a logical OR of members of the
 *                enumeration ::pit_status_flags_t
 */
static inline void PIT_ClearStatusFlags(PIT_Type *base, pit_chnl_t channel, uint32_t mask)
{
    9d92:	b084      	sub	sp, #16
    9d94:	9003      	str	r0, [sp, #12]
    9d96:	460b      	mov	r3, r1
    9d98:	9201      	str	r2, [sp, #4]
    9d9a:	f88d 300b 	strb.w	r3, [sp, #11]
    base->CHANNEL[channel].TFLG = mask;
    9d9e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9da2:	9a03      	ldr	r2, [sp, #12]
    9da4:	011b      	lsls	r3, r3, #4
    9da6:	4413      	add	r3, r2
    9da8:	f503 7386 	add.w	r3, r3, #268	; 0x10c
    9dac:	9a01      	ldr	r2, [sp, #4]
    9dae:	601a      	str	r2, [r3, #0]
}
    9db0:	bf00      	nop
    9db2:	b004      	add	sp, #16
    9db4:	4770      	bx	lr

00009db6 <PIT_SetTimerPeriod>:
 * @param base    PIT peripheral base address
 * @param channel Timer channel number
 * @param count   Timer period in units of ticks
 */
static inline void PIT_SetTimerPeriod(PIT_Type *base, pit_chnl_t channel, uint32_t count)
{
    9db6:	b084      	sub	sp, #16
    9db8:	9003      	str	r0, [sp, #12]
    9dba:	460b      	mov	r3, r1
    9dbc:	9201      	str	r2, [sp, #4]
    9dbe:	f88d 300b 	strb.w	r3, [sp, #11]
    base->CHANNEL[channel].LDVAL = count;
    9dc2:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9dc6:	9a03      	ldr	r2, [sp, #12]
    9dc8:	3310      	adds	r3, #16
    9dca:	011b      	lsls	r3, r3, #4
    9dcc:	4413      	add	r3, r2
    9dce:	9a01      	ldr	r2, [sp, #4]
    9dd0:	601a      	str	r2, [r3, #0]
}
    9dd2:	bf00      	nop
    9dd4:	b004      	add	sp, #16
    9dd6:	4770      	bx	lr

00009dd8 <PIT_GetCurrentTimerCount>:
 * @param channel Timer channel number
 *
 * @return Current timer counting value in ticks
 */
static inline uint32_t PIT_GetCurrentTimerCount(PIT_Type *base, pit_chnl_t channel)
{
    9dd8:	b082      	sub	sp, #8
    9dda:	9001      	str	r0, [sp, #4]
    9ddc:	460b      	mov	r3, r1
    9dde:	f88d 3003 	strb.w	r3, [sp, #3]
    return base->CHANNEL[channel].CVAL;
    9de2:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9de6:	9a01      	ldr	r2, [sp, #4]
    9de8:	3310      	adds	r3, #16
    9dea:	011b      	lsls	r3, r3, #4
    9dec:	4413      	add	r3, r2
    9dee:	3304      	adds	r3, #4
    9df0:	681b      	ldr	r3, [r3, #0]
}
    9df2:	4618      	mov	r0, r3
    9df4:	b002      	add	sp, #8
    9df6:	4770      	bx	lr

00009df8 <PIT_StartTimer>:
 *
 * @param base    PIT peripheral base address
 * @param channel Timer channel number.
 */
static inline void PIT_StartTimer(PIT_Type *base, pit_chnl_t channel)
{
    9df8:	b082      	sub	sp, #8
    9dfa:	9001      	str	r0, [sp, #4]
    9dfc:	460b      	mov	r3, r1
    9dfe:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CHANNEL[channel].TCTRL |= PIT_TCTRL_TEN_MASK;
    9e02:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9e06:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9e0a:	9901      	ldr	r1, [sp, #4]
    9e0c:	0112      	lsls	r2, r2, #4
    9e0e:	440a      	add	r2, r1
    9e10:	f502 7284 	add.w	r2, r2, #264	; 0x108
    9e14:	6812      	ldr	r2, [r2, #0]
    9e16:	f042 0201 	orr.w	r2, r2, #1
    9e1a:	9901      	ldr	r1, [sp, #4]
    9e1c:	011b      	lsls	r3, r3, #4
    9e1e:	440b      	add	r3, r1
    9e20:	f503 7384 	add.w	r3, r3, #264	; 0x108
    9e24:	601a      	str	r2, [r3, #0]
}
    9e26:	bf00      	nop
    9e28:	b002      	add	sp, #8
    9e2a:	4770      	bx	lr

00009e2c <PIT_StopTimer>:
 *
 * @param base    PIT peripheral base address
 * @param channel Timer channel number.
 */
static inline void PIT_StopTimer(PIT_Type *base, pit_chnl_t channel)
{
    9e2c:	b082      	sub	sp, #8
    9e2e:	9001      	str	r0, [sp, #4]
    9e30:	460b      	mov	r3, r1
    9e32:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CHANNEL[channel].TCTRL &= ~PIT_TCTRL_TEN_MASK;
    9e36:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9e3a:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9e3e:	9901      	ldr	r1, [sp, #4]
    9e40:	0112      	lsls	r2, r2, #4
    9e42:	440a      	add	r2, r1
    9e44:	f502 7284 	add.w	r2, r2, #264	; 0x108
    9e48:	6812      	ldr	r2, [r2, #0]
    9e4a:	f022 0201 	bic.w	r2, r2, #1
    9e4e:	9901      	ldr	r1, [sp, #4]
    9e50:	011b      	lsls	r3, r3, #4
    9e52:	440b      	add	r3, r1
    9e54:	f503 7384 	add.w	r3, r3, #264	; 0x108
    9e58:	601a      	str	r2, [r3, #0]
}
    9e5a:	bf00      	nop
    9e5c:	b002      	add	sp, #8
    9e5e:	4770      	bx	lr

00009e60 <us_ticker_get_info>:
{
    static const ticker_info_t info = {
        1000000,    // 1 MHz
             32     // 32 bit counter
    };
    return &info;
    9e60:	4b01      	ldr	r3, [pc, #4]	; (9e68 <us_ticker_get_info+0x8>)
}
    9e62:	4618      	mov	r0, r3
    9e64:	4770      	bx	lr
    9e66:	bf00      	nop
    9e68:	00012990 	.word	0x00012990

00009e6c <pit_isr>:

static bool us_ticker_inited = false;

static void pit_isr(void)
{
    9e6c:	b508      	push	{r3, lr}
    PIT_ClearStatusFlags(PIT, kPIT_Chnl_3, PIT_TFLG_TIF_MASK);
    9e6e:	2201      	movs	r2, #1
    9e70:	2103      	movs	r1, #3
    9e72:	480a      	ldr	r0, [pc, #40]	; (9e9c <pit_isr+0x30>)
    9e74:	f7ff ff8d 	bl	9d92 <PIT_ClearStatusFlags>
    PIT_ClearStatusFlags(PIT, kPIT_Chnl_2, PIT_TFLG_TIF_MASK);
    9e78:	2201      	movs	r2, #1
    9e7a:	2102      	movs	r1, #2
    9e7c:	4807      	ldr	r0, [pc, #28]	; (9e9c <pit_isr+0x30>)
    9e7e:	f7ff ff88 	bl	9d92 <PIT_ClearStatusFlags>
    PIT_StopTimer(PIT, kPIT_Chnl_2);
    9e82:	2102      	movs	r1, #2
    9e84:	4805      	ldr	r0, [pc, #20]	; (9e9c <pit_isr+0x30>)
    9e86:	f7ff ffd1 	bl	9e2c <PIT_StopTimer>
    PIT_StopTimer(PIT, kPIT_Chnl_3);
    9e8a:	2103      	movs	r1, #3
    9e8c:	4803      	ldr	r0, [pc, #12]	; (9e9c <pit_isr+0x30>)
    9e8e:	f7ff ffcd 	bl	9e2c <PIT_StopTimer>

    us_ticker_irq_handler();
    9e92:	f7f8 fc39 	bl	2708 <us_ticker_irq_handler>
}
    9e96:	bf00      	nop
    9e98:	bd08      	pop	{r3, pc}
    9e9a:	bf00      	nop
    9e9c:	40037000 	.word	0x40037000

00009ea0 <us_ticker_init>:

/** Initialize the high frequency ticker
 *
 */
void us_ticker_init(void)
{
    9ea0:	b500      	push	{lr}
    9ea2:	b083      	sub	sp, #12
    /* Common for ticker/timer. */
    uint32_t busClock;
    /* Structure to initialize PIT. */
    pit_config_t pitConfig;

    PIT_GetDefaultConfig(&pitConfig);
    9ea4:	466b      	mov	r3, sp
    9ea6:	4618      	mov	r0, r3
    9ea8:	f7ff feee 	bl	9c88 <PIT_GetDefaultConfig>
    PIT_Init(PIT, &pitConfig);
    9eac:	466b      	mov	r3, sp
    9eae:	4619      	mov	r1, r3
    9eb0:	482b      	ldr	r0, [pc, #172]	; (9f60 <us_ticker_init+0xc0>)
    9eb2:	f7ff f8ed 	bl	9090 <PIT_Init>

    busClock = CLOCK_GetFreq(kCLOCK_BusClk);
    9eb6:	2002      	movs	r0, #2
    9eb8:	f7fe fa8e 	bl	83d8 <CLOCK_GetFreq>
    9ebc:	9001      	str	r0, [sp, #4]

    /* Let the timer to count if re-init. */
    if (!us_ticker_inited) {
    9ebe:	4b29      	ldr	r3, [pc, #164]	; (9f64 <us_ticker_init+0xc4>)
    9ec0:	781b      	ldrb	r3, [r3, #0]
    9ec2:	f083 0301 	eor.w	r3, r3, #1
    9ec6:	b2db      	uxtb	r3, r3
    9ec8:	2b00      	cmp	r3, #0
    9eca:	d01d      	beq.n	9f08 <us_ticker_init+0x68>

        PIT_SetTimerPeriod(PIT, kPIT_Chnl_0, busClock / 1000000 - 1);
    9ecc:	9b01      	ldr	r3, [sp, #4]
    9ece:	4a26      	ldr	r2, [pc, #152]	; (9f68 <us_ticker_init+0xc8>)
    9ed0:	fba2 2303 	umull	r2, r3, r2, r3
    9ed4:	0c9b      	lsrs	r3, r3, #18
    9ed6:	3b01      	subs	r3, #1
    9ed8:	461a      	mov	r2, r3
    9eda:	2100      	movs	r1, #0
    9edc:	4820      	ldr	r0, [pc, #128]	; (9f60 <us_ticker_init+0xc0>)
    9ede:	f7ff ff6a 	bl	9db6 <PIT_SetTimerPeriod>
        PIT_SetTimerPeriod(PIT, kPIT_Chnl_1, 0xFFFFFFFF);
    9ee2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    9ee6:	2101      	movs	r1, #1
    9ee8:	481d      	ldr	r0, [pc, #116]	; (9f60 <us_ticker_init+0xc0>)
    9eea:	f7ff ff64 	bl	9db6 <PIT_SetTimerPeriod>
        PIT_SetTimerChainMode(PIT, kPIT_Chnl_1, true);
    9eee:	2201      	movs	r2, #1
    9ef0:	2101      	movs	r1, #1
    9ef2:	481b      	ldr	r0, [pc, #108]	; (9f60 <us_ticker_init+0xc0>)
    9ef4:	f7ff fee2 	bl	9cbc <PIT_SetTimerChainMode>
        PIT_StartTimer(PIT, kPIT_Chnl_0);
    9ef8:	2100      	movs	r1, #0
    9efa:	4819      	ldr	r0, [pc, #100]	; (9f60 <us_ticker_init+0xc0>)
    9efc:	f7ff ff7c 	bl	9df8 <PIT_StartTimer>
        PIT_StartTimer(PIT, kPIT_Chnl_1);
    9f00:	2101      	movs	r1, #1
    9f02:	4817      	ldr	r0, [pc, #92]	; (9f60 <us_ticker_init+0xc0>)
    9f04:	f7ff ff78 	bl	9df8 <PIT_StartTimer>
    }

    /* Configure interrupt generation counters and disable ticker interrupts. */
    PIT_StopTimer(PIT, kPIT_Chnl_3);
    9f08:	2103      	movs	r1, #3
    9f0a:	4815      	ldr	r0, [pc, #84]	; (9f60 <us_ticker_init+0xc0>)
    9f0c:	f7ff ff8e 	bl	9e2c <PIT_StopTimer>
    PIT_StopTimer(PIT, kPIT_Chnl_2);
    9f10:	2102      	movs	r1, #2
    9f12:	4813      	ldr	r0, [pc, #76]	; (9f60 <us_ticker_init+0xc0>)
    9f14:	f7ff ff8a 	bl	9e2c <PIT_StopTimer>
    PIT_SetTimerPeriod(PIT, kPIT_Chnl_2, busClock / 1000000 - 1);
    9f18:	9b01      	ldr	r3, [sp, #4]
    9f1a:	4a13      	ldr	r2, [pc, #76]	; (9f68 <us_ticker_init+0xc8>)
    9f1c:	fba2 2303 	umull	r2, r3, r2, r3
    9f20:	0c9b      	lsrs	r3, r3, #18
    9f22:	3b01      	subs	r3, #1
    9f24:	461a      	mov	r2, r3
    9f26:	2102      	movs	r1, #2
    9f28:	480d      	ldr	r0, [pc, #52]	; (9f60 <us_ticker_init+0xc0>)
    9f2a:	f7ff ff44 	bl	9db6 <PIT_SetTimerPeriod>
    PIT_SetTimerChainMode(PIT, kPIT_Chnl_3, true);
    9f2e:	2201      	movs	r2, #1
    9f30:	2103      	movs	r1, #3
    9f32:	480b      	ldr	r0, [pc, #44]	; (9f60 <us_ticker_init+0xc0>)
    9f34:	f7ff fec2 	bl	9cbc <PIT_SetTimerChainMode>
    NVIC_SetVector(PIT3_IRQn, (uint32_t) pit_isr);
    9f38:	4b0c      	ldr	r3, [pc, #48]	; (9f6c <us_ticker_init+0xcc>)
    9f3a:	4619      	mov	r1, r3
    9f3c:	2033      	movs	r0, #51	; 0x33
    9f3e:	f7ff fe8d 	bl	9c5c <__NVIC_SetVector>
    NVIC_EnableIRQ(PIT3_IRQn);
    9f42:	2033      	movs	r0, #51	; 0x33
    9f44:	f7ff fe54 	bl	9bf0 <__NVIC_EnableIRQ>
    PIT_DisableInterrupts(PIT, kPIT_Chnl_3, kPIT_TimerInterruptEnable);
    9f48:	2202      	movs	r2, #2
    9f4a:	2103      	movs	r1, #3
    9f4c:	4804      	ldr	r0, [pc, #16]	; (9f60 <us_ticker_init+0xc0>)
    9f4e:	f7ff ff04 	bl	9d5a <PIT_DisableInterrupts>

    us_ticker_inited = true;
    9f52:	4b04      	ldr	r3, [pc, #16]	; (9f64 <us_ticker_init+0xc4>)
    9f54:	2201      	movs	r2, #1
    9f56:	701a      	strb	r2, [r3, #0]
}
    9f58:	bf00      	nop
    9f5a:	b003      	add	sp, #12
    9f5c:	f85d fb04 	ldr.w	pc, [sp], #4
    9f60:	40037000 	.word	0x40037000
    9f64:	2000153c 	.word	0x2000153c
    9f68:	431bde83 	.word	0x431bde83
    9f6c:	00009e6d 	.word	0x00009e6d

00009f70 <us_ticker_read>:
/** Read the current counter
 *
 * @return The current timer's counter value in ticks
 */
uint32_t us_ticker_read()
{
    9f70:	b508      	push	{r3, lr}
    return ~(PIT_GetCurrentTimerCount(PIT, kPIT_Chnl_1));
    9f72:	2101      	movs	r1, #1
    9f74:	4803      	ldr	r0, [pc, #12]	; (9f84 <us_ticker_read+0x14>)
    9f76:	f7ff ff2f 	bl	9dd8 <PIT_GetCurrentTimerCount>
    9f7a:	4603      	mov	r3, r0
    9f7c:	43db      	mvns	r3, r3
}
    9f7e:	4618      	mov	r0, r3
    9f80:	bd08      	pop	{r3, pc}
    9f82:	bf00      	nop
    9f84:	40037000 	.word	0x40037000

00009f88 <us_ticker_disable_interrupt>:

/** Disable us ticker interrupt
 *
 */
void us_ticker_disable_interrupt(void)
{
    9f88:	b508      	push	{r3, lr}
    PIT_DisableInterrupts(PIT, kPIT_Chnl_3, kPIT_TimerInterruptEnable);
    9f8a:	2202      	movs	r2, #2
    9f8c:	2103      	movs	r1, #3
    9f8e:	4802      	ldr	r0, [pc, #8]	; (9f98 <us_ticker_disable_interrupt+0x10>)
    9f90:	f7ff fee3 	bl	9d5a <PIT_DisableInterrupts>
}
    9f94:	bf00      	nop
    9f96:	bd08      	pop	{r3, pc}
    9f98:	40037000 	.word	0x40037000

00009f9c <us_ticker_clear_interrupt>:

/** Clear us ticker interrupt
 *
 */
void us_ticker_clear_interrupt(void)
{
    9f9c:	b508      	push	{r3, lr}
    PIT_ClearStatusFlags(PIT, kPIT_Chnl_3, PIT_TFLG_TIF_MASK);
    9f9e:	2201      	movs	r2, #1
    9fa0:	2103      	movs	r1, #3
    9fa2:	4802      	ldr	r0, [pc, #8]	; (9fac <us_ticker_clear_interrupt+0x10>)
    9fa4:	f7ff fef5 	bl	9d92 <PIT_ClearStatusFlags>
}
    9fa8:	bf00      	nop
    9faa:	bd08      	pop	{r3, pc}
    9fac:	40037000 	.word	0x40037000

00009fb0 <us_ticker_set_interrupt>:
/** Set interrupt for specified timestamp
 *
 * @param timestamp The time in ticks when interrupt should be generated
 */
void us_ticker_set_interrupt(timestamp_t timestamp)
{
    9fb0:	b500      	push	{lr}
    9fb2:	b085      	sub	sp, #20
    9fb4:	9001      	str	r0, [sp, #4]
    /* We get here absolute interrupt time which takes into account counter overflow.
     * Since we use additional count-down timer to generate interrupt we need to calculate
     * load value based on time-stamp.
     */
    const uint32_t now_ticks = us_ticker_read();
    9fb6:	f7ff ffdb 	bl	9f70 <us_ticker_read>
    9fba:	9002      	str	r0, [sp, #8]
    uint32_t delta_ticks =
            timestamp >= now_ticks ? timestamp - now_ticks : (uint32_t)((uint64_t) timestamp + 0xFFFFFFFF - now_ticks);
    9fbc:	9a01      	ldr	r2, [sp, #4]
    9fbe:	9b02      	ldr	r3, [sp, #8]
    9fc0:	429a      	cmp	r2, r3
    9fc2:	d303      	bcc.n	9fcc <us_ticker_set_interrupt+0x1c>
    9fc4:	9a01      	ldr	r2, [sp, #4]
    9fc6:	9b02      	ldr	r3, [sp, #8]
    9fc8:	1ad3      	subs	r3, r2, r3
    9fca:	e003      	b.n	9fd4 <us_ticker_set_interrupt+0x24>
    9fcc:	9a01      	ldr	r2, [sp, #4]
    9fce:	9b02      	ldr	r3, [sp, #8]
    9fd0:	1ad3      	subs	r3, r2, r3
    9fd2:	3b01      	subs	r3, #1
    uint32_t delta_ticks =
    9fd4:	9303      	str	r3, [sp, #12]

    if (delta_ticks == 0) {
    9fd6:	9b03      	ldr	r3, [sp, #12]
    9fd8:	2b00      	cmp	r3, #0
    9fda:	d101      	bne.n	9fe0 <us_ticker_set_interrupt+0x30>
        /* The requested delay is less than the minimum resolution of this counter. */
        delta_ticks = 1;
    9fdc:	2301      	movs	r3, #1
    9fde:	9303      	str	r3, [sp, #12]
    }

    PIT_StopTimer(PIT, kPIT_Chnl_3);
    9fe0:	2103      	movs	r1, #3
    9fe2:	480e      	ldr	r0, [pc, #56]	; (a01c <us_ticker_set_interrupt+0x6c>)
    9fe4:	f7ff ff22 	bl	9e2c <PIT_StopTimer>
    PIT_StopTimer(PIT, kPIT_Chnl_2);
    9fe8:	2102      	movs	r1, #2
    9fea:	480c      	ldr	r0, [pc, #48]	; (a01c <us_ticker_set_interrupt+0x6c>)
    9fec:	f7ff ff1e 	bl	9e2c <PIT_StopTimer>
    PIT_SetTimerPeriod(PIT, kPIT_Chnl_3, delta_ticks);
    9ff0:	9a03      	ldr	r2, [sp, #12]
    9ff2:	2103      	movs	r1, #3
    9ff4:	4809      	ldr	r0, [pc, #36]	; (a01c <us_ticker_set_interrupt+0x6c>)
    9ff6:	f7ff fede 	bl	9db6 <PIT_SetTimerPeriod>
    PIT_EnableInterrupts(PIT, kPIT_Chnl_3, kPIT_TimerInterruptEnable);
    9ffa:	2202      	movs	r2, #2
    9ffc:	2103      	movs	r1, #3
    9ffe:	4807      	ldr	r0, [pc, #28]	; (a01c <us_ticker_set_interrupt+0x6c>)
    a000:	f7ff fe90 	bl	9d24 <PIT_EnableInterrupts>
    PIT_StartTimer(PIT, kPIT_Chnl_3);
    a004:	2103      	movs	r1, #3
    a006:	4805      	ldr	r0, [pc, #20]	; (a01c <us_ticker_set_interrupt+0x6c>)
    a008:	f7ff fef6 	bl	9df8 <PIT_StartTimer>
    PIT_StartTimer(PIT, kPIT_Chnl_2);
    a00c:	2102      	movs	r1, #2
    a00e:	4803      	ldr	r0, [pc, #12]	; (a01c <us_ticker_set_interrupt+0x6c>)
    a010:	f7ff fef2 	bl	9df8 <PIT_StartTimer>
}
    a014:	bf00      	nop
    a016:	b005      	add	sp, #20
    a018:	f85d fb04 	ldr.w	pc, [sp], #4
    a01c:	40037000 	.word	0x40037000

0000a020 <us_ticker_fire_interrupt>:

/** Fire us ticker interrupt
 *
 */
void us_ticker_fire_interrupt(void)
{
    a020:	b508      	push	{r3, lr}
    NVIC_SetPendingIRQ(PIT3_IRQn);
    a022:	2033      	movs	r0, #51	; 0x33
    a024:	f7ff fdfe 	bl	9c24 <__NVIC_SetPendingIRQ>
}
    a028:	bf00      	nop
    a02a:	bd08      	pop	{r3, pc}

0000a02c <GPIO_WritePinOutput>:
 * @param output  GPIO pin output logic level.
 *        - 0: corresponding pin output low-logic level.
 *        - 1: corresponding pin output high-logic level.
 */
static inline void GPIO_WritePinOutput(GPIO_Type *base, uint32_t pin, uint8_t output)
{
    a02c:	b084      	sub	sp, #16
    a02e:	9003      	str	r0, [sp, #12]
    a030:	9102      	str	r1, [sp, #8]
    a032:	4613      	mov	r3, r2
    a034:	f88d 3007 	strb.w	r3, [sp, #7]
    if (output == 0U)
    a038:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a03c:	2b00      	cmp	r3, #0
    a03e:	d105      	bne.n	a04c <GPIO_WritePinOutput+0x20>
    {
        base->PCOR = 1U << pin;
    a040:	2201      	movs	r2, #1
    a042:	9b02      	ldr	r3, [sp, #8]
    a044:	409a      	lsls	r2, r3
    a046:	9b03      	ldr	r3, [sp, #12]
    a048:	609a      	str	r2, [r3, #8]
    }
    else
    {
        base->PSOR = 1U << pin;
    }
}
    a04a:	e004      	b.n	a056 <GPIO_WritePinOutput+0x2a>
        base->PSOR = 1U << pin;
    a04c:	2201      	movs	r2, #1
    a04e:	9b02      	ldr	r3, [sp, #8]
    a050:	409a      	lsls	r2, r3
    a052:	9b03      	ldr	r3, [sp, #12]
    a054:	605a      	str	r2, [r3, #4]
}
    a056:	bf00      	nop
    a058:	b004      	add	sp, #16
    a05a:	4770      	bx	lr

0000a05c <gpio_init>:
    pin_function(pin, (int)kPORT_MuxAsGpio);
    return 1 << pin_num;
}

void gpio_init(gpio_t *obj, PinName pin)
{
    a05c:	b500      	push	{lr}
    a05e:	b083      	sub	sp, #12
    a060:	9001      	str	r0, [sp, #4]
    a062:	9100      	str	r1, [sp, #0]
    obj->pin = pin;
    a064:	9b01      	ldr	r3, [sp, #4]
    a066:	9a00      	ldr	r2, [sp, #0]
    a068:	601a      	str	r2, [r3, #0]
    if (pin == (PinName)NC)
    a06a:	9b00      	ldr	r3, [sp, #0]
    a06c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    a070:	d004      	beq.n	a07c <gpio_init+0x20>
        return;

    pin_function(pin, (int)kPORT_MuxAsGpio);
    a072:	2101      	movs	r1, #1
    a074:	9800      	ldr	r0, [sp, #0]
    a076:	f000 f8b5 	bl	a1e4 <pin_function>
    a07a:	e000      	b.n	a07e <gpio_init+0x22>
        return;
    a07c:	bf00      	nop
}
    a07e:	b003      	add	sp, #12
    a080:	f85d fb04 	ldr.w	pc, [sp], #4

0000a084 <gpio_mode>:

void gpio_mode(gpio_t *obj, PinMode mode)
{
    a084:	b500      	push	{lr}
    a086:	b083      	sub	sp, #12
    a088:	9001      	str	r0, [sp, #4]
    a08a:	460b      	mov	r3, r1
    a08c:	f88d 3003 	strb.w	r3, [sp, #3]
    pin_mode(obj->pin, mode);
    a090:	9b01      	ldr	r3, [sp, #4]
    a092:	681b      	ldr	r3, [r3, #0]
    a094:	f89d 2003 	ldrb.w	r2, [sp, #3]
    a098:	4611      	mov	r1, r2
    a09a:	4618      	mov	r0, r3
    a09c:	f000 f8d8 	bl	a250 <pin_mode>
}
    a0a0:	bf00      	nop
    a0a2:	b003      	add	sp, #12
    a0a4:	f85d fb04 	ldr.w	pc, [sp], #4

0000a0a8 <gpio_dir>:

void gpio_dir(gpio_t *obj, PinDirection direction)
{
    a0a8:	b500      	push	{lr}
    a0aa:	b087      	sub	sp, #28
    a0ac:	9001      	str	r0, [sp, #4]
    a0ae:	460b      	mov	r3, r1
    a0b0:	f88d 3003 	strb.w	r3, [sp, #3]
    MBED_ASSERT(obj->pin != (PinName)NC);
    a0b4:	9b01      	ldr	r3, [sp, #4]
    a0b6:	681b      	ldr	r3, [r3, #0]
    a0b8:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    a0bc:	d104      	bne.n	a0c8 <gpio_dir+0x20>
    a0be:	2231      	movs	r2, #49	; 0x31
    a0c0:	4918      	ldr	r1, [pc, #96]	; (a124 <gpio_dir+0x7c>)
    a0c2:	4819      	ldr	r0, [pc, #100]	; (a128 <gpio_dir+0x80>)
    a0c4:	f7f8 fca6 	bl	2a14 <mbed_assert_internal>
    uint32_t port = obj->pin >> GPIO_PORT_SHIFT;
    a0c8:	9b01      	ldr	r3, [sp, #4]
    a0ca:	681b      	ldr	r3, [r3, #0]
    a0cc:	131b      	asrs	r3, r3, #12
    a0ce:	9305      	str	r3, [sp, #20]
    uint32_t pin_num = obj->pin & 0xFF;
    a0d0:	9b01      	ldr	r3, [sp, #4]
    a0d2:	681b      	ldr	r3, [r3, #0]
    a0d4:	b2db      	uxtb	r3, r3
    a0d6:	9304      	str	r3, [sp, #16]
    GPIO_Type *base = gpio_addrs[port];
    a0d8:	4a14      	ldr	r2, [pc, #80]	; (a12c <gpio_dir+0x84>)
    a0da:	9b05      	ldr	r3, [sp, #20]
    a0dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a0e0:	9303      	str	r3, [sp, #12]

    switch (direction) {
    a0e2:	f89d 3003 	ldrb.w	r3, [sp, #3]
    a0e6:	2b00      	cmp	r3, #0
    a0e8:	d002      	beq.n	a0f0 <gpio_dir+0x48>
    a0ea:	2b01      	cmp	r3, #1
    a0ec:	d00b      	beq.n	a106 <gpio_dir+0x5e>
            break;
        case PIN_OUTPUT:
            base->PDDR |= (1U << pin_num);
            break;
    }
}
    a0ee:	e014      	b.n	a11a <gpio_dir+0x72>
            base->PDDR &= ~(1U << pin_num);
    a0f0:	9b03      	ldr	r3, [sp, #12]
    a0f2:	695a      	ldr	r2, [r3, #20]
    a0f4:	2101      	movs	r1, #1
    a0f6:	9b04      	ldr	r3, [sp, #16]
    a0f8:	fa01 f303 	lsl.w	r3, r1, r3
    a0fc:	43db      	mvns	r3, r3
    a0fe:	401a      	ands	r2, r3
    a100:	9b03      	ldr	r3, [sp, #12]
    a102:	615a      	str	r2, [r3, #20]
            break;
    a104:	e009      	b.n	a11a <gpio_dir+0x72>
            base->PDDR |= (1U << pin_num);
    a106:	9b03      	ldr	r3, [sp, #12]
    a108:	695a      	ldr	r2, [r3, #20]
    a10a:	2101      	movs	r1, #1
    a10c:	9b04      	ldr	r3, [sp, #16]
    a10e:	fa01 f303 	lsl.w	r3, r1, r3
    a112:	431a      	orrs	r2, r3
    a114:	9b03      	ldr	r3, [sp, #12]
    a116:	615a      	str	r2, [r3, #20]
            break;
    a118:	bf00      	nop
}
    a11a:	bf00      	nop
    a11c:	b007      	add	sp, #28
    a11e:	f85d fb04 	ldr.w	pc, [sp], #4
    a122:	bf00      	nop
    a124:	00012420 	.word	0x00012420
    a128:	00012480 	.word	0x00012480
    a12c:	000129b0 	.word	0x000129b0

0000a130 <gpio_write>:

void gpio_write(gpio_t *obj, int value)
{
    a130:	b500      	push	{lr}
    a132:	b085      	sub	sp, #20
    a134:	9001      	str	r0, [sp, #4]
    a136:	9100      	str	r1, [sp, #0]
    MBED_ASSERT(obj->pin != (PinName)NC);
    a138:	9b01      	ldr	r3, [sp, #4]
    a13a:	681b      	ldr	r3, [r3, #0]
    a13c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    a140:	d104      	bne.n	a14c <gpio_write+0x1c>
    a142:	2242      	movs	r2, #66	; 0x42
    a144:	490c      	ldr	r1, [pc, #48]	; (a178 <gpio_write+0x48>)
    a146:	480d      	ldr	r0, [pc, #52]	; (a17c <gpio_write+0x4c>)
    a148:	f7f8 fc64 	bl	2a14 <mbed_assert_internal>
    uint32_t port = obj->pin >> GPIO_PORT_SHIFT;
    a14c:	9b01      	ldr	r3, [sp, #4]
    a14e:	681b      	ldr	r3, [r3, #0]
    a150:	131b      	asrs	r3, r3, #12
    a152:	9303      	str	r3, [sp, #12]
    uint32_t pin = obj->pin & 0xFF;
    a154:	9b01      	ldr	r3, [sp, #4]
    a156:	681b      	ldr	r3, [r3, #0]
    a158:	b2db      	uxtb	r3, r3
    a15a:	9302      	str	r3, [sp, #8]

    GPIO_WritePinOutput(gpio_addrs[port], pin, value);
    a15c:	4a08      	ldr	r2, [pc, #32]	; (a180 <gpio_write+0x50>)
    a15e:	9b03      	ldr	r3, [sp, #12]
    a160:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a164:	9a00      	ldr	r2, [sp, #0]
    a166:	b2d2      	uxtb	r2, r2
    a168:	9902      	ldr	r1, [sp, #8]
    a16a:	4618      	mov	r0, r3
    a16c:	f7ff ff5e 	bl	a02c <GPIO_WritePinOutput>
}
    a170:	bf00      	nop
    a172:	b005      	add	sp, #20
    a174:	f85d fb04 	ldr.w	pc, [sp], #4
    a178:	00012420 	.word	0x00012420
    a17c:	00012480 	.word	0x00012480
    a180:	000129b0 	.word	0x000129b0

0000a184 <CLOCK_EnableClock>:
{
    a184:	b084      	sub	sp, #16
    a186:	9001      	str	r0, [sp, #4]
    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
    a188:	9b01      	ldr	r3, [sp, #4]
    a18a:	0c1b      	lsrs	r3, r3, #16
    a18c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    a190:	f503 238e 	add.w	r3, r3, #290816	; 0x47000
    a194:	9303      	str	r3, [sp, #12]
    __FSL_CLOCK_SECURE_BITS_SET((volatile uint32_t *) regAddr, (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name)));
    a196:	9b03      	ldr	r3, [sp, #12]
    a198:	9a03      	ldr	r2, [sp, #12]
    a19a:	6811      	ldr	r1, [r2, #0]
    a19c:	9a01      	ldr	r2, [sp, #4]
    a19e:	b292      	uxth	r2, r2
    a1a0:	2001      	movs	r0, #1
    a1a2:	fa00 f202 	lsl.w	r2, r0, r2
    a1a6:	430a      	orrs	r2, r1
    a1a8:	601a      	str	r2, [r3, #0]
}
    a1aa:	bf00      	nop
    a1ac:	b004      	add	sp, #16
    a1ae:	4770      	bx	lr

0000a1b0 <PORT_SetPinMux>:
 *         reset to zero : kPORT_PinDisabledOrAnalog).
 *        This function is recommended to use to reset the pin mux
 *
 */
static inline void PORT_SetPinMux(PORT_Type *base, uint32_t pin, port_mux_t mux)
{
    a1b0:	b084      	sub	sp, #16
    a1b2:	9003      	str	r0, [sp, #12]
    a1b4:	9102      	str	r1, [sp, #8]
    a1b6:	4613      	mov	r3, r2
    a1b8:	f88d 3007 	strb.w	r3, [sp, #7]
    base->PCR[pin] = (base->PCR[pin] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(mux);
    a1bc:	9b03      	ldr	r3, [sp, #12]
    a1be:	9a02      	ldr	r2, [sp, #8]
    a1c0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    a1c4:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
    a1c8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a1cc:	021b      	lsls	r3, r3, #8
    a1ce:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    a1d2:	ea42 0103 	orr.w	r1, r2, r3
    a1d6:	9b03      	ldr	r3, [sp, #12]
    a1d8:	9a02      	ldr	r2, [sp, #8]
    a1da:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    a1de:	bf00      	nop
    a1e0:	b004      	add	sp, #16
    a1e2:	4770      	bx	lr

0000a1e4 <pin_function>:

/* Array of PORT peripheral base address. */
static PORT_Type *const port_addrs[] = PORT_BASE_PTRS;

void pin_function(PinName pin, int function)
{
    a1e4:	b530      	push	{r4, r5, lr}
    a1e6:	b089      	sub	sp, #36	; 0x24
    a1e8:	9001      	str	r0, [sp, #4]
    a1ea:	9100      	str	r1, [sp, #0]
    MBED_ASSERT(pin != (PinName)NC);
    a1ec:	9b01      	ldr	r3, [sp, #4]
    a1ee:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    a1f2:	d104      	bne.n	a1fe <pin_function+0x1a>
    a1f4:	221a      	movs	r2, #26
    a1f6:	4912      	ldr	r1, [pc, #72]	; (a240 <pin_function+0x5c>)
    a1f8:	4812      	ldr	r0, [pc, #72]	; (a244 <pin_function+0x60>)
    a1fa:	f7f8 fc0b 	bl	2a14 <mbed_assert_internal>
    clock_ip_name_t port_clocks[] = PORT_CLOCKS;
    a1fe:	4b12      	ldr	r3, [pc, #72]	; (a248 <pin_function+0x64>)
    a200:	ac03      	add	r4, sp, #12
    a202:	461d      	mov	r5, r3
    a204:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    a206:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    a208:	682b      	ldr	r3, [r5, #0]
    a20a:	6023      	str	r3, [r4, #0]

    CLOCK_EnableClock(port_clocks[pin >> GPIO_PORT_SHIFT]);
    a20c:	9b01      	ldr	r3, [sp, #4]
    a20e:	131b      	asrs	r3, r3, #12
    a210:	009b      	lsls	r3, r3, #2
    a212:	aa08      	add	r2, sp, #32
    a214:	4413      	add	r3, r2
    a216:	f853 3c14 	ldr.w	r3, [r3, #-20]
    a21a:	4618      	mov	r0, r3
    a21c:	f7ff ffb2 	bl	a184 <CLOCK_EnableClock>

    PORT_SetPinMux(port_addrs[pin >> GPIO_PORT_SHIFT], pin & 0xFF, (port_mux_t)function);
    a220:	9b01      	ldr	r3, [sp, #4]
    a222:	131b      	asrs	r3, r3, #12
    a224:	4a09      	ldr	r2, [pc, #36]	; (a24c <pin_function+0x68>)
    a226:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a22a:	9a01      	ldr	r2, [sp, #4]
    a22c:	b2d1      	uxtb	r1, r2
    a22e:	9a00      	ldr	r2, [sp, #0]
    a230:	b2d2      	uxtb	r2, r2
    a232:	4618      	mov	r0, r3
    a234:	f7ff ffbc 	bl	a1b0 <PORT_SetPinMux>
}
    a238:	bf00      	nop
    a23a:	b009      	add	sp, #36	; 0x24
    a23c:	bd30      	pop	{r4, r5, pc}
    a23e:	bf00      	nop
    a240:	00012498 	.word	0x00012498
    a244:	000124e0 	.word	0x000124e0
    a248:	000124f4 	.word	0x000124f4
    a24c:	000129c4 	.word	0x000129c4

0000a250 <pin_mode>:

void pin_mode(PinName pin, PinMode mode)
{
    a250:	b500      	push	{lr}
    a252:	b087      	sub	sp, #28
    a254:	9001      	str	r0, [sp, #4]
    a256:	460b      	mov	r3, r1
    a258:	f88d 3003 	strb.w	r3, [sp, #3]
    MBED_ASSERT(pin != (PinName)NC);
    a25c:	9b01      	ldr	r3, [sp, #4]
    a25e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    a262:	d104      	bne.n	a26e <pin_mode+0x1e>
    a264:	2224      	movs	r2, #36	; 0x24
    a266:	4920      	ldr	r1, [pc, #128]	; (a2e8 <pin_mode+0x98>)
    a268:	4820      	ldr	r0, [pc, #128]	; (a2ec <pin_mode+0x9c>)
    a26a:	f7f8 fbd3 	bl	2a14 <mbed_assert_internal>
    uint32_t instance = pin >> GPIO_PORT_SHIFT;
    a26e:	9b01      	ldr	r3, [sp, #4]
    a270:	131b      	asrs	r3, r3, #12
    a272:	9304      	str	r3, [sp, #16]
    uint32_t pinName = pin & 0xFF;
    a274:	9b01      	ldr	r3, [sp, #4]
    a276:	b2db      	uxtb	r3, r3
    a278:	9303      	str	r3, [sp, #12]
    PORT_Type *base = port_addrs[instance];
    a27a:	4a1d      	ldr	r2, [pc, #116]	; (a2f0 <pin_mode+0xa0>)
    a27c:	9b04      	ldr	r3, [sp, #16]
    a27e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a282:	9302      	str	r3, [sp, #8]
    uint32_t reg = base->PCR[pinName];
    a284:	9b02      	ldr	r3, [sp, #8]
    a286:	9a03      	ldr	r2, [sp, #12]
    a288:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    a28c:	9305      	str	r3, [sp, #20]

    switch (mode) {
    a28e:	f89d 3003 	ldrb.w	r3, [sp, #3]
    a292:	2b01      	cmp	r3, #1
    a294:	d00b      	beq.n	a2ae <pin_mode+0x5e>
    a296:	2b02      	cmp	r3, #2
    a298:	d014      	beq.n	a2c4 <pin_mode+0x74>
    a29a:	2b00      	cmp	r3, #0
    a29c:	d000      	beq.n	a2a0 <pin_mode+0x50>
            /* Write 0 ISF bit, 1 to the PE & PS bits to enable the pull up configuration */
            reg &= ~(PORT_PCR_ISF_MASK);
            reg |= (PORT_PCR_PE_MASK | PORT_PCR_PS_MASK);
            break;
        default:
            break;
    a29e:	e01a      	b.n	a2d6 <pin_mode+0x86>
            reg &= ~(PORT_PCR_PE_MASK | PORT_PCR_PS_MASK | PORT_PCR_ISF_MASK);
    a2a0:	9b05      	ldr	r3, [sp, #20]
    a2a2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    a2a6:	f023 0303 	bic.w	r3, r3, #3
    a2aa:	9305      	str	r3, [sp, #20]
            break;
    a2ac:	e013      	b.n	a2d6 <pin_mode+0x86>
            reg &= ~(PORT_PCR_PS_MASK | PORT_PCR_ISF_MASK);
    a2ae:	9b05      	ldr	r3, [sp, #20]
    a2b0:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    a2b4:	f023 0301 	bic.w	r3, r3, #1
    a2b8:	9305      	str	r3, [sp, #20]
            reg |= PORT_PCR_PE_MASK;
    a2ba:	9b05      	ldr	r3, [sp, #20]
    a2bc:	f043 0302 	orr.w	r3, r3, #2
    a2c0:	9305      	str	r3, [sp, #20]
            break;
    a2c2:	e008      	b.n	a2d6 <pin_mode+0x86>
            reg &= ~(PORT_PCR_ISF_MASK);
    a2c4:	9b05      	ldr	r3, [sp, #20]
    a2c6:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    a2ca:	9305      	str	r3, [sp, #20]
            reg |= (PORT_PCR_PE_MASK | PORT_PCR_PS_MASK);
    a2cc:	9b05      	ldr	r3, [sp, #20]
    a2ce:	f043 0303 	orr.w	r3, r3, #3
    a2d2:	9305      	str	r3, [sp, #20]
            break;
    a2d4:	bf00      	nop
    }

    base->PCR[pinName] = reg;
    a2d6:	9b02      	ldr	r3, [sp, #8]
    a2d8:	9a03      	ldr	r2, [sp, #12]
    a2da:	9905      	ldr	r1, [sp, #20]
    a2dc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    a2e0:	bf00      	nop
    a2e2:	b007      	add	sp, #28
    a2e4:	f85d fb04 	ldr.w	pc, [sp], #4
    a2e8:	00012498 	.word	0x00012498
    a2ec:	000124e0 	.word	0x000124e0
    a2f0:	000129c4 	.word	0x000129c4

0000a2f4 <SMC_SetPowerModeProtection>:
 *
 * @param base SMC peripheral base address.
 * @param allowedModes Bitmap of the allowed power modes.
 */
static inline void SMC_SetPowerModeProtection(SMC_Type *base, uint8_t allowedModes)
{
    a2f4:	b082      	sub	sp, #8
    a2f6:	9001      	str	r0, [sp, #4]
    a2f8:	460b      	mov	r3, r1
    a2fa:	f88d 3003 	strb.w	r3, [sp, #3]
    base->PMPROT = allowedModes;
    a2fe:	9b01      	ldr	r3, [sp, #4]
    a300:	f89d 2003 	ldrb.w	r2, [sp, #3]
    a304:	701a      	strb	r2, [r3, #0]
}
    a306:	bf00      	nop
    a308:	b002      	add	sp, #8
    a30a:	4770      	bx	lr

0000a30c <hal_sleep>:
#include "cmsis.h"
#include "fsl_smc.h"
#include "fsl_clock_config.h"

void hal_sleep(void)
{
    a30c:	b508      	push	{r3, lr}
    SMC_SetPowerModeProtection(SMC, kSMC_AllowPowerModeAll);
    a30e:	212a      	movs	r1, #42	; 0x2a
    a310:	4803      	ldr	r0, [pc, #12]	; (a320 <hal_sleep+0x14>)
    a312:	f7ff ffef 	bl	a2f4 <SMC_SetPowerModeProtection>

    SMC_SetPowerModeWait(SMC);
    a316:	4802      	ldr	r0, [pc, #8]	; (a320 <hal_sleep+0x14>)
    a318:	f7fe ff58 	bl	91cc <SMC_SetPowerModeWait>
}
    a31c:	bf00      	nop
    a31e:	bd08      	pop	{r3, pc}
    a320:	4007e000 	.word	0x4007e000

0000a324 <__assert_func>:
    a324:	b500      	push	{lr}
    a326:	4c0a      	ldr	r4, [pc, #40]	; (a350 <__assert_func+0x2c>)
    a328:	6826      	ldr	r6, [r4, #0]
    a32a:	4605      	mov	r5, r0
    a32c:	b085      	sub	sp, #20
    a32e:	461c      	mov	r4, r3
    a330:	68f0      	ldr	r0, [r6, #12]
    a332:	b152      	cbz	r2, a34a <__assert_func+0x26>
    a334:	4b07      	ldr	r3, [pc, #28]	; (a354 <__assert_func+0x30>)
    a336:	9202      	str	r2, [sp, #8]
    a338:	e88d 000a 	stmia.w	sp, {r1, r3}
    a33c:	4622      	mov	r2, r4
    a33e:	462b      	mov	r3, r5
    a340:	4905      	ldr	r1, [pc, #20]	; (a358 <__assert_func+0x34>)
    a342:	f000 f9bf 	bl	a6c4 <fiprintf>
    a346:	f004 fec5 	bl	f0d4 <abort>
    a34a:	4b04      	ldr	r3, [pc, #16]	; (a35c <__assert_func+0x38>)
    a34c:	461a      	mov	r2, r3
    a34e:	e7f2      	b.n	a336 <__assert_func+0x12>
    a350:	200001c0 	.word	0x200001c0
    a354:	000129d8 	.word	0x000129d8
    a358:	000129e8 	.word	0x000129e8
    a35c:	000129e4 	.word	0x000129e4

0000a360 <calloc>:
    a360:	4b02      	ldr	r3, [pc, #8]	; (a36c <calloc+0xc>)
    a362:	460a      	mov	r2, r1
    a364:	4601      	mov	r1, r0
    a366:	6818      	ldr	r0, [r3, #0]
    a368:	f7f8 bb2a 	b.w	29c0 <__wrap__calloc_r>
    a36c:	200001c0 	.word	0x200001c0

0000a370 <__errno>:
    a370:	4b01      	ldr	r3, [pc, #4]	; (a378 <__errno+0x8>)
    a372:	6818      	ldr	r0, [r3, #0]
    a374:	4770      	bx	lr
    a376:	bf00      	nop
    a378:	200001c0 	.word	0x200001c0

0000a37c <_fclose_r>:
    a37c:	b570      	push	{r4, r5, r6, lr}
    a37e:	b159      	cbz	r1, a398 <_fclose_r+0x1c>
    a380:	4605      	mov	r5, r0
    a382:	460c      	mov	r4, r1
    a384:	b110      	cbz	r0, a38c <_fclose_r+0x10>
    a386:	6b83      	ldr	r3, [r0, #56]	; 0x38
    a388:	2b00      	cmp	r3, #0
    a38a:	d03c      	beq.n	a406 <_fclose_r+0x8a>
    a38c:	6e63      	ldr	r3, [r4, #100]	; 0x64
    a38e:	07d8      	lsls	r0, r3, #31
    a390:	d505      	bpl.n	a39e <_fclose_r+0x22>
    a392:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    a396:	b92b      	cbnz	r3, a3a4 <_fclose_r+0x28>
    a398:	2600      	movs	r6, #0
    a39a:	4630      	mov	r0, r6
    a39c:	bd70      	pop	{r4, r5, r6, pc}
    a39e:	89a3      	ldrh	r3, [r4, #12]
    a3a0:	0599      	lsls	r1, r3, #22
    a3a2:	d53c      	bpl.n	a41e <_fclose_r+0xa2>
    a3a4:	4621      	mov	r1, r4
    a3a6:	4628      	mov	r0, r5
    a3a8:	f000 f84a 	bl	a440 <__sflush_r>
    a3ac:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    a3ae:	4606      	mov	r6, r0
    a3b0:	b133      	cbz	r3, a3c0 <_fclose_r+0x44>
    a3b2:	69e1      	ldr	r1, [r4, #28]
    a3b4:	4628      	mov	r0, r5
    a3b6:	4798      	blx	r3
    a3b8:	2800      	cmp	r0, #0
    a3ba:	bfb8      	it	lt
    a3bc:	f04f 36ff 	movlt.w	r6, #4294967295	; 0xffffffff
    a3c0:	89a3      	ldrh	r3, [r4, #12]
    a3c2:	061a      	lsls	r2, r3, #24
    a3c4:	d422      	bmi.n	a40c <_fclose_r+0x90>
    a3c6:	6b21      	ldr	r1, [r4, #48]	; 0x30
    a3c8:	b141      	cbz	r1, a3dc <_fclose_r+0x60>
    a3ca:	f104 0340 	add.w	r3, r4, #64	; 0x40
    a3ce:	4299      	cmp	r1, r3
    a3d0:	d002      	beq.n	a3d8 <_fclose_r+0x5c>
    a3d2:	4628      	mov	r0, r5
    a3d4:	f7f8 faa7 	bl	2926 <__wrap__free_r>
    a3d8:	2300      	movs	r3, #0
    a3da:	6323      	str	r3, [r4, #48]	; 0x30
    a3dc:	6c61      	ldr	r1, [r4, #68]	; 0x44
    a3de:	b121      	cbz	r1, a3ea <_fclose_r+0x6e>
    a3e0:	4628      	mov	r0, r5
    a3e2:	f7f8 faa0 	bl	2926 <__wrap__free_r>
    a3e6:	2300      	movs	r3, #0
    a3e8:	6463      	str	r3, [r4, #68]	; 0x44
    a3ea:	f000 f95f 	bl	a6ac <__sfp_lock_acquire>
    a3ee:	6e63      	ldr	r3, [r4, #100]	; 0x64
    a3f0:	2200      	movs	r2, #0
    a3f2:	07db      	lsls	r3, r3, #31
    a3f4:	81a2      	strh	r2, [r4, #12]
    a3f6:	d50e      	bpl.n	a416 <_fclose_r+0x9a>
    a3f8:	6da0      	ldr	r0, [r4, #88]	; 0x58
    a3fa:	f000 fc9b 	bl	ad34 <__retarget_lock_close_recursive>
    a3fe:	f000 f95b 	bl	a6b8 <__sfp_lock_release>
    a402:	4630      	mov	r0, r6
    a404:	bd70      	pop	{r4, r5, r6, pc}
    a406:	f000 f925 	bl	a654 <__sinit>
    a40a:	e7bf      	b.n	a38c <_fclose_r+0x10>
    a40c:	6921      	ldr	r1, [r4, #16]
    a40e:	4628      	mov	r0, r5
    a410:	f7f8 fa89 	bl	2926 <__wrap__free_r>
    a414:	e7d7      	b.n	a3c6 <_fclose_r+0x4a>
    a416:	6da0      	ldr	r0, [r4, #88]	; 0x58
    a418:	f000 fc90 	bl	ad3c <__retarget_lock_release_recursive>
    a41c:	e7ec      	b.n	a3f8 <_fclose_r+0x7c>
    a41e:	6da0      	ldr	r0, [r4, #88]	; 0x58
    a420:	f000 fc8a 	bl	ad38 <__retarget_lock_acquire_recursive>
    a424:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    a428:	2b00      	cmp	r3, #0
    a42a:	d1bb      	bne.n	a3a4 <_fclose_r+0x28>
    a42c:	6e66      	ldr	r6, [r4, #100]	; 0x64
    a42e:	f016 0601 	ands.w	r6, r6, #1
    a432:	d1b1      	bne.n	a398 <_fclose_r+0x1c>
    a434:	6da0      	ldr	r0, [r4, #88]	; 0x58
    a436:	f000 fc81 	bl	ad3c <__retarget_lock_release_recursive>
    a43a:	4630      	mov	r0, r6
    a43c:	bd70      	pop	{r4, r5, r6, pc}
    a43e:	bf00      	nop

0000a440 <__sflush_r>:
    a440:	f9b1 300c 	ldrsh.w	r3, [r1, #12]
    a444:	b29a      	uxth	r2, r3
    a446:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a44a:	460d      	mov	r5, r1
    a44c:	0711      	lsls	r1, r2, #28
    a44e:	4680      	mov	r8, r0
    a450:	d43a      	bmi.n	a4c8 <__sflush_r+0x88>
    a452:	686a      	ldr	r2, [r5, #4]
    a454:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
    a458:	2a00      	cmp	r2, #0
    a45a:	81ab      	strh	r3, [r5, #12]
    a45c:	dd6f      	ble.n	a53e <__sflush_r+0xfe>
    a45e:	6aac      	ldr	r4, [r5, #40]	; 0x28
    a460:	2c00      	cmp	r4, #0
    a462:	d049      	beq.n	a4f8 <__sflush_r+0xb8>
    a464:	2200      	movs	r2, #0
    a466:	b29b      	uxth	r3, r3
    a468:	f8d8 6000 	ldr.w	r6, [r8]
    a46c:	f8c8 2000 	str.w	r2, [r8]
    a470:	f413 5280 	ands.w	r2, r3, #4096	; 0x1000
    a474:	d067      	beq.n	a546 <__sflush_r+0x106>
    a476:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    a478:	075f      	lsls	r7, r3, #29
    a47a:	d505      	bpl.n	a488 <__sflush_r+0x48>
    a47c:	6869      	ldr	r1, [r5, #4]
    a47e:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    a480:	1a52      	subs	r2, r2, r1
    a482:	b10b      	cbz	r3, a488 <__sflush_r+0x48>
    a484:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    a486:	1ad2      	subs	r2, r2, r3
    a488:	2300      	movs	r3, #0
    a48a:	69e9      	ldr	r1, [r5, #28]
    a48c:	4640      	mov	r0, r8
    a48e:	47a0      	blx	r4
    a490:	1c44      	adds	r4, r0, #1
    a492:	d03c      	beq.n	a50e <__sflush_r+0xce>
    a494:	f9b5 300c 	ldrsh.w	r3, [r5, #12]
    a498:	692a      	ldr	r2, [r5, #16]
    a49a:	602a      	str	r2, [r5, #0]
    a49c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    a4a0:	2200      	movs	r2, #0
    a4a2:	81ab      	strh	r3, [r5, #12]
    a4a4:	04db      	lsls	r3, r3, #19
    a4a6:	606a      	str	r2, [r5, #4]
    a4a8:	d447      	bmi.n	a53a <__sflush_r+0xfa>
    a4aa:	6b29      	ldr	r1, [r5, #48]	; 0x30
    a4ac:	f8c8 6000 	str.w	r6, [r8]
    a4b0:	b311      	cbz	r1, a4f8 <__sflush_r+0xb8>
    a4b2:	f105 0340 	add.w	r3, r5, #64	; 0x40
    a4b6:	4299      	cmp	r1, r3
    a4b8:	d002      	beq.n	a4c0 <__sflush_r+0x80>
    a4ba:	4640      	mov	r0, r8
    a4bc:	f7f8 fa33 	bl	2926 <__wrap__free_r>
    a4c0:	2000      	movs	r0, #0
    a4c2:	6328      	str	r0, [r5, #48]	; 0x30
    a4c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a4c8:	692e      	ldr	r6, [r5, #16]
    a4ca:	b1ae      	cbz	r6, a4f8 <__sflush_r+0xb8>
    a4cc:	682c      	ldr	r4, [r5, #0]
    a4ce:	602e      	str	r6, [r5, #0]
    a4d0:	0791      	lsls	r1, r2, #30
    a4d2:	bf0c      	ite	eq
    a4d4:	696b      	ldreq	r3, [r5, #20]
    a4d6:	2300      	movne	r3, #0
    a4d8:	1ba4      	subs	r4, r4, r6
    a4da:	60ab      	str	r3, [r5, #8]
    a4dc:	e00a      	b.n	a4f4 <__sflush_r+0xb4>
    a4de:	4623      	mov	r3, r4
    a4e0:	4632      	mov	r2, r6
    a4e2:	6a6f      	ldr	r7, [r5, #36]	; 0x24
    a4e4:	69e9      	ldr	r1, [r5, #28]
    a4e6:	4640      	mov	r0, r8
    a4e8:	47b8      	blx	r7
    a4ea:	2800      	cmp	r0, #0
    a4ec:	eba4 0400 	sub.w	r4, r4, r0
    a4f0:	4406      	add	r6, r0
    a4f2:	dd04      	ble.n	a4fe <__sflush_r+0xbe>
    a4f4:	2c00      	cmp	r4, #0
    a4f6:	dcf2      	bgt.n	a4de <__sflush_r+0x9e>
    a4f8:	2000      	movs	r0, #0
    a4fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a4fe:	89ab      	ldrh	r3, [r5, #12]
    a500:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a504:	81ab      	strh	r3, [r5, #12]
    a506:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a50a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a50e:	f8d8 4000 	ldr.w	r4, [r8]
    a512:	2c1d      	cmp	r4, #29
    a514:	d8f3      	bhi.n	a4fe <__sflush_r+0xbe>
    a516:	4b19      	ldr	r3, [pc, #100]	; (a57c <__sflush_r+0x13c>)
    a518:	40e3      	lsrs	r3, r4
    a51a:	43db      	mvns	r3, r3
    a51c:	f013 0301 	ands.w	r3, r3, #1
    a520:	d1ed      	bne.n	a4fe <__sflush_r+0xbe>
    a522:	f9b5 200c 	ldrsh.w	r2, [r5, #12]
    a526:	606b      	str	r3, [r5, #4]
    a528:	f422 6300 	bic.w	r3, r2, #2048	; 0x800
    a52c:	6929      	ldr	r1, [r5, #16]
    a52e:	81ab      	strh	r3, [r5, #12]
    a530:	04da      	lsls	r2, r3, #19
    a532:	6029      	str	r1, [r5, #0]
    a534:	d5b9      	bpl.n	a4aa <__sflush_r+0x6a>
    a536:	2c00      	cmp	r4, #0
    a538:	d1b7      	bne.n	a4aa <__sflush_r+0x6a>
    a53a:	6528      	str	r0, [r5, #80]	; 0x50
    a53c:	e7b5      	b.n	a4aa <__sflush_r+0x6a>
    a53e:	6bea      	ldr	r2, [r5, #60]	; 0x3c
    a540:	2a00      	cmp	r2, #0
    a542:	dc8c      	bgt.n	a45e <__sflush_r+0x1e>
    a544:	e7d8      	b.n	a4f8 <__sflush_r+0xb8>
    a546:	2301      	movs	r3, #1
    a548:	69e9      	ldr	r1, [r5, #28]
    a54a:	4640      	mov	r0, r8
    a54c:	47a0      	blx	r4
    a54e:	1c43      	adds	r3, r0, #1
    a550:	4602      	mov	r2, r0
    a552:	d002      	beq.n	a55a <__sflush_r+0x11a>
    a554:	89ab      	ldrh	r3, [r5, #12]
    a556:	6aac      	ldr	r4, [r5, #40]	; 0x28
    a558:	e78e      	b.n	a478 <__sflush_r+0x38>
    a55a:	f8d8 3000 	ldr.w	r3, [r8]
    a55e:	2b00      	cmp	r3, #0
    a560:	d0f8      	beq.n	a554 <__sflush_r+0x114>
    a562:	2b1d      	cmp	r3, #29
    a564:	d001      	beq.n	a56a <__sflush_r+0x12a>
    a566:	2b16      	cmp	r3, #22
    a568:	d102      	bne.n	a570 <__sflush_r+0x130>
    a56a:	f8c8 6000 	str.w	r6, [r8]
    a56e:	e7c3      	b.n	a4f8 <__sflush_r+0xb8>
    a570:	89ab      	ldrh	r3, [r5, #12]
    a572:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a576:	81ab      	strh	r3, [r5, #12]
    a578:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a57c:	20400001 	.word	0x20400001

0000a580 <_fflush_r>:
    a580:	b538      	push	{r3, r4, r5, lr}
    a582:	460d      	mov	r5, r1
    a584:	4604      	mov	r4, r0
    a586:	b108      	cbz	r0, a58c <_fflush_r+0xc>
    a588:	6b83      	ldr	r3, [r0, #56]	; 0x38
    a58a:	b1bb      	cbz	r3, a5bc <_fflush_r+0x3c>
    a58c:	f9b5 000c 	ldrsh.w	r0, [r5, #12]
    a590:	b188      	cbz	r0, a5b6 <_fflush_r+0x36>
    a592:	6e6b      	ldr	r3, [r5, #100]	; 0x64
    a594:	07db      	lsls	r3, r3, #31
    a596:	d401      	bmi.n	a59c <_fflush_r+0x1c>
    a598:	0581      	lsls	r1, r0, #22
    a59a:	d517      	bpl.n	a5cc <_fflush_r+0x4c>
    a59c:	4620      	mov	r0, r4
    a59e:	4629      	mov	r1, r5
    a5a0:	f7ff ff4e 	bl	a440 <__sflush_r>
    a5a4:	6e6b      	ldr	r3, [r5, #100]	; 0x64
    a5a6:	07da      	lsls	r2, r3, #31
    a5a8:	4604      	mov	r4, r0
    a5aa:	d402      	bmi.n	a5b2 <_fflush_r+0x32>
    a5ac:	89ab      	ldrh	r3, [r5, #12]
    a5ae:	059b      	lsls	r3, r3, #22
    a5b0:	d507      	bpl.n	a5c2 <_fflush_r+0x42>
    a5b2:	4620      	mov	r0, r4
    a5b4:	bd38      	pop	{r3, r4, r5, pc}
    a5b6:	4604      	mov	r4, r0
    a5b8:	4620      	mov	r0, r4
    a5ba:	bd38      	pop	{r3, r4, r5, pc}
    a5bc:	f000 f84a 	bl	a654 <__sinit>
    a5c0:	e7e4      	b.n	a58c <_fflush_r+0xc>
    a5c2:	6da8      	ldr	r0, [r5, #88]	; 0x58
    a5c4:	f000 fbba 	bl	ad3c <__retarget_lock_release_recursive>
    a5c8:	4620      	mov	r0, r4
    a5ca:	bd38      	pop	{r3, r4, r5, pc}
    a5cc:	6da8      	ldr	r0, [r5, #88]	; 0x58
    a5ce:	f000 fbb3 	bl	ad38 <__retarget_lock_acquire_recursive>
    a5d2:	e7e3      	b.n	a59c <_fflush_r+0x1c>

0000a5d4 <fflush>:
    a5d4:	b120      	cbz	r0, a5e0 <fflush+0xc>
    a5d6:	4b05      	ldr	r3, [pc, #20]	; (a5ec <fflush+0x18>)
    a5d8:	4601      	mov	r1, r0
    a5da:	6818      	ldr	r0, [r3, #0]
    a5dc:	f7ff bfd0 	b.w	a580 <_fflush_r>
    a5e0:	4b03      	ldr	r3, [pc, #12]	; (a5f0 <fflush+0x1c>)
    a5e2:	4904      	ldr	r1, [pc, #16]	; (a5f4 <fflush+0x20>)
    a5e4:	6818      	ldr	r0, [r3, #0]
    a5e6:	f000 bb43 	b.w	ac70 <_fwalk_reent>
    a5ea:	bf00      	nop
    a5ec:	200001c0 	.word	0x200001c0
    a5f0:	00012a18 	.word	0x00012a18
    a5f4:	0000a581 	.word	0x0000a581

0000a5f8 <_cleanup_r>:
    a5f8:	4901      	ldr	r1, [pc, #4]	; (a600 <_cleanup_r+0x8>)
    a5fa:	f000 bb39 	b.w	ac70 <_fwalk_reent>
    a5fe:	bf00      	nop
    a600:	0000a37d 	.word	0x0000a37d

0000a604 <std.isra.0>:
    a604:	b510      	push	{r4, lr}
    a606:	2300      	movs	r3, #0
    a608:	4604      	mov	r4, r0
    a60a:	8181      	strh	r1, [r0, #12]
    a60c:	81c2      	strh	r2, [r0, #14]
    a60e:	6003      	str	r3, [r0, #0]
    a610:	6043      	str	r3, [r0, #4]
    a612:	6083      	str	r3, [r0, #8]
    a614:	6643      	str	r3, [r0, #100]	; 0x64
    a616:	6103      	str	r3, [r0, #16]
    a618:	6143      	str	r3, [r0, #20]
    a61a:	6183      	str	r3, [r0, #24]
    a61c:	4619      	mov	r1, r3
    a61e:	2208      	movs	r2, #8
    a620:	305c      	adds	r0, #92	; 0x5c
    a622:	f000 ff3f 	bl	b4a4 <memset>
    a626:	4807      	ldr	r0, [pc, #28]	; (a644 <std.isra.0+0x40>)
    a628:	4907      	ldr	r1, [pc, #28]	; (a648 <std.isra.0+0x44>)
    a62a:	4a08      	ldr	r2, [pc, #32]	; (a64c <std.isra.0+0x48>)
    a62c:	4b08      	ldr	r3, [pc, #32]	; (a650 <std.isra.0+0x4c>)
    a62e:	6220      	str	r0, [r4, #32]
    a630:	61e4      	str	r4, [r4, #28]
    a632:	6261      	str	r1, [r4, #36]	; 0x24
    a634:	62a2      	str	r2, [r4, #40]	; 0x28
    a636:	62e3      	str	r3, [r4, #44]	; 0x2c
    a638:	f104 0058 	add.w	r0, r4, #88	; 0x58
    a63c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    a640:	f000 bb76 	b.w	ad30 <__retarget_lock_init_recursive>
    a644:	0000b59d 	.word	0x0000b59d
    a648:	0000b5c1 	.word	0x0000b5c1
    a64c:	0000b5fd 	.word	0x0000b5fd
    a650:	0000b61d 	.word	0x0000b61d

0000a654 <__sinit>:
    a654:	b510      	push	{r4, lr}
    a656:	4604      	mov	r4, r0
    a658:	4812      	ldr	r0, [pc, #72]	; (a6a4 <__sinit+0x50>)
    a65a:	f000 fb6d 	bl	ad38 <__retarget_lock_acquire_recursive>
    a65e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    a660:	b9d2      	cbnz	r2, a698 <__sinit+0x44>
    a662:	f504 733b 	add.w	r3, r4, #748	; 0x2ec
    a666:	4810      	ldr	r0, [pc, #64]	; (a6a8 <__sinit+0x54>)
    a668:	f8c4 32e8 	str.w	r3, [r4, #744]	; 0x2e8
    a66c:	2103      	movs	r1, #3
    a66e:	f8c4 22e0 	str.w	r2, [r4, #736]	; 0x2e0
    a672:	63e0      	str	r0, [r4, #60]	; 0x3c
    a674:	f8c4 12e4 	str.w	r1, [r4, #740]	; 0x2e4
    a678:	6860      	ldr	r0, [r4, #4]
    a67a:	2104      	movs	r1, #4
    a67c:	f7ff ffc2 	bl	a604 <std.isra.0>
    a680:	2201      	movs	r2, #1
    a682:	2109      	movs	r1, #9
    a684:	68a0      	ldr	r0, [r4, #8]
    a686:	f7ff ffbd 	bl	a604 <std.isra.0>
    a68a:	2202      	movs	r2, #2
    a68c:	2112      	movs	r1, #18
    a68e:	68e0      	ldr	r0, [r4, #12]
    a690:	f7ff ffb8 	bl	a604 <std.isra.0>
    a694:	2301      	movs	r3, #1
    a696:	63a3      	str	r3, [r4, #56]	; 0x38
    a698:	4802      	ldr	r0, [pc, #8]	; (a6a4 <__sinit+0x50>)
    a69a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    a69e:	f000 bb4d 	b.w	ad3c <__retarget_lock_release_recursive>
    a6a2:	bf00      	nop
    a6a4:	20003028 	.word	0x20003028
    a6a8:	0000a5f9 	.word	0x0000a5f9

0000a6ac <__sfp_lock_acquire>:
    a6ac:	4801      	ldr	r0, [pc, #4]	; (a6b4 <__sfp_lock_acquire+0x8>)
    a6ae:	f000 bb43 	b.w	ad38 <__retarget_lock_acquire_recursive>
    a6b2:	bf00      	nop
    a6b4:	20003034 	.word	0x20003034

0000a6b8 <__sfp_lock_release>:
    a6b8:	4801      	ldr	r0, [pc, #4]	; (a6c0 <__sfp_lock_release+0x8>)
    a6ba:	f000 bb3f 	b.w	ad3c <__retarget_lock_release_recursive>
    a6be:	bf00      	nop
    a6c0:	20003034 	.word	0x20003034

0000a6c4 <fiprintf>:
    a6c4:	b40e      	push	{r1, r2, r3}
    a6c6:	b510      	push	{r4, lr}
    a6c8:	b083      	sub	sp, #12
    a6ca:	ab05      	add	r3, sp, #20
    a6cc:	4c06      	ldr	r4, [pc, #24]	; (a6e8 <fiprintf+0x24>)
    a6ce:	f853 2b04 	ldr.w	r2, [r3], #4
    a6d2:	9301      	str	r3, [sp, #4]
    a6d4:	4601      	mov	r1, r0
    a6d6:	6820      	ldr	r0, [r4, #0]
    a6d8:	f002 fa3c 	bl	cb54 <_vfiprintf_r>
    a6dc:	b003      	add	sp, #12
    a6de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    a6e2:	b003      	add	sp, #12
    a6e4:	4770      	bx	lr
    a6e6:	bf00      	nop
    a6e8:	200001c0 	.word	0x200001c0

0000a6ec <_malloc_trim_r>:
    a6ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a6ee:	4f24      	ldr	r7, [pc, #144]	; (a780 <_malloc_trim_r+0x94>)
    a6f0:	460c      	mov	r4, r1
    a6f2:	4606      	mov	r6, r0
    a6f4:	f7f9 f9e6 	bl	3ac4 <__malloc_lock>
    a6f8:	68bb      	ldr	r3, [r7, #8]
    a6fa:	685d      	ldr	r5, [r3, #4]
    a6fc:	f5c4 617e 	rsb	r1, r4, #4064	; 0xfe0
    a700:	310f      	adds	r1, #15
    a702:	f025 0503 	bic.w	r5, r5, #3
    a706:	4429      	add	r1, r5
    a708:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
    a70c:	f021 010f 	bic.w	r1, r1, #15
    a710:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
    a714:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    a718:	db07      	blt.n	a72a <_malloc_trim_r+0x3e>
    a71a:	2100      	movs	r1, #0
    a71c:	4630      	mov	r0, r6
    a71e:	f000 ff2b 	bl	b578 <_sbrk_r>
    a722:	68bb      	ldr	r3, [r7, #8]
    a724:	442b      	add	r3, r5
    a726:	4298      	cmp	r0, r3
    a728:	d004      	beq.n	a734 <_malloc_trim_r+0x48>
    a72a:	4630      	mov	r0, r6
    a72c:	f7f9 f9d4 	bl	3ad8 <__malloc_unlock>
    a730:	2000      	movs	r0, #0
    a732:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a734:	4261      	negs	r1, r4
    a736:	4630      	mov	r0, r6
    a738:	f000 ff1e 	bl	b578 <_sbrk_r>
    a73c:	3001      	adds	r0, #1
    a73e:	d00d      	beq.n	a75c <_malloc_trim_r+0x70>
    a740:	4b10      	ldr	r3, [pc, #64]	; (a784 <_malloc_trim_r+0x98>)
    a742:	68ba      	ldr	r2, [r7, #8]
    a744:	6819      	ldr	r1, [r3, #0]
    a746:	1b2d      	subs	r5, r5, r4
    a748:	f045 0501 	orr.w	r5, r5, #1
    a74c:	4630      	mov	r0, r6
    a74e:	1b09      	subs	r1, r1, r4
    a750:	6055      	str	r5, [r2, #4]
    a752:	6019      	str	r1, [r3, #0]
    a754:	f7f9 f9c0 	bl	3ad8 <__malloc_unlock>
    a758:	2001      	movs	r0, #1
    a75a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a75c:	2100      	movs	r1, #0
    a75e:	4630      	mov	r0, r6
    a760:	f000 ff0a 	bl	b578 <_sbrk_r>
    a764:	68ba      	ldr	r2, [r7, #8]
    a766:	1a83      	subs	r3, r0, r2
    a768:	2b0f      	cmp	r3, #15
    a76a:	ddde      	ble.n	a72a <_malloc_trim_r+0x3e>
    a76c:	4c06      	ldr	r4, [pc, #24]	; (a788 <_malloc_trim_r+0x9c>)
    a76e:	4905      	ldr	r1, [pc, #20]	; (a784 <_malloc_trim_r+0x98>)
    a770:	6824      	ldr	r4, [r4, #0]
    a772:	f043 0301 	orr.w	r3, r3, #1
    a776:	1b00      	subs	r0, r0, r4
    a778:	6053      	str	r3, [r2, #4]
    a77a:	6008      	str	r0, [r1, #0]
    a77c:	e7d5      	b.n	a72a <_malloc_trim_r+0x3e>
    a77e:	bf00      	nop
    a780:	2000075c 	.word	0x2000075c
    a784:	20001540 	.word	0x20001540
    a788:	20000b64 	.word	0x20000b64

0000a78c <_free_r>:
    a78c:	2900      	cmp	r1, #0
    a78e:	d044      	beq.n	a81a <_free_r+0x8e>
    a790:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a794:	460d      	mov	r5, r1
    a796:	4680      	mov	r8, r0
    a798:	f7f9 f994 	bl	3ac4 <__malloc_lock>
    a79c:	f855 7c04 	ldr.w	r7, [r5, #-4]
    a7a0:	4969      	ldr	r1, [pc, #420]	; (a948 <_free_r+0x1bc>)
    a7a2:	f027 0301 	bic.w	r3, r7, #1
    a7a6:	f1a5 0408 	sub.w	r4, r5, #8
    a7aa:	18e2      	adds	r2, r4, r3
    a7ac:	688e      	ldr	r6, [r1, #8]
    a7ae:	6850      	ldr	r0, [r2, #4]
    a7b0:	42b2      	cmp	r2, r6
    a7b2:	f020 0003 	bic.w	r0, r0, #3
    a7b6:	d05e      	beq.n	a876 <_free_r+0xea>
    a7b8:	07fe      	lsls	r6, r7, #31
    a7ba:	6050      	str	r0, [r2, #4]
    a7bc:	d40b      	bmi.n	a7d6 <_free_r+0x4a>
    a7be:	f855 7c08 	ldr.w	r7, [r5, #-8]
    a7c2:	1be4      	subs	r4, r4, r7
    a7c4:	f101 0e08 	add.w	lr, r1, #8
    a7c8:	68a5      	ldr	r5, [r4, #8]
    a7ca:	4575      	cmp	r5, lr
    a7cc:	443b      	add	r3, r7
    a7ce:	d06d      	beq.n	a8ac <_free_r+0x120>
    a7d0:	68e7      	ldr	r7, [r4, #12]
    a7d2:	60ef      	str	r7, [r5, #12]
    a7d4:	60bd      	str	r5, [r7, #8]
    a7d6:	1815      	adds	r5, r2, r0
    a7d8:	686d      	ldr	r5, [r5, #4]
    a7da:	07ed      	lsls	r5, r5, #31
    a7dc:	d53e      	bpl.n	a85c <_free_r+0xd0>
    a7de:	f043 0201 	orr.w	r2, r3, #1
    a7e2:	6062      	str	r2, [r4, #4]
    a7e4:	50e3      	str	r3, [r4, r3]
    a7e6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    a7ea:	d217      	bcs.n	a81c <_free_r+0x90>
    a7ec:	08db      	lsrs	r3, r3, #3
    a7ee:	1c58      	adds	r0, r3, #1
    a7f0:	109a      	asrs	r2, r3, #2
    a7f2:	684d      	ldr	r5, [r1, #4]
    a7f4:	f851 7030 	ldr.w	r7, [r1, r0, lsl #3]
    a7f8:	60a7      	str	r7, [r4, #8]
    a7fa:	2301      	movs	r3, #1
    a7fc:	4093      	lsls	r3, r2
    a7fe:	eb01 02c0 	add.w	r2, r1, r0, lsl #3
    a802:	432b      	orrs	r3, r5
    a804:	3a08      	subs	r2, #8
    a806:	60e2      	str	r2, [r4, #12]
    a808:	604b      	str	r3, [r1, #4]
    a80a:	f841 4030 	str.w	r4, [r1, r0, lsl #3]
    a80e:	60fc      	str	r4, [r7, #12]
    a810:	4640      	mov	r0, r8
    a812:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    a816:	f7f9 b95f 	b.w	3ad8 <__malloc_unlock>
    a81a:	4770      	bx	lr
    a81c:	0a5a      	lsrs	r2, r3, #9
    a81e:	2a04      	cmp	r2, #4
    a820:	d852      	bhi.n	a8c8 <_free_r+0x13c>
    a822:	099a      	lsrs	r2, r3, #6
    a824:	f102 0739 	add.w	r7, r2, #57	; 0x39
    a828:	00ff      	lsls	r7, r7, #3
    a82a:	f102 0538 	add.w	r5, r2, #56	; 0x38
    a82e:	19c8      	adds	r0, r1, r7
    a830:	59ca      	ldr	r2, [r1, r7]
    a832:	3808      	subs	r0, #8
    a834:	4290      	cmp	r0, r2
    a836:	d04f      	beq.n	a8d8 <_free_r+0x14c>
    a838:	6851      	ldr	r1, [r2, #4]
    a83a:	f021 0103 	bic.w	r1, r1, #3
    a83e:	428b      	cmp	r3, r1
    a840:	d232      	bcs.n	a8a8 <_free_r+0x11c>
    a842:	6892      	ldr	r2, [r2, #8]
    a844:	4290      	cmp	r0, r2
    a846:	d1f7      	bne.n	a838 <_free_r+0xac>
    a848:	68c3      	ldr	r3, [r0, #12]
    a84a:	60a0      	str	r0, [r4, #8]
    a84c:	60e3      	str	r3, [r4, #12]
    a84e:	609c      	str	r4, [r3, #8]
    a850:	60c4      	str	r4, [r0, #12]
    a852:	4640      	mov	r0, r8
    a854:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    a858:	f7f9 b93e 	b.w	3ad8 <__malloc_unlock>
    a85c:	6895      	ldr	r5, [r2, #8]
    a85e:	4f3b      	ldr	r7, [pc, #236]	; (a94c <_free_r+0x1c0>)
    a860:	42bd      	cmp	r5, r7
    a862:	4403      	add	r3, r0
    a864:	d040      	beq.n	a8e8 <_free_r+0x15c>
    a866:	68d0      	ldr	r0, [r2, #12]
    a868:	60e8      	str	r0, [r5, #12]
    a86a:	f043 0201 	orr.w	r2, r3, #1
    a86e:	6085      	str	r5, [r0, #8]
    a870:	6062      	str	r2, [r4, #4]
    a872:	50e3      	str	r3, [r4, r3]
    a874:	e7b7      	b.n	a7e6 <_free_r+0x5a>
    a876:	07ff      	lsls	r7, r7, #31
    a878:	4403      	add	r3, r0
    a87a:	d407      	bmi.n	a88c <_free_r+0x100>
    a87c:	f855 2c08 	ldr.w	r2, [r5, #-8]
    a880:	1aa4      	subs	r4, r4, r2
    a882:	4413      	add	r3, r2
    a884:	68a0      	ldr	r0, [r4, #8]
    a886:	68e2      	ldr	r2, [r4, #12]
    a888:	60c2      	str	r2, [r0, #12]
    a88a:	6090      	str	r0, [r2, #8]
    a88c:	4a30      	ldr	r2, [pc, #192]	; (a950 <_free_r+0x1c4>)
    a88e:	6812      	ldr	r2, [r2, #0]
    a890:	f043 0001 	orr.w	r0, r3, #1
    a894:	4293      	cmp	r3, r2
    a896:	6060      	str	r0, [r4, #4]
    a898:	608c      	str	r4, [r1, #8]
    a89a:	d3b9      	bcc.n	a810 <_free_r+0x84>
    a89c:	4b2d      	ldr	r3, [pc, #180]	; (a954 <_free_r+0x1c8>)
    a89e:	4640      	mov	r0, r8
    a8a0:	6819      	ldr	r1, [r3, #0]
    a8a2:	f7ff ff23 	bl	a6ec <_malloc_trim_r>
    a8a6:	e7b3      	b.n	a810 <_free_r+0x84>
    a8a8:	4610      	mov	r0, r2
    a8aa:	e7cd      	b.n	a848 <_free_r+0xbc>
    a8ac:	1811      	adds	r1, r2, r0
    a8ae:	6849      	ldr	r1, [r1, #4]
    a8b0:	07c9      	lsls	r1, r1, #31
    a8b2:	d444      	bmi.n	a93e <_free_r+0x1b2>
    a8b4:	6891      	ldr	r1, [r2, #8]
    a8b6:	68d2      	ldr	r2, [r2, #12]
    a8b8:	60ca      	str	r2, [r1, #12]
    a8ba:	4403      	add	r3, r0
    a8bc:	f043 0001 	orr.w	r0, r3, #1
    a8c0:	6091      	str	r1, [r2, #8]
    a8c2:	6060      	str	r0, [r4, #4]
    a8c4:	50e3      	str	r3, [r4, r3]
    a8c6:	e7a3      	b.n	a810 <_free_r+0x84>
    a8c8:	2a14      	cmp	r2, #20
    a8ca:	d816      	bhi.n	a8fa <_free_r+0x16e>
    a8cc:	f102 075c 	add.w	r7, r2, #92	; 0x5c
    a8d0:	00ff      	lsls	r7, r7, #3
    a8d2:	f102 055b 	add.w	r5, r2, #91	; 0x5b
    a8d6:	e7aa      	b.n	a82e <_free_r+0xa2>
    a8d8:	10aa      	asrs	r2, r5, #2
    a8da:	2301      	movs	r3, #1
    a8dc:	684d      	ldr	r5, [r1, #4]
    a8de:	4093      	lsls	r3, r2
    a8e0:	432b      	orrs	r3, r5
    a8e2:	604b      	str	r3, [r1, #4]
    a8e4:	4603      	mov	r3, r0
    a8e6:	e7b0      	b.n	a84a <_free_r+0xbe>
    a8e8:	f043 0201 	orr.w	r2, r3, #1
    a8ec:	614c      	str	r4, [r1, #20]
    a8ee:	610c      	str	r4, [r1, #16]
    a8f0:	60e5      	str	r5, [r4, #12]
    a8f2:	60a5      	str	r5, [r4, #8]
    a8f4:	6062      	str	r2, [r4, #4]
    a8f6:	50e3      	str	r3, [r4, r3]
    a8f8:	e78a      	b.n	a810 <_free_r+0x84>
    a8fa:	2a54      	cmp	r2, #84	; 0x54
    a8fc:	d806      	bhi.n	a90c <_free_r+0x180>
    a8fe:	0b1a      	lsrs	r2, r3, #12
    a900:	f102 076f 	add.w	r7, r2, #111	; 0x6f
    a904:	00ff      	lsls	r7, r7, #3
    a906:	f102 056e 	add.w	r5, r2, #110	; 0x6e
    a90a:	e790      	b.n	a82e <_free_r+0xa2>
    a90c:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    a910:	d806      	bhi.n	a920 <_free_r+0x194>
    a912:	0bda      	lsrs	r2, r3, #15
    a914:	f102 0778 	add.w	r7, r2, #120	; 0x78
    a918:	00ff      	lsls	r7, r7, #3
    a91a:	f102 0577 	add.w	r5, r2, #119	; 0x77
    a91e:	e786      	b.n	a82e <_free_r+0xa2>
    a920:	f240 5054 	movw	r0, #1364	; 0x554
    a924:	4282      	cmp	r2, r0
    a926:	d806      	bhi.n	a936 <_free_r+0x1aa>
    a928:	0c9a      	lsrs	r2, r3, #18
    a92a:	f102 077d 	add.w	r7, r2, #125	; 0x7d
    a92e:	00ff      	lsls	r7, r7, #3
    a930:	f102 057c 	add.w	r5, r2, #124	; 0x7c
    a934:	e77b      	b.n	a82e <_free_r+0xa2>
    a936:	f44f 777e 	mov.w	r7, #1016	; 0x3f8
    a93a:	257e      	movs	r5, #126	; 0x7e
    a93c:	e777      	b.n	a82e <_free_r+0xa2>
    a93e:	f043 0101 	orr.w	r1, r3, #1
    a942:	6061      	str	r1, [r4, #4]
    a944:	6013      	str	r3, [r2, #0]
    a946:	e763      	b.n	a810 <_free_r+0x84>
    a948:	2000075c 	.word	0x2000075c
    a94c:	20000764 	.word	0x20000764
    a950:	20000b68 	.word	0x20000b68
    a954:	20001570 	.word	0x20001570

0000a958 <_fstat_r>:
    a958:	b538      	push	{r3, r4, r5, lr}
    a95a:	460b      	mov	r3, r1
    a95c:	4c07      	ldr	r4, [pc, #28]	; (a97c <_fstat_r+0x24>)
    a95e:	4605      	mov	r5, r0
    a960:	4611      	mov	r1, r2
    a962:	4618      	mov	r0, r3
    a964:	2300      	movs	r3, #0
    a966:	6023      	str	r3, [r4, #0]
    a968:	f7f8 fff7 	bl	395a <_fstat>
    a96c:	1c43      	adds	r3, r0, #1
    a96e:	d000      	beq.n	a972 <_fstat_r+0x1a>
    a970:	bd38      	pop	{r3, r4, r5, pc}
    a972:	6823      	ldr	r3, [r4, #0]
    a974:	2b00      	cmp	r3, #0
    a976:	d0fb      	beq.n	a970 <_fstat_r+0x18>
    a978:	602b      	str	r3, [r5, #0]
    a97a:	bd38      	pop	{r3, r4, r5, pc}
    a97c:	2000304c 	.word	0x2000304c

0000a980 <__sfvwrite_r>:
    a980:	6893      	ldr	r3, [r2, #8]
    a982:	2b00      	cmp	r3, #0
    a984:	d073      	beq.n	aa6e <__sfvwrite_r+0xee>
    a986:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a98a:	898b      	ldrh	r3, [r1, #12]
    a98c:	b083      	sub	sp, #12
    a98e:	460c      	mov	r4, r1
    a990:	0719      	lsls	r1, r3, #28
    a992:	9000      	str	r0, [sp, #0]
    a994:	4616      	mov	r6, r2
    a996:	d526      	bpl.n	a9e6 <__sfvwrite_r+0x66>
    a998:	6922      	ldr	r2, [r4, #16]
    a99a:	b322      	cbz	r2, a9e6 <__sfvwrite_r+0x66>
    a99c:	f013 0002 	ands.w	r0, r3, #2
    a9a0:	6835      	ldr	r5, [r6, #0]
    a9a2:	d02c      	beq.n	a9fe <__sfvwrite_r+0x7e>
    a9a4:	f04f 0900 	mov.w	r9, #0
    a9a8:	4fb0      	ldr	r7, [pc, #704]	; (ac6c <__sfvwrite_r+0x2ec>)
    a9aa:	46c8      	mov	r8, r9
    a9ac:	46b2      	mov	sl, r6
    a9ae:	45b8      	cmp	r8, r7
    a9b0:	4643      	mov	r3, r8
    a9b2:	464a      	mov	r2, r9
    a9b4:	bf28      	it	cs
    a9b6:	463b      	movcs	r3, r7
    a9b8:	9800      	ldr	r0, [sp, #0]
    a9ba:	f1b8 0f00 	cmp.w	r8, #0
    a9be:	d050      	beq.n	aa62 <__sfvwrite_r+0xe2>
    a9c0:	69e1      	ldr	r1, [r4, #28]
    a9c2:	6a66      	ldr	r6, [r4, #36]	; 0x24
    a9c4:	47b0      	blx	r6
    a9c6:	2800      	cmp	r0, #0
    a9c8:	dd58      	ble.n	aa7c <__sfvwrite_r+0xfc>
    a9ca:	f8da 3008 	ldr.w	r3, [sl, #8]
    a9ce:	1a1b      	subs	r3, r3, r0
    a9d0:	4481      	add	r9, r0
    a9d2:	eba8 0800 	sub.w	r8, r8, r0
    a9d6:	f8ca 3008 	str.w	r3, [sl, #8]
    a9da:	2b00      	cmp	r3, #0
    a9dc:	d1e7      	bne.n	a9ae <__sfvwrite_r+0x2e>
    a9de:	2000      	movs	r0, #0
    a9e0:	b003      	add	sp, #12
    a9e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a9e6:	4621      	mov	r1, r4
    a9e8:	9800      	ldr	r0, [sp, #0]
    a9ea:	f004 fb0f 	bl	f00c <__swsetup_r>
    a9ee:	2800      	cmp	r0, #0
    a9f0:	f040 8133 	bne.w	ac5a <__sfvwrite_r+0x2da>
    a9f4:	89a3      	ldrh	r3, [r4, #12]
    a9f6:	6835      	ldr	r5, [r6, #0]
    a9f8:	f013 0002 	ands.w	r0, r3, #2
    a9fc:	d1d2      	bne.n	a9a4 <__sfvwrite_r+0x24>
    a9fe:	f013 0901 	ands.w	r9, r3, #1
    aa02:	d145      	bne.n	aa90 <__sfvwrite_r+0x110>
    aa04:	464f      	mov	r7, r9
    aa06:	9601      	str	r6, [sp, #4]
    aa08:	b337      	cbz	r7, aa58 <__sfvwrite_r+0xd8>
    aa0a:	059a      	lsls	r2, r3, #22
    aa0c:	f8d4 8008 	ldr.w	r8, [r4, #8]
    aa10:	f140 8083 	bpl.w	ab1a <__sfvwrite_r+0x19a>
    aa14:	4547      	cmp	r7, r8
    aa16:	46c3      	mov	fp, r8
    aa18:	f0c0 80ab 	bcc.w	ab72 <__sfvwrite_r+0x1f2>
    aa1c:	f413 6f90 	tst.w	r3, #1152	; 0x480
    aa20:	f040 80ac 	bne.w	ab7c <__sfvwrite_r+0x1fc>
    aa24:	6820      	ldr	r0, [r4, #0]
    aa26:	46ba      	mov	sl, r7
    aa28:	465a      	mov	r2, fp
    aa2a:	4649      	mov	r1, r9
    aa2c:	f000 fcd6 	bl	b3dc <memmove>
    aa30:	68a2      	ldr	r2, [r4, #8]
    aa32:	6823      	ldr	r3, [r4, #0]
    aa34:	eba2 0208 	sub.w	r2, r2, r8
    aa38:	445b      	add	r3, fp
    aa3a:	60a2      	str	r2, [r4, #8]
    aa3c:	6023      	str	r3, [r4, #0]
    aa3e:	9a01      	ldr	r2, [sp, #4]
    aa40:	6893      	ldr	r3, [r2, #8]
    aa42:	eba3 030a 	sub.w	r3, r3, sl
    aa46:	44d1      	add	r9, sl
    aa48:	eba7 070a 	sub.w	r7, r7, sl
    aa4c:	6093      	str	r3, [r2, #8]
    aa4e:	2b00      	cmp	r3, #0
    aa50:	d0c5      	beq.n	a9de <__sfvwrite_r+0x5e>
    aa52:	89a3      	ldrh	r3, [r4, #12]
    aa54:	2f00      	cmp	r7, #0
    aa56:	d1d8      	bne.n	aa0a <__sfvwrite_r+0x8a>
    aa58:	f8d5 9000 	ldr.w	r9, [r5]
    aa5c:	686f      	ldr	r7, [r5, #4]
    aa5e:	3508      	adds	r5, #8
    aa60:	e7d2      	b.n	aa08 <__sfvwrite_r+0x88>
    aa62:	f8d5 9000 	ldr.w	r9, [r5]
    aa66:	f8d5 8004 	ldr.w	r8, [r5, #4]
    aa6a:	3508      	adds	r5, #8
    aa6c:	e79f      	b.n	a9ae <__sfvwrite_r+0x2e>
    aa6e:	2000      	movs	r0, #0
    aa70:	4770      	bx	lr
    aa72:	4621      	mov	r1, r4
    aa74:	9800      	ldr	r0, [sp, #0]
    aa76:	f7ff fd83 	bl	a580 <_fflush_r>
    aa7a:	b370      	cbz	r0, aada <__sfvwrite_r+0x15a>
    aa7c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    aa80:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    aa84:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    aa88:	81a3      	strh	r3, [r4, #12]
    aa8a:	b003      	add	sp, #12
    aa8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    aa90:	4681      	mov	r9, r0
    aa92:	4633      	mov	r3, r6
    aa94:	464e      	mov	r6, r9
    aa96:	46a8      	mov	r8, r5
    aa98:	469a      	mov	sl, r3
    aa9a:	464d      	mov	r5, r9
    aa9c:	b34e      	cbz	r6, aaf2 <__sfvwrite_r+0x172>
    aa9e:	b380      	cbz	r0, ab02 <__sfvwrite_r+0x182>
    aaa0:	6820      	ldr	r0, [r4, #0]
    aaa2:	6923      	ldr	r3, [r4, #16]
    aaa4:	6962      	ldr	r2, [r4, #20]
    aaa6:	45b1      	cmp	r9, r6
    aaa8:	46cb      	mov	fp, r9
    aaaa:	bf28      	it	cs
    aaac:	46b3      	movcs	fp, r6
    aaae:	4298      	cmp	r0, r3
    aab0:	465f      	mov	r7, fp
    aab2:	d904      	bls.n	aabe <__sfvwrite_r+0x13e>
    aab4:	68a3      	ldr	r3, [r4, #8]
    aab6:	4413      	add	r3, r2
    aab8:	459b      	cmp	fp, r3
    aaba:	f300 80a6 	bgt.w	ac0a <__sfvwrite_r+0x28a>
    aabe:	4593      	cmp	fp, r2
    aac0:	db4b      	blt.n	ab5a <__sfvwrite_r+0x1da>
    aac2:	4613      	mov	r3, r2
    aac4:	6a67      	ldr	r7, [r4, #36]	; 0x24
    aac6:	69e1      	ldr	r1, [r4, #28]
    aac8:	9800      	ldr	r0, [sp, #0]
    aaca:	462a      	mov	r2, r5
    aacc:	47b8      	blx	r7
    aace:	1e07      	subs	r7, r0, #0
    aad0:	ddd4      	ble.n	aa7c <__sfvwrite_r+0xfc>
    aad2:	ebb9 0907 	subs.w	r9, r9, r7
    aad6:	d0cc      	beq.n	aa72 <__sfvwrite_r+0xf2>
    aad8:	2001      	movs	r0, #1
    aada:	f8da 3008 	ldr.w	r3, [sl, #8]
    aade:	1bdb      	subs	r3, r3, r7
    aae0:	443d      	add	r5, r7
    aae2:	1bf6      	subs	r6, r6, r7
    aae4:	f8ca 3008 	str.w	r3, [sl, #8]
    aae8:	2b00      	cmp	r3, #0
    aaea:	f43f af78 	beq.w	a9de <__sfvwrite_r+0x5e>
    aaee:	2e00      	cmp	r6, #0
    aaf0:	d1d5      	bne.n	aa9e <__sfvwrite_r+0x11e>
    aaf2:	f108 0308 	add.w	r3, r8, #8
    aaf6:	e913 0060 	ldmdb	r3, {r5, r6}
    aafa:	4698      	mov	r8, r3
    aafc:	3308      	adds	r3, #8
    aafe:	2e00      	cmp	r6, #0
    ab00:	d0f9      	beq.n	aaf6 <__sfvwrite_r+0x176>
    ab02:	4632      	mov	r2, r6
    ab04:	210a      	movs	r1, #10
    ab06:	4628      	mov	r0, r5
    ab08:	f7f5 feba 	bl	880 <memchr>
    ab0c:	2800      	cmp	r0, #0
    ab0e:	f000 80a1 	beq.w	ac54 <__sfvwrite_r+0x2d4>
    ab12:	3001      	adds	r0, #1
    ab14:	eba0 0905 	sub.w	r9, r0, r5
    ab18:	e7c2      	b.n	aaa0 <__sfvwrite_r+0x120>
    ab1a:	6820      	ldr	r0, [r4, #0]
    ab1c:	6923      	ldr	r3, [r4, #16]
    ab1e:	4298      	cmp	r0, r3
    ab20:	d802      	bhi.n	ab28 <__sfvwrite_r+0x1a8>
    ab22:	6963      	ldr	r3, [r4, #20]
    ab24:	429f      	cmp	r7, r3
    ab26:	d25d      	bcs.n	abe4 <__sfvwrite_r+0x264>
    ab28:	45b8      	cmp	r8, r7
    ab2a:	bf28      	it	cs
    ab2c:	46b8      	movcs	r8, r7
    ab2e:	4642      	mov	r2, r8
    ab30:	4649      	mov	r1, r9
    ab32:	f000 fc53 	bl	b3dc <memmove>
    ab36:	68a3      	ldr	r3, [r4, #8]
    ab38:	6822      	ldr	r2, [r4, #0]
    ab3a:	eba3 0308 	sub.w	r3, r3, r8
    ab3e:	4442      	add	r2, r8
    ab40:	60a3      	str	r3, [r4, #8]
    ab42:	6022      	str	r2, [r4, #0]
    ab44:	b10b      	cbz	r3, ab4a <__sfvwrite_r+0x1ca>
    ab46:	46c2      	mov	sl, r8
    ab48:	e779      	b.n	aa3e <__sfvwrite_r+0xbe>
    ab4a:	4621      	mov	r1, r4
    ab4c:	9800      	ldr	r0, [sp, #0]
    ab4e:	f7ff fd17 	bl	a580 <_fflush_r>
    ab52:	2800      	cmp	r0, #0
    ab54:	d192      	bne.n	aa7c <__sfvwrite_r+0xfc>
    ab56:	46c2      	mov	sl, r8
    ab58:	e771      	b.n	aa3e <__sfvwrite_r+0xbe>
    ab5a:	465a      	mov	r2, fp
    ab5c:	4629      	mov	r1, r5
    ab5e:	f000 fc3d 	bl	b3dc <memmove>
    ab62:	68a2      	ldr	r2, [r4, #8]
    ab64:	6823      	ldr	r3, [r4, #0]
    ab66:	eba2 020b 	sub.w	r2, r2, fp
    ab6a:	445b      	add	r3, fp
    ab6c:	60a2      	str	r2, [r4, #8]
    ab6e:	6023      	str	r3, [r4, #0]
    ab70:	e7af      	b.n	aad2 <__sfvwrite_r+0x152>
    ab72:	6820      	ldr	r0, [r4, #0]
    ab74:	46b8      	mov	r8, r7
    ab76:	46ba      	mov	sl, r7
    ab78:	46bb      	mov	fp, r7
    ab7a:	e755      	b.n	aa28 <__sfvwrite_r+0xa8>
    ab7c:	6962      	ldr	r2, [r4, #20]
    ab7e:	6820      	ldr	r0, [r4, #0]
    ab80:	6921      	ldr	r1, [r4, #16]
    ab82:	eb02 0842 	add.w	r8, r2, r2, lsl #1
    ab86:	eba0 0a01 	sub.w	sl, r0, r1
    ab8a:	eb08 78d8 	add.w	r8, r8, r8, lsr #31
    ab8e:	f10a 0001 	add.w	r0, sl, #1
    ab92:	ea4f 0868 	mov.w	r8, r8, asr #1
    ab96:	4438      	add	r0, r7
    ab98:	4540      	cmp	r0, r8
    ab9a:	4642      	mov	r2, r8
    ab9c:	bf84      	itt	hi
    ab9e:	4680      	movhi	r8, r0
    aba0:	4642      	movhi	r2, r8
    aba2:	055b      	lsls	r3, r3, #21
    aba4:	d544      	bpl.n	ac30 <__sfvwrite_r+0x2b0>
    aba6:	4611      	mov	r1, r2
    aba8:	9800      	ldr	r0, [sp, #0]
    abaa:	f7f7 fe17 	bl	27dc <__wrap__malloc_r>
    abae:	4683      	mov	fp, r0
    abb0:	2800      	cmp	r0, #0
    abb2:	d055      	beq.n	ac60 <__sfvwrite_r+0x2e0>
    abb4:	4652      	mov	r2, sl
    abb6:	6921      	ldr	r1, [r4, #16]
    abb8:	f7f5 feb2 	bl	920 <memcpy>
    abbc:	89a3      	ldrh	r3, [r4, #12]
    abbe:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
    abc2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    abc6:	81a3      	strh	r3, [r4, #12]
    abc8:	eb0b 000a 	add.w	r0, fp, sl
    abcc:	eba8 030a 	sub.w	r3, r8, sl
    abd0:	f8c4 b010 	str.w	fp, [r4, #16]
    abd4:	f8c4 8014 	str.w	r8, [r4, #20]
    abd8:	6020      	str	r0, [r4, #0]
    abda:	60a3      	str	r3, [r4, #8]
    abdc:	46b8      	mov	r8, r7
    abde:	46ba      	mov	sl, r7
    abe0:	46bb      	mov	fp, r7
    abe2:	e721      	b.n	aa28 <__sfvwrite_r+0xa8>
    abe4:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    abe8:	42b9      	cmp	r1, r7
    abea:	bf28      	it	cs
    abec:	4639      	movcs	r1, r7
    abee:	464a      	mov	r2, r9
    abf0:	fb91 f1f3 	sdiv	r1, r1, r3
    abf4:	9800      	ldr	r0, [sp, #0]
    abf6:	6a66      	ldr	r6, [r4, #36]	; 0x24
    abf8:	fb03 f301 	mul.w	r3, r3, r1
    abfc:	69e1      	ldr	r1, [r4, #28]
    abfe:	47b0      	blx	r6
    ac00:	f1b0 0a00 	subs.w	sl, r0, #0
    ac04:	f73f af1b 	bgt.w	aa3e <__sfvwrite_r+0xbe>
    ac08:	e738      	b.n	aa7c <__sfvwrite_r+0xfc>
    ac0a:	461a      	mov	r2, r3
    ac0c:	4629      	mov	r1, r5
    ac0e:	9301      	str	r3, [sp, #4]
    ac10:	f000 fbe4 	bl	b3dc <memmove>
    ac14:	6822      	ldr	r2, [r4, #0]
    ac16:	9b01      	ldr	r3, [sp, #4]
    ac18:	9800      	ldr	r0, [sp, #0]
    ac1a:	441a      	add	r2, r3
    ac1c:	6022      	str	r2, [r4, #0]
    ac1e:	4621      	mov	r1, r4
    ac20:	f7ff fcae 	bl	a580 <_fflush_r>
    ac24:	9b01      	ldr	r3, [sp, #4]
    ac26:	2800      	cmp	r0, #0
    ac28:	f47f af28 	bne.w	aa7c <__sfvwrite_r+0xfc>
    ac2c:	461f      	mov	r7, r3
    ac2e:	e750      	b.n	aad2 <__sfvwrite_r+0x152>
    ac30:	9800      	ldr	r0, [sp, #0]
    ac32:	f7f7 fe3d 	bl	28b0 <__wrap__realloc_r>
    ac36:	4683      	mov	fp, r0
    ac38:	2800      	cmp	r0, #0
    ac3a:	d1c5      	bne.n	abc8 <__sfvwrite_r+0x248>
    ac3c:	9d00      	ldr	r5, [sp, #0]
    ac3e:	6921      	ldr	r1, [r4, #16]
    ac40:	4628      	mov	r0, r5
    ac42:	f7f7 fe70 	bl	2926 <__wrap__free_r>
    ac46:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    ac4a:	220c      	movs	r2, #12
    ac4c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    ac50:	602a      	str	r2, [r5, #0]
    ac52:	e715      	b.n	aa80 <__sfvwrite_r+0x100>
    ac54:	f106 0901 	add.w	r9, r6, #1
    ac58:	e722      	b.n	aaa0 <__sfvwrite_r+0x120>
    ac5a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    ac5e:	e6bf      	b.n	a9e0 <__sfvwrite_r+0x60>
    ac60:	9a00      	ldr	r2, [sp, #0]
    ac62:	230c      	movs	r3, #12
    ac64:	6013      	str	r3, [r2, #0]
    ac66:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    ac6a:	e709      	b.n	aa80 <__sfvwrite_r+0x100>
    ac6c:	7ffffc00 	.word	0x7ffffc00

0000ac70 <_fwalk_reent>:
    ac70:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ac74:	f510 7738 	adds.w	r7, r0, #736	; 0x2e0
    ac78:	d01f      	beq.n	acba <_fwalk_reent+0x4a>
    ac7a:	4688      	mov	r8, r1
    ac7c:	4606      	mov	r6, r0
    ac7e:	f04f 0900 	mov.w	r9, #0
    ac82:	687d      	ldr	r5, [r7, #4]
    ac84:	68bc      	ldr	r4, [r7, #8]
    ac86:	3d01      	subs	r5, #1
    ac88:	d411      	bmi.n	acae <_fwalk_reent+0x3e>
    ac8a:	89a3      	ldrh	r3, [r4, #12]
    ac8c:	2b01      	cmp	r3, #1
    ac8e:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
    ac92:	d908      	bls.n	aca6 <_fwalk_reent+0x36>
    ac94:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
    ac98:	3301      	adds	r3, #1
    ac9a:	4621      	mov	r1, r4
    ac9c:	4630      	mov	r0, r6
    ac9e:	d002      	beq.n	aca6 <_fwalk_reent+0x36>
    aca0:	47c0      	blx	r8
    aca2:	ea49 0900 	orr.w	r9, r9, r0
    aca6:	1c6b      	adds	r3, r5, #1
    aca8:	f104 0468 	add.w	r4, r4, #104	; 0x68
    acac:	d1ed      	bne.n	ac8a <_fwalk_reent+0x1a>
    acae:	683f      	ldr	r7, [r7, #0]
    acb0:	2f00      	cmp	r7, #0
    acb2:	d1e6      	bne.n	ac82 <_fwalk_reent+0x12>
    acb4:	4648      	mov	r0, r9
    acb6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    acba:	46b9      	mov	r9, r7
    acbc:	4648      	mov	r0, r9
    acbe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    acc2:	bf00      	nop

0000acc4 <__libc_init_array>:
    acc4:	b570      	push	{r4, r5, r6, lr}
    acc6:	4e0f      	ldr	r6, [pc, #60]	; (ad04 <__libc_init_array+0x40>)
    acc8:	4d0f      	ldr	r5, [pc, #60]	; (ad08 <__libc_init_array+0x44>)
    acca:	1b76      	subs	r6, r6, r5
    accc:	10b6      	asrs	r6, r6, #2
    acce:	bf18      	it	ne
    acd0:	2400      	movne	r4, #0
    acd2:	d005      	beq.n	ace0 <__libc_init_array+0x1c>
    acd4:	3401      	adds	r4, #1
    acd6:	f855 3b04 	ldr.w	r3, [r5], #4
    acda:	4798      	blx	r3
    acdc:	42a6      	cmp	r6, r4
    acde:	d1f9      	bne.n	acd4 <__libc_init_array+0x10>
    ace0:	4e0a      	ldr	r6, [pc, #40]	; (ad0c <__libc_init_array+0x48>)
    ace2:	4d0b      	ldr	r5, [pc, #44]	; (ad10 <__libc_init_array+0x4c>)
    ace4:	1b76      	subs	r6, r6, r5
    ace6:	f007 fffd 	bl	12ce4 <_init>
    acea:	10b6      	asrs	r6, r6, #2
    acec:	bf18      	it	ne
    acee:	2400      	movne	r4, #0
    acf0:	d006      	beq.n	ad00 <__libc_init_array+0x3c>
    acf2:	3401      	adds	r4, #1
    acf4:	f855 3b04 	ldr.w	r3, [r5], #4
    acf8:	4798      	blx	r3
    acfa:	42a6      	cmp	r6, r4
    acfc:	d1f9      	bne.n	acf2 <__libc_init_array+0x2e>
    acfe:	bd70      	pop	{r4, r5, r6, pc}
    ad00:	bd70      	pop	{r4, r5, r6, pc}
    ad02:	bf00      	nop
    ad04:	00012d04 	.word	0x00012d04
    ad08:	00012d04 	.word	0x00012d04
    ad0c:	00012d10 	.word	0x00012d10
    ad10:	00012d04 	.word	0x00012d04

0000ad14 <__locale_mb_cur_max>:
    ad14:	4b04      	ldr	r3, [pc, #16]	; (ad28 <__locale_mb_cur_max+0x14>)
    ad16:	4a05      	ldr	r2, [pc, #20]	; (ad2c <__locale_mb_cur_max+0x18>)
    ad18:	681b      	ldr	r3, [r3, #0]
    ad1a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    ad1c:	2b00      	cmp	r3, #0
    ad1e:	bf08      	it	eq
    ad20:	4613      	moveq	r3, r2
    ad22:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
    ad26:	4770      	bx	lr
    ad28:	200001c0 	.word	0x200001c0
    ad2c:	200005f0 	.word	0x200005f0

0000ad30 <__retarget_lock_init_recursive>:
    ad30:	4770      	bx	lr
    ad32:	bf00      	nop

0000ad34 <__retarget_lock_close_recursive>:
    ad34:	4770      	bx	lr
    ad36:	bf00      	nop

0000ad38 <__retarget_lock_acquire_recursive>:
    ad38:	4770      	bx	lr
    ad3a:	bf00      	nop

0000ad3c <__retarget_lock_release_recursive>:
    ad3c:	4770      	bx	lr
    ad3e:	bf00      	nop

0000ad40 <__swhatbuf_r>:
    ad40:	b570      	push	{r4, r5, r6, lr}
    ad42:	460c      	mov	r4, r1
    ad44:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    ad48:	2900      	cmp	r1, #0
    ad4a:	b090      	sub	sp, #64	; 0x40
    ad4c:	4615      	mov	r5, r2
    ad4e:	461e      	mov	r6, r3
    ad50:	db14      	blt.n	ad7c <__swhatbuf_r+0x3c>
    ad52:	aa01      	add	r2, sp, #4
    ad54:	f7ff fe00 	bl	a958 <_fstat_r>
    ad58:	2800      	cmp	r0, #0
    ad5a:	db0f      	blt.n	ad7c <__swhatbuf_r+0x3c>
    ad5c:	9a02      	ldr	r2, [sp, #8]
    ad5e:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
    ad62:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
    ad66:	fab2 f282 	clz	r2, r2
    ad6a:	0952      	lsrs	r2, r2, #5
    ad6c:	f44f 6380 	mov.w	r3, #1024	; 0x400
    ad70:	f44f 6000 	mov.w	r0, #2048	; 0x800
    ad74:	6032      	str	r2, [r6, #0]
    ad76:	602b      	str	r3, [r5, #0]
    ad78:	b010      	add	sp, #64	; 0x40
    ad7a:	bd70      	pop	{r4, r5, r6, pc}
    ad7c:	89a2      	ldrh	r2, [r4, #12]
    ad7e:	2300      	movs	r3, #0
    ad80:	f012 0080 	ands.w	r0, r2, #128	; 0x80
    ad84:	6033      	str	r3, [r6, #0]
    ad86:	d004      	beq.n	ad92 <__swhatbuf_r+0x52>
    ad88:	2240      	movs	r2, #64	; 0x40
    ad8a:	4618      	mov	r0, r3
    ad8c:	602a      	str	r2, [r5, #0]
    ad8e:	b010      	add	sp, #64	; 0x40
    ad90:	bd70      	pop	{r4, r5, r6, pc}
    ad92:	f44f 6380 	mov.w	r3, #1024	; 0x400
    ad96:	602b      	str	r3, [r5, #0]
    ad98:	b010      	add	sp, #64	; 0x40
    ad9a:	bd70      	pop	{r4, r5, r6, pc}

0000ad9c <__smakebuf_r>:
    ad9c:	898a      	ldrh	r2, [r1, #12]
    ad9e:	0792      	lsls	r2, r2, #30
    ada0:	460b      	mov	r3, r1
    ada2:	d506      	bpl.n	adb2 <__smakebuf_r+0x16>
    ada4:	f101 0243 	add.w	r2, r1, #67	; 0x43
    ada8:	2101      	movs	r1, #1
    adaa:	601a      	str	r2, [r3, #0]
    adac:	611a      	str	r2, [r3, #16]
    adae:	6159      	str	r1, [r3, #20]
    adb0:	4770      	bx	lr
    adb2:	b5f0      	push	{r4, r5, r6, r7, lr}
    adb4:	b083      	sub	sp, #12
    adb6:	ab01      	add	r3, sp, #4
    adb8:	466a      	mov	r2, sp
    adba:	460c      	mov	r4, r1
    adbc:	4606      	mov	r6, r0
    adbe:	f7ff ffbf 	bl	ad40 <__swhatbuf_r>
    adc2:	9900      	ldr	r1, [sp, #0]
    adc4:	4605      	mov	r5, r0
    adc6:	4630      	mov	r0, r6
    adc8:	f7f7 fd08 	bl	27dc <__wrap__malloc_r>
    adcc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    add0:	b1d8      	cbz	r0, ae0a <__smakebuf_r+0x6e>
    add2:	9a01      	ldr	r2, [sp, #4]
    add4:	4f15      	ldr	r7, [pc, #84]	; (ae2c <__smakebuf_r+0x90>)
    add6:	9900      	ldr	r1, [sp, #0]
    add8:	63f7      	str	r7, [r6, #60]	; 0x3c
    adda:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    adde:	81a3      	strh	r3, [r4, #12]
    ade0:	6020      	str	r0, [r4, #0]
    ade2:	6120      	str	r0, [r4, #16]
    ade4:	6161      	str	r1, [r4, #20]
    ade6:	b91a      	cbnz	r2, adf0 <__smakebuf_r+0x54>
    ade8:	432b      	orrs	r3, r5
    adea:	81a3      	strh	r3, [r4, #12]
    adec:	b003      	add	sp, #12
    adee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    adf0:	4630      	mov	r0, r6
    adf2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    adf6:	f005 f9b9 	bl	1016c <_isatty_r>
    adfa:	b1a0      	cbz	r0, ae26 <__smakebuf_r+0x8a>
    adfc:	89a3      	ldrh	r3, [r4, #12]
    adfe:	f023 0303 	bic.w	r3, r3, #3
    ae02:	f043 0301 	orr.w	r3, r3, #1
    ae06:	b21b      	sxth	r3, r3
    ae08:	e7ee      	b.n	ade8 <__smakebuf_r+0x4c>
    ae0a:	059a      	lsls	r2, r3, #22
    ae0c:	d4ee      	bmi.n	adec <__smakebuf_r+0x50>
    ae0e:	f023 0303 	bic.w	r3, r3, #3
    ae12:	f104 0243 	add.w	r2, r4, #67	; 0x43
    ae16:	f043 0302 	orr.w	r3, r3, #2
    ae1a:	2101      	movs	r1, #1
    ae1c:	81a3      	strh	r3, [r4, #12]
    ae1e:	6022      	str	r2, [r4, #0]
    ae20:	6122      	str	r2, [r4, #16]
    ae22:	6161      	str	r1, [r4, #20]
    ae24:	e7e2      	b.n	adec <__smakebuf_r+0x50>
    ae26:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    ae2a:	e7dd      	b.n	ade8 <__smakebuf_r+0x4c>
    ae2c:	0000a5f9 	.word	0x0000a5f9

0000ae30 <malloc>:
    ae30:	4b02      	ldr	r3, [pc, #8]	; (ae3c <malloc+0xc>)
    ae32:	4601      	mov	r1, r0
    ae34:	6818      	ldr	r0, [r3, #0]
    ae36:	f7f7 bcd1 	b.w	27dc <__wrap__malloc_r>
    ae3a:	bf00      	nop
    ae3c:	200001c0 	.word	0x200001c0

0000ae40 <free>:
    ae40:	4b02      	ldr	r3, [pc, #8]	; (ae4c <free+0xc>)
    ae42:	4601      	mov	r1, r0
    ae44:	6818      	ldr	r0, [r3, #0]
    ae46:	f7f7 bd6e 	b.w	2926 <__wrap__free_r>
    ae4a:	bf00      	nop
    ae4c:	200001c0 	.word	0x200001c0

0000ae50 <_malloc_r>:
    ae50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ae54:	f101 060b 	add.w	r6, r1, #11
    ae58:	2e16      	cmp	r6, #22
    ae5a:	b083      	sub	sp, #12
    ae5c:	4605      	mov	r5, r0
    ae5e:	f240 809e 	bls.w	af9e <_malloc_r+0x14e>
    ae62:	f036 0607 	bics.w	r6, r6, #7
    ae66:	f100 80bd 	bmi.w	afe4 <_malloc_r+0x194>
    ae6a:	42b1      	cmp	r1, r6
    ae6c:	f200 80ba 	bhi.w	afe4 <_malloc_r+0x194>
    ae70:	f7f8 fe28 	bl	3ac4 <__malloc_lock>
    ae74:	f5b6 7ffc 	cmp.w	r6, #504	; 0x1f8
    ae78:	f0c0 8293 	bcc.w	b3a2 <_malloc_r+0x552>
    ae7c:	0a73      	lsrs	r3, r6, #9
    ae7e:	f000 80b8 	beq.w	aff2 <_malloc_r+0x1a2>
    ae82:	2b04      	cmp	r3, #4
    ae84:	f200 8179 	bhi.w	b17a <_malloc_r+0x32a>
    ae88:	09b3      	lsrs	r3, r6, #6
    ae8a:	f103 0039 	add.w	r0, r3, #57	; 0x39
    ae8e:	f103 0e38 	add.w	lr, r3, #56	; 0x38
    ae92:	00c3      	lsls	r3, r0, #3
    ae94:	4fbf      	ldr	r7, [pc, #764]	; (b194 <_malloc_r+0x344>)
    ae96:	443b      	add	r3, r7
    ae98:	f1a3 0108 	sub.w	r1, r3, #8
    ae9c:	685c      	ldr	r4, [r3, #4]
    ae9e:	42a1      	cmp	r1, r4
    aea0:	d106      	bne.n	aeb0 <_malloc_r+0x60>
    aea2:	e00c      	b.n	aebe <_malloc_r+0x6e>
    aea4:	2a00      	cmp	r2, #0
    aea6:	f280 80aa 	bge.w	affe <_malloc_r+0x1ae>
    aeaa:	68e4      	ldr	r4, [r4, #12]
    aeac:	42a1      	cmp	r1, r4
    aeae:	d006      	beq.n	aebe <_malloc_r+0x6e>
    aeb0:	6863      	ldr	r3, [r4, #4]
    aeb2:	f023 0303 	bic.w	r3, r3, #3
    aeb6:	1b9a      	subs	r2, r3, r6
    aeb8:	2a0f      	cmp	r2, #15
    aeba:	ddf3      	ble.n	aea4 <_malloc_r+0x54>
    aebc:	4670      	mov	r0, lr
    aebe:	693c      	ldr	r4, [r7, #16]
    aec0:	f8df e2e4 	ldr.w	lr, [pc, #740]	; b1a8 <_malloc_r+0x358>
    aec4:	4574      	cmp	r4, lr
    aec6:	f000 81ab 	beq.w	b220 <_malloc_r+0x3d0>
    aeca:	6863      	ldr	r3, [r4, #4]
    aecc:	f023 0303 	bic.w	r3, r3, #3
    aed0:	1b9a      	subs	r2, r3, r6
    aed2:	2a0f      	cmp	r2, #15
    aed4:	f300 8190 	bgt.w	b1f8 <_malloc_r+0x3a8>
    aed8:	2a00      	cmp	r2, #0
    aeda:	f8c7 e014 	str.w	lr, [r7, #20]
    aede:	f8c7 e010 	str.w	lr, [r7, #16]
    aee2:	f280 809d 	bge.w	b020 <_malloc_r+0x1d0>
    aee6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    aeea:	f080 8161 	bcs.w	b1b0 <_malloc_r+0x360>
    aeee:	08db      	lsrs	r3, r3, #3
    aef0:	f103 0c01 	add.w	ip, r3, #1
    aef4:	1099      	asrs	r1, r3, #2
    aef6:	687a      	ldr	r2, [r7, #4]
    aef8:	f857 803c 	ldr.w	r8, [r7, ip, lsl #3]
    aefc:	f8c4 8008 	str.w	r8, [r4, #8]
    af00:	2301      	movs	r3, #1
    af02:	408b      	lsls	r3, r1
    af04:	eb07 01cc 	add.w	r1, r7, ip, lsl #3
    af08:	4313      	orrs	r3, r2
    af0a:	3908      	subs	r1, #8
    af0c:	60e1      	str	r1, [r4, #12]
    af0e:	607b      	str	r3, [r7, #4]
    af10:	f847 403c 	str.w	r4, [r7, ip, lsl #3]
    af14:	f8c8 400c 	str.w	r4, [r8, #12]
    af18:	1082      	asrs	r2, r0, #2
    af1a:	2401      	movs	r4, #1
    af1c:	4094      	lsls	r4, r2
    af1e:	429c      	cmp	r4, r3
    af20:	f200 808b 	bhi.w	b03a <_malloc_r+0x1ea>
    af24:	421c      	tst	r4, r3
    af26:	d106      	bne.n	af36 <_malloc_r+0xe6>
    af28:	f020 0003 	bic.w	r0, r0, #3
    af2c:	0064      	lsls	r4, r4, #1
    af2e:	421c      	tst	r4, r3
    af30:	f100 0004 	add.w	r0, r0, #4
    af34:	d0fa      	beq.n	af2c <_malloc_r+0xdc>
    af36:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    af3a:	46cc      	mov	ip, r9
    af3c:	4680      	mov	r8, r0
    af3e:	f8dc 300c 	ldr.w	r3, [ip, #12]
    af42:	459c      	cmp	ip, r3
    af44:	d107      	bne.n	af56 <_malloc_r+0x106>
    af46:	e16d      	b.n	b224 <_malloc_r+0x3d4>
    af48:	2a00      	cmp	r2, #0
    af4a:	f280 817b 	bge.w	b244 <_malloc_r+0x3f4>
    af4e:	68db      	ldr	r3, [r3, #12]
    af50:	459c      	cmp	ip, r3
    af52:	f000 8167 	beq.w	b224 <_malloc_r+0x3d4>
    af56:	6859      	ldr	r1, [r3, #4]
    af58:	f021 0103 	bic.w	r1, r1, #3
    af5c:	1b8a      	subs	r2, r1, r6
    af5e:	2a0f      	cmp	r2, #15
    af60:	ddf2      	ble.n	af48 <_malloc_r+0xf8>
    af62:	f8d3 c00c 	ldr.w	ip, [r3, #12]
    af66:	f8d3 8008 	ldr.w	r8, [r3, #8]
    af6a:	9300      	str	r3, [sp, #0]
    af6c:	199c      	adds	r4, r3, r6
    af6e:	4628      	mov	r0, r5
    af70:	f046 0601 	orr.w	r6, r6, #1
    af74:	f042 0501 	orr.w	r5, r2, #1
    af78:	605e      	str	r6, [r3, #4]
    af7a:	f8c8 c00c 	str.w	ip, [r8, #12]
    af7e:	f8cc 8008 	str.w	r8, [ip, #8]
    af82:	617c      	str	r4, [r7, #20]
    af84:	613c      	str	r4, [r7, #16]
    af86:	f8c4 e00c 	str.w	lr, [r4, #12]
    af8a:	f8c4 e008 	str.w	lr, [r4, #8]
    af8e:	6065      	str	r5, [r4, #4]
    af90:	505a      	str	r2, [r3, r1]
    af92:	f7f8 fda1 	bl	3ad8 <__malloc_unlock>
    af96:	9b00      	ldr	r3, [sp, #0]
    af98:	f103 0408 	add.w	r4, r3, #8
    af9c:	e01e      	b.n	afdc <_malloc_r+0x18c>
    af9e:	2910      	cmp	r1, #16
    afa0:	d820      	bhi.n	afe4 <_malloc_r+0x194>
    afa2:	f7f8 fd8f 	bl	3ac4 <__malloc_lock>
    afa6:	2610      	movs	r6, #16
    afa8:	2318      	movs	r3, #24
    afaa:	2002      	movs	r0, #2
    afac:	4f79      	ldr	r7, [pc, #484]	; (b194 <_malloc_r+0x344>)
    afae:	443b      	add	r3, r7
    afb0:	f1a3 0208 	sub.w	r2, r3, #8
    afb4:	685c      	ldr	r4, [r3, #4]
    afb6:	4294      	cmp	r4, r2
    afb8:	f000 813d 	beq.w	b236 <_malloc_r+0x3e6>
    afbc:	6863      	ldr	r3, [r4, #4]
    afbe:	68e1      	ldr	r1, [r4, #12]
    afc0:	68a6      	ldr	r6, [r4, #8]
    afc2:	f023 0303 	bic.w	r3, r3, #3
    afc6:	4423      	add	r3, r4
    afc8:	4628      	mov	r0, r5
    afca:	685a      	ldr	r2, [r3, #4]
    afcc:	60f1      	str	r1, [r6, #12]
    afce:	f042 0201 	orr.w	r2, r2, #1
    afd2:	608e      	str	r6, [r1, #8]
    afd4:	605a      	str	r2, [r3, #4]
    afd6:	f7f8 fd7f 	bl	3ad8 <__malloc_unlock>
    afda:	3408      	adds	r4, #8
    afdc:	4620      	mov	r0, r4
    afde:	b003      	add	sp, #12
    afe0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    afe4:	2400      	movs	r4, #0
    afe6:	230c      	movs	r3, #12
    afe8:	4620      	mov	r0, r4
    afea:	602b      	str	r3, [r5, #0]
    afec:	b003      	add	sp, #12
    afee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    aff2:	2040      	movs	r0, #64	; 0x40
    aff4:	f44f 7300 	mov.w	r3, #512	; 0x200
    aff8:	f04f 0e3f 	mov.w	lr, #63	; 0x3f
    affc:	e74a      	b.n	ae94 <_malloc_r+0x44>
    affe:	4423      	add	r3, r4
    b000:	68e1      	ldr	r1, [r4, #12]
    b002:	685a      	ldr	r2, [r3, #4]
    b004:	68a6      	ldr	r6, [r4, #8]
    b006:	f042 0201 	orr.w	r2, r2, #1
    b00a:	60f1      	str	r1, [r6, #12]
    b00c:	4628      	mov	r0, r5
    b00e:	608e      	str	r6, [r1, #8]
    b010:	605a      	str	r2, [r3, #4]
    b012:	f7f8 fd61 	bl	3ad8 <__malloc_unlock>
    b016:	3408      	adds	r4, #8
    b018:	4620      	mov	r0, r4
    b01a:	b003      	add	sp, #12
    b01c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b020:	4423      	add	r3, r4
    b022:	4628      	mov	r0, r5
    b024:	685a      	ldr	r2, [r3, #4]
    b026:	f042 0201 	orr.w	r2, r2, #1
    b02a:	605a      	str	r2, [r3, #4]
    b02c:	f7f8 fd54 	bl	3ad8 <__malloc_unlock>
    b030:	3408      	adds	r4, #8
    b032:	4620      	mov	r0, r4
    b034:	b003      	add	sp, #12
    b036:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b03a:	68bc      	ldr	r4, [r7, #8]
    b03c:	6863      	ldr	r3, [r4, #4]
    b03e:	f023 0803 	bic.w	r8, r3, #3
    b042:	45b0      	cmp	r8, r6
    b044:	d304      	bcc.n	b050 <_malloc_r+0x200>
    b046:	eba8 0306 	sub.w	r3, r8, r6
    b04a:	2b0f      	cmp	r3, #15
    b04c:	f300 8085 	bgt.w	b15a <_malloc_r+0x30a>
    b050:	f8df 9158 	ldr.w	r9, [pc, #344]	; b1ac <_malloc_r+0x35c>
    b054:	4b50      	ldr	r3, [pc, #320]	; (b198 <_malloc_r+0x348>)
    b056:	f8d9 2000 	ldr.w	r2, [r9]
    b05a:	681b      	ldr	r3, [r3, #0]
    b05c:	3201      	adds	r2, #1
    b05e:	4433      	add	r3, r6
    b060:	eb04 0a08 	add.w	sl, r4, r8
    b064:	f000 8155 	beq.w	b312 <_malloc_r+0x4c2>
    b068:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    b06c:	330f      	adds	r3, #15
    b06e:	f423 6b7f 	bic.w	fp, r3, #4080	; 0xff0
    b072:	f02b 0b0f 	bic.w	fp, fp, #15
    b076:	4659      	mov	r1, fp
    b078:	4628      	mov	r0, r5
    b07a:	f000 fa7d 	bl	b578 <_sbrk_r>
    b07e:	1c41      	adds	r1, r0, #1
    b080:	4602      	mov	r2, r0
    b082:	f000 80fc 	beq.w	b27e <_malloc_r+0x42e>
    b086:	4582      	cmp	sl, r0
    b088:	f200 80f7 	bhi.w	b27a <_malloc_r+0x42a>
    b08c:	4b43      	ldr	r3, [pc, #268]	; (b19c <_malloc_r+0x34c>)
    b08e:	6819      	ldr	r1, [r3, #0]
    b090:	4459      	add	r1, fp
    b092:	6019      	str	r1, [r3, #0]
    b094:	f000 814d 	beq.w	b332 <_malloc_r+0x4e2>
    b098:	f8d9 0000 	ldr.w	r0, [r9]
    b09c:	3001      	adds	r0, #1
    b09e:	bf1b      	ittet	ne
    b0a0:	eba2 0a0a 	subne.w	sl, r2, sl
    b0a4:	4451      	addne	r1, sl
    b0a6:	f8c9 2000 	streq.w	r2, [r9]
    b0aa:	6019      	strne	r1, [r3, #0]
    b0ac:	f012 0107 	ands.w	r1, r2, #7
    b0b0:	f000 8115 	beq.w	b2de <_malloc_r+0x48e>
    b0b4:	f1c1 0008 	rsb	r0, r1, #8
    b0b8:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
    b0bc:	4402      	add	r2, r0
    b0be:	3108      	adds	r1, #8
    b0c0:	eb02 090b 	add.w	r9, r2, fp
    b0c4:	f3c9 090b 	ubfx	r9, r9, #0, #12
    b0c8:	eba1 0909 	sub.w	r9, r1, r9
    b0cc:	4649      	mov	r1, r9
    b0ce:	4628      	mov	r0, r5
    b0d0:	9301      	str	r3, [sp, #4]
    b0d2:	9200      	str	r2, [sp, #0]
    b0d4:	f000 fa50 	bl	b578 <_sbrk_r>
    b0d8:	1c43      	adds	r3, r0, #1
    b0da:	e89d 000c 	ldmia.w	sp, {r2, r3}
    b0de:	f000 8143 	beq.w	b368 <_malloc_r+0x518>
    b0e2:	1a80      	subs	r0, r0, r2
    b0e4:	4448      	add	r0, r9
    b0e6:	f040 0001 	orr.w	r0, r0, #1
    b0ea:	6819      	ldr	r1, [r3, #0]
    b0ec:	60ba      	str	r2, [r7, #8]
    b0ee:	4449      	add	r1, r9
    b0f0:	42bc      	cmp	r4, r7
    b0f2:	6050      	str	r0, [r2, #4]
    b0f4:	6019      	str	r1, [r3, #0]
    b0f6:	d017      	beq.n	b128 <_malloc_r+0x2d8>
    b0f8:	f1b8 0f0f 	cmp.w	r8, #15
    b0fc:	f240 80fb 	bls.w	b2f6 <_malloc_r+0x4a6>
    b100:	6860      	ldr	r0, [r4, #4]
    b102:	f1a8 020c 	sub.w	r2, r8, #12
    b106:	f022 0207 	bic.w	r2, r2, #7
    b10a:	eb04 0e02 	add.w	lr, r4, r2
    b10e:	f000 0001 	and.w	r0, r0, #1
    b112:	f04f 0c05 	mov.w	ip, #5
    b116:	4310      	orrs	r0, r2
    b118:	2a0f      	cmp	r2, #15
    b11a:	6060      	str	r0, [r4, #4]
    b11c:	f8ce c004 	str.w	ip, [lr, #4]
    b120:	f8ce c008 	str.w	ip, [lr, #8]
    b124:	f200 8117 	bhi.w	b356 <_malloc_r+0x506>
    b128:	4b1d      	ldr	r3, [pc, #116]	; (b1a0 <_malloc_r+0x350>)
    b12a:	68bc      	ldr	r4, [r7, #8]
    b12c:	681a      	ldr	r2, [r3, #0]
    b12e:	4291      	cmp	r1, r2
    b130:	bf88      	it	hi
    b132:	6019      	strhi	r1, [r3, #0]
    b134:	4b1b      	ldr	r3, [pc, #108]	; (b1a4 <_malloc_r+0x354>)
    b136:	681a      	ldr	r2, [r3, #0]
    b138:	4291      	cmp	r1, r2
    b13a:	6862      	ldr	r2, [r4, #4]
    b13c:	bf88      	it	hi
    b13e:	6019      	strhi	r1, [r3, #0]
    b140:	f022 0203 	bic.w	r2, r2, #3
    b144:	4296      	cmp	r6, r2
    b146:	eba2 0306 	sub.w	r3, r2, r6
    b14a:	d801      	bhi.n	b150 <_malloc_r+0x300>
    b14c:	2b0f      	cmp	r3, #15
    b14e:	dc04      	bgt.n	b15a <_malloc_r+0x30a>
    b150:	4628      	mov	r0, r5
    b152:	f7f8 fcc1 	bl	3ad8 <__malloc_unlock>
    b156:	2400      	movs	r4, #0
    b158:	e740      	b.n	afdc <_malloc_r+0x18c>
    b15a:	19a2      	adds	r2, r4, r6
    b15c:	f043 0301 	orr.w	r3, r3, #1
    b160:	f046 0601 	orr.w	r6, r6, #1
    b164:	6066      	str	r6, [r4, #4]
    b166:	4628      	mov	r0, r5
    b168:	60ba      	str	r2, [r7, #8]
    b16a:	6053      	str	r3, [r2, #4]
    b16c:	f7f8 fcb4 	bl	3ad8 <__malloc_unlock>
    b170:	3408      	adds	r4, #8
    b172:	4620      	mov	r0, r4
    b174:	b003      	add	sp, #12
    b176:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b17a:	2b14      	cmp	r3, #20
    b17c:	d971      	bls.n	b262 <_malloc_r+0x412>
    b17e:	2b54      	cmp	r3, #84	; 0x54
    b180:	f200 80a3 	bhi.w	b2ca <_malloc_r+0x47a>
    b184:	0b33      	lsrs	r3, r6, #12
    b186:	f103 006f 	add.w	r0, r3, #111	; 0x6f
    b18a:	f103 0e6e 	add.w	lr, r3, #110	; 0x6e
    b18e:	00c3      	lsls	r3, r0, #3
    b190:	e680      	b.n	ae94 <_malloc_r+0x44>
    b192:	bf00      	nop
    b194:	2000075c 	.word	0x2000075c
    b198:	20001570 	.word	0x20001570
    b19c:	20001540 	.word	0x20001540
    b1a0:	20001568 	.word	0x20001568
    b1a4:	2000156c 	.word	0x2000156c
    b1a8:	20000764 	.word	0x20000764
    b1ac:	20000b64 	.word	0x20000b64
    b1b0:	0a5a      	lsrs	r2, r3, #9
    b1b2:	2a04      	cmp	r2, #4
    b1b4:	d95b      	bls.n	b26e <_malloc_r+0x41e>
    b1b6:	2a14      	cmp	r2, #20
    b1b8:	f200 80ae 	bhi.w	b318 <_malloc_r+0x4c8>
    b1bc:	f102 015c 	add.w	r1, r2, #92	; 0x5c
    b1c0:	00c9      	lsls	r1, r1, #3
    b1c2:	325b      	adds	r2, #91	; 0x5b
    b1c4:	eb07 0c01 	add.w	ip, r7, r1
    b1c8:	5879      	ldr	r1, [r7, r1]
    b1ca:	f1ac 0c08 	sub.w	ip, ip, #8
    b1ce:	458c      	cmp	ip, r1
    b1d0:	f000 8088 	beq.w	b2e4 <_malloc_r+0x494>
    b1d4:	684a      	ldr	r2, [r1, #4]
    b1d6:	f022 0203 	bic.w	r2, r2, #3
    b1da:	4293      	cmp	r3, r2
    b1dc:	d273      	bcs.n	b2c6 <_malloc_r+0x476>
    b1de:	6889      	ldr	r1, [r1, #8]
    b1e0:	458c      	cmp	ip, r1
    b1e2:	d1f7      	bne.n	b1d4 <_malloc_r+0x384>
    b1e4:	f8dc 200c 	ldr.w	r2, [ip, #12]
    b1e8:	687b      	ldr	r3, [r7, #4]
    b1ea:	60e2      	str	r2, [r4, #12]
    b1ec:	f8c4 c008 	str.w	ip, [r4, #8]
    b1f0:	6094      	str	r4, [r2, #8]
    b1f2:	f8cc 400c 	str.w	r4, [ip, #12]
    b1f6:	e68f      	b.n	af18 <_malloc_r+0xc8>
    b1f8:	19a1      	adds	r1, r4, r6
    b1fa:	f046 0c01 	orr.w	ip, r6, #1
    b1fe:	f042 0601 	orr.w	r6, r2, #1
    b202:	f8c4 c004 	str.w	ip, [r4, #4]
    b206:	4628      	mov	r0, r5
    b208:	6179      	str	r1, [r7, #20]
    b20a:	6139      	str	r1, [r7, #16]
    b20c:	f8c1 e00c 	str.w	lr, [r1, #12]
    b210:	f8c1 e008 	str.w	lr, [r1, #8]
    b214:	604e      	str	r6, [r1, #4]
    b216:	50e2      	str	r2, [r4, r3]
    b218:	f7f8 fc5e 	bl	3ad8 <__malloc_unlock>
    b21c:	3408      	adds	r4, #8
    b21e:	e6dd      	b.n	afdc <_malloc_r+0x18c>
    b220:	687b      	ldr	r3, [r7, #4]
    b222:	e679      	b.n	af18 <_malloc_r+0xc8>
    b224:	f108 0801 	add.w	r8, r8, #1
    b228:	f018 0f03 	tst.w	r8, #3
    b22c:	f10c 0c08 	add.w	ip, ip, #8
    b230:	f47f ae85 	bne.w	af3e <_malloc_r+0xee>
    b234:	e02d      	b.n	b292 <_malloc_r+0x442>
    b236:	68dc      	ldr	r4, [r3, #12]
    b238:	42a3      	cmp	r3, r4
    b23a:	bf08      	it	eq
    b23c:	3002      	addeq	r0, #2
    b23e:	f43f ae3e 	beq.w	aebe <_malloc_r+0x6e>
    b242:	e6bb      	b.n	afbc <_malloc_r+0x16c>
    b244:	4419      	add	r1, r3
    b246:	461c      	mov	r4, r3
    b248:	684a      	ldr	r2, [r1, #4]
    b24a:	68db      	ldr	r3, [r3, #12]
    b24c:	f854 6f08 	ldr.w	r6, [r4, #8]!
    b250:	f042 0201 	orr.w	r2, r2, #1
    b254:	604a      	str	r2, [r1, #4]
    b256:	4628      	mov	r0, r5
    b258:	60f3      	str	r3, [r6, #12]
    b25a:	609e      	str	r6, [r3, #8]
    b25c:	f7f8 fc3c 	bl	3ad8 <__malloc_unlock>
    b260:	e6bc      	b.n	afdc <_malloc_r+0x18c>
    b262:	f103 005c 	add.w	r0, r3, #92	; 0x5c
    b266:	f103 0e5b 	add.w	lr, r3, #91	; 0x5b
    b26a:	00c3      	lsls	r3, r0, #3
    b26c:	e612      	b.n	ae94 <_malloc_r+0x44>
    b26e:	099a      	lsrs	r2, r3, #6
    b270:	f102 0139 	add.w	r1, r2, #57	; 0x39
    b274:	00c9      	lsls	r1, r1, #3
    b276:	3238      	adds	r2, #56	; 0x38
    b278:	e7a4      	b.n	b1c4 <_malloc_r+0x374>
    b27a:	42bc      	cmp	r4, r7
    b27c:	d054      	beq.n	b328 <_malloc_r+0x4d8>
    b27e:	68bc      	ldr	r4, [r7, #8]
    b280:	6862      	ldr	r2, [r4, #4]
    b282:	f022 0203 	bic.w	r2, r2, #3
    b286:	e75d      	b.n	b144 <_malloc_r+0x2f4>
    b288:	f859 3908 	ldr.w	r3, [r9], #-8
    b28c:	4599      	cmp	r9, r3
    b28e:	f040 8086 	bne.w	b39e <_malloc_r+0x54e>
    b292:	f010 0f03 	tst.w	r0, #3
    b296:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    b29a:	d1f5      	bne.n	b288 <_malloc_r+0x438>
    b29c:	687b      	ldr	r3, [r7, #4]
    b29e:	ea23 0304 	bic.w	r3, r3, r4
    b2a2:	607b      	str	r3, [r7, #4]
    b2a4:	0064      	lsls	r4, r4, #1
    b2a6:	429c      	cmp	r4, r3
    b2a8:	f63f aec7 	bhi.w	b03a <_malloc_r+0x1ea>
    b2ac:	2c00      	cmp	r4, #0
    b2ae:	f43f aec4 	beq.w	b03a <_malloc_r+0x1ea>
    b2b2:	421c      	tst	r4, r3
    b2b4:	4640      	mov	r0, r8
    b2b6:	f47f ae3e 	bne.w	af36 <_malloc_r+0xe6>
    b2ba:	0064      	lsls	r4, r4, #1
    b2bc:	421c      	tst	r4, r3
    b2be:	f100 0004 	add.w	r0, r0, #4
    b2c2:	d0fa      	beq.n	b2ba <_malloc_r+0x46a>
    b2c4:	e637      	b.n	af36 <_malloc_r+0xe6>
    b2c6:	468c      	mov	ip, r1
    b2c8:	e78c      	b.n	b1e4 <_malloc_r+0x394>
    b2ca:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    b2ce:	d815      	bhi.n	b2fc <_malloc_r+0x4ac>
    b2d0:	0bf3      	lsrs	r3, r6, #15
    b2d2:	f103 0078 	add.w	r0, r3, #120	; 0x78
    b2d6:	f103 0e77 	add.w	lr, r3, #119	; 0x77
    b2da:	00c3      	lsls	r3, r0, #3
    b2dc:	e5da      	b.n	ae94 <_malloc_r+0x44>
    b2de:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    b2e2:	e6ed      	b.n	b0c0 <_malloc_r+0x270>
    b2e4:	687b      	ldr	r3, [r7, #4]
    b2e6:	1092      	asrs	r2, r2, #2
    b2e8:	2101      	movs	r1, #1
    b2ea:	fa01 f202 	lsl.w	r2, r1, r2
    b2ee:	4313      	orrs	r3, r2
    b2f0:	607b      	str	r3, [r7, #4]
    b2f2:	4662      	mov	r2, ip
    b2f4:	e779      	b.n	b1ea <_malloc_r+0x39a>
    b2f6:	2301      	movs	r3, #1
    b2f8:	6053      	str	r3, [r2, #4]
    b2fa:	e729      	b.n	b150 <_malloc_r+0x300>
    b2fc:	f240 5254 	movw	r2, #1364	; 0x554
    b300:	4293      	cmp	r3, r2
    b302:	d822      	bhi.n	b34a <_malloc_r+0x4fa>
    b304:	0cb3      	lsrs	r3, r6, #18
    b306:	f103 007d 	add.w	r0, r3, #125	; 0x7d
    b30a:	f103 0e7c 	add.w	lr, r3, #124	; 0x7c
    b30e:	00c3      	lsls	r3, r0, #3
    b310:	e5c0      	b.n	ae94 <_malloc_r+0x44>
    b312:	f103 0b10 	add.w	fp, r3, #16
    b316:	e6ae      	b.n	b076 <_malloc_r+0x226>
    b318:	2a54      	cmp	r2, #84	; 0x54
    b31a:	d829      	bhi.n	b370 <_malloc_r+0x520>
    b31c:	0b1a      	lsrs	r2, r3, #12
    b31e:	f102 016f 	add.w	r1, r2, #111	; 0x6f
    b322:	00c9      	lsls	r1, r1, #3
    b324:	326e      	adds	r2, #110	; 0x6e
    b326:	e74d      	b.n	b1c4 <_malloc_r+0x374>
    b328:	4b20      	ldr	r3, [pc, #128]	; (b3ac <_malloc_r+0x55c>)
    b32a:	6819      	ldr	r1, [r3, #0]
    b32c:	4459      	add	r1, fp
    b32e:	6019      	str	r1, [r3, #0]
    b330:	e6b2      	b.n	b098 <_malloc_r+0x248>
    b332:	f3ca 000b 	ubfx	r0, sl, #0, #12
    b336:	2800      	cmp	r0, #0
    b338:	f47f aeae 	bne.w	b098 <_malloc_r+0x248>
    b33c:	eb08 030b 	add.w	r3, r8, fp
    b340:	68ba      	ldr	r2, [r7, #8]
    b342:	f043 0301 	orr.w	r3, r3, #1
    b346:	6053      	str	r3, [r2, #4]
    b348:	e6ee      	b.n	b128 <_malloc_r+0x2d8>
    b34a:	207f      	movs	r0, #127	; 0x7f
    b34c:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
    b350:	f04f 0e7e 	mov.w	lr, #126	; 0x7e
    b354:	e59e      	b.n	ae94 <_malloc_r+0x44>
    b356:	f104 0108 	add.w	r1, r4, #8
    b35a:	4628      	mov	r0, r5
    b35c:	9300      	str	r3, [sp, #0]
    b35e:	f7f7 fae2 	bl	2926 <__wrap__free_r>
    b362:	9b00      	ldr	r3, [sp, #0]
    b364:	6819      	ldr	r1, [r3, #0]
    b366:	e6df      	b.n	b128 <_malloc_r+0x2d8>
    b368:	2001      	movs	r0, #1
    b36a:	f04f 0900 	mov.w	r9, #0
    b36e:	e6bc      	b.n	b0ea <_malloc_r+0x29a>
    b370:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    b374:	d805      	bhi.n	b382 <_malloc_r+0x532>
    b376:	0bda      	lsrs	r2, r3, #15
    b378:	f102 0178 	add.w	r1, r2, #120	; 0x78
    b37c:	00c9      	lsls	r1, r1, #3
    b37e:	3277      	adds	r2, #119	; 0x77
    b380:	e720      	b.n	b1c4 <_malloc_r+0x374>
    b382:	f240 5154 	movw	r1, #1364	; 0x554
    b386:	428a      	cmp	r2, r1
    b388:	d805      	bhi.n	b396 <_malloc_r+0x546>
    b38a:	0c9a      	lsrs	r2, r3, #18
    b38c:	f102 017d 	add.w	r1, r2, #125	; 0x7d
    b390:	00c9      	lsls	r1, r1, #3
    b392:	327c      	adds	r2, #124	; 0x7c
    b394:	e716      	b.n	b1c4 <_malloc_r+0x374>
    b396:	f44f 717e 	mov.w	r1, #1016	; 0x3f8
    b39a:	227e      	movs	r2, #126	; 0x7e
    b39c:	e712      	b.n	b1c4 <_malloc_r+0x374>
    b39e:	687b      	ldr	r3, [r7, #4]
    b3a0:	e780      	b.n	b2a4 <_malloc_r+0x454>
    b3a2:	08f0      	lsrs	r0, r6, #3
    b3a4:	f106 0308 	add.w	r3, r6, #8
    b3a8:	e600      	b.n	afac <_malloc_r+0x15c>
    b3aa:	bf00      	nop
    b3ac:	20001540 	.word	0x20001540

0000b3b0 <__ascii_mbtowc>:
    b3b0:	b082      	sub	sp, #8
    b3b2:	b149      	cbz	r1, b3c8 <__ascii_mbtowc+0x18>
    b3b4:	b15a      	cbz	r2, b3ce <__ascii_mbtowc+0x1e>
    b3b6:	b16b      	cbz	r3, b3d4 <__ascii_mbtowc+0x24>
    b3b8:	7813      	ldrb	r3, [r2, #0]
    b3ba:	600b      	str	r3, [r1, #0]
    b3bc:	7812      	ldrb	r2, [r2, #0]
    b3be:	1c10      	adds	r0, r2, #0
    b3c0:	bf18      	it	ne
    b3c2:	2001      	movne	r0, #1
    b3c4:	b002      	add	sp, #8
    b3c6:	4770      	bx	lr
    b3c8:	a901      	add	r1, sp, #4
    b3ca:	2a00      	cmp	r2, #0
    b3cc:	d1f3      	bne.n	b3b6 <__ascii_mbtowc+0x6>
    b3ce:	4610      	mov	r0, r2
    b3d0:	b002      	add	sp, #8
    b3d2:	4770      	bx	lr
    b3d4:	f06f 0001 	mvn.w	r0, #1
    b3d8:	e7f4      	b.n	b3c4 <__ascii_mbtowc+0x14>
    b3da:	bf00      	nop

0000b3dc <memmove>:
    b3dc:	4288      	cmp	r0, r1
    b3de:	b5f0      	push	{r4, r5, r6, r7, lr}
    b3e0:	d90d      	bls.n	b3fe <memmove+0x22>
    b3e2:	188b      	adds	r3, r1, r2
    b3e4:	4298      	cmp	r0, r3
    b3e6:	d20a      	bcs.n	b3fe <memmove+0x22>
    b3e8:	1884      	adds	r4, r0, r2
    b3ea:	2a00      	cmp	r2, #0
    b3ec:	d051      	beq.n	b492 <memmove+0xb6>
    b3ee:	4622      	mov	r2, r4
    b3f0:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    b3f4:	f802 4d01 	strb.w	r4, [r2, #-1]!
    b3f8:	4299      	cmp	r1, r3
    b3fa:	d1f9      	bne.n	b3f0 <memmove+0x14>
    b3fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b3fe:	2a0f      	cmp	r2, #15
    b400:	d948      	bls.n	b494 <memmove+0xb8>
    b402:	ea41 0300 	orr.w	r3, r1, r0
    b406:	079b      	lsls	r3, r3, #30
    b408:	d146      	bne.n	b498 <memmove+0xbc>
    b40a:	f100 0410 	add.w	r4, r0, #16
    b40e:	f101 0310 	add.w	r3, r1, #16
    b412:	4615      	mov	r5, r2
    b414:	f853 6c10 	ldr.w	r6, [r3, #-16]
    b418:	f844 6c10 	str.w	r6, [r4, #-16]
    b41c:	f853 6c0c 	ldr.w	r6, [r3, #-12]
    b420:	f844 6c0c 	str.w	r6, [r4, #-12]
    b424:	f853 6c08 	ldr.w	r6, [r3, #-8]
    b428:	f844 6c08 	str.w	r6, [r4, #-8]
    b42c:	3d10      	subs	r5, #16
    b42e:	f853 6c04 	ldr.w	r6, [r3, #-4]
    b432:	f844 6c04 	str.w	r6, [r4, #-4]
    b436:	2d0f      	cmp	r5, #15
    b438:	f103 0310 	add.w	r3, r3, #16
    b43c:	f104 0410 	add.w	r4, r4, #16
    b440:	d8e8      	bhi.n	b414 <memmove+0x38>
    b442:	f1a2 0310 	sub.w	r3, r2, #16
    b446:	f023 030f 	bic.w	r3, r3, #15
    b44a:	f002 0e0f 	and.w	lr, r2, #15
    b44e:	3310      	adds	r3, #16
    b450:	f1be 0f03 	cmp.w	lr, #3
    b454:	4419      	add	r1, r3
    b456:	4403      	add	r3, r0
    b458:	d921      	bls.n	b49e <memmove+0xc2>
    b45a:	1f1e      	subs	r6, r3, #4
    b45c:	460d      	mov	r5, r1
    b45e:	4674      	mov	r4, lr
    b460:	3c04      	subs	r4, #4
    b462:	f855 7b04 	ldr.w	r7, [r5], #4
    b466:	f846 7f04 	str.w	r7, [r6, #4]!
    b46a:	2c03      	cmp	r4, #3
    b46c:	d8f8      	bhi.n	b460 <memmove+0x84>
    b46e:	f1ae 0404 	sub.w	r4, lr, #4
    b472:	f024 0403 	bic.w	r4, r4, #3
    b476:	3404      	adds	r4, #4
    b478:	4421      	add	r1, r4
    b47a:	4423      	add	r3, r4
    b47c:	f002 0203 	and.w	r2, r2, #3
    b480:	b162      	cbz	r2, b49c <memmove+0xc0>
    b482:	3b01      	subs	r3, #1
    b484:	440a      	add	r2, r1
    b486:	f811 4b01 	ldrb.w	r4, [r1], #1
    b48a:	f803 4f01 	strb.w	r4, [r3, #1]!
    b48e:	428a      	cmp	r2, r1
    b490:	d1f9      	bne.n	b486 <memmove+0xaa>
    b492:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b494:	4603      	mov	r3, r0
    b496:	e7f3      	b.n	b480 <memmove+0xa4>
    b498:	4603      	mov	r3, r0
    b49a:	e7f2      	b.n	b482 <memmove+0xa6>
    b49c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b49e:	4672      	mov	r2, lr
    b4a0:	e7ee      	b.n	b480 <memmove+0xa4>
    b4a2:	bf00      	nop

0000b4a4 <memset>:
    b4a4:	b470      	push	{r4, r5, r6}
    b4a6:	0786      	lsls	r6, r0, #30
    b4a8:	d046      	beq.n	b538 <memset+0x94>
    b4aa:	1e54      	subs	r4, r2, #1
    b4ac:	2a00      	cmp	r2, #0
    b4ae:	d041      	beq.n	b534 <memset+0x90>
    b4b0:	b2ca      	uxtb	r2, r1
    b4b2:	4603      	mov	r3, r0
    b4b4:	e002      	b.n	b4bc <memset+0x18>
    b4b6:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
    b4ba:	d33b      	bcc.n	b534 <memset+0x90>
    b4bc:	f803 2b01 	strb.w	r2, [r3], #1
    b4c0:	079d      	lsls	r5, r3, #30
    b4c2:	d1f8      	bne.n	b4b6 <memset+0x12>
    b4c4:	2c03      	cmp	r4, #3
    b4c6:	d92e      	bls.n	b526 <memset+0x82>
    b4c8:	b2cd      	uxtb	r5, r1
    b4ca:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    b4ce:	2c0f      	cmp	r4, #15
    b4d0:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    b4d4:	d919      	bls.n	b50a <memset+0x66>
    b4d6:	f103 0210 	add.w	r2, r3, #16
    b4da:	4626      	mov	r6, r4
    b4dc:	3e10      	subs	r6, #16
    b4de:	2e0f      	cmp	r6, #15
    b4e0:	f842 5c10 	str.w	r5, [r2, #-16]
    b4e4:	f842 5c0c 	str.w	r5, [r2, #-12]
    b4e8:	f842 5c08 	str.w	r5, [r2, #-8]
    b4ec:	f842 5c04 	str.w	r5, [r2, #-4]
    b4f0:	f102 0210 	add.w	r2, r2, #16
    b4f4:	d8f2      	bhi.n	b4dc <memset+0x38>
    b4f6:	f1a4 0210 	sub.w	r2, r4, #16
    b4fa:	f022 020f 	bic.w	r2, r2, #15
    b4fe:	f004 040f 	and.w	r4, r4, #15
    b502:	3210      	adds	r2, #16
    b504:	2c03      	cmp	r4, #3
    b506:	4413      	add	r3, r2
    b508:	d90d      	bls.n	b526 <memset+0x82>
    b50a:	461e      	mov	r6, r3
    b50c:	4622      	mov	r2, r4
    b50e:	3a04      	subs	r2, #4
    b510:	2a03      	cmp	r2, #3
    b512:	f846 5b04 	str.w	r5, [r6], #4
    b516:	d8fa      	bhi.n	b50e <memset+0x6a>
    b518:	1f22      	subs	r2, r4, #4
    b51a:	f022 0203 	bic.w	r2, r2, #3
    b51e:	3204      	adds	r2, #4
    b520:	4413      	add	r3, r2
    b522:	f004 0403 	and.w	r4, r4, #3
    b526:	b12c      	cbz	r4, b534 <memset+0x90>
    b528:	b2c9      	uxtb	r1, r1
    b52a:	441c      	add	r4, r3
    b52c:	f803 1b01 	strb.w	r1, [r3], #1
    b530:	429c      	cmp	r4, r3
    b532:	d1fb      	bne.n	b52c <memset+0x88>
    b534:	bc70      	pop	{r4, r5, r6}
    b536:	4770      	bx	lr
    b538:	4614      	mov	r4, r2
    b53a:	4603      	mov	r3, r0
    b53c:	e7c2      	b.n	b4c4 <memset+0x20>
    b53e:	bf00      	nop

0000b540 <printf>:
    b540:	b40f      	push	{r0, r1, r2, r3}
    b542:	b500      	push	{lr}
    b544:	4907      	ldr	r1, [pc, #28]	; (b564 <printf+0x24>)
    b546:	b083      	sub	sp, #12
    b548:	ab04      	add	r3, sp, #16
    b54a:	6808      	ldr	r0, [r1, #0]
    b54c:	f853 2b04 	ldr.w	r2, [r3], #4
    b550:	6881      	ldr	r1, [r0, #8]
    b552:	9301      	str	r3, [sp, #4]
    b554:	f002 f988 	bl	d868 <_vfprintf_r>
    b558:	b003      	add	sp, #12
    b55a:	f85d eb04 	ldr.w	lr, [sp], #4
    b55e:	b004      	add	sp, #16
    b560:	4770      	bx	lr
    b562:	bf00      	nop
    b564:	200001c0 	.word	0x200001c0

0000b568 <realloc>:
    b568:	4b02      	ldr	r3, [pc, #8]	; (b574 <realloc+0xc>)
    b56a:	460a      	mov	r2, r1
    b56c:	4601      	mov	r1, r0
    b56e:	6818      	ldr	r0, [r3, #0]
    b570:	f7f7 b99e 	b.w	28b0 <__wrap__realloc_r>
    b574:	200001c0 	.word	0x200001c0

0000b578 <_sbrk_r>:
    b578:	b538      	push	{r3, r4, r5, lr}
    b57a:	4c07      	ldr	r4, [pc, #28]	; (b598 <_sbrk_r+0x20>)
    b57c:	2300      	movs	r3, #0
    b57e:	4605      	mov	r5, r0
    b580:	4608      	mov	r0, r1
    b582:	6023      	str	r3, [r4, #0]
    b584:	f7f8 fa2c 	bl	39e0 <_sbrk>
    b588:	1c43      	adds	r3, r0, #1
    b58a:	d000      	beq.n	b58e <_sbrk_r+0x16>
    b58c:	bd38      	pop	{r3, r4, r5, pc}
    b58e:	6823      	ldr	r3, [r4, #0]
    b590:	2b00      	cmp	r3, #0
    b592:	d0fb      	beq.n	b58c <_sbrk_r+0x14>
    b594:	602b      	str	r3, [r5, #0]
    b596:	bd38      	pop	{r3, r4, r5, pc}
    b598:	2000304c 	.word	0x2000304c

0000b59c <__sread>:
    b59c:	b510      	push	{r4, lr}
    b59e:	460c      	mov	r4, r1
    b5a0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    b5a4:	f005 f912 	bl	107cc <_read_r>
    b5a8:	2800      	cmp	r0, #0
    b5aa:	db03      	blt.n	b5b4 <__sread+0x18>
    b5ac:	6d23      	ldr	r3, [r4, #80]	; 0x50
    b5ae:	4403      	add	r3, r0
    b5b0:	6523      	str	r3, [r4, #80]	; 0x50
    b5b2:	bd10      	pop	{r4, pc}
    b5b4:	89a3      	ldrh	r3, [r4, #12]
    b5b6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    b5ba:	81a3      	strh	r3, [r4, #12]
    b5bc:	bd10      	pop	{r4, pc}
    b5be:	bf00      	nop

0000b5c0 <__swrite>:
    b5c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b5c4:	4616      	mov	r6, r2
    b5c6:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
    b5ca:	461f      	mov	r7, r3
    b5cc:	05d3      	lsls	r3, r2, #23
    b5ce:	460c      	mov	r4, r1
    b5d0:	4605      	mov	r5, r0
    b5d2:	d507      	bpl.n	b5e4 <__swrite+0x24>
    b5d4:	2200      	movs	r2, #0
    b5d6:	2302      	movs	r3, #2
    b5d8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    b5dc:	f004 fde6 	bl	101ac <_lseek_r>
    b5e0:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    b5e4:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    b5e8:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    b5ec:	81a2      	strh	r2, [r4, #12]
    b5ee:	463b      	mov	r3, r7
    b5f0:	4632      	mov	r2, r6
    b5f2:	4628      	mov	r0, r5
    b5f4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    b5f8:	f003 bcf2 	b.w	efe0 <_write_r>

0000b5fc <__sseek>:
    b5fc:	b510      	push	{r4, lr}
    b5fe:	460c      	mov	r4, r1
    b600:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    b604:	f004 fdd2 	bl	101ac <_lseek_r>
    b608:	89a3      	ldrh	r3, [r4, #12]
    b60a:	1c42      	adds	r2, r0, #1
    b60c:	bf0e      	itee	eq
    b60e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
    b612:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
    b616:	6520      	strne	r0, [r4, #80]	; 0x50
    b618:	81a3      	strh	r3, [r4, #12]
    b61a:	bd10      	pop	{r4, pc}

0000b61c <__sclose>:
    b61c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    b620:	f003 bd60 	b.w	f0e4 <_close_r>
    b624:	0000      	movs	r0, r0
	...

0000b628 <_svfprintf_r>:
    b628:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b62c:	b0c5      	sub	sp, #276	; 0x114
    b62e:	460c      	mov	r4, r1
    b630:	910b      	str	r1, [sp, #44]	; 0x2c
    b632:	4692      	mov	sl, r2
    b634:	930f      	str	r3, [sp, #60]	; 0x3c
    b636:	900c      	str	r0, [sp, #48]	; 0x30
    b638:	f004 fdaa 	bl	10190 <_localeconv_r>
    b63c:	6803      	ldr	r3, [r0, #0]
    b63e:	9318      	str	r3, [sp, #96]	; 0x60
    b640:	4618      	mov	r0, r3
    b642:	f7f5 fa1d 	bl	a80 <strlen>
    b646:	89a3      	ldrh	r3, [r4, #12]
    b648:	9017      	str	r0, [sp, #92]	; 0x5c
    b64a:	0619      	lsls	r1, r3, #24
    b64c:	d503      	bpl.n	b656 <_svfprintf_r+0x2e>
    b64e:	6923      	ldr	r3, [r4, #16]
    b650:	2b00      	cmp	r3, #0
    b652:	f001 801b 	beq.w	c68c <_svfprintf_r+0x1064>
    b656:	ed9f 7b94 	vldr	d7, [pc, #592]	; b8a8 <_svfprintf_r+0x280>
    b65a:	ed8d 7b14 	vstr	d7, [sp, #80]	; 0x50
    b65e:	2300      	movs	r3, #0
    b660:	f10d 09d0 	add.w	r9, sp, #208	; 0xd0
    b664:	9313      	str	r3, [sp, #76]	; 0x4c
    b666:	9329      	str	r3, [sp, #164]	; 0xa4
    b668:	9328      	str	r3, [sp, #160]	; 0xa0
    b66a:	9316      	str	r3, [sp, #88]	; 0x58
    b66c:	9319      	str	r3, [sp, #100]	; 0x64
    b66e:	9309      	str	r3, [sp, #36]	; 0x24
    b670:	f8cd 909c 	str.w	r9, [sp, #156]	; 0x9c
    b674:	46c8      	mov	r8, r9
    b676:	f89a 3000 	ldrb.w	r3, [sl]
    b67a:	4654      	mov	r4, sl
    b67c:	b1e3      	cbz	r3, b6b8 <_svfprintf_r+0x90>
    b67e:	2b25      	cmp	r3, #37	; 0x25
    b680:	d102      	bne.n	b688 <_svfprintf_r+0x60>
    b682:	e019      	b.n	b6b8 <_svfprintf_r+0x90>
    b684:	2b25      	cmp	r3, #37	; 0x25
    b686:	d003      	beq.n	b690 <_svfprintf_r+0x68>
    b688:	f814 3f01 	ldrb.w	r3, [r4, #1]!
    b68c:	2b00      	cmp	r3, #0
    b68e:	d1f9      	bne.n	b684 <_svfprintf_r+0x5c>
    b690:	eba4 050a 	sub.w	r5, r4, sl
    b694:	b185      	cbz	r5, b6b8 <_svfprintf_r+0x90>
    b696:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    b698:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    b69a:	f8c8 a000 	str.w	sl, [r8]
    b69e:	3301      	adds	r3, #1
    b6a0:	442a      	add	r2, r5
    b6a2:	2b07      	cmp	r3, #7
    b6a4:	f8c8 5004 	str.w	r5, [r8, #4]
    b6a8:	9229      	str	r2, [sp, #164]	; 0xa4
    b6aa:	9328      	str	r3, [sp, #160]	; 0xa0
    b6ac:	dc7f      	bgt.n	b7ae <_svfprintf_r+0x186>
    b6ae:	f108 0808 	add.w	r8, r8, #8
    b6b2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b6b4:	442b      	add	r3, r5
    b6b6:	9309      	str	r3, [sp, #36]	; 0x24
    b6b8:	7823      	ldrb	r3, [r4, #0]
    b6ba:	2b00      	cmp	r3, #0
    b6bc:	d07f      	beq.n	b7be <_svfprintf_r+0x196>
    b6be:	2300      	movs	r3, #0
    b6c0:	461a      	mov	r2, r3
    b6c2:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
    b6c6:	4619      	mov	r1, r3
    b6c8:	930d      	str	r3, [sp, #52]	; 0x34
    b6ca:	469b      	mov	fp, r3
    b6cc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    b6d0:	7863      	ldrb	r3, [r4, #1]
    b6d2:	900a      	str	r0, [sp, #40]	; 0x28
    b6d4:	f104 0a01 	add.w	sl, r4, #1
    b6d8:	f10a 0a01 	add.w	sl, sl, #1
    b6dc:	f1a3 0020 	sub.w	r0, r3, #32
    b6e0:	2858      	cmp	r0, #88	; 0x58
    b6e2:	f200 83d3 	bhi.w	be8c <_svfprintf_r+0x864>
    b6e6:	e8df f010 	tbh	[pc, r0, lsl #1]
    b6ea:	023f      	.short	0x023f
    b6ec:	03d103d1 	.word	0x03d103d1
    b6f0:	03d10247 	.word	0x03d10247
    b6f4:	03d103d1 	.word	0x03d103d1
    b6f8:	03d103d1 	.word	0x03d103d1
    b6fc:	024c03d1 	.word	0x024c03d1
    b700:	03d1020a 	.word	0x03d1020a
    b704:	0273005d 	.word	0x0273005d
    b708:	028e03d1 	.word	0x028e03d1
    b70c:	03c103c1 	.word	0x03c103c1
    b710:	03c103c1 	.word	0x03c103c1
    b714:	03c103c1 	.word	0x03c103c1
    b718:	03c103c1 	.word	0x03c103c1
    b71c:	03d103c1 	.word	0x03d103c1
    b720:	03d103d1 	.word	0x03d103d1
    b724:	03d103d1 	.word	0x03d103d1
    b728:	03d103d1 	.word	0x03d103d1
    b72c:	03d103d1 	.word	0x03d103d1
    b730:	033f03d1 	.word	0x033f03d1
    b734:	03d1035f 	.word	0x03d1035f
    b738:	03d1035f 	.word	0x03d1035f
    b73c:	03d103d1 	.word	0x03d103d1
    b740:	03aa03d1 	.word	0x03aa03d1
    b744:	03d103d1 	.word	0x03d103d1
    b748:	03d103af 	.word	0x03d103af
    b74c:	03d103d1 	.word	0x03d103d1
    b750:	03d103d1 	.word	0x03d103d1
    b754:	03d10261 	.word	0x03d10261
    b758:	032603d1 	.word	0x032603d1
    b75c:	03d103d1 	.word	0x03d103d1
    b760:	03d103d1 	.word	0x03d103d1
    b764:	03d103d1 	.word	0x03d103d1
    b768:	03d103d1 	.word	0x03d103d1
    b76c:	03d103d1 	.word	0x03d103d1
    b770:	02e302ce 	.word	0x02e302ce
    b774:	035f035f 	.word	0x035f035f
    b778:	0293035f 	.word	0x0293035f
    b77c:	03d102e3 	.word	0x03d102e3
    b780:	029803d1 	.word	0x029803d1
    b784:	02a503d1 	.word	0x02a503d1
    b788:	02bc01d3 	.word	0x02bc01d3
    b78c:	03d1020f 	.word	0x03d1020f
    b790:	03d101e8 	.word	0x03d101e8
    b794:	03d1007e 	.word	0x03d1007e
    b798:	021403d1 	.word	0x021403d1
    b79c:	980d      	ldr	r0, [sp, #52]	; 0x34
    b79e:	930f      	str	r3, [sp, #60]	; 0x3c
    b7a0:	4240      	negs	r0, r0
    b7a2:	900d      	str	r0, [sp, #52]	; 0x34
    b7a4:	f04b 0b04 	orr.w	fp, fp, #4
    b7a8:	f89a 3000 	ldrb.w	r3, [sl]
    b7ac:	e794      	b.n	b6d8 <_svfprintf_r+0xb0>
    b7ae:	aa27      	add	r2, sp, #156	; 0x9c
    b7b0:	990b      	ldr	r1, [sp, #44]	; 0x2c
    b7b2:	980c      	ldr	r0, [sp, #48]	; 0x30
    b7b4:	f005 f86e 	bl	10894 <__ssprint_r>
    b7b8:	b940      	cbnz	r0, b7cc <_svfprintf_r+0x1a4>
    b7ba:	46c8      	mov	r8, r9
    b7bc:	e779      	b.n	b6b2 <_svfprintf_r+0x8a>
    b7be:	9b29      	ldr	r3, [sp, #164]	; 0xa4
    b7c0:	b123      	cbz	r3, b7cc <_svfprintf_r+0x1a4>
    b7c2:	980c      	ldr	r0, [sp, #48]	; 0x30
    b7c4:	990b      	ldr	r1, [sp, #44]	; 0x2c
    b7c6:	aa27      	add	r2, sp, #156	; 0x9c
    b7c8:	f005 f864 	bl	10894 <__ssprint_r>
    b7cc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    b7ce:	899b      	ldrh	r3, [r3, #12]
    b7d0:	f013 0f40 	tst.w	r3, #64	; 0x40
    b7d4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b7d6:	bf18      	it	ne
    b7d8:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
    b7dc:	9309      	str	r3, [sp, #36]	; 0x24
    b7de:	9809      	ldr	r0, [sp, #36]	; 0x24
    b7e0:	b045      	add	sp, #276	; 0x114
    b7e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b7e6:	f01b 0f20 	tst.w	fp, #32
    b7ea:	9311      	str	r3, [sp, #68]	; 0x44
    b7ec:	f040 81e5 	bne.w	bbba <_svfprintf_r+0x592>
    b7f0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    b7f2:	f01b 0f10 	tst.w	fp, #16
    b7f6:	4613      	mov	r3, r2
    b7f8:	f040 8588 	bne.w	c30c <_svfprintf_r+0xce4>
    b7fc:	f01b 0f40 	tst.w	fp, #64	; 0x40
    b800:	f000 8584 	beq.w	c30c <_svfprintf_r+0xce4>
    b804:	8814      	ldrh	r4, [r2, #0]
    b806:	3204      	adds	r2, #4
    b808:	2500      	movs	r5, #0
    b80a:	2301      	movs	r3, #1
    b80c:	920f      	str	r2, [sp, #60]	; 0x3c
    b80e:	2700      	movs	r7, #0
    b810:	f88d 707f 	strb.w	r7, [sp, #127]	; 0x7f
    b814:	990a      	ldr	r1, [sp, #40]	; 0x28
    b816:	1c4a      	adds	r2, r1, #1
    b818:	f000 826d 	beq.w	bcf6 <_svfprintf_r+0x6ce>
    b81c:	f02b 0280 	bic.w	r2, fp, #128	; 0x80
    b820:	9207      	str	r2, [sp, #28]
    b822:	ea54 0205 	orrs.w	r2, r4, r5
    b826:	f040 826c 	bne.w	bd02 <_svfprintf_r+0x6da>
    b82a:	2900      	cmp	r1, #0
    b82c:	f040 8451 	bne.w	c0d2 <_svfprintf_r+0xaaa>
    b830:	2b00      	cmp	r3, #0
    b832:	f040 850b 	bne.w	c24c <_svfprintf_r+0xc24>
    b836:	f01b 0301 	ands.w	r3, fp, #1
    b83a:	930e      	str	r3, [sp, #56]	; 0x38
    b83c:	f000 861a 	beq.w	c474 <_svfprintf_r+0xe4c>
    b840:	ae44      	add	r6, sp, #272	; 0x110
    b842:	2330      	movs	r3, #48	; 0x30
    b844:	f806 3d41 	strb.w	r3, [r6, #-65]!
    b848:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    b84a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    b84c:	4293      	cmp	r3, r2
    b84e:	bfb8      	it	lt
    b850:	4613      	movlt	r3, r2
    b852:	9308      	str	r3, [sp, #32]
    b854:	2300      	movs	r3, #0
    b856:	9312      	str	r3, [sp, #72]	; 0x48
    b858:	b117      	cbz	r7, b860 <_svfprintf_r+0x238>
    b85a:	9b08      	ldr	r3, [sp, #32]
    b85c:	3301      	adds	r3, #1
    b85e:	9308      	str	r3, [sp, #32]
    b860:	9b07      	ldr	r3, [sp, #28]
    b862:	f013 0302 	ands.w	r3, r3, #2
    b866:	9310      	str	r3, [sp, #64]	; 0x40
    b868:	d002      	beq.n	b870 <_svfprintf_r+0x248>
    b86a:	9b08      	ldr	r3, [sp, #32]
    b86c:	3302      	adds	r3, #2
    b86e:	9308      	str	r3, [sp, #32]
    b870:	9b07      	ldr	r3, [sp, #28]
    b872:	f013 0584 	ands.w	r5, r3, #132	; 0x84
    b876:	f040 8320 	bne.w	beba <_svfprintf_r+0x892>
    b87a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    b87c:	9a08      	ldr	r2, [sp, #32]
    b87e:	eba3 0b02 	sub.w	fp, r3, r2
    b882:	f1bb 0f00 	cmp.w	fp, #0
    b886:	f340 8318 	ble.w	beba <_svfprintf_r+0x892>
    b88a:	f1bb 0f10 	cmp.w	fp, #16
    b88e:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    b890:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    b892:	dd30      	ble.n	b8f6 <_svfprintf_r+0x2ce>
    b894:	4643      	mov	r3, r8
    b896:	4621      	mov	r1, r4
    b898:	46a8      	mov	r8, r5
    b89a:	2710      	movs	r7, #16
    b89c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    b89e:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    b8a0:	e00d      	b.n	b8be <_svfprintf_r+0x296>
    b8a2:	bf00      	nop
    b8a4:	f3af 8000 	nop.w
	...
    b8b0:	f1ab 0b10 	sub.w	fp, fp, #16
    b8b4:	f1bb 0f10 	cmp.w	fp, #16
    b8b8:	f103 0308 	add.w	r3, r3, #8
    b8bc:	dd18      	ble.n	b8f0 <_svfprintf_r+0x2c8>
    b8be:	3201      	adds	r2, #1
    b8c0:	48b7      	ldr	r0, [pc, #732]	; (bba0 <_svfprintf_r+0x578>)
    b8c2:	9228      	str	r2, [sp, #160]	; 0xa0
    b8c4:	3110      	adds	r1, #16
    b8c6:	2a07      	cmp	r2, #7
    b8c8:	9129      	str	r1, [sp, #164]	; 0xa4
    b8ca:	e883 0081 	stmia.w	r3, {r0, r7}
    b8ce:	ddef      	ble.n	b8b0 <_svfprintf_r+0x288>
    b8d0:	aa27      	add	r2, sp, #156	; 0x9c
    b8d2:	4629      	mov	r1, r5
    b8d4:	4620      	mov	r0, r4
    b8d6:	f004 ffdd 	bl	10894 <__ssprint_r>
    b8da:	2800      	cmp	r0, #0
    b8dc:	f47f af76 	bne.w	b7cc <_svfprintf_r+0x1a4>
    b8e0:	f1ab 0b10 	sub.w	fp, fp, #16
    b8e4:	f1bb 0f10 	cmp.w	fp, #16
    b8e8:	9929      	ldr	r1, [sp, #164]	; 0xa4
    b8ea:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    b8ec:	464b      	mov	r3, r9
    b8ee:	dce6      	bgt.n	b8be <_svfprintf_r+0x296>
    b8f0:	4645      	mov	r5, r8
    b8f2:	460c      	mov	r4, r1
    b8f4:	4698      	mov	r8, r3
    b8f6:	3201      	adds	r2, #1
    b8f8:	4ba9      	ldr	r3, [pc, #676]	; (bba0 <_svfprintf_r+0x578>)
    b8fa:	9228      	str	r2, [sp, #160]	; 0xa0
    b8fc:	445c      	add	r4, fp
    b8fe:	2a07      	cmp	r2, #7
    b900:	9429      	str	r4, [sp, #164]	; 0xa4
    b902:	e888 0808 	stmia.w	r8, {r3, fp}
    b906:	f300 84a6 	bgt.w	c256 <_svfprintf_r+0xc2e>
    b90a:	f89d 707f 	ldrb.w	r7, [sp, #127]	; 0x7f
    b90e:	f108 0808 	add.w	r8, r8, #8
    b912:	b177      	cbz	r7, b932 <_svfprintf_r+0x30a>
    b914:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    b916:	3301      	adds	r3, #1
    b918:	3401      	adds	r4, #1
    b91a:	f10d 017f 	add.w	r1, sp, #127	; 0x7f
    b91e:	2201      	movs	r2, #1
    b920:	2b07      	cmp	r3, #7
    b922:	9429      	str	r4, [sp, #164]	; 0xa4
    b924:	9328      	str	r3, [sp, #160]	; 0xa0
    b926:	e888 0006 	stmia.w	r8, {r1, r2}
    b92a:	f300 83f4 	bgt.w	c116 <_svfprintf_r+0xaee>
    b92e:	f108 0808 	add.w	r8, r8, #8
    b932:	9b10      	ldr	r3, [sp, #64]	; 0x40
    b934:	b16b      	cbz	r3, b952 <_svfprintf_r+0x32a>
    b936:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    b938:	3301      	adds	r3, #1
    b93a:	3402      	adds	r4, #2
    b93c:	a920      	add	r1, sp, #128	; 0x80
    b93e:	2202      	movs	r2, #2
    b940:	2b07      	cmp	r3, #7
    b942:	9429      	str	r4, [sp, #164]	; 0xa4
    b944:	9328      	str	r3, [sp, #160]	; 0xa0
    b946:	e888 0006 	stmia.w	r8, {r1, r2}
    b94a:	f300 83d9 	bgt.w	c100 <_svfprintf_r+0xad8>
    b94e:	f108 0808 	add.w	r8, r8, #8
    b952:	2d80      	cmp	r5, #128	; 0x80
    b954:	f000 8322 	beq.w	bf9c <_svfprintf_r+0x974>
    b958:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    b95a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    b95c:	1a9f      	subs	r7, r3, r2
    b95e:	2f00      	cmp	r7, #0
    b960:	dd36      	ble.n	b9d0 <_svfprintf_r+0x3a8>
    b962:	2f10      	cmp	r7, #16
    b964:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    b966:	4d8f      	ldr	r5, [pc, #572]	; (bba4 <_svfprintf_r+0x57c>)
    b968:	dd27      	ble.n	b9ba <_svfprintf_r+0x392>
    b96a:	4642      	mov	r2, r8
    b96c:	4621      	mov	r1, r4
    b96e:	46b0      	mov	r8, r6
    b970:	f04f 0b10 	mov.w	fp, #16
    b974:	462e      	mov	r6, r5
    b976:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    b978:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    b97a:	e004      	b.n	b986 <_svfprintf_r+0x35e>
    b97c:	3f10      	subs	r7, #16
    b97e:	2f10      	cmp	r7, #16
    b980:	f102 0208 	add.w	r2, r2, #8
    b984:	dd15      	ble.n	b9b2 <_svfprintf_r+0x38a>
    b986:	3301      	adds	r3, #1
    b988:	3110      	adds	r1, #16
    b98a:	2b07      	cmp	r3, #7
    b98c:	9129      	str	r1, [sp, #164]	; 0xa4
    b98e:	9328      	str	r3, [sp, #160]	; 0xa0
    b990:	e882 0840 	stmia.w	r2, {r6, fp}
    b994:	ddf2      	ble.n	b97c <_svfprintf_r+0x354>
    b996:	aa27      	add	r2, sp, #156	; 0x9c
    b998:	4629      	mov	r1, r5
    b99a:	4620      	mov	r0, r4
    b99c:	f004 ff7a 	bl	10894 <__ssprint_r>
    b9a0:	2800      	cmp	r0, #0
    b9a2:	f47f af13 	bne.w	b7cc <_svfprintf_r+0x1a4>
    b9a6:	3f10      	subs	r7, #16
    b9a8:	2f10      	cmp	r7, #16
    b9aa:	9929      	ldr	r1, [sp, #164]	; 0xa4
    b9ac:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    b9ae:	464a      	mov	r2, r9
    b9b0:	dce9      	bgt.n	b986 <_svfprintf_r+0x35e>
    b9b2:	4635      	mov	r5, r6
    b9b4:	460c      	mov	r4, r1
    b9b6:	4646      	mov	r6, r8
    b9b8:	4690      	mov	r8, r2
    b9ba:	3301      	adds	r3, #1
    b9bc:	443c      	add	r4, r7
    b9be:	2b07      	cmp	r3, #7
    b9c0:	9429      	str	r4, [sp, #164]	; 0xa4
    b9c2:	9328      	str	r3, [sp, #160]	; 0xa0
    b9c4:	e888 00a0 	stmia.w	r8, {r5, r7}
    b9c8:	f300 838f 	bgt.w	c0ea <_svfprintf_r+0xac2>
    b9cc:	f108 0808 	add.w	r8, r8, #8
    b9d0:	9b07      	ldr	r3, [sp, #28]
    b9d2:	05df      	lsls	r7, r3, #23
    b9d4:	f100 8273 	bmi.w	bebe <_svfprintf_r+0x896>
    b9d8:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    b9da:	990e      	ldr	r1, [sp, #56]	; 0x38
    b9dc:	f8c8 6000 	str.w	r6, [r8]
    b9e0:	3301      	adds	r3, #1
    b9e2:	440c      	add	r4, r1
    b9e4:	2b07      	cmp	r3, #7
    b9e6:	9429      	str	r4, [sp, #164]	; 0xa4
    b9e8:	f8c8 1004 	str.w	r1, [r8, #4]
    b9ec:	9328      	str	r3, [sp, #160]	; 0xa0
    b9ee:	f300 835b 	bgt.w	c0a8 <_svfprintf_r+0xa80>
    b9f2:	f108 0808 	add.w	r8, r8, #8
    b9f6:	9b07      	ldr	r3, [sp, #28]
    b9f8:	075b      	lsls	r3, r3, #29
    b9fa:	d53a      	bpl.n	ba72 <_svfprintf_r+0x44a>
    b9fc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    b9fe:	9a08      	ldr	r2, [sp, #32]
    ba00:	1a9d      	subs	r5, r3, r2
    ba02:	2d00      	cmp	r5, #0
    ba04:	dd35      	ble.n	ba72 <_svfprintf_r+0x44a>
    ba06:	2d10      	cmp	r5, #16
    ba08:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    ba0a:	dd20      	ble.n	ba4e <_svfprintf_r+0x426>
    ba0c:	2610      	movs	r6, #16
    ba0e:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    ba10:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
    ba14:	e004      	b.n	ba20 <_svfprintf_r+0x3f8>
    ba16:	3d10      	subs	r5, #16
    ba18:	2d10      	cmp	r5, #16
    ba1a:	f108 0808 	add.w	r8, r8, #8
    ba1e:	dd16      	ble.n	ba4e <_svfprintf_r+0x426>
    ba20:	3301      	adds	r3, #1
    ba22:	4a5f      	ldr	r2, [pc, #380]	; (bba0 <_svfprintf_r+0x578>)
    ba24:	9328      	str	r3, [sp, #160]	; 0xa0
    ba26:	3410      	adds	r4, #16
    ba28:	2b07      	cmp	r3, #7
    ba2a:	9429      	str	r4, [sp, #164]	; 0xa4
    ba2c:	e888 0044 	stmia.w	r8, {r2, r6}
    ba30:	ddf1      	ble.n	ba16 <_svfprintf_r+0x3ee>
    ba32:	aa27      	add	r2, sp, #156	; 0x9c
    ba34:	4659      	mov	r1, fp
    ba36:	4638      	mov	r0, r7
    ba38:	f004 ff2c 	bl	10894 <__ssprint_r>
    ba3c:	2800      	cmp	r0, #0
    ba3e:	f47f aec5 	bne.w	b7cc <_svfprintf_r+0x1a4>
    ba42:	3d10      	subs	r5, #16
    ba44:	2d10      	cmp	r5, #16
    ba46:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    ba48:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    ba4a:	46c8      	mov	r8, r9
    ba4c:	dce8      	bgt.n	ba20 <_svfprintf_r+0x3f8>
    ba4e:	3301      	adds	r3, #1
    ba50:	4a53      	ldr	r2, [pc, #332]	; (bba0 <_svfprintf_r+0x578>)
    ba52:	9328      	str	r3, [sp, #160]	; 0xa0
    ba54:	442c      	add	r4, r5
    ba56:	2b07      	cmp	r3, #7
    ba58:	9429      	str	r4, [sp, #164]	; 0xa4
    ba5a:	e888 0024 	stmia.w	r8, {r2, r5}
    ba5e:	dd08      	ble.n	ba72 <_svfprintf_r+0x44a>
    ba60:	aa27      	add	r2, sp, #156	; 0x9c
    ba62:	990b      	ldr	r1, [sp, #44]	; 0x2c
    ba64:	980c      	ldr	r0, [sp, #48]	; 0x30
    ba66:	f004 ff15 	bl	10894 <__ssprint_r>
    ba6a:	2800      	cmp	r0, #0
    ba6c:	f47f aeae 	bne.w	b7cc <_svfprintf_r+0x1a4>
    ba70:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    ba72:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ba74:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    ba76:	9908      	ldr	r1, [sp, #32]
    ba78:	428a      	cmp	r2, r1
    ba7a:	bfac      	ite	ge
    ba7c:	189b      	addge	r3, r3, r2
    ba7e:	185b      	addlt	r3, r3, r1
    ba80:	9309      	str	r3, [sp, #36]	; 0x24
    ba82:	2c00      	cmp	r4, #0
    ba84:	f040 831b 	bne.w	c0be <_svfprintf_r+0xa96>
    ba88:	2300      	movs	r3, #0
    ba8a:	9328      	str	r3, [sp, #160]	; 0xa0
    ba8c:	46c8      	mov	r8, r9
    ba8e:	e5f2      	b.n	b676 <_svfprintf_r+0x4e>
    ba90:	9311      	str	r3, [sp, #68]	; 0x44
    ba92:	f01b 0320 	ands.w	r3, fp, #32
    ba96:	f040 81de 	bne.w	be56 <_svfprintf_r+0x82e>
    ba9a:	f01b 0210 	ands.w	r2, fp, #16
    ba9e:	f040 842d 	bne.w	c2fc <_svfprintf_r+0xcd4>
    baa2:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
    baa6:	f000 8429 	beq.w	c2fc <_svfprintf_r+0xcd4>
    baaa:	990f      	ldr	r1, [sp, #60]	; 0x3c
    baac:	4613      	mov	r3, r2
    baae:	460a      	mov	r2, r1
    bab0:	3204      	adds	r2, #4
    bab2:	880c      	ldrh	r4, [r1, #0]
    bab4:	920f      	str	r2, [sp, #60]	; 0x3c
    bab6:	2500      	movs	r5, #0
    bab8:	e6a9      	b.n	b80e <_svfprintf_r+0x1e6>
    baba:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    babc:	9311      	str	r3, [sp, #68]	; 0x44
    babe:	6816      	ldr	r6, [r2, #0]
    bac0:	2400      	movs	r4, #0
    bac2:	f88d 407f 	strb.w	r4, [sp, #127]	; 0x7f
    bac6:	1d15      	adds	r5, r2, #4
    bac8:	2e00      	cmp	r6, #0
    baca:	f000 86b8 	beq.w	c83e <_svfprintf_r+0x1216>
    bace:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    bad0:	1c53      	adds	r3, r2, #1
    bad2:	f000 861a 	beq.w	c70a <_svfprintf_r+0x10e2>
    bad6:	4621      	mov	r1, r4
    bad8:	4630      	mov	r0, r6
    bada:	f7f4 fed1 	bl	880 <memchr>
    bade:	2800      	cmp	r0, #0
    bae0:	f000 870b 	beq.w	c8fa <_svfprintf_r+0x12d2>
    bae4:	1b83      	subs	r3, r0, r6
    bae6:	930e      	str	r3, [sp, #56]	; 0x38
    bae8:	940a      	str	r4, [sp, #40]	; 0x28
    baea:	950f      	str	r5, [sp, #60]	; 0x3c
    baec:	f8cd b01c 	str.w	fp, [sp, #28]
    baf0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    baf4:	9308      	str	r3, [sp, #32]
    baf6:	9412      	str	r4, [sp, #72]	; 0x48
    baf8:	f89d 707f 	ldrb.w	r7, [sp, #127]	; 0x7f
    bafc:	e6ac      	b.n	b858 <_svfprintf_r+0x230>
    bafe:	f89a 3000 	ldrb.w	r3, [sl]
    bb02:	2201      	movs	r2, #1
    bb04:	212b      	movs	r1, #43	; 0x2b
    bb06:	e5e7      	b.n	b6d8 <_svfprintf_r+0xb0>
    bb08:	f04b 0b20 	orr.w	fp, fp, #32
    bb0c:	f89a 3000 	ldrb.w	r3, [sl]
    bb10:	e5e2      	b.n	b6d8 <_svfprintf_r+0xb0>
    bb12:	9311      	str	r3, [sp, #68]	; 0x44
    bb14:	2a00      	cmp	r2, #0
    bb16:	f040 87ac 	bne.w	ca72 <_svfprintf_r+0x144a>
    bb1a:	4b23      	ldr	r3, [pc, #140]	; (bba8 <_svfprintf_r+0x580>)
    bb1c:	9316      	str	r3, [sp, #88]	; 0x58
    bb1e:	f01b 0f20 	tst.w	fp, #32
    bb22:	f040 8112 	bne.w	bd4a <_svfprintf_r+0x722>
    bb26:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    bb28:	f01b 0f10 	tst.w	fp, #16
    bb2c:	4613      	mov	r3, r2
    bb2e:	f040 83e0 	bne.w	c2f2 <_svfprintf_r+0xcca>
    bb32:	f01b 0f40 	tst.w	fp, #64	; 0x40
    bb36:	f000 83dc 	beq.w	c2f2 <_svfprintf_r+0xcca>
    bb3a:	3304      	adds	r3, #4
    bb3c:	8814      	ldrh	r4, [r2, #0]
    bb3e:	930f      	str	r3, [sp, #60]	; 0x3c
    bb40:	2500      	movs	r5, #0
    bb42:	f01b 0f01 	tst.w	fp, #1
    bb46:	f000 810d 	beq.w	bd64 <_svfprintf_r+0x73c>
    bb4a:	ea54 0305 	orrs.w	r3, r4, r5
    bb4e:	f000 8109 	beq.w	bd64 <_svfprintf_r+0x73c>
    bb52:	2330      	movs	r3, #48	; 0x30
    bb54:	f89d 2044 	ldrb.w	r2, [sp, #68]	; 0x44
    bb58:	f88d 3080 	strb.w	r3, [sp, #128]	; 0x80
    bb5c:	f88d 2081 	strb.w	r2, [sp, #129]	; 0x81
    bb60:	f04b 0b02 	orr.w	fp, fp, #2
    bb64:	2302      	movs	r3, #2
    bb66:	e652      	b.n	b80e <_svfprintf_r+0x1e6>
    bb68:	f89a 3000 	ldrb.w	r3, [sl]
    bb6c:	2900      	cmp	r1, #0
    bb6e:	f47f adb3 	bne.w	b6d8 <_svfprintf_r+0xb0>
    bb72:	2201      	movs	r2, #1
    bb74:	2120      	movs	r1, #32
    bb76:	e5af      	b.n	b6d8 <_svfprintf_r+0xb0>
    bb78:	f04b 0b01 	orr.w	fp, fp, #1
    bb7c:	f89a 3000 	ldrb.w	r3, [sl]
    bb80:	e5aa      	b.n	b6d8 <_svfprintf_r+0xb0>
    bb82:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    bb84:	6823      	ldr	r3, [r4, #0]
    bb86:	930d      	str	r3, [sp, #52]	; 0x34
    bb88:	4618      	mov	r0, r3
    bb8a:	2800      	cmp	r0, #0
    bb8c:	4623      	mov	r3, r4
    bb8e:	f103 0304 	add.w	r3, r3, #4
    bb92:	f6ff ae03 	blt.w	b79c <_svfprintf_r+0x174>
    bb96:	930f      	str	r3, [sp, #60]	; 0x3c
    bb98:	f89a 3000 	ldrb.w	r3, [sl]
    bb9c:	e59c      	b.n	b6d8 <_svfprintf_r+0xb0>
    bb9e:	bf00      	nop
    bba0:	00012a70 	.word	0x00012a70
    bba4:	00012a80 	.word	0x00012a80
    bba8:	00012a50 	.word	0x00012a50
    bbac:	f04b 0b10 	orr.w	fp, fp, #16
    bbb0:	f01b 0f20 	tst.w	fp, #32
    bbb4:	9311      	str	r3, [sp, #68]	; 0x44
    bbb6:	f43f ae1b 	beq.w	b7f0 <_svfprintf_r+0x1c8>
    bbba:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    bbbc:	3507      	adds	r5, #7
    bbbe:	f025 0307 	bic.w	r3, r5, #7
    bbc2:	f103 0208 	add.w	r2, r3, #8
    bbc6:	e9d3 4500 	ldrd	r4, r5, [r3]
    bbca:	920f      	str	r2, [sp, #60]	; 0x3c
    bbcc:	2301      	movs	r3, #1
    bbce:	e61e      	b.n	b80e <_svfprintf_r+0x1e6>
    bbd0:	f89a 3000 	ldrb.w	r3, [sl]
    bbd4:	2b2a      	cmp	r3, #42	; 0x2a
    bbd6:	f10a 0401 	add.w	r4, sl, #1
    bbda:	f000 873d 	beq.w	ca58 <_svfprintf_r+0x1430>
    bbde:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    bbe2:	2809      	cmp	r0, #9
    bbe4:	46a2      	mov	sl, r4
    bbe6:	f200 8694 	bhi.w	c912 <_svfprintf_r+0x12ea>
    bbea:	2300      	movs	r3, #0
    bbec:	461c      	mov	r4, r3
    bbee:	f81a 3b01 	ldrb.w	r3, [sl], #1
    bbf2:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    bbf6:	eb00 0444 	add.w	r4, r0, r4, lsl #1
    bbfa:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    bbfe:	2809      	cmp	r0, #9
    bc00:	d9f5      	bls.n	bbee <_svfprintf_r+0x5c6>
    bc02:	940a      	str	r4, [sp, #40]	; 0x28
    bc04:	e56a      	b.n	b6dc <_svfprintf_r+0xb4>
    bc06:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
    bc0a:	f89a 3000 	ldrb.w	r3, [sl]
    bc0e:	e563      	b.n	b6d8 <_svfprintf_r+0xb0>
    bc10:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
    bc14:	f89a 3000 	ldrb.w	r3, [sl]
    bc18:	e55e      	b.n	b6d8 <_svfprintf_r+0xb0>
    bc1a:	f89a 3000 	ldrb.w	r3, [sl]
    bc1e:	2b6c      	cmp	r3, #108	; 0x6c
    bc20:	bf03      	ittte	eq
    bc22:	f89a 3001 	ldrbeq.w	r3, [sl, #1]
    bc26:	f04b 0b20 	orreq.w	fp, fp, #32
    bc2a:	f10a 0a01 	addeq.w	sl, sl, #1
    bc2e:	f04b 0b10 	orrne.w	fp, fp, #16
    bc32:	e551      	b.n	b6d8 <_svfprintf_r+0xb0>
    bc34:	2a00      	cmp	r2, #0
    bc36:	f040 8720 	bne.w	ca7a <_svfprintf_r+0x1452>
    bc3a:	f01b 0f20 	tst.w	fp, #32
    bc3e:	f040 850a 	bne.w	c656 <_svfprintf_r+0x102e>
    bc42:	f01b 0f10 	tst.w	fp, #16
    bc46:	f040 84bd 	bne.w	c5c4 <_svfprintf_r+0xf9c>
    bc4a:	f01b 0f40 	tst.w	fp, #64	; 0x40
    bc4e:	f000 84b9 	beq.w	c5c4 <_svfprintf_r+0xf9c>
    bc52:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    bc54:	6813      	ldr	r3, [r2, #0]
    bc56:	3204      	adds	r2, #4
    bc58:	920f      	str	r2, [sp, #60]	; 0x3c
    bc5a:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    bc5e:	801a      	strh	r2, [r3, #0]
    bc60:	e509      	b.n	b676 <_svfprintf_r+0x4e>
    bc62:	990f      	ldr	r1, [sp, #60]	; 0x3c
    bc64:	4bb9      	ldr	r3, [pc, #740]	; (bf4c <_svfprintf_r+0x924>)
    bc66:	680c      	ldr	r4, [r1, #0]
    bc68:	9316      	str	r3, [sp, #88]	; 0x58
    bc6a:	2230      	movs	r2, #48	; 0x30
    bc6c:	2378      	movs	r3, #120	; 0x78
    bc6e:	3104      	adds	r1, #4
    bc70:	f88d 3081 	strb.w	r3, [sp, #129]	; 0x81
    bc74:	9311      	str	r3, [sp, #68]	; 0x44
    bc76:	f04b 0b02 	orr.w	fp, fp, #2
    bc7a:	910f      	str	r1, [sp, #60]	; 0x3c
    bc7c:	2500      	movs	r5, #0
    bc7e:	f88d 2080 	strb.w	r2, [sp, #128]	; 0x80
    bc82:	2302      	movs	r3, #2
    bc84:	e5c3      	b.n	b80e <_svfprintf_r+0x1e6>
    bc86:	990f      	ldr	r1, [sp, #60]	; 0x3c
    bc88:	9311      	str	r3, [sp, #68]	; 0x44
    bc8a:	680a      	ldr	r2, [r1, #0]
    bc8c:	f88d 20a8 	strb.w	r2, [sp, #168]	; 0xa8
    bc90:	2300      	movs	r3, #0
    bc92:	460a      	mov	r2, r1
    bc94:	461f      	mov	r7, r3
    bc96:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
    bc9a:	3204      	adds	r2, #4
    bc9c:	2301      	movs	r3, #1
    bc9e:	9308      	str	r3, [sp, #32]
    bca0:	f8cd b01c 	str.w	fp, [sp, #28]
    bca4:	970a      	str	r7, [sp, #40]	; 0x28
    bca6:	9712      	str	r7, [sp, #72]	; 0x48
    bca8:	920f      	str	r2, [sp, #60]	; 0x3c
    bcaa:	930e      	str	r3, [sp, #56]	; 0x38
    bcac:	ae2a      	add	r6, sp, #168	; 0xa8
    bcae:	e5d7      	b.n	b860 <_svfprintf_r+0x238>
    bcb0:	9311      	str	r3, [sp, #68]	; 0x44
    bcb2:	2a00      	cmp	r2, #0
    bcb4:	f040 8700 	bne.w	cab8 <_svfprintf_r+0x1490>
    bcb8:	f01b 0f20 	tst.w	fp, #32
    bcbc:	d15d      	bne.n	bd7a <_svfprintf_r+0x752>
    bcbe:	f01b 0f10 	tst.w	fp, #16
    bcc2:	f040 8335 	bne.w	c330 <_svfprintf_r+0xd08>
    bcc6:	f01b 0f40 	tst.w	fp, #64	; 0x40
    bcca:	f000 8331 	beq.w	c330 <_svfprintf_r+0xd08>
    bcce:	990f      	ldr	r1, [sp, #60]	; 0x3c
    bcd0:	f9b1 4000 	ldrsh.w	r4, [r1]
    bcd4:	3104      	adds	r1, #4
    bcd6:	17e5      	asrs	r5, r4, #31
    bcd8:	4622      	mov	r2, r4
    bcda:	462b      	mov	r3, r5
    bcdc:	910f      	str	r1, [sp, #60]	; 0x3c
    bcde:	2a00      	cmp	r2, #0
    bce0:	f173 0300 	sbcs.w	r3, r3, #0
    bce4:	db58      	blt.n	bd98 <_svfprintf_r+0x770>
    bce6:	990a      	ldr	r1, [sp, #40]	; 0x28
    bce8:	f89d 707f 	ldrb.w	r7, [sp, #127]	; 0x7f
    bcec:	1c4a      	adds	r2, r1, #1
    bcee:	f04f 0301 	mov.w	r3, #1
    bcf2:	f47f ad93 	bne.w	b81c <_svfprintf_r+0x1f4>
    bcf6:	ea54 0205 	orrs.w	r2, r4, r5
    bcfa:	f000 81ec 	beq.w	c0d6 <_svfprintf_r+0xaae>
    bcfe:	f8cd b01c 	str.w	fp, [sp, #28]
    bd02:	2b01      	cmp	r3, #1
    bd04:	f000 8283 	beq.w	c20e <_svfprintf_r+0xbe6>
    bd08:	2b02      	cmp	r3, #2
    bd0a:	f040 8213 	bne.w	c134 <_svfprintf_r+0xb0c>
    bd0e:	9816      	ldr	r0, [sp, #88]	; 0x58
    bd10:	464e      	mov	r6, r9
    bd12:	0923      	lsrs	r3, r4, #4
    bd14:	f004 010f 	and.w	r1, r4, #15
    bd18:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
    bd1c:	092a      	lsrs	r2, r5, #4
    bd1e:	461c      	mov	r4, r3
    bd20:	4615      	mov	r5, r2
    bd22:	5c43      	ldrb	r3, [r0, r1]
    bd24:	f806 3d01 	strb.w	r3, [r6, #-1]!
    bd28:	ea54 0305 	orrs.w	r3, r4, r5
    bd2c:	d1f1      	bne.n	bd12 <_svfprintf_r+0x6ea>
    bd2e:	eba9 0306 	sub.w	r3, r9, r6
    bd32:	930e      	str	r3, [sp, #56]	; 0x38
    bd34:	e588      	b.n	b848 <_svfprintf_r+0x220>
    bd36:	9311      	str	r3, [sp, #68]	; 0x44
    bd38:	2a00      	cmp	r2, #0
    bd3a:	f040 86b9 	bne.w	cab0 <_svfprintf_r+0x1488>
    bd3e:	4b84      	ldr	r3, [pc, #528]	; (bf50 <_svfprintf_r+0x928>)
    bd40:	9316      	str	r3, [sp, #88]	; 0x58
    bd42:	f01b 0f20 	tst.w	fp, #32
    bd46:	f43f aeee 	beq.w	bb26 <_svfprintf_r+0x4fe>
    bd4a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    bd4c:	3507      	adds	r5, #7
    bd4e:	f025 0307 	bic.w	r3, r5, #7
    bd52:	f103 0208 	add.w	r2, r3, #8
    bd56:	f01b 0f01 	tst.w	fp, #1
    bd5a:	920f      	str	r2, [sp, #60]	; 0x3c
    bd5c:	e9d3 4500 	ldrd	r4, r5, [r3]
    bd60:	f47f aef3 	bne.w	bb4a <_svfprintf_r+0x522>
    bd64:	2302      	movs	r3, #2
    bd66:	e552      	b.n	b80e <_svfprintf_r+0x1e6>
    bd68:	9311      	str	r3, [sp, #68]	; 0x44
    bd6a:	2a00      	cmp	r2, #0
    bd6c:	f040 869c 	bne.w	caa8 <_svfprintf_r+0x1480>
    bd70:	f04b 0b10 	orr.w	fp, fp, #16
    bd74:	f01b 0f20 	tst.w	fp, #32
    bd78:	d0a1      	beq.n	bcbe <_svfprintf_r+0x696>
    bd7a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    bd7c:	3507      	adds	r5, #7
    bd7e:	f025 0507 	bic.w	r5, r5, #7
    bd82:	e9d5 2300 	ldrd	r2, r3, [r5]
    bd86:	2a00      	cmp	r2, #0
    bd88:	f105 0108 	add.w	r1, r5, #8
    bd8c:	461d      	mov	r5, r3
    bd8e:	f173 0300 	sbcs.w	r3, r3, #0
    bd92:	910f      	str	r1, [sp, #60]	; 0x3c
    bd94:	4614      	mov	r4, r2
    bd96:	daa6      	bge.n	bce6 <_svfprintf_r+0x6be>
    bd98:	272d      	movs	r7, #45	; 0x2d
    bd9a:	4264      	negs	r4, r4
    bd9c:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
    bda0:	f88d 707f 	strb.w	r7, [sp, #127]	; 0x7f
    bda4:	2301      	movs	r3, #1
    bda6:	e535      	b.n	b814 <_svfprintf_r+0x1ec>
    bda8:	9311      	str	r3, [sp, #68]	; 0x44
    bdaa:	2a00      	cmp	r2, #0
    bdac:	f040 8678 	bne.w	caa0 <_svfprintf_r+0x1478>
    bdb0:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    bdb2:	f01b 0f08 	tst.w	fp, #8
    bdb6:	f105 0507 	add.w	r5, r5, #7
    bdba:	f000 83e9 	beq.w	c590 <_svfprintf_r+0xf68>
    bdbe:	f025 0307 	bic.w	r3, r5, #7
    bdc2:	ed93 7b00 	vldr	d7, [r3]
    bdc6:	ed8d 7b14 	vstr	d7, [sp, #80]	; 0x50
    bdca:	f103 0208 	add.w	r2, r3, #8
    bdce:	920f      	str	r2, [sp, #60]	; 0x3c
    bdd0:	e9dd 1214 	ldrd	r1, r2, [sp, #80]	; 0x50
    bdd4:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
    bdd8:	911a      	str	r1, [sp, #104]	; 0x68
    bdda:	931b      	str	r3, [sp, #108]	; 0x6c
    bddc:	e9dd 451a 	ldrd	r4, r5, [sp, #104]	; 0x68
    bde0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    bde4:	4620      	mov	r0, r4
    bde6:	4629      	mov	r1, r5
    bde8:	4b5a      	ldr	r3, [pc, #360]	; (bf54 <_svfprintf_r+0x92c>)
    bdea:	f7f5 fb09 	bl	1400 <__aeabi_dcmpun>
    bdee:	2800      	cmp	r0, #0
    bdf0:	f040 834f 	bne.w	c492 <_svfprintf_r+0xe6a>
    bdf4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    bdf8:	4b56      	ldr	r3, [pc, #344]	; (bf54 <_svfprintf_r+0x92c>)
    bdfa:	4620      	mov	r0, r4
    bdfc:	4629      	mov	r1, r5
    bdfe:	f7f5 fae1 	bl	13c4 <__aeabi_dcmple>
    be02:	2800      	cmp	r0, #0
    be04:	f040 8345 	bne.w	c492 <_svfprintf_r+0xe6a>
    be08:	2200      	movs	r2, #0
    be0a:	2300      	movs	r3, #0
    be0c:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
    be10:	f7f5 face 	bl	13b0 <__aeabi_dcmplt>
    be14:	2800      	cmp	r0, #0
    be16:	f040 8536 	bne.w	c886 <_svfprintf_r+0x125e>
    be1a:	f89d 707f 	ldrb.w	r7, [sp, #127]	; 0x7f
    be1e:	4e4e      	ldr	r6, [pc, #312]	; (bf58 <_svfprintf_r+0x930>)
    be20:	4b4e      	ldr	r3, [pc, #312]	; (bf5c <_svfprintf_r+0x934>)
    be22:	f02b 0080 	bic.w	r0, fp, #128	; 0x80
    be26:	9007      	str	r0, [sp, #28]
    be28:	9811      	ldr	r0, [sp, #68]	; 0x44
    be2a:	2203      	movs	r2, #3
    be2c:	2100      	movs	r1, #0
    be2e:	9208      	str	r2, [sp, #32]
    be30:	910a      	str	r1, [sp, #40]	; 0x28
    be32:	2847      	cmp	r0, #71	; 0x47
    be34:	bfd8      	it	le
    be36:	461e      	movle	r6, r3
    be38:	920e      	str	r2, [sp, #56]	; 0x38
    be3a:	9112      	str	r1, [sp, #72]	; 0x48
    be3c:	e50c      	b.n	b858 <_svfprintf_r+0x230>
    be3e:	f04b 0b08 	orr.w	fp, fp, #8
    be42:	f89a 3000 	ldrb.w	r3, [sl]
    be46:	e447      	b.n	b6d8 <_svfprintf_r+0xb0>
    be48:	f04b 0b10 	orr.w	fp, fp, #16
    be4c:	9311      	str	r3, [sp, #68]	; 0x44
    be4e:	f01b 0320 	ands.w	r3, fp, #32
    be52:	f43f ae22 	beq.w	ba9a <_svfprintf_r+0x472>
    be56:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    be58:	3507      	adds	r5, #7
    be5a:	f025 0307 	bic.w	r3, r5, #7
    be5e:	f103 0208 	add.w	r2, r3, #8
    be62:	e9d3 4500 	ldrd	r4, r5, [r3]
    be66:	920f      	str	r2, [sp, #60]	; 0x3c
    be68:	2300      	movs	r3, #0
    be6a:	e4d0      	b.n	b80e <_svfprintf_r+0x1e6>
    be6c:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    be70:	2300      	movs	r3, #0
    be72:	461c      	mov	r4, r3
    be74:	f81a 3b01 	ldrb.w	r3, [sl], #1
    be78:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    be7c:	eb00 0444 	add.w	r4, r0, r4, lsl #1
    be80:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    be84:	2809      	cmp	r0, #9
    be86:	d9f5      	bls.n	be74 <_svfprintf_r+0x84c>
    be88:	940d      	str	r4, [sp, #52]	; 0x34
    be8a:	e427      	b.n	b6dc <_svfprintf_r+0xb4>
    be8c:	9311      	str	r3, [sp, #68]	; 0x44
    be8e:	2a00      	cmp	r2, #0
    be90:	f040 85f7 	bne.w	ca82 <_svfprintf_r+0x145a>
    be94:	9a11      	ldr	r2, [sp, #68]	; 0x44
    be96:	2a00      	cmp	r2, #0
    be98:	f43f ac91 	beq.w	b7be <_svfprintf_r+0x196>
    be9c:	2300      	movs	r3, #0
    be9e:	2101      	movs	r1, #1
    bea0:	461f      	mov	r7, r3
    bea2:	9108      	str	r1, [sp, #32]
    bea4:	f88d 20a8 	strb.w	r2, [sp, #168]	; 0xa8
    bea8:	f8cd b01c 	str.w	fp, [sp, #28]
    beac:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
    beb0:	930a      	str	r3, [sp, #40]	; 0x28
    beb2:	9312      	str	r3, [sp, #72]	; 0x48
    beb4:	910e      	str	r1, [sp, #56]	; 0x38
    beb6:	ae2a      	add	r6, sp, #168	; 0xa8
    beb8:	e4d2      	b.n	b860 <_svfprintf_r+0x238>
    beba:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    bebc:	e529      	b.n	b912 <_svfprintf_r+0x2ea>
    bebe:	9b11      	ldr	r3, [sp, #68]	; 0x44
    bec0:	2b65      	cmp	r3, #101	; 0x65
    bec2:	f340 80a9 	ble.w	c018 <_svfprintf_r+0x9f0>
    bec6:	2200      	movs	r2, #0
    bec8:	2300      	movs	r3, #0
    beca:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
    bece:	f7f5 fa65 	bl	139c <__aeabi_dcmpeq>
    bed2:	2800      	cmp	r0, #0
    bed4:	f000 8152 	beq.w	c17c <_svfprintf_r+0xb54>
    bed8:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    beda:	4a21      	ldr	r2, [pc, #132]	; (bf60 <_svfprintf_r+0x938>)
    bedc:	f8c8 2000 	str.w	r2, [r8]
    bee0:	3301      	adds	r3, #1
    bee2:	3401      	adds	r4, #1
    bee4:	2201      	movs	r2, #1
    bee6:	2b07      	cmp	r3, #7
    bee8:	9429      	str	r4, [sp, #164]	; 0xa4
    beea:	9328      	str	r3, [sp, #160]	; 0xa0
    beec:	f8c8 2004 	str.w	r2, [r8, #4]
    bef0:	f300 8370 	bgt.w	c5d4 <_svfprintf_r+0xfac>
    bef4:	f108 0808 	add.w	r8, r8, #8
    bef8:	9b21      	ldr	r3, [sp, #132]	; 0x84
    befa:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    befc:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    befe:	4293      	cmp	r3, r2
    bf00:	db03      	blt.n	bf0a <_svfprintf_r+0x8e2>
    bf02:	9b07      	ldr	r3, [sp, #28]
    bf04:	07dd      	lsls	r5, r3, #31
    bf06:	f57f ad76 	bpl.w	b9f6 <_svfprintf_r+0x3ce>
    bf0a:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    bf0c:	9917      	ldr	r1, [sp, #92]	; 0x5c
    bf0e:	9a18      	ldr	r2, [sp, #96]	; 0x60
    bf10:	f8c8 2000 	str.w	r2, [r8]
    bf14:	3301      	adds	r3, #1
    bf16:	440c      	add	r4, r1
    bf18:	2b07      	cmp	r3, #7
    bf1a:	f8c8 1004 	str.w	r1, [r8, #4]
    bf1e:	9429      	str	r4, [sp, #164]	; 0xa4
    bf20:	9328      	str	r3, [sp, #160]	; 0xa0
    bf22:	f300 83a4 	bgt.w	c66e <_svfprintf_r+0x1046>
    bf26:	f108 0808 	add.w	r8, r8, #8
    bf2a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    bf2c:	1e5e      	subs	r6, r3, #1
    bf2e:	2e00      	cmp	r6, #0
    bf30:	f77f ad61 	ble.w	b9f6 <_svfprintf_r+0x3ce>
    bf34:	2e10      	cmp	r6, #16
    bf36:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    bf38:	4d0a      	ldr	r5, [pc, #40]	; (bf64 <_svfprintf_r+0x93c>)
    bf3a:	f340 81ef 	ble.w	c31c <_svfprintf_r+0xcf4>
    bf3e:	4622      	mov	r2, r4
    bf40:	2710      	movs	r7, #16
    bf42:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
    bf46:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    bf48:	e014      	b.n	bf74 <_svfprintf_r+0x94c>
    bf4a:	bf00      	nop
    bf4c:	00012a50 	.word	0x00012a50
    bf50:	00012a3c 	.word	0x00012a3c
    bf54:	7fefffff 	.word	0x7fefffff
    bf58:	00012a30 	.word	0x00012a30
    bf5c:	00012a2c 	.word	0x00012a2c
    bf60:	00012a6c 	.word	0x00012a6c
    bf64:	00012a80 	.word	0x00012a80
    bf68:	f108 0808 	add.w	r8, r8, #8
    bf6c:	3e10      	subs	r6, #16
    bf6e:	2e10      	cmp	r6, #16
    bf70:	f340 81d3 	ble.w	c31a <_svfprintf_r+0xcf2>
    bf74:	3301      	adds	r3, #1
    bf76:	3210      	adds	r2, #16
    bf78:	2b07      	cmp	r3, #7
    bf7a:	9229      	str	r2, [sp, #164]	; 0xa4
    bf7c:	9328      	str	r3, [sp, #160]	; 0xa0
    bf7e:	e888 00a0 	stmia.w	r8, {r5, r7}
    bf82:	ddf1      	ble.n	bf68 <_svfprintf_r+0x940>
    bf84:	aa27      	add	r2, sp, #156	; 0x9c
    bf86:	4621      	mov	r1, r4
    bf88:	4658      	mov	r0, fp
    bf8a:	f004 fc83 	bl	10894 <__ssprint_r>
    bf8e:	2800      	cmp	r0, #0
    bf90:	f47f ac1c 	bne.w	b7cc <_svfprintf_r+0x1a4>
    bf94:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    bf96:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    bf98:	46c8      	mov	r8, r9
    bf9a:	e7e7      	b.n	bf6c <_svfprintf_r+0x944>
    bf9c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    bf9e:	9a08      	ldr	r2, [sp, #32]
    bfa0:	1a9f      	subs	r7, r3, r2
    bfa2:	2f00      	cmp	r7, #0
    bfa4:	f77f acd8 	ble.w	b958 <_svfprintf_r+0x330>
    bfa8:	2f10      	cmp	r7, #16
    bfaa:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    bfac:	4db7      	ldr	r5, [pc, #732]	; (c28c <_svfprintf_r+0xc64>)
    bfae:	dd27      	ble.n	c000 <_svfprintf_r+0x9d8>
    bfb0:	4642      	mov	r2, r8
    bfb2:	4621      	mov	r1, r4
    bfb4:	46b0      	mov	r8, r6
    bfb6:	f04f 0b10 	mov.w	fp, #16
    bfba:	462e      	mov	r6, r5
    bfbc:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    bfbe:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    bfc0:	e004      	b.n	bfcc <_svfprintf_r+0x9a4>
    bfc2:	3f10      	subs	r7, #16
    bfc4:	2f10      	cmp	r7, #16
    bfc6:	f102 0208 	add.w	r2, r2, #8
    bfca:	dd15      	ble.n	bff8 <_svfprintf_r+0x9d0>
    bfcc:	3301      	adds	r3, #1
    bfce:	3110      	adds	r1, #16
    bfd0:	2b07      	cmp	r3, #7
    bfd2:	9129      	str	r1, [sp, #164]	; 0xa4
    bfd4:	9328      	str	r3, [sp, #160]	; 0xa0
    bfd6:	e882 0840 	stmia.w	r2, {r6, fp}
    bfda:	ddf2      	ble.n	bfc2 <_svfprintf_r+0x99a>
    bfdc:	aa27      	add	r2, sp, #156	; 0x9c
    bfde:	4629      	mov	r1, r5
    bfe0:	4620      	mov	r0, r4
    bfe2:	f004 fc57 	bl	10894 <__ssprint_r>
    bfe6:	2800      	cmp	r0, #0
    bfe8:	f47f abf0 	bne.w	b7cc <_svfprintf_r+0x1a4>
    bfec:	3f10      	subs	r7, #16
    bfee:	2f10      	cmp	r7, #16
    bff0:	9929      	ldr	r1, [sp, #164]	; 0xa4
    bff2:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    bff4:	464a      	mov	r2, r9
    bff6:	dce9      	bgt.n	bfcc <_svfprintf_r+0x9a4>
    bff8:	4635      	mov	r5, r6
    bffa:	460c      	mov	r4, r1
    bffc:	4646      	mov	r6, r8
    bffe:	4690      	mov	r8, r2
    c000:	3301      	adds	r3, #1
    c002:	443c      	add	r4, r7
    c004:	2b07      	cmp	r3, #7
    c006:	9429      	str	r4, [sp, #164]	; 0xa4
    c008:	9328      	str	r3, [sp, #160]	; 0xa0
    c00a:	e888 00a0 	stmia.w	r8, {r5, r7}
    c00e:	f300 8234 	bgt.w	c47a <_svfprintf_r+0xe52>
    c012:	f108 0808 	add.w	r8, r8, #8
    c016:	e49f      	b.n	b958 <_svfprintf_r+0x330>
    c018:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c01a:	9f28      	ldr	r7, [sp, #160]	; 0xa0
    c01c:	2b01      	cmp	r3, #1
    c01e:	f340 8200 	ble.w	c422 <_svfprintf_r+0xdfa>
    c022:	3701      	adds	r7, #1
    c024:	3401      	adds	r4, #1
    c026:	2301      	movs	r3, #1
    c028:	2f07      	cmp	r7, #7
    c02a:	9429      	str	r4, [sp, #164]	; 0xa4
    c02c:	9728      	str	r7, [sp, #160]	; 0xa0
    c02e:	f8c8 6000 	str.w	r6, [r8]
    c032:	f8c8 3004 	str.w	r3, [r8, #4]
    c036:	f300 8205 	bgt.w	c444 <_svfprintf_r+0xe1c>
    c03a:	f108 0808 	add.w	r8, r8, #8
    c03e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    c040:	9b18      	ldr	r3, [sp, #96]	; 0x60
    c042:	f8c8 3000 	str.w	r3, [r8]
    c046:	3701      	adds	r7, #1
    c048:	4414      	add	r4, r2
    c04a:	2f07      	cmp	r7, #7
    c04c:	9429      	str	r4, [sp, #164]	; 0xa4
    c04e:	9728      	str	r7, [sp, #160]	; 0xa0
    c050:	f8c8 2004 	str.w	r2, [r8, #4]
    c054:	f300 8202 	bgt.w	c45c <_svfprintf_r+0xe34>
    c058:	f108 0808 	add.w	r8, r8, #8
    c05c:	2300      	movs	r3, #0
    c05e:	2200      	movs	r2, #0
    c060:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
    c064:	f7f5 f99a 	bl	139c <__aeabi_dcmpeq>
    c068:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c06a:	2800      	cmp	r0, #0
    c06c:	f040 8101 	bne.w	c272 <_svfprintf_r+0xc4a>
    c070:	3b01      	subs	r3, #1
    c072:	3701      	adds	r7, #1
    c074:	3601      	adds	r6, #1
    c076:	441c      	add	r4, r3
    c078:	2f07      	cmp	r7, #7
    c07a:	9728      	str	r7, [sp, #160]	; 0xa0
    c07c:	9429      	str	r4, [sp, #164]	; 0xa4
    c07e:	f8c8 6000 	str.w	r6, [r8]
    c082:	f8c8 3004 	str.w	r3, [r8, #4]
    c086:	f300 8128 	bgt.w	c2da <_svfprintf_r+0xcb2>
    c08a:	f108 0808 	add.w	r8, r8, #8
    c08e:	9a19      	ldr	r2, [sp, #100]	; 0x64
    c090:	f8c8 2004 	str.w	r2, [r8, #4]
    c094:	3701      	adds	r7, #1
    c096:	4414      	add	r4, r2
    c098:	ab23      	add	r3, sp, #140	; 0x8c
    c09a:	2f07      	cmp	r7, #7
    c09c:	9429      	str	r4, [sp, #164]	; 0xa4
    c09e:	9728      	str	r7, [sp, #160]	; 0xa0
    c0a0:	f8c8 3000 	str.w	r3, [r8]
    c0a4:	f77f aca5 	ble.w	b9f2 <_svfprintf_r+0x3ca>
    c0a8:	aa27      	add	r2, sp, #156	; 0x9c
    c0aa:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c0ac:	980c      	ldr	r0, [sp, #48]	; 0x30
    c0ae:	f004 fbf1 	bl	10894 <__ssprint_r>
    c0b2:	2800      	cmp	r0, #0
    c0b4:	f47f ab8a 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c0b8:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c0ba:	46c8      	mov	r8, r9
    c0bc:	e49b      	b.n	b9f6 <_svfprintf_r+0x3ce>
    c0be:	aa27      	add	r2, sp, #156	; 0x9c
    c0c0:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c0c2:	980c      	ldr	r0, [sp, #48]	; 0x30
    c0c4:	f004 fbe6 	bl	10894 <__ssprint_r>
    c0c8:	2800      	cmp	r0, #0
    c0ca:	f43f acdd 	beq.w	ba88 <_svfprintf_r+0x460>
    c0ce:	f7ff bb7d 	b.w	b7cc <_svfprintf_r+0x1a4>
    c0d2:	f8dd b01c 	ldr.w	fp, [sp, #28]
    c0d6:	2b01      	cmp	r3, #1
    c0d8:	f000 8135 	beq.w	c346 <_svfprintf_r+0xd1e>
    c0dc:	2b02      	cmp	r3, #2
    c0de:	d125      	bne.n	c12c <_svfprintf_r+0xb04>
    c0e0:	f8cd b01c 	str.w	fp, [sp, #28]
    c0e4:	2400      	movs	r4, #0
    c0e6:	2500      	movs	r5, #0
    c0e8:	e611      	b.n	bd0e <_svfprintf_r+0x6e6>
    c0ea:	aa27      	add	r2, sp, #156	; 0x9c
    c0ec:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c0ee:	980c      	ldr	r0, [sp, #48]	; 0x30
    c0f0:	f004 fbd0 	bl	10894 <__ssprint_r>
    c0f4:	2800      	cmp	r0, #0
    c0f6:	f47f ab69 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c0fa:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c0fc:	46c8      	mov	r8, r9
    c0fe:	e467      	b.n	b9d0 <_svfprintf_r+0x3a8>
    c100:	aa27      	add	r2, sp, #156	; 0x9c
    c102:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c104:	980c      	ldr	r0, [sp, #48]	; 0x30
    c106:	f004 fbc5 	bl	10894 <__ssprint_r>
    c10a:	2800      	cmp	r0, #0
    c10c:	f47f ab5e 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c110:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c112:	46c8      	mov	r8, r9
    c114:	e41d      	b.n	b952 <_svfprintf_r+0x32a>
    c116:	aa27      	add	r2, sp, #156	; 0x9c
    c118:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c11a:	980c      	ldr	r0, [sp, #48]	; 0x30
    c11c:	f004 fbba 	bl	10894 <__ssprint_r>
    c120:	2800      	cmp	r0, #0
    c122:	f47f ab53 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c126:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c128:	46c8      	mov	r8, r9
    c12a:	e402      	b.n	b932 <_svfprintf_r+0x30a>
    c12c:	f8cd b01c 	str.w	fp, [sp, #28]
    c130:	2400      	movs	r4, #0
    c132:	2500      	movs	r5, #0
    c134:	4649      	mov	r1, r9
    c136:	e000      	b.n	c13a <_svfprintf_r+0xb12>
    c138:	4631      	mov	r1, r6
    c13a:	08e2      	lsrs	r2, r4, #3
    c13c:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
    c140:	08e8      	lsrs	r0, r5, #3
    c142:	f004 0307 	and.w	r3, r4, #7
    c146:	4605      	mov	r5, r0
    c148:	4614      	mov	r4, r2
    c14a:	3330      	adds	r3, #48	; 0x30
    c14c:	ea54 0205 	orrs.w	r2, r4, r5
    c150:	f801 3c01 	strb.w	r3, [r1, #-1]
    c154:	f101 36ff 	add.w	r6, r1, #4294967295	; 0xffffffff
    c158:	d1ee      	bne.n	c138 <_svfprintf_r+0xb10>
    c15a:	9a07      	ldr	r2, [sp, #28]
    c15c:	07d2      	lsls	r2, r2, #31
    c15e:	f57f ade6 	bpl.w	bd2e <_svfprintf_r+0x706>
    c162:	2b30      	cmp	r3, #48	; 0x30
    c164:	f43f ade3 	beq.w	bd2e <_svfprintf_r+0x706>
    c168:	3902      	subs	r1, #2
    c16a:	2330      	movs	r3, #48	; 0x30
    c16c:	f806 3c01 	strb.w	r3, [r6, #-1]
    c170:	eba9 0301 	sub.w	r3, r9, r1
    c174:	930e      	str	r3, [sp, #56]	; 0x38
    c176:	460e      	mov	r6, r1
    c178:	f7ff bb66 	b.w	b848 <_svfprintf_r+0x220>
    c17c:	9921      	ldr	r1, [sp, #132]	; 0x84
    c17e:	2900      	cmp	r1, #0
    c180:	f340 8232 	ble.w	c5e8 <_svfprintf_r+0xfc0>
    c184:	9b12      	ldr	r3, [sp, #72]	; 0x48
    c186:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    c188:	4293      	cmp	r3, r2
    c18a:	bfa8      	it	ge
    c18c:	4613      	movge	r3, r2
    c18e:	2b00      	cmp	r3, #0
    c190:	461f      	mov	r7, r3
    c192:	dd0d      	ble.n	c1b0 <_svfprintf_r+0xb88>
    c194:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c196:	f8c8 6000 	str.w	r6, [r8]
    c19a:	3301      	adds	r3, #1
    c19c:	443c      	add	r4, r7
    c19e:	2b07      	cmp	r3, #7
    c1a0:	9429      	str	r4, [sp, #164]	; 0xa4
    c1a2:	f8c8 7004 	str.w	r7, [r8, #4]
    c1a6:	9328      	str	r3, [sp, #160]	; 0xa0
    c1a8:	f300 8324 	bgt.w	c7f4 <_svfprintf_r+0x11cc>
    c1ac:	f108 0808 	add.w	r8, r8, #8
    c1b0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    c1b2:	2f00      	cmp	r7, #0
    c1b4:	bfa8      	it	ge
    c1b6:	1bdb      	subge	r3, r3, r7
    c1b8:	2b00      	cmp	r3, #0
    c1ba:	461f      	mov	r7, r3
    c1bc:	f340 80d7 	ble.w	c36e <_svfprintf_r+0xd46>
    c1c0:	2f10      	cmp	r7, #16
    c1c2:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c1c4:	4d31      	ldr	r5, [pc, #196]	; (c28c <_svfprintf_r+0xc64>)
    c1c6:	f340 81f1 	ble.w	c5ac <_svfprintf_r+0xf84>
    c1ca:	4642      	mov	r2, r8
    c1cc:	4621      	mov	r1, r4
    c1ce:	46b0      	mov	r8, r6
    c1d0:	f04f 0b10 	mov.w	fp, #16
    c1d4:	462e      	mov	r6, r5
    c1d6:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    c1d8:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    c1da:	e004      	b.n	c1e6 <_svfprintf_r+0xbbe>
    c1dc:	3208      	adds	r2, #8
    c1de:	3f10      	subs	r7, #16
    c1e0:	2f10      	cmp	r7, #16
    c1e2:	f340 81df 	ble.w	c5a4 <_svfprintf_r+0xf7c>
    c1e6:	3301      	adds	r3, #1
    c1e8:	3110      	adds	r1, #16
    c1ea:	2b07      	cmp	r3, #7
    c1ec:	9129      	str	r1, [sp, #164]	; 0xa4
    c1ee:	9328      	str	r3, [sp, #160]	; 0xa0
    c1f0:	e882 0840 	stmia.w	r2, {r6, fp}
    c1f4:	ddf2      	ble.n	c1dc <_svfprintf_r+0xbb4>
    c1f6:	aa27      	add	r2, sp, #156	; 0x9c
    c1f8:	4629      	mov	r1, r5
    c1fa:	4620      	mov	r0, r4
    c1fc:	f004 fb4a 	bl	10894 <__ssprint_r>
    c200:	2800      	cmp	r0, #0
    c202:	f47f aae3 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c206:	9929      	ldr	r1, [sp, #164]	; 0xa4
    c208:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c20a:	464a      	mov	r2, r9
    c20c:	e7e7      	b.n	c1de <_svfprintf_r+0xbb6>
    c20e:	2d00      	cmp	r5, #0
    c210:	bf08      	it	eq
    c212:	2c0a      	cmpeq	r4, #10
    c214:	f0c0 8095 	bcc.w	c342 <_svfprintf_r+0xd1a>
    c218:	464e      	mov	r6, r9
    c21a:	4620      	mov	r0, r4
    c21c:	4629      	mov	r1, r5
    c21e:	220a      	movs	r2, #10
    c220:	2300      	movs	r3, #0
    c222:	f7f5 f92b 	bl	147c <__aeabi_uldivmod>
    c226:	3230      	adds	r2, #48	; 0x30
    c228:	f806 2d01 	strb.w	r2, [r6, #-1]!
    c22c:	4620      	mov	r0, r4
    c22e:	4629      	mov	r1, r5
    c230:	2300      	movs	r3, #0
    c232:	220a      	movs	r2, #10
    c234:	f7f5 f922 	bl	147c <__aeabi_uldivmod>
    c238:	4604      	mov	r4, r0
    c23a:	460d      	mov	r5, r1
    c23c:	ea54 0305 	orrs.w	r3, r4, r5
    c240:	d1eb      	bne.n	c21a <_svfprintf_r+0xbf2>
    c242:	eba9 0306 	sub.w	r3, r9, r6
    c246:	930e      	str	r3, [sp, #56]	; 0x38
    c248:	f7ff bafe 	b.w	b848 <_svfprintf_r+0x220>
    c24c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c24e:	930e      	str	r3, [sp, #56]	; 0x38
    c250:	464e      	mov	r6, r9
    c252:	f7ff baf9 	b.w	b848 <_svfprintf_r+0x220>
    c256:	aa27      	add	r2, sp, #156	; 0x9c
    c258:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c25a:	980c      	ldr	r0, [sp, #48]	; 0x30
    c25c:	f004 fb1a 	bl	10894 <__ssprint_r>
    c260:	2800      	cmp	r0, #0
    c262:	f47f aab3 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c266:	f89d 707f 	ldrb.w	r7, [sp, #127]	; 0x7f
    c26a:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c26c:	46c8      	mov	r8, r9
    c26e:	f7ff bb50 	b.w	b912 <_svfprintf_r+0x2ea>
    c272:	1e5e      	subs	r6, r3, #1
    c274:	2e00      	cmp	r6, #0
    c276:	f77f af0a 	ble.w	c08e <_svfprintf_r+0xa66>
    c27a:	2e10      	cmp	r6, #16
    c27c:	4d03      	ldr	r5, [pc, #12]	; (c28c <_svfprintf_r+0xc64>)
    c27e:	dd23      	ble.n	c2c8 <_svfprintf_r+0xca0>
    c280:	4622      	mov	r2, r4
    c282:	f04f 0b10 	mov.w	fp, #16
    c286:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    c288:	e007      	b.n	c29a <_svfprintf_r+0xc72>
    c28a:	bf00      	nop
    c28c:	00012a80 	.word	0x00012a80
    c290:	3e10      	subs	r6, #16
    c292:	2e10      	cmp	r6, #16
    c294:	f108 0808 	add.w	r8, r8, #8
    c298:	dd15      	ble.n	c2c6 <_svfprintf_r+0xc9e>
    c29a:	3701      	adds	r7, #1
    c29c:	3210      	adds	r2, #16
    c29e:	2f07      	cmp	r7, #7
    c2a0:	9229      	str	r2, [sp, #164]	; 0xa4
    c2a2:	9728      	str	r7, [sp, #160]	; 0xa0
    c2a4:	e888 0820 	stmia.w	r8, {r5, fp}
    c2a8:	ddf2      	ble.n	c290 <_svfprintf_r+0xc68>
    c2aa:	aa27      	add	r2, sp, #156	; 0x9c
    c2ac:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c2ae:	4620      	mov	r0, r4
    c2b0:	f004 faf0 	bl	10894 <__ssprint_r>
    c2b4:	2800      	cmp	r0, #0
    c2b6:	f47f aa89 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c2ba:	3e10      	subs	r6, #16
    c2bc:	2e10      	cmp	r6, #16
    c2be:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    c2c0:	9f28      	ldr	r7, [sp, #160]	; 0xa0
    c2c2:	46c8      	mov	r8, r9
    c2c4:	dce9      	bgt.n	c29a <_svfprintf_r+0xc72>
    c2c6:	4614      	mov	r4, r2
    c2c8:	3701      	adds	r7, #1
    c2ca:	4434      	add	r4, r6
    c2cc:	2f07      	cmp	r7, #7
    c2ce:	9429      	str	r4, [sp, #164]	; 0xa4
    c2d0:	9728      	str	r7, [sp, #160]	; 0xa0
    c2d2:	e888 0060 	stmia.w	r8, {r5, r6}
    c2d6:	f77f aed8 	ble.w	c08a <_svfprintf_r+0xa62>
    c2da:	aa27      	add	r2, sp, #156	; 0x9c
    c2dc:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c2de:	980c      	ldr	r0, [sp, #48]	; 0x30
    c2e0:	f004 fad8 	bl	10894 <__ssprint_r>
    c2e4:	2800      	cmp	r0, #0
    c2e6:	f47f aa71 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c2ea:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c2ec:	9f28      	ldr	r7, [sp, #160]	; 0xa0
    c2ee:	46c8      	mov	r8, r9
    c2f0:	e6cd      	b.n	c08e <_svfprintf_r+0xa66>
    c2f2:	681c      	ldr	r4, [r3, #0]
    c2f4:	3304      	adds	r3, #4
    c2f6:	930f      	str	r3, [sp, #60]	; 0x3c
    c2f8:	2500      	movs	r5, #0
    c2fa:	e422      	b.n	bb42 <_svfprintf_r+0x51a>
    c2fc:	990f      	ldr	r1, [sp, #60]	; 0x3c
    c2fe:	460a      	mov	r2, r1
    c300:	3204      	adds	r2, #4
    c302:	680c      	ldr	r4, [r1, #0]
    c304:	920f      	str	r2, [sp, #60]	; 0x3c
    c306:	2500      	movs	r5, #0
    c308:	f7ff ba81 	b.w	b80e <_svfprintf_r+0x1e6>
    c30c:	3204      	adds	r2, #4
    c30e:	681c      	ldr	r4, [r3, #0]
    c310:	920f      	str	r2, [sp, #60]	; 0x3c
    c312:	2301      	movs	r3, #1
    c314:	2500      	movs	r5, #0
    c316:	f7ff ba7a 	b.w	b80e <_svfprintf_r+0x1e6>
    c31a:	4614      	mov	r4, r2
    c31c:	3301      	adds	r3, #1
    c31e:	4434      	add	r4, r6
    c320:	2b07      	cmp	r3, #7
    c322:	9429      	str	r4, [sp, #164]	; 0xa4
    c324:	9328      	str	r3, [sp, #160]	; 0xa0
    c326:	e888 0060 	stmia.w	r8, {r5, r6}
    c32a:	f77f ab62 	ble.w	b9f2 <_svfprintf_r+0x3ca>
    c32e:	e6bb      	b.n	c0a8 <_svfprintf_r+0xa80>
    c330:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    c332:	6814      	ldr	r4, [r2, #0]
    c334:	4613      	mov	r3, r2
    c336:	3304      	adds	r3, #4
    c338:	17e5      	asrs	r5, r4, #31
    c33a:	930f      	str	r3, [sp, #60]	; 0x3c
    c33c:	4622      	mov	r2, r4
    c33e:	462b      	mov	r3, r5
    c340:	e4cd      	b.n	bcde <_svfprintf_r+0x6b6>
    c342:	f8dd b01c 	ldr.w	fp, [sp, #28]
    c346:	f8cd b01c 	str.w	fp, [sp, #28]
    c34a:	ae44      	add	r6, sp, #272	; 0x110
    c34c:	3430      	adds	r4, #48	; 0x30
    c34e:	2301      	movs	r3, #1
    c350:	f806 4d41 	strb.w	r4, [r6, #-65]!
    c354:	930e      	str	r3, [sp, #56]	; 0x38
    c356:	f7ff ba77 	b.w	b848 <_svfprintf_r+0x220>
    c35a:	aa27      	add	r2, sp, #156	; 0x9c
    c35c:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c35e:	980c      	ldr	r0, [sp, #48]	; 0x30
    c360:	f004 fa98 	bl	10894 <__ssprint_r>
    c364:	2800      	cmp	r0, #0
    c366:	f47f aa31 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c36a:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c36c:	46c8      	mov	r8, r9
    c36e:	9a21      	ldr	r2, [sp, #132]	; 0x84
    c370:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c372:	429a      	cmp	r2, r3
    c374:	db44      	blt.n	c400 <_svfprintf_r+0xdd8>
    c376:	9b07      	ldr	r3, [sp, #28]
    c378:	07d9      	lsls	r1, r3, #31
    c37a:	d441      	bmi.n	c400 <_svfprintf_r+0xdd8>
    c37c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c37e:	9812      	ldr	r0, [sp, #72]	; 0x48
    c380:	1a9a      	subs	r2, r3, r2
    c382:	1a1d      	subs	r5, r3, r0
    c384:	4295      	cmp	r5, r2
    c386:	bfa8      	it	ge
    c388:	4615      	movge	r5, r2
    c38a:	2d00      	cmp	r5, #0
    c38c:	dd0e      	ble.n	c3ac <_svfprintf_r+0xd84>
    c38e:	9928      	ldr	r1, [sp, #160]	; 0xa0
    c390:	f8c8 5004 	str.w	r5, [r8, #4]
    c394:	3101      	adds	r1, #1
    c396:	4406      	add	r6, r0
    c398:	442c      	add	r4, r5
    c39a:	2907      	cmp	r1, #7
    c39c:	f8c8 6000 	str.w	r6, [r8]
    c3a0:	9429      	str	r4, [sp, #164]	; 0xa4
    c3a2:	9128      	str	r1, [sp, #160]	; 0xa0
    c3a4:	f300 823d 	bgt.w	c822 <_svfprintf_r+0x11fa>
    c3a8:	f108 0808 	add.w	r8, r8, #8
    c3ac:	2d00      	cmp	r5, #0
    c3ae:	bfac      	ite	ge
    c3b0:	1b56      	subge	r6, r2, r5
    c3b2:	4616      	movlt	r6, r2
    c3b4:	2e00      	cmp	r6, #0
    c3b6:	f77f ab1e 	ble.w	b9f6 <_svfprintf_r+0x3ce>
    c3ba:	2e10      	cmp	r6, #16
    c3bc:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c3be:	4db1      	ldr	r5, [pc, #708]	; (c684 <_svfprintf_r+0x105c>)
    c3c0:	ddac      	ble.n	c31c <_svfprintf_r+0xcf4>
    c3c2:	4622      	mov	r2, r4
    c3c4:	2710      	movs	r7, #16
    c3c6:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
    c3ca:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    c3cc:	e004      	b.n	c3d8 <_svfprintf_r+0xdb0>
    c3ce:	f108 0808 	add.w	r8, r8, #8
    c3d2:	3e10      	subs	r6, #16
    c3d4:	2e10      	cmp	r6, #16
    c3d6:	dda0      	ble.n	c31a <_svfprintf_r+0xcf2>
    c3d8:	3301      	adds	r3, #1
    c3da:	3210      	adds	r2, #16
    c3dc:	2b07      	cmp	r3, #7
    c3de:	9229      	str	r2, [sp, #164]	; 0xa4
    c3e0:	9328      	str	r3, [sp, #160]	; 0xa0
    c3e2:	e888 00a0 	stmia.w	r8, {r5, r7}
    c3e6:	ddf2      	ble.n	c3ce <_svfprintf_r+0xda6>
    c3e8:	aa27      	add	r2, sp, #156	; 0x9c
    c3ea:	4621      	mov	r1, r4
    c3ec:	4658      	mov	r0, fp
    c3ee:	f004 fa51 	bl	10894 <__ssprint_r>
    c3f2:	2800      	cmp	r0, #0
    c3f4:	f47f a9ea 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c3f8:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    c3fa:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c3fc:	46c8      	mov	r8, r9
    c3fe:	e7e8      	b.n	c3d2 <_svfprintf_r+0xdaa>
    c400:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c402:	9817      	ldr	r0, [sp, #92]	; 0x5c
    c404:	9918      	ldr	r1, [sp, #96]	; 0x60
    c406:	f8c8 1000 	str.w	r1, [r8]
    c40a:	3301      	adds	r3, #1
    c40c:	4404      	add	r4, r0
    c40e:	2b07      	cmp	r3, #7
    c410:	9429      	str	r4, [sp, #164]	; 0xa4
    c412:	f8c8 0004 	str.w	r0, [r8, #4]
    c416:	9328      	str	r3, [sp, #160]	; 0xa0
    c418:	f300 81f7 	bgt.w	c80a <_svfprintf_r+0x11e2>
    c41c:	f108 0808 	add.w	r8, r8, #8
    c420:	e7ac      	b.n	c37c <_svfprintf_r+0xd54>
    c422:	9b07      	ldr	r3, [sp, #28]
    c424:	07da      	lsls	r2, r3, #31
    c426:	f53f adfc 	bmi.w	c022 <_svfprintf_r+0x9fa>
    c42a:	3701      	adds	r7, #1
    c42c:	3401      	adds	r4, #1
    c42e:	2301      	movs	r3, #1
    c430:	2f07      	cmp	r7, #7
    c432:	9429      	str	r4, [sp, #164]	; 0xa4
    c434:	9728      	str	r7, [sp, #160]	; 0xa0
    c436:	f8c8 6000 	str.w	r6, [r8]
    c43a:	f8c8 3004 	str.w	r3, [r8, #4]
    c43e:	f77f ae24 	ble.w	c08a <_svfprintf_r+0xa62>
    c442:	e74a      	b.n	c2da <_svfprintf_r+0xcb2>
    c444:	aa27      	add	r2, sp, #156	; 0x9c
    c446:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c448:	980c      	ldr	r0, [sp, #48]	; 0x30
    c44a:	f004 fa23 	bl	10894 <__ssprint_r>
    c44e:	2800      	cmp	r0, #0
    c450:	f47f a9bc 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c454:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c456:	9f28      	ldr	r7, [sp, #160]	; 0xa0
    c458:	46c8      	mov	r8, r9
    c45a:	e5f0      	b.n	c03e <_svfprintf_r+0xa16>
    c45c:	aa27      	add	r2, sp, #156	; 0x9c
    c45e:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c460:	980c      	ldr	r0, [sp, #48]	; 0x30
    c462:	f004 fa17 	bl	10894 <__ssprint_r>
    c466:	2800      	cmp	r0, #0
    c468:	f47f a9b0 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c46c:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c46e:	9f28      	ldr	r7, [sp, #160]	; 0xa0
    c470:	46c8      	mov	r8, r9
    c472:	e5f3      	b.n	c05c <_svfprintf_r+0xa34>
    c474:	464e      	mov	r6, r9
    c476:	f7ff b9e7 	b.w	b848 <_svfprintf_r+0x220>
    c47a:	aa27      	add	r2, sp, #156	; 0x9c
    c47c:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c47e:	980c      	ldr	r0, [sp, #48]	; 0x30
    c480:	f004 fa08 	bl	10894 <__ssprint_r>
    c484:	2800      	cmp	r0, #0
    c486:	f47f a9a1 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c48a:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c48c:	46c8      	mov	r8, r9
    c48e:	f7ff ba63 	b.w	b958 <_svfprintf_r+0x330>
    c492:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
    c496:	4602      	mov	r2, r0
    c498:	460b      	mov	r3, r1
    c49a:	f7f4 ffb1 	bl	1400 <__aeabi_dcmpun>
    c49e:	2800      	cmp	r0, #0
    c4a0:	f040 829b 	bne.w	c9da <_svfprintf_r+0x13b2>
    c4a4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c4a6:	3301      	adds	r3, #1
    c4a8:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c4aa:	f023 0720 	bic.w	r7, r3, #32
    c4ae:	f000 81d5 	beq.w	c85c <_svfprintf_r+0x1234>
    c4b2:	2f47      	cmp	r7, #71	; 0x47
    c4b4:	f000 8123 	beq.w	c6fe <_svfprintf_r+0x10d6>
    c4b8:	9b15      	ldr	r3, [sp, #84]	; 0x54
    c4ba:	f44b 7280 	orr.w	r2, fp, #256	; 0x100
    c4be:	2b00      	cmp	r3, #0
    c4c0:	9207      	str	r2, [sp, #28]
    c4c2:	f2c0 81f3 	blt.w	c8ac <_svfprintf_r+0x1284>
    c4c6:	ed9d 7b14 	vldr	d7, [sp, #80]	; 0x50
    c4ca:	ed8d 7b1c 	vstr	d7, [sp, #112]	; 0x70
    c4ce:	2300      	movs	r3, #0
    c4d0:	9310      	str	r3, [sp, #64]	; 0x40
    c4d2:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c4d4:	2b66      	cmp	r3, #102	; 0x66
    c4d6:	f000 81c4 	beq.w	c862 <_svfprintf_r+0x123a>
    c4da:	2b46      	cmp	r3, #70	; 0x46
    c4dc:	f000 80f1 	beq.w	c6c2 <_svfprintf_r+0x109a>
    c4e0:	2f45      	cmp	r7, #69	; 0x45
    c4e2:	bf0a      	itet	eq
    c4e4:	9b0a      	ldreq	r3, [sp, #40]	; 0x28
    c4e6:	9d0a      	ldrne	r5, [sp, #40]	; 0x28
    c4e8:	1c5d      	addeq	r5, r3, #1
    c4ea:	a825      	add	r0, sp, #148	; 0x94
    c4ec:	a922      	add	r1, sp, #136	; 0x88
    c4ee:	aa21      	add	r2, sp, #132	; 0x84
    c4f0:	2302      	movs	r3, #2
    c4f2:	9004      	str	r0, [sp, #16]
    c4f4:	9202      	str	r2, [sp, #8]
    c4f6:	9300      	str	r3, [sp, #0]
    c4f8:	9501      	str	r5, [sp, #4]
    c4fa:	e9dd 231c 	ldrd	r2, r3, [sp, #112]	; 0x70
    c4fe:	9103      	str	r1, [sp, #12]
    c500:	980c      	ldr	r0, [sp, #48]	; 0x30
    c502:	f002 fe95 	bl	f230 <_dtoa_r>
    c506:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c508:	2b67      	cmp	r3, #103	; 0x67
    c50a:	4606      	mov	r6, r0
    c50c:	f040 81d7 	bne.w	c8be <_svfprintf_r+0x1296>
    c510:	f01b 0f01 	tst.w	fp, #1
    c514:	f000 8250 	beq.w	c9b8 <_svfprintf_r+0x1390>
    c518:	1974      	adds	r4, r6, r5
    c51a:	2200      	movs	r2, #0
    c51c:	2300      	movs	r3, #0
    c51e:	e9dd 011c 	ldrd	r0, r1, [sp, #112]	; 0x70
    c522:	f7f4 ff3b 	bl	139c <__aeabi_dcmpeq>
    c526:	2800      	cmp	r0, #0
    c528:	f040 8162 	bne.w	c7f0 <_svfprintf_r+0x11c8>
    c52c:	9b25      	ldr	r3, [sp, #148]	; 0x94
    c52e:	42a3      	cmp	r3, r4
    c530:	d206      	bcs.n	c540 <_svfprintf_r+0xf18>
    c532:	2130      	movs	r1, #48	; 0x30
    c534:	1c5a      	adds	r2, r3, #1
    c536:	9225      	str	r2, [sp, #148]	; 0x94
    c538:	7019      	strb	r1, [r3, #0]
    c53a:	9b25      	ldr	r3, [sp, #148]	; 0x94
    c53c:	429c      	cmp	r4, r3
    c53e:	d8f9      	bhi.n	c534 <_svfprintf_r+0xf0c>
    c540:	1b9b      	subs	r3, r3, r6
    c542:	2f47      	cmp	r7, #71	; 0x47
    c544:	9313      	str	r3, [sp, #76]	; 0x4c
    c546:	f000 80f2 	beq.w	c72e <_svfprintf_r+0x1106>
    c54a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c54c:	2b65      	cmp	r3, #101	; 0x65
    c54e:	f340 81c5 	ble.w	c8dc <_svfprintf_r+0x12b4>
    c552:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c554:	2b66      	cmp	r3, #102	; 0x66
    c556:	9b21      	ldr	r3, [sp, #132]	; 0x84
    c558:	9312      	str	r3, [sp, #72]	; 0x48
    c55a:	f000 81c2 	beq.w	c8e2 <_svfprintf_r+0x12ba>
    c55e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c560:	9a12      	ldr	r2, [sp, #72]	; 0x48
    c562:	4619      	mov	r1, r3
    c564:	4291      	cmp	r1, r2
    c566:	f300 8193 	bgt.w	c890 <_svfprintf_r+0x1268>
    c56a:	f01b 0f01 	tst.w	fp, #1
    c56e:	f040 8225 	bne.w	c9bc <_svfprintf_r+0x1394>
    c572:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    c576:	9308      	str	r3, [sp, #32]
    c578:	2367      	movs	r3, #103	; 0x67
    c57a:	920e      	str	r2, [sp, #56]	; 0x38
    c57c:	9311      	str	r3, [sp, #68]	; 0x44
    c57e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    c580:	2b00      	cmp	r3, #0
    c582:	f040 80cd 	bne.w	c720 <_svfprintf_r+0x10f8>
    c586:	930a      	str	r3, [sp, #40]	; 0x28
    c588:	f89d 707f 	ldrb.w	r7, [sp, #127]	; 0x7f
    c58c:	f7ff b964 	b.w	b858 <_svfprintf_r+0x230>
    c590:	f025 0507 	bic.w	r5, r5, #7
    c594:	ed95 7b00 	vldr	d7, [r5]
    c598:	f105 0308 	add.w	r3, r5, #8
    c59c:	ed8d 7b14 	vstr	d7, [sp, #80]	; 0x50
    c5a0:	930f      	str	r3, [sp, #60]	; 0x3c
    c5a2:	e415      	b.n	bdd0 <_svfprintf_r+0x7a8>
    c5a4:	4635      	mov	r5, r6
    c5a6:	460c      	mov	r4, r1
    c5a8:	4646      	mov	r6, r8
    c5aa:	4690      	mov	r8, r2
    c5ac:	3301      	adds	r3, #1
    c5ae:	443c      	add	r4, r7
    c5b0:	2b07      	cmp	r3, #7
    c5b2:	9429      	str	r4, [sp, #164]	; 0xa4
    c5b4:	9328      	str	r3, [sp, #160]	; 0xa0
    c5b6:	e888 00a0 	stmia.w	r8, {r5, r7}
    c5ba:	f73f aece 	bgt.w	c35a <_svfprintf_r+0xd32>
    c5be:	f108 0808 	add.w	r8, r8, #8
    c5c2:	e6d4      	b.n	c36e <_svfprintf_r+0xd46>
    c5c4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    c5c6:	6813      	ldr	r3, [r2, #0]
    c5c8:	3204      	adds	r2, #4
    c5ca:	920f      	str	r2, [sp, #60]	; 0x3c
    c5cc:	9a09      	ldr	r2, [sp, #36]	; 0x24
    c5ce:	601a      	str	r2, [r3, #0]
    c5d0:	f7ff b851 	b.w	b676 <_svfprintf_r+0x4e>
    c5d4:	aa27      	add	r2, sp, #156	; 0x9c
    c5d6:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c5d8:	980c      	ldr	r0, [sp, #48]	; 0x30
    c5da:	f004 f95b 	bl	10894 <__ssprint_r>
    c5de:	2800      	cmp	r0, #0
    c5e0:	f47f a8f4 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c5e4:	46c8      	mov	r8, r9
    c5e6:	e487      	b.n	bef8 <_svfprintf_r+0x8d0>
    c5e8:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c5ea:	4a27      	ldr	r2, [pc, #156]	; (c688 <_svfprintf_r+0x1060>)
    c5ec:	f8c8 2000 	str.w	r2, [r8]
    c5f0:	3301      	adds	r3, #1
    c5f2:	3401      	adds	r4, #1
    c5f4:	2201      	movs	r2, #1
    c5f6:	2b07      	cmp	r3, #7
    c5f8:	9429      	str	r4, [sp, #164]	; 0xa4
    c5fa:	9328      	str	r3, [sp, #160]	; 0xa0
    c5fc:	f8c8 2004 	str.w	r2, [r8, #4]
    c600:	dc53      	bgt.n	c6aa <_svfprintf_r+0x1082>
    c602:	f108 0808 	add.w	r8, r8, #8
    c606:	b929      	cbnz	r1, c614 <_svfprintf_r+0xfec>
    c608:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c60a:	b91b      	cbnz	r3, c614 <_svfprintf_r+0xfec>
    c60c:	9b07      	ldr	r3, [sp, #28]
    c60e:	07d8      	lsls	r0, r3, #31
    c610:	f57f a9f1 	bpl.w	b9f6 <_svfprintf_r+0x3ce>
    c614:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c616:	9817      	ldr	r0, [sp, #92]	; 0x5c
    c618:	9a18      	ldr	r2, [sp, #96]	; 0x60
    c61a:	f8c8 2000 	str.w	r2, [r8]
    c61e:	3301      	adds	r3, #1
    c620:	4602      	mov	r2, r0
    c622:	4422      	add	r2, r4
    c624:	2b07      	cmp	r3, #7
    c626:	9229      	str	r2, [sp, #164]	; 0xa4
    c628:	f8c8 0004 	str.w	r0, [r8, #4]
    c62c:	9328      	str	r3, [sp, #160]	; 0xa0
    c62e:	f300 8197 	bgt.w	c960 <_svfprintf_r+0x1338>
    c632:	f108 0808 	add.w	r8, r8, #8
    c636:	2900      	cmp	r1, #0
    c638:	f2c0 816f 	blt.w	c91a <_svfprintf_r+0x12f2>
    c63c:	9913      	ldr	r1, [sp, #76]	; 0x4c
    c63e:	f8c8 6000 	str.w	r6, [r8]
    c642:	3301      	adds	r3, #1
    c644:	188c      	adds	r4, r1, r2
    c646:	2b07      	cmp	r3, #7
    c648:	9429      	str	r4, [sp, #164]	; 0xa4
    c64a:	9328      	str	r3, [sp, #160]	; 0xa0
    c64c:	f8c8 1004 	str.w	r1, [r8, #4]
    c650:	f77f a9cf 	ble.w	b9f2 <_svfprintf_r+0x3ca>
    c654:	e528      	b.n	c0a8 <_svfprintf_r+0xa80>
    c656:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    c658:	9909      	ldr	r1, [sp, #36]	; 0x24
    c65a:	6813      	ldr	r3, [r2, #0]
    c65c:	17cd      	asrs	r5, r1, #31
    c65e:	4608      	mov	r0, r1
    c660:	3204      	adds	r2, #4
    c662:	4629      	mov	r1, r5
    c664:	920f      	str	r2, [sp, #60]	; 0x3c
    c666:	e9c3 0100 	strd	r0, r1, [r3]
    c66a:	f7ff b804 	b.w	b676 <_svfprintf_r+0x4e>
    c66e:	aa27      	add	r2, sp, #156	; 0x9c
    c670:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c672:	980c      	ldr	r0, [sp, #48]	; 0x30
    c674:	f004 f90e 	bl	10894 <__ssprint_r>
    c678:	2800      	cmp	r0, #0
    c67a:	f47f a8a7 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c67e:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c680:	46c8      	mov	r8, r9
    c682:	e452      	b.n	bf2a <_svfprintf_r+0x902>
    c684:	00012a80 	.word	0x00012a80
    c688:	00012a6c 	.word	0x00012a6c
    c68c:	2140      	movs	r1, #64	; 0x40
    c68e:	980c      	ldr	r0, [sp, #48]	; 0x30
    c690:	f7f6 f8a4 	bl	27dc <__wrap__malloc_r>
    c694:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    c696:	6010      	str	r0, [r2, #0]
    c698:	6110      	str	r0, [r2, #16]
    c69a:	2800      	cmp	r0, #0
    c69c:	f000 81f8 	beq.w	ca90 <_svfprintf_r+0x1468>
    c6a0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    c6a2:	2340      	movs	r3, #64	; 0x40
    c6a4:	6153      	str	r3, [r2, #20]
    c6a6:	f7fe bfd6 	b.w	b656 <_svfprintf_r+0x2e>
    c6aa:	aa27      	add	r2, sp, #156	; 0x9c
    c6ac:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c6ae:	980c      	ldr	r0, [sp, #48]	; 0x30
    c6b0:	f004 f8f0 	bl	10894 <__ssprint_r>
    c6b4:	2800      	cmp	r0, #0
    c6b6:	f47f a889 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c6ba:	9921      	ldr	r1, [sp, #132]	; 0x84
    c6bc:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c6be:	46c8      	mov	r8, r9
    c6c0:	e7a1      	b.n	c606 <_svfprintf_r+0xfde>
    c6c2:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    c6c4:	9401      	str	r4, [sp, #4]
    c6c6:	a825      	add	r0, sp, #148	; 0x94
    c6c8:	a922      	add	r1, sp, #136	; 0x88
    c6ca:	aa21      	add	r2, sp, #132	; 0x84
    c6cc:	2303      	movs	r3, #3
    c6ce:	9004      	str	r0, [sp, #16]
    c6d0:	9202      	str	r2, [sp, #8]
    c6d2:	9300      	str	r3, [sp, #0]
    c6d4:	9103      	str	r1, [sp, #12]
    c6d6:	e9dd 231c 	ldrd	r2, r3, [sp, #112]	; 0x70
    c6da:	980c      	ldr	r0, [sp, #48]	; 0x30
    c6dc:	f002 fda8 	bl	f230 <_dtoa_r>
    c6e0:	4625      	mov	r5, r4
    c6e2:	4606      	mov	r6, r0
    c6e4:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c6e6:	2b46      	cmp	r3, #70	; 0x46
    c6e8:	eb06 0405 	add.w	r4, r6, r5
    c6ec:	f47f af15 	bne.w	c51a <_svfprintf_r+0xef2>
    c6f0:	7833      	ldrb	r3, [r6, #0]
    c6f2:	2b30      	cmp	r3, #48	; 0x30
    c6f4:	f000 817d 	beq.w	c9f2 <_svfprintf_r+0x13ca>
    c6f8:	9d21      	ldr	r5, [sp, #132]	; 0x84
    c6fa:	442c      	add	r4, r5
    c6fc:	e70d      	b.n	c51a <_svfprintf_r+0xef2>
    c6fe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c700:	2b00      	cmp	r3, #0
    c702:	bf08      	it	eq
    c704:	2301      	moveq	r3, #1
    c706:	930a      	str	r3, [sp, #40]	; 0x28
    c708:	e6d6      	b.n	c4b8 <_svfprintf_r+0xe90>
    c70a:	4630      	mov	r0, r6
    c70c:	940a      	str	r4, [sp, #40]	; 0x28
    c70e:	f7f4 f9b7 	bl	a80 <strlen>
    c712:	950f      	str	r5, [sp, #60]	; 0x3c
    c714:	900e      	str	r0, [sp, #56]	; 0x38
    c716:	f8cd b01c 	str.w	fp, [sp, #28]
    c71a:	4603      	mov	r3, r0
    c71c:	f7ff b9e8 	b.w	baf0 <_svfprintf_r+0x4c8>
    c720:	272d      	movs	r7, #45	; 0x2d
    c722:	2300      	movs	r3, #0
    c724:	f88d 707f 	strb.w	r7, [sp, #127]	; 0x7f
    c728:	930a      	str	r3, [sp, #40]	; 0x28
    c72a:	f7ff b896 	b.w	b85a <_svfprintf_r+0x232>
    c72e:	9b21      	ldr	r3, [sp, #132]	; 0x84
    c730:	9312      	str	r3, [sp, #72]	; 0x48
    c732:	461a      	mov	r2, r3
    c734:	3303      	adds	r3, #3
    c736:	db04      	blt.n	c742 <_svfprintf_r+0x111a>
    c738:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c73a:	4619      	mov	r1, r3
    c73c:	4291      	cmp	r1, r2
    c73e:	f6bf af0e 	bge.w	c55e <_svfprintf_r+0xf36>
    c742:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c744:	3b02      	subs	r3, #2
    c746:	9311      	str	r3, [sp, #68]	; 0x44
    c748:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
    c74c:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
    c750:	9b12      	ldr	r3, [sp, #72]	; 0x48
    c752:	3b01      	subs	r3, #1
    c754:	2b00      	cmp	r3, #0
    c756:	9321      	str	r3, [sp, #132]	; 0x84
    c758:	bfbd      	ittte	lt
    c75a:	9b12      	ldrlt	r3, [sp, #72]	; 0x48
    c75c:	f1c3 0301 	rsblt	r3, r3, #1
    c760:	222d      	movlt	r2, #45	; 0x2d
    c762:	222b      	movge	r2, #43	; 0x2b
    c764:	2b09      	cmp	r3, #9
    c766:	f88d 208d 	strb.w	r2, [sp, #141]	; 0x8d
    c76a:	f340 811d 	ble.w	c9a8 <_svfprintf_r+0x1380>
    c76e:	f10d 049b 	add.w	r4, sp, #155	; 0x9b
    c772:	4620      	mov	r0, r4
    c774:	4da9      	ldr	r5, [pc, #676]	; (ca1c <_svfprintf_r+0x13f4>)
    c776:	e000      	b.n	c77a <_svfprintf_r+0x1152>
    c778:	4610      	mov	r0, r2
    c77a:	fb85 1203 	smull	r1, r2, r5, r3
    c77e:	17d9      	asrs	r1, r3, #31
    c780:	ebc1 01a2 	rsb	r1, r1, r2, asr #2
    c784:	eb01 0281 	add.w	r2, r1, r1, lsl #2
    c788:	eba3 0242 	sub.w	r2, r3, r2, lsl #1
    c78c:	3230      	adds	r2, #48	; 0x30
    c78e:	2909      	cmp	r1, #9
    c790:	f800 2c01 	strb.w	r2, [r0, #-1]
    c794:	460b      	mov	r3, r1
    c796:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    c79a:	dced      	bgt.n	c778 <_svfprintf_r+0x1150>
    c79c:	3330      	adds	r3, #48	; 0x30
    c79e:	3802      	subs	r0, #2
    c7a0:	b2d9      	uxtb	r1, r3
    c7a2:	4284      	cmp	r4, r0
    c7a4:	f802 1c01 	strb.w	r1, [r2, #-1]
    c7a8:	f240 816f 	bls.w	ca8a <_svfprintf_r+0x1462>
    c7ac:	f10d 008e 	add.w	r0, sp, #142	; 0x8e
    c7b0:	4613      	mov	r3, r2
    c7b2:	e001      	b.n	c7b8 <_svfprintf_r+0x1190>
    c7b4:	f813 1b01 	ldrb.w	r1, [r3], #1
    c7b8:	f800 1b01 	strb.w	r1, [r0], #1
    c7bc:	42a3      	cmp	r3, r4
    c7be:	d1f9      	bne.n	c7b4 <_svfprintf_r+0x118c>
    c7c0:	3301      	adds	r3, #1
    c7c2:	1a9b      	subs	r3, r3, r2
    c7c4:	f10d 028e 	add.w	r2, sp, #142	; 0x8e
    c7c8:	4413      	add	r3, r2
    c7ca:	aa23      	add	r2, sp, #140	; 0x8c
    c7cc:	1a9b      	subs	r3, r3, r2
    c7ce:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    c7d0:	9319      	str	r3, [sp, #100]	; 0x64
    c7d2:	2a01      	cmp	r2, #1
    c7d4:	4413      	add	r3, r2
    c7d6:	930e      	str	r3, [sp, #56]	; 0x38
    c7d8:	f340 812a 	ble.w	ca30 <_svfprintf_r+0x1408>
    c7dc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    c7de:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    c7e0:	4413      	add	r3, r2
    c7e2:	930e      	str	r3, [sp, #56]	; 0x38
    c7e4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    c7e8:	9308      	str	r3, [sp, #32]
    c7ea:	2300      	movs	r3, #0
    c7ec:	9312      	str	r3, [sp, #72]	; 0x48
    c7ee:	e6c6      	b.n	c57e <_svfprintf_r+0xf56>
    c7f0:	4623      	mov	r3, r4
    c7f2:	e6a5      	b.n	c540 <_svfprintf_r+0xf18>
    c7f4:	aa27      	add	r2, sp, #156	; 0x9c
    c7f6:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c7f8:	980c      	ldr	r0, [sp, #48]	; 0x30
    c7fa:	f004 f84b 	bl	10894 <__ssprint_r>
    c7fe:	2800      	cmp	r0, #0
    c800:	f47e afe4 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c804:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c806:	46c8      	mov	r8, r9
    c808:	e4d2      	b.n	c1b0 <_svfprintf_r+0xb88>
    c80a:	aa27      	add	r2, sp, #156	; 0x9c
    c80c:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c80e:	980c      	ldr	r0, [sp, #48]	; 0x30
    c810:	f004 f840 	bl	10894 <__ssprint_r>
    c814:	2800      	cmp	r0, #0
    c816:	f47e afd9 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c81a:	9a21      	ldr	r2, [sp, #132]	; 0x84
    c81c:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c81e:	46c8      	mov	r8, r9
    c820:	e5ac      	b.n	c37c <_svfprintf_r+0xd54>
    c822:	aa27      	add	r2, sp, #156	; 0x9c
    c824:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c826:	980c      	ldr	r0, [sp, #48]	; 0x30
    c828:	f004 f834 	bl	10894 <__ssprint_r>
    c82c:	2800      	cmp	r0, #0
    c82e:	f47e afcd 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c832:	9a21      	ldr	r2, [sp, #132]	; 0x84
    c834:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c836:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c838:	1a9a      	subs	r2, r3, r2
    c83a:	46c8      	mov	r8, r9
    c83c:	e5b6      	b.n	c3ac <_svfprintf_r+0xd84>
    c83e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c840:	9612      	str	r6, [sp, #72]	; 0x48
    c842:	2b06      	cmp	r3, #6
    c844:	bf28      	it	cs
    c846:	2306      	movcs	r3, #6
    c848:	960a      	str	r6, [sp, #40]	; 0x28
    c84a:	4637      	mov	r7, r6
    c84c:	9308      	str	r3, [sp, #32]
    c84e:	950f      	str	r5, [sp, #60]	; 0x3c
    c850:	f8cd b01c 	str.w	fp, [sp, #28]
    c854:	930e      	str	r3, [sp, #56]	; 0x38
    c856:	4e72      	ldr	r6, [pc, #456]	; (ca20 <_svfprintf_r+0x13f8>)
    c858:	f7fe bffe 	b.w	b858 <_svfprintf_r+0x230>
    c85c:	2306      	movs	r3, #6
    c85e:	930a      	str	r3, [sp, #40]	; 0x28
    c860:	e62a      	b.n	c4b8 <_svfprintf_r+0xe90>
    c862:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    c864:	9501      	str	r5, [sp, #4]
    c866:	a825      	add	r0, sp, #148	; 0x94
    c868:	a922      	add	r1, sp, #136	; 0x88
    c86a:	aa21      	add	r2, sp, #132	; 0x84
    c86c:	2303      	movs	r3, #3
    c86e:	9004      	str	r0, [sp, #16]
    c870:	9202      	str	r2, [sp, #8]
    c872:	9300      	str	r3, [sp, #0]
    c874:	9103      	str	r1, [sp, #12]
    c876:	e9dd 231c 	ldrd	r2, r3, [sp, #112]	; 0x70
    c87a:	980c      	ldr	r0, [sp, #48]	; 0x30
    c87c:	f002 fcd8 	bl	f230 <_dtoa_r>
    c880:	4606      	mov	r6, r0
    c882:	1944      	adds	r4, r0, r5
    c884:	e734      	b.n	c6f0 <_svfprintf_r+0x10c8>
    c886:	272d      	movs	r7, #45	; 0x2d
    c888:	f88d 707f 	strb.w	r7, [sp, #127]	; 0x7f
    c88c:	f7ff bac7 	b.w	be1e <_svfprintf_r+0x7f6>
    c890:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    c892:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c894:	4413      	add	r3, r2
    c896:	9a12      	ldr	r2, [sp, #72]	; 0x48
    c898:	930e      	str	r3, [sp, #56]	; 0x38
    c89a:	2a00      	cmp	r2, #0
    c89c:	f340 80b7 	ble.w	ca0e <_svfprintf_r+0x13e6>
    c8a0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    c8a4:	9308      	str	r3, [sp, #32]
    c8a6:	2367      	movs	r3, #103	; 0x67
    c8a8:	9311      	str	r3, [sp, #68]	; 0x44
    c8aa:	e668      	b.n	c57e <_svfprintf_r+0xf56>
    c8ac:	e9dd 1214 	ldrd	r1, r2, [sp, #80]	; 0x50
    c8b0:	f102 4300 	add.w	r3, r2, #2147483648	; 0x80000000
    c8b4:	931d      	str	r3, [sp, #116]	; 0x74
    c8b6:	232d      	movs	r3, #45	; 0x2d
    c8b8:	911c      	str	r1, [sp, #112]	; 0x70
    c8ba:	9310      	str	r3, [sp, #64]	; 0x40
    c8bc:	e609      	b.n	c4d2 <_svfprintf_r+0xeaa>
    c8be:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c8c0:	2b47      	cmp	r3, #71	; 0x47
    c8c2:	f47f ae29 	bne.w	c518 <_svfprintf_r+0xef0>
    c8c6:	f01b 0f01 	tst.w	fp, #1
    c8ca:	f47f af0b 	bne.w	c6e4 <_svfprintf_r+0x10bc>
    c8ce:	9b25      	ldr	r3, [sp, #148]	; 0x94
    c8d0:	2f47      	cmp	r7, #71	; 0x47
    c8d2:	eba3 0306 	sub.w	r3, r3, r6
    c8d6:	9313      	str	r3, [sp, #76]	; 0x4c
    c8d8:	f43f af29 	beq.w	c72e <_svfprintf_r+0x1106>
    c8dc:	9b21      	ldr	r3, [sp, #132]	; 0x84
    c8de:	9312      	str	r3, [sp, #72]	; 0x48
    c8e0:	e732      	b.n	c748 <_svfprintf_r+0x1120>
    c8e2:	2b00      	cmp	r3, #0
    c8e4:	f340 80ae 	ble.w	ca44 <_svfprintf_r+0x141c>
    c8e8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    c8ea:	2a00      	cmp	r2, #0
    c8ec:	d16b      	bne.n	c9c6 <_svfprintf_r+0x139e>
    c8ee:	f01b 0f01 	tst.w	fp, #1
    c8f2:	d168      	bne.n	c9c6 <_svfprintf_r+0x139e>
    c8f4:	9308      	str	r3, [sp, #32]
    c8f6:	930e      	str	r3, [sp, #56]	; 0x38
    c8f8:	e641      	b.n	c57e <_svfprintf_r+0xf56>
    c8fa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c8fc:	9308      	str	r3, [sp, #32]
    c8fe:	930e      	str	r3, [sp, #56]	; 0x38
    c900:	900a      	str	r0, [sp, #40]	; 0x28
    c902:	950f      	str	r5, [sp, #60]	; 0x3c
    c904:	f8cd b01c 	str.w	fp, [sp, #28]
    c908:	9012      	str	r0, [sp, #72]	; 0x48
    c90a:	f89d 707f 	ldrb.w	r7, [sp, #127]	; 0x7f
    c90e:	f7fe bfa3 	b.w	b858 <_svfprintf_r+0x230>
    c912:	2000      	movs	r0, #0
    c914:	900a      	str	r0, [sp, #40]	; 0x28
    c916:	f7fe bee1 	b.w	b6dc <_svfprintf_r+0xb4>
    c91a:	424f      	negs	r7, r1
    c91c:	3110      	adds	r1, #16
    c91e:	4d41      	ldr	r5, [pc, #260]	; (ca24 <_svfprintf_r+0x13fc>)
    c920:	da2b      	bge.n	c97a <_svfprintf_r+0x1352>
    c922:	2410      	movs	r4, #16
    c924:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
    c928:	e004      	b.n	c934 <_svfprintf_r+0x130c>
    c92a:	f108 0808 	add.w	r8, r8, #8
    c92e:	3f10      	subs	r7, #16
    c930:	2f10      	cmp	r7, #16
    c932:	dd22      	ble.n	c97a <_svfprintf_r+0x1352>
    c934:	3301      	adds	r3, #1
    c936:	3210      	adds	r2, #16
    c938:	2b07      	cmp	r3, #7
    c93a:	9229      	str	r2, [sp, #164]	; 0xa4
    c93c:	9328      	str	r3, [sp, #160]	; 0xa0
    c93e:	f8c8 5000 	str.w	r5, [r8]
    c942:	f8c8 4004 	str.w	r4, [r8, #4]
    c946:	ddf0      	ble.n	c92a <_svfprintf_r+0x1302>
    c948:	aa27      	add	r2, sp, #156	; 0x9c
    c94a:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c94c:	4658      	mov	r0, fp
    c94e:	f003 ffa1 	bl	10894 <__ssprint_r>
    c952:	2800      	cmp	r0, #0
    c954:	f47e af3a 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c958:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    c95a:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c95c:	46c8      	mov	r8, r9
    c95e:	e7e6      	b.n	c92e <_svfprintf_r+0x1306>
    c960:	aa27      	add	r2, sp, #156	; 0x9c
    c962:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c964:	980c      	ldr	r0, [sp, #48]	; 0x30
    c966:	f003 ff95 	bl	10894 <__ssprint_r>
    c96a:	2800      	cmp	r0, #0
    c96c:	f47e af2e 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c970:	9921      	ldr	r1, [sp, #132]	; 0x84
    c972:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    c974:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c976:	46c8      	mov	r8, r9
    c978:	e65d      	b.n	c636 <_svfprintf_r+0x100e>
    c97a:	3301      	adds	r3, #1
    c97c:	443a      	add	r2, r7
    c97e:	2b07      	cmp	r3, #7
    c980:	e888 00a0 	stmia.w	r8, {r5, r7}
    c984:	9229      	str	r2, [sp, #164]	; 0xa4
    c986:	9328      	str	r3, [sp, #160]	; 0xa0
    c988:	f108 0808 	add.w	r8, r8, #8
    c98c:	f77f ae56 	ble.w	c63c <_svfprintf_r+0x1014>
    c990:	aa27      	add	r2, sp, #156	; 0x9c
    c992:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c994:	980c      	ldr	r0, [sp, #48]	; 0x30
    c996:	f003 ff7d 	bl	10894 <__ssprint_r>
    c99a:	2800      	cmp	r0, #0
    c99c:	f47e af16 	bne.w	b7cc <_svfprintf_r+0x1a4>
    c9a0:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    c9a2:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c9a4:	46c8      	mov	r8, r9
    c9a6:	e649      	b.n	c63c <_svfprintf_r+0x1014>
    c9a8:	3330      	adds	r3, #48	; 0x30
    c9aa:	2230      	movs	r2, #48	; 0x30
    c9ac:	f88d 308f 	strb.w	r3, [sp, #143]	; 0x8f
    c9b0:	f88d 208e 	strb.w	r2, [sp, #142]	; 0x8e
    c9b4:	ab24      	add	r3, sp, #144	; 0x90
    c9b6:	e708      	b.n	c7ca <_svfprintf_r+0x11a2>
    c9b8:	9b25      	ldr	r3, [sp, #148]	; 0x94
    c9ba:	e5c1      	b.n	c540 <_svfprintf_r+0xf18>
    c9bc:	9b12      	ldr	r3, [sp, #72]	; 0x48
    c9be:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    c9c0:	4413      	add	r3, r2
    c9c2:	930e      	str	r3, [sp, #56]	; 0x38
    c9c4:	e76c      	b.n	c8a0 <_svfprintf_r+0x1278>
    c9c6:	9b12      	ldr	r3, [sp, #72]	; 0x48
    c9c8:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    c9ca:	4413      	add	r3, r2
    c9cc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    c9ce:	441a      	add	r2, r3
    c9d0:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    c9d4:	920e      	str	r2, [sp, #56]	; 0x38
    c9d6:	9308      	str	r3, [sp, #32]
    c9d8:	e5d1      	b.n	c57e <_svfprintf_r+0xf56>
    c9da:	9b15      	ldr	r3, [sp, #84]	; 0x54
    c9dc:	4e12      	ldr	r6, [pc, #72]	; (ca28 <_svfprintf_r+0x1400>)
    c9de:	2b00      	cmp	r3, #0
    c9e0:	bfb6      	itet	lt
    c9e2:	272d      	movlt	r7, #45	; 0x2d
    c9e4:	f89d 707f 	ldrbge.w	r7, [sp, #127]	; 0x7f
    c9e8:	f88d 707f 	strblt.w	r7, [sp, #127]	; 0x7f
    c9ec:	4b0f      	ldr	r3, [pc, #60]	; (ca2c <_svfprintf_r+0x1404>)
    c9ee:	f7ff ba18 	b.w	be22 <_svfprintf_r+0x7fa>
    c9f2:	2200      	movs	r2, #0
    c9f4:	2300      	movs	r3, #0
    c9f6:	e9dd 011c 	ldrd	r0, r1, [sp, #112]	; 0x70
    c9fa:	f7f4 fccf 	bl	139c <__aeabi_dcmpeq>
    c9fe:	2800      	cmp	r0, #0
    ca00:	f47f ae7a 	bne.w	c6f8 <_svfprintf_r+0x10d0>
    ca04:	f1c5 0501 	rsb	r5, r5, #1
    ca08:	9521      	str	r5, [sp, #132]	; 0x84
    ca0a:	442c      	add	r4, r5
    ca0c:	e585      	b.n	c51a <_svfprintf_r+0xef2>
    ca0e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    ca10:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    ca12:	f1c3 0301 	rsb	r3, r3, #1
    ca16:	441a      	add	r2, r3
    ca18:	4613      	mov	r3, r2
    ca1a:	e7d2      	b.n	c9c2 <_svfprintf_r+0x139a>
    ca1c:	66666667 	.word	0x66666667
    ca20:	00012a64 	.word	0x00012a64
    ca24:	00012a80 	.word	0x00012a80
    ca28:	00012a38 	.word	0x00012a38
    ca2c:	00012a34 	.word	0x00012a34
    ca30:	f01b 0301 	ands.w	r3, fp, #1
    ca34:	9312      	str	r3, [sp, #72]	; 0x48
    ca36:	f47f aed1 	bne.w	c7dc <_svfprintf_r+0x11b4>
    ca3a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    ca3c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    ca40:	9308      	str	r3, [sp, #32]
    ca42:	e59c      	b.n	c57e <_svfprintf_r+0xf56>
    ca44:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ca46:	b913      	cbnz	r3, ca4e <_svfprintf_r+0x1426>
    ca48:	f01b 0f01 	tst.w	fp, #1
    ca4c:	d002      	beq.n	ca54 <_svfprintf_r+0x142c>
    ca4e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    ca50:	3301      	adds	r3, #1
    ca52:	e7bb      	b.n	c9cc <_svfprintf_r+0x13a4>
    ca54:	2301      	movs	r3, #1
    ca56:	e74d      	b.n	c8f4 <_svfprintf_r+0x12cc>
    ca58:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    ca5a:	f89a 3001 	ldrb.w	r3, [sl, #1]
    ca5e:	6828      	ldr	r0, [r5, #0]
    ca60:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
    ca64:	900a      	str	r0, [sp, #40]	; 0x28
    ca66:	4628      	mov	r0, r5
    ca68:	3004      	adds	r0, #4
    ca6a:	46a2      	mov	sl, r4
    ca6c:	900f      	str	r0, [sp, #60]	; 0x3c
    ca6e:	f7fe be33 	b.w	b6d8 <_svfprintf_r+0xb0>
    ca72:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    ca76:	f7ff b850 	b.w	bb1a <_svfprintf_r+0x4f2>
    ca7a:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    ca7e:	f7ff b8dc 	b.w	bc3a <_svfprintf_r+0x612>
    ca82:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    ca86:	f7ff ba05 	b.w	be94 <_svfprintf_r+0x86c>
    ca8a:	f10d 038e 	add.w	r3, sp, #142	; 0x8e
    ca8e:	e69c      	b.n	c7ca <_svfprintf_r+0x11a2>
    ca90:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    ca92:	230c      	movs	r3, #12
    ca94:	6013      	str	r3, [r2, #0]
    ca96:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    ca9a:	9309      	str	r3, [sp, #36]	; 0x24
    ca9c:	f7fe be9f 	b.w	b7de <_svfprintf_r+0x1b6>
    caa0:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    caa4:	f7ff b984 	b.w	bdb0 <_svfprintf_r+0x788>
    caa8:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    caac:	f7ff b960 	b.w	bd70 <_svfprintf_r+0x748>
    cab0:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    cab4:	f7ff b943 	b.w	bd3e <_svfprintf_r+0x716>
    cab8:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    cabc:	f7ff b8fc 	b.w	bcb8 <_svfprintf_r+0x690>

0000cac0 <__sprint_r.part.0>:
    cac0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cac4:	6e4b      	ldr	r3, [r1, #100]	; 0x64
    cac6:	049c      	lsls	r4, r3, #18
    cac8:	4693      	mov	fp, r2
    caca:	d52f      	bpl.n	cb2c <__sprint_r.part.0+0x6c>
    cacc:	6893      	ldr	r3, [r2, #8]
    cace:	6812      	ldr	r2, [r2, #0]
    cad0:	b353      	cbz	r3, cb28 <__sprint_r.part.0+0x68>
    cad2:	460e      	mov	r6, r1
    cad4:	4607      	mov	r7, r0
    cad6:	f102 0908 	add.w	r9, r2, #8
    cada:	e919 0420 	ldmdb	r9, {r5, sl}
    cade:	ea5f 089a 	movs.w	r8, sl, lsr #2
    cae2:	d017      	beq.n	cb14 <__sprint_r.part.0+0x54>
    cae4:	3d04      	subs	r5, #4
    cae6:	2400      	movs	r4, #0
    cae8:	e001      	b.n	caee <__sprint_r.part.0+0x2e>
    caea:	45a0      	cmp	r8, r4
    caec:	d010      	beq.n	cb10 <__sprint_r.part.0+0x50>
    caee:	4632      	mov	r2, r6
    caf0:	f855 1f04 	ldr.w	r1, [r5, #4]!
    caf4:	4638      	mov	r0, r7
    caf6:	f003 fb05 	bl	10104 <_fputwc_r>
    cafa:	1c43      	adds	r3, r0, #1
    cafc:	f104 0401 	add.w	r4, r4, #1
    cb00:	d1f3      	bne.n	caea <__sprint_r.part.0+0x2a>
    cb02:	2300      	movs	r3, #0
    cb04:	f8cb 3008 	str.w	r3, [fp, #8]
    cb08:	f8cb 3004 	str.w	r3, [fp, #4]
    cb0c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cb10:	f8db 3008 	ldr.w	r3, [fp, #8]
    cb14:	f02a 0a03 	bic.w	sl, sl, #3
    cb18:	eba3 030a 	sub.w	r3, r3, sl
    cb1c:	f8cb 3008 	str.w	r3, [fp, #8]
    cb20:	f109 0908 	add.w	r9, r9, #8
    cb24:	2b00      	cmp	r3, #0
    cb26:	d1d8      	bne.n	cada <__sprint_r.part.0+0x1a>
    cb28:	2000      	movs	r0, #0
    cb2a:	e7ea      	b.n	cb02 <__sprint_r.part.0+0x42>
    cb2c:	f7fd ff28 	bl	a980 <__sfvwrite_r>
    cb30:	2300      	movs	r3, #0
    cb32:	f8cb 3008 	str.w	r3, [fp, #8]
    cb36:	f8cb 3004 	str.w	r3, [fp, #4]
    cb3a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cb3e:	bf00      	nop

0000cb40 <__sprint_r>:
    cb40:	6893      	ldr	r3, [r2, #8]
    cb42:	b10b      	cbz	r3, cb48 <__sprint_r+0x8>
    cb44:	f7ff bfbc 	b.w	cac0 <__sprint_r.part.0>
    cb48:	b410      	push	{r4}
    cb4a:	4618      	mov	r0, r3
    cb4c:	6053      	str	r3, [r2, #4]
    cb4e:	f85d 4b04 	ldr.w	r4, [sp], #4
    cb52:	4770      	bx	lr

0000cb54 <_vfiprintf_r>:
    cb54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cb58:	b0ad      	sub	sp, #180	; 0xb4
    cb5a:	461d      	mov	r5, r3
    cb5c:	468b      	mov	fp, r1
    cb5e:	4690      	mov	r8, r2
    cb60:	9307      	str	r3, [sp, #28]
    cb62:	9006      	str	r0, [sp, #24]
    cb64:	b118      	cbz	r0, cb6e <_vfiprintf_r+0x1a>
    cb66:	6b83      	ldr	r3, [r0, #56]	; 0x38
    cb68:	2b00      	cmp	r3, #0
    cb6a:	f000 80f3 	beq.w	cd54 <_vfiprintf_r+0x200>
    cb6e:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
    cb72:	f9bb 000c 	ldrsh.w	r0, [fp, #12]
    cb76:	07df      	lsls	r7, r3, #31
    cb78:	b281      	uxth	r1, r0
    cb7a:	d402      	bmi.n	cb82 <_vfiprintf_r+0x2e>
    cb7c:	058e      	lsls	r6, r1, #22
    cb7e:	f140 80fc 	bpl.w	cd7a <_vfiprintf_r+0x226>
    cb82:	048c      	lsls	r4, r1, #18
    cb84:	d40a      	bmi.n	cb9c <_vfiprintf_r+0x48>
    cb86:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
    cb8a:	f440 5100 	orr.w	r1, r0, #8192	; 0x2000
    cb8e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    cb92:	f8ab 100c 	strh.w	r1, [fp, #12]
    cb96:	f8cb 3064 	str.w	r3, [fp, #100]	; 0x64
    cb9a:	b289      	uxth	r1, r1
    cb9c:	0708      	lsls	r0, r1, #28
    cb9e:	f140 80b3 	bpl.w	cd08 <_vfiprintf_r+0x1b4>
    cba2:	f8db 3010 	ldr.w	r3, [fp, #16]
    cba6:	2b00      	cmp	r3, #0
    cba8:	f000 80ae 	beq.w	cd08 <_vfiprintf_r+0x1b4>
    cbac:	f001 031a 	and.w	r3, r1, #26
    cbb0:	2b0a      	cmp	r3, #10
    cbb2:	f000 80b5 	beq.w	cd20 <_vfiprintf_r+0x1cc>
    cbb6:	2300      	movs	r3, #0
    cbb8:	f10d 0970 	add.w	r9, sp, #112	; 0x70
    cbbc:	930b      	str	r3, [sp, #44]	; 0x2c
    cbbe:	9311      	str	r3, [sp, #68]	; 0x44
    cbc0:	9310      	str	r3, [sp, #64]	; 0x40
    cbc2:	9303      	str	r3, [sp, #12]
    cbc4:	f8cd 903c 	str.w	r9, [sp, #60]	; 0x3c
    cbc8:	46ca      	mov	sl, r9
    cbca:	f8cd b010 	str.w	fp, [sp, #16]
    cbce:	f898 3000 	ldrb.w	r3, [r8]
    cbd2:	4644      	mov	r4, r8
    cbd4:	b1fb      	cbz	r3, cc16 <_vfiprintf_r+0xc2>
    cbd6:	2b25      	cmp	r3, #37	; 0x25
    cbd8:	d102      	bne.n	cbe0 <_vfiprintf_r+0x8c>
    cbda:	e01c      	b.n	cc16 <_vfiprintf_r+0xc2>
    cbdc:	2b25      	cmp	r3, #37	; 0x25
    cbde:	d003      	beq.n	cbe8 <_vfiprintf_r+0x94>
    cbe0:	f814 3f01 	ldrb.w	r3, [r4, #1]!
    cbe4:	2b00      	cmp	r3, #0
    cbe6:	d1f9      	bne.n	cbdc <_vfiprintf_r+0x88>
    cbe8:	eba4 0508 	sub.w	r5, r4, r8
    cbec:	b19d      	cbz	r5, cc16 <_vfiprintf_r+0xc2>
    cbee:	9b10      	ldr	r3, [sp, #64]	; 0x40
    cbf0:	9a11      	ldr	r2, [sp, #68]	; 0x44
    cbf2:	f8ca 8000 	str.w	r8, [sl]
    cbf6:	3301      	adds	r3, #1
    cbf8:	442a      	add	r2, r5
    cbfa:	2b07      	cmp	r3, #7
    cbfc:	f8ca 5004 	str.w	r5, [sl, #4]
    cc00:	9211      	str	r2, [sp, #68]	; 0x44
    cc02:	9310      	str	r3, [sp, #64]	; 0x40
    cc04:	dd7a      	ble.n	ccfc <_vfiprintf_r+0x1a8>
    cc06:	2a00      	cmp	r2, #0
    cc08:	f040 84b0 	bne.w	d56c <_vfiprintf_r+0xa18>
    cc0c:	9b03      	ldr	r3, [sp, #12]
    cc0e:	9210      	str	r2, [sp, #64]	; 0x40
    cc10:	442b      	add	r3, r5
    cc12:	46ca      	mov	sl, r9
    cc14:	9303      	str	r3, [sp, #12]
    cc16:	7823      	ldrb	r3, [r4, #0]
    cc18:	2b00      	cmp	r3, #0
    cc1a:	f000 83e0 	beq.w	d3de <_vfiprintf_r+0x88a>
    cc1e:	2000      	movs	r0, #0
    cc20:	f04f 0300 	mov.w	r3, #0
    cc24:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    cc28:	f104 0801 	add.w	r8, r4, #1
    cc2c:	7862      	ldrb	r2, [r4, #1]
    cc2e:	4605      	mov	r5, r0
    cc30:	4606      	mov	r6, r0
    cc32:	4603      	mov	r3, r0
    cc34:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    cc38:	f108 0801 	add.w	r8, r8, #1
    cc3c:	f1a2 0120 	sub.w	r1, r2, #32
    cc40:	2958      	cmp	r1, #88	; 0x58
    cc42:	f200 82de 	bhi.w	d202 <_vfiprintf_r+0x6ae>
    cc46:	e8df f011 	tbh	[pc, r1, lsl #1]
    cc4a:	0221      	.short	0x0221
    cc4c:	02dc02dc 	.word	0x02dc02dc
    cc50:	02dc0229 	.word	0x02dc0229
    cc54:	02dc02dc 	.word	0x02dc02dc
    cc58:	02dc02dc 	.word	0x02dc02dc
    cc5c:	028902dc 	.word	0x028902dc
    cc60:	02dc0295 	.word	0x02dc0295
    cc64:	02bd00a2 	.word	0x02bd00a2
    cc68:	019f02dc 	.word	0x019f02dc
    cc6c:	01a401a4 	.word	0x01a401a4
    cc70:	01a401a4 	.word	0x01a401a4
    cc74:	01a401a4 	.word	0x01a401a4
    cc78:	01a401a4 	.word	0x01a401a4
    cc7c:	02dc01a4 	.word	0x02dc01a4
    cc80:	02dc02dc 	.word	0x02dc02dc
    cc84:	02dc02dc 	.word	0x02dc02dc
    cc88:	02dc02dc 	.word	0x02dc02dc
    cc8c:	02dc02dc 	.word	0x02dc02dc
    cc90:	01b202dc 	.word	0x01b202dc
    cc94:	02dc02dc 	.word	0x02dc02dc
    cc98:	02dc02dc 	.word	0x02dc02dc
    cc9c:	02dc02dc 	.word	0x02dc02dc
    cca0:	02dc02dc 	.word	0x02dc02dc
    cca4:	02dc02dc 	.word	0x02dc02dc
    cca8:	02dc0197 	.word	0x02dc0197
    ccac:	02dc02dc 	.word	0x02dc02dc
    ccb0:	02dc02dc 	.word	0x02dc02dc
    ccb4:	02dc019b 	.word	0x02dc019b
    ccb8:	025302dc 	.word	0x025302dc
    ccbc:	02dc02dc 	.word	0x02dc02dc
    ccc0:	02dc02dc 	.word	0x02dc02dc
    ccc4:	02dc02dc 	.word	0x02dc02dc
    ccc8:	02dc02dc 	.word	0x02dc02dc
    cccc:	02dc02dc 	.word	0x02dc02dc
    ccd0:	021b025a 	.word	0x021b025a
    ccd4:	02dc02dc 	.word	0x02dc02dc
    ccd8:	026e02dc 	.word	0x026e02dc
    ccdc:	02dc021b 	.word	0x02dc021b
    cce0:	027302dc 	.word	0x027302dc
    cce4:	01f502dc 	.word	0x01f502dc
    cce8:	02090182 	.word	0x02090182
    ccec:	02dc02d7 	.word	0x02dc02d7
    ccf0:	02dc029a 	.word	0x02dc029a
    ccf4:	02dc00a7 	.word	0x02dc00a7
    ccf8:	022e02dc 	.word	0x022e02dc
    ccfc:	f10a 0a08 	add.w	sl, sl, #8
    cd00:	9b03      	ldr	r3, [sp, #12]
    cd02:	442b      	add	r3, r5
    cd04:	9303      	str	r3, [sp, #12]
    cd06:	e786      	b.n	cc16 <_vfiprintf_r+0xc2>
    cd08:	4659      	mov	r1, fp
    cd0a:	9806      	ldr	r0, [sp, #24]
    cd0c:	f002 f97e 	bl	f00c <__swsetup_r>
    cd10:	bb18      	cbnz	r0, cd5a <_vfiprintf_r+0x206>
    cd12:	f8bb 100c 	ldrh.w	r1, [fp, #12]
    cd16:	f001 031a 	and.w	r3, r1, #26
    cd1a:	2b0a      	cmp	r3, #10
    cd1c:	f47f af4b 	bne.w	cbb6 <_vfiprintf_r+0x62>
    cd20:	f9bb 300e 	ldrsh.w	r3, [fp, #14]
    cd24:	2b00      	cmp	r3, #0
    cd26:	f6ff af46 	blt.w	cbb6 <_vfiprintf_r+0x62>
    cd2a:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
    cd2e:	07db      	lsls	r3, r3, #31
    cd30:	d405      	bmi.n	cd3e <_vfiprintf_r+0x1ea>
    cd32:	058f      	lsls	r7, r1, #22
    cd34:	d403      	bmi.n	cd3e <_vfiprintf_r+0x1ea>
    cd36:	f8db 0058 	ldr.w	r0, [fp, #88]	; 0x58
    cd3a:	f7fd ffff 	bl	ad3c <__retarget_lock_release_recursive>
    cd3e:	462b      	mov	r3, r5
    cd40:	4642      	mov	r2, r8
    cd42:	4659      	mov	r1, fp
    cd44:	9806      	ldr	r0, [sp, #24]
    cd46:	f000 fd4d 	bl	d7e4 <__sbprintf>
    cd4a:	9003      	str	r0, [sp, #12]
    cd4c:	9803      	ldr	r0, [sp, #12]
    cd4e:	b02d      	add	sp, #180	; 0xb4
    cd50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cd54:	f7fd fc7e 	bl	a654 <__sinit>
    cd58:	e709      	b.n	cb6e <_vfiprintf_r+0x1a>
    cd5a:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
    cd5e:	07d9      	lsls	r1, r3, #31
    cd60:	d404      	bmi.n	cd6c <_vfiprintf_r+0x218>
    cd62:	f8bb 300c 	ldrh.w	r3, [fp, #12]
    cd66:	059a      	lsls	r2, r3, #22
    cd68:	f140 84aa 	bpl.w	d6c0 <_vfiprintf_r+0xb6c>
    cd6c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    cd70:	9303      	str	r3, [sp, #12]
    cd72:	9803      	ldr	r0, [sp, #12]
    cd74:	b02d      	add	sp, #180	; 0xb4
    cd76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cd7a:	f8db 0058 	ldr.w	r0, [fp, #88]	; 0x58
    cd7e:	f7fd ffdb 	bl	ad38 <__retarget_lock_acquire_recursive>
    cd82:	f9bb 000c 	ldrsh.w	r0, [fp, #12]
    cd86:	b281      	uxth	r1, r0
    cd88:	e6fb      	b.n	cb82 <_vfiprintf_r+0x2e>
    cd8a:	4276      	negs	r6, r6
    cd8c:	9207      	str	r2, [sp, #28]
    cd8e:	f043 0304 	orr.w	r3, r3, #4
    cd92:	f898 2000 	ldrb.w	r2, [r8]
    cd96:	e74f      	b.n	cc38 <_vfiprintf_r+0xe4>
    cd98:	9608      	str	r6, [sp, #32]
    cd9a:	069e      	lsls	r6, r3, #26
    cd9c:	f100 8450 	bmi.w	d640 <_vfiprintf_r+0xaec>
    cda0:	9907      	ldr	r1, [sp, #28]
    cda2:	06dd      	lsls	r5, r3, #27
    cda4:	460a      	mov	r2, r1
    cda6:	f100 83ef 	bmi.w	d588 <_vfiprintf_r+0xa34>
    cdaa:	0658      	lsls	r0, r3, #25
    cdac:	f140 83ec 	bpl.w	d588 <_vfiprintf_r+0xa34>
    cdb0:	880e      	ldrh	r6, [r1, #0]
    cdb2:	3104      	adds	r1, #4
    cdb4:	2700      	movs	r7, #0
    cdb6:	2201      	movs	r2, #1
    cdb8:	9107      	str	r1, [sp, #28]
    cdba:	f04f 0100 	mov.w	r1, #0
    cdbe:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
    cdc2:	2500      	movs	r5, #0
    cdc4:	1c61      	adds	r1, r4, #1
    cdc6:	f000 8116 	beq.w	cff6 <_vfiprintf_r+0x4a2>
    cdca:	f023 0180 	bic.w	r1, r3, #128	; 0x80
    cdce:	9102      	str	r1, [sp, #8]
    cdd0:	ea56 0107 	orrs.w	r1, r6, r7
    cdd4:	f040 8114 	bne.w	d000 <_vfiprintf_r+0x4ac>
    cdd8:	2c00      	cmp	r4, #0
    cdda:	f040 835c 	bne.w	d496 <_vfiprintf_r+0x942>
    cdde:	2a00      	cmp	r2, #0
    cde0:	f040 83b7 	bne.w	d552 <_vfiprintf_r+0x9fe>
    cde4:	f013 0301 	ands.w	r3, r3, #1
    cde8:	9305      	str	r3, [sp, #20]
    cdea:	f000 8457 	beq.w	d69c <_vfiprintf_r+0xb48>
    cdee:	f10d 0bb0 	add.w	fp, sp, #176	; 0xb0
    cdf2:	2330      	movs	r3, #48	; 0x30
    cdf4:	f80b 3d41 	strb.w	r3, [fp, #-65]!
    cdf8:	9b05      	ldr	r3, [sp, #20]
    cdfa:	42a3      	cmp	r3, r4
    cdfc:	bfb8      	it	lt
    cdfe:	4623      	movlt	r3, r4
    ce00:	9301      	str	r3, [sp, #4]
    ce02:	b10d      	cbz	r5, ce08 <_vfiprintf_r+0x2b4>
    ce04:	3301      	adds	r3, #1
    ce06:	9301      	str	r3, [sp, #4]
    ce08:	9b02      	ldr	r3, [sp, #8]
    ce0a:	f013 0302 	ands.w	r3, r3, #2
    ce0e:	9309      	str	r3, [sp, #36]	; 0x24
    ce10:	d002      	beq.n	ce18 <_vfiprintf_r+0x2c4>
    ce12:	9b01      	ldr	r3, [sp, #4]
    ce14:	3302      	adds	r3, #2
    ce16:	9301      	str	r3, [sp, #4]
    ce18:	9b02      	ldr	r3, [sp, #8]
    ce1a:	f013 0384 	ands.w	r3, r3, #132	; 0x84
    ce1e:	930a      	str	r3, [sp, #40]	; 0x28
    ce20:	f040 8217 	bne.w	d252 <_vfiprintf_r+0x6fe>
    ce24:	9b08      	ldr	r3, [sp, #32]
    ce26:	9a01      	ldr	r2, [sp, #4]
    ce28:	1a9d      	subs	r5, r3, r2
    ce2a:	2d00      	cmp	r5, #0
    ce2c:	f340 8211 	ble.w	d252 <_vfiprintf_r+0x6fe>
    ce30:	2d10      	cmp	r5, #16
    ce32:	f340 8490 	ble.w	d756 <_vfiprintf_r+0xc02>
    ce36:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ce38:	9a11      	ldr	r2, [sp, #68]	; 0x44
    ce3a:	4ec4      	ldr	r6, [pc, #784]	; (d14c <_vfiprintf_r+0x5f8>)
    ce3c:	46d6      	mov	lr, sl
    ce3e:	2710      	movs	r7, #16
    ce40:	46a2      	mov	sl, r4
    ce42:	4619      	mov	r1, r3
    ce44:	9c06      	ldr	r4, [sp, #24]
    ce46:	e007      	b.n	ce58 <_vfiprintf_r+0x304>
    ce48:	f101 0c02 	add.w	ip, r1, #2
    ce4c:	f10e 0e08 	add.w	lr, lr, #8
    ce50:	4601      	mov	r1, r0
    ce52:	3d10      	subs	r5, #16
    ce54:	2d10      	cmp	r5, #16
    ce56:	dd11      	ble.n	ce7c <_vfiprintf_r+0x328>
    ce58:	1c48      	adds	r0, r1, #1
    ce5a:	3210      	adds	r2, #16
    ce5c:	2807      	cmp	r0, #7
    ce5e:	9211      	str	r2, [sp, #68]	; 0x44
    ce60:	e88e 00c0 	stmia.w	lr, {r6, r7}
    ce64:	9010      	str	r0, [sp, #64]	; 0x40
    ce66:	ddef      	ble.n	ce48 <_vfiprintf_r+0x2f4>
    ce68:	2a00      	cmp	r2, #0
    ce6a:	f040 81e4 	bne.w	d236 <_vfiprintf_r+0x6e2>
    ce6e:	3d10      	subs	r5, #16
    ce70:	2d10      	cmp	r5, #16
    ce72:	4611      	mov	r1, r2
    ce74:	f04f 0c01 	mov.w	ip, #1
    ce78:	46ce      	mov	lr, r9
    ce7a:	dced      	bgt.n	ce58 <_vfiprintf_r+0x304>
    ce7c:	4654      	mov	r4, sl
    ce7e:	4661      	mov	r1, ip
    ce80:	46f2      	mov	sl, lr
    ce82:	442a      	add	r2, r5
    ce84:	2907      	cmp	r1, #7
    ce86:	9211      	str	r2, [sp, #68]	; 0x44
    ce88:	f8ca 6000 	str.w	r6, [sl]
    ce8c:	f8ca 5004 	str.w	r5, [sl, #4]
    ce90:	9110      	str	r1, [sp, #64]	; 0x40
    ce92:	f300 82ec 	bgt.w	d46e <_vfiprintf_r+0x91a>
    ce96:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
    ce9a:	f10a 0a08 	add.w	sl, sl, #8
    ce9e:	1c48      	adds	r0, r1, #1
    cea0:	2d00      	cmp	r5, #0
    cea2:	f040 81de 	bne.w	d262 <_vfiprintf_r+0x70e>
    cea6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    cea8:	2b00      	cmp	r3, #0
    ceaa:	f000 81f8 	beq.w	d29e <_vfiprintf_r+0x74a>
    ceae:	3202      	adds	r2, #2
    ceb0:	a90e      	add	r1, sp, #56	; 0x38
    ceb2:	2302      	movs	r3, #2
    ceb4:	2807      	cmp	r0, #7
    ceb6:	9211      	str	r2, [sp, #68]	; 0x44
    ceb8:	9010      	str	r0, [sp, #64]	; 0x40
    ceba:	e88a 000a 	stmia.w	sl, {r1, r3}
    cebe:	f340 81ea 	ble.w	d296 <_vfiprintf_r+0x742>
    cec2:	2a00      	cmp	r2, #0
    cec4:	f040 838c 	bne.w	d5e0 <_vfiprintf_r+0xa8c>
    cec8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ceca:	2b80      	cmp	r3, #128	; 0x80
    cecc:	f04f 0001 	mov.w	r0, #1
    ced0:	4611      	mov	r1, r2
    ced2:	46ca      	mov	sl, r9
    ced4:	f040 81e7 	bne.w	d2a6 <_vfiprintf_r+0x752>
    ced8:	9b08      	ldr	r3, [sp, #32]
    ceda:	9d01      	ldr	r5, [sp, #4]
    cedc:	1b5e      	subs	r6, r3, r5
    cede:	2e00      	cmp	r6, #0
    cee0:	f340 81e1 	ble.w	d2a6 <_vfiprintf_r+0x752>
    cee4:	2e10      	cmp	r6, #16
    cee6:	4d9a      	ldr	r5, [pc, #616]	; (d150 <_vfiprintf_r+0x5fc>)
    cee8:	f340 8450 	ble.w	d78c <_vfiprintf_r+0xc38>
    ceec:	46d4      	mov	ip, sl
    ceee:	2710      	movs	r7, #16
    cef0:	46a2      	mov	sl, r4
    cef2:	9c06      	ldr	r4, [sp, #24]
    cef4:	e007      	b.n	cf06 <_vfiprintf_r+0x3b2>
    cef6:	f101 0e02 	add.w	lr, r1, #2
    cefa:	f10c 0c08 	add.w	ip, ip, #8
    cefe:	4601      	mov	r1, r0
    cf00:	3e10      	subs	r6, #16
    cf02:	2e10      	cmp	r6, #16
    cf04:	dd11      	ble.n	cf2a <_vfiprintf_r+0x3d6>
    cf06:	1c48      	adds	r0, r1, #1
    cf08:	3210      	adds	r2, #16
    cf0a:	2807      	cmp	r0, #7
    cf0c:	9211      	str	r2, [sp, #68]	; 0x44
    cf0e:	e88c 00a0 	stmia.w	ip, {r5, r7}
    cf12:	9010      	str	r0, [sp, #64]	; 0x40
    cf14:	ddef      	ble.n	cef6 <_vfiprintf_r+0x3a2>
    cf16:	2a00      	cmp	r2, #0
    cf18:	f040 829d 	bne.w	d456 <_vfiprintf_r+0x902>
    cf1c:	3e10      	subs	r6, #16
    cf1e:	2e10      	cmp	r6, #16
    cf20:	f04f 0e01 	mov.w	lr, #1
    cf24:	4611      	mov	r1, r2
    cf26:	46cc      	mov	ip, r9
    cf28:	dced      	bgt.n	cf06 <_vfiprintf_r+0x3b2>
    cf2a:	4654      	mov	r4, sl
    cf2c:	46e2      	mov	sl, ip
    cf2e:	4432      	add	r2, r6
    cf30:	f1be 0f07 	cmp.w	lr, #7
    cf34:	9211      	str	r2, [sp, #68]	; 0x44
    cf36:	e88a 0060 	stmia.w	sl, {r5, r6}
    cf3a:	f8cd e040 	str.w	lr, [sp, #64]	; 0x40
    cf3e:	f300 8369 	bgt.w	d614 <_vfiprintf_r+0xac0>
    cf42:	f10a 0a08 	add.w	sl, sl, #8
    cf46:	f10e 0001 	add.w	r0, lr, #1
    cf4a:	4671      	mov	r1, lr
    cf4c:	e1ab      	b.n	d2a6 <_vfiprintf_r+0x752>
    cf4e:	9608      	str	r6, [sp, #32]
    cf50:	f013 0220 	ands.w	r2, r3, #32
    cf54:	f040 838c 	bne.w	d670 <_vfiprintf_r+0xb1c>
    cf58:	f013 0110 	ands.w	r1, r3, #16
    cf5c:	f040 831a 	bne.w	d594 <_vfiprintf_r+0xa40>
    cf60:	f013 0240 	ands.w	r2, r3, #64	; 0x40
    cf64:	f000 8316 	beq.w	d594 <_vfiprintf_r+0xa40>
    cf68:	9807      	ldr	r0, [sp, #28]
    cf6a:	460a      	mov	r2, r1
    cf6c:	4601      	mov	r1, r0
    cf6e:	3104      	adds	r1, #4
    cf70:	8806      	ldrh	r6, [r0, #0]
    cf72:	9107      	str	r1, [sp, #28]
    cf74:	2700      	movs	r7, #0
    cf76:	e720      	b.n	cdba <_vfiprintf_r+0x266>
    cf78:	9608      	str	r6, [sp, #32]
    cf7a:	f043 0310 	orr.w	r3, r3, #16
    cf7e:	e7e7      	b.n	cf50 <_vfiprintf_r+0x3fc>
    cf80:	9608      	str	r6, [sp, #32]
    cf82:	f043 0310 	orr.w	r3, r3, #16
    cf86:	e708      	b.n	cd9a <_vfiprintf_r+0x246>
    cf88:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    cf8c:	f898 2000 	ldrb.w	r2, [r8]
    cf90:	e652      	b.n	cc38 <_vfiprintf_r+0xe4>
    cf92:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
    cf96:	2600      	movs	r6, #0
    cf98:	f818 2b01 	ldrb.w	r2, [r8], #1
    cf9c:	eb06 0686 	add.w	r6, r6, r6, lsl #2
    cfa0:	eb01 0646 	add.w	r6, r1, r6, lsl #1
    cfa4:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
    cfa8:	2909      	cmp	r1, #9
    cfaa:	d9f5      	bls.n	cf98 <_vfiprintf_r+0x444>
    cfac:	e646      	b.n	cc3c <_vfiprintf_r+0xe8>
    cfae:	9608      	str	r6, [sp, #32]
    cfb0:	2800      	cmp	r0, #0
    cfb2:	f040 8408 	bne.w	d7c6 <_vfiprintf_r+0xc72>
    cfb6:	f043 0310 	orr.w	r3, r3, #16
    cfba:	069e      	lsls	r6, r3, #26
    cfbc:	f100 834c 	bmi.w	d658 <_vfiprintf_r+0xb04>
    cfc0:	06dd      	lsls	r5, r3, #27
    cfc2:	f100 82f3 	bmi.w	d5ac <_vfiprintf_r+0xa58>
    cfc6:	0658      	lsls	r0, r3, #25
    cfc8:	f140 82f0 	bpl.w	d5ac <_vfiprintf_r+0xa58>
    cfcc:	9d07      	ldr	r5, [sp, #28]
    cfce:	f9b5 6000 	ldrsh.w	r6, [r5]
    cfd2:	462a      	mov	r2, r5
    cfd4:	17f7      	asrs	r7, r6, #31
    cfd6:	3204      	adds	r2, #4
    cfd8:	4630      	mov	r0, r6
    cfda:	4639      	mov	r1, r7
    cfdc:	9207      	str	r2, [sp, #28]
    cfde:	2800      	cmp	r0, #0
    cfe0:	f171 0200 	sbcs.w	r2, r1, #0
    cfe4:	f2c0 835d 	blt.w	d6a2 <_vfiprintf_r+0xb4e>
    cfe8:	1c61      	adds	r1, r4, #1
    cfea:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
    cfee:	f04f 0201 	mov.w	r2, #1
    cff2:	f47f aeea 	bne.w	cdca <_vfiprintf_r+0x276>
    cff6:	ea56 0107 	orrs.w	r1, r6, r7
    cffa:	f000 824d 	beq.w	d498 <_vfiprintf_r+0x944>
    cffe:	9302      	str	r3, [sp, #8]
    d000:	2a01      	cmp	r2, #1
    d002:	f000 828c 	beq.w	d51e <_vfiprintf_r+0x9ca>
    d006:	2a02      	cmp	r2, #2
    d008:	f040 825c 	bne.w	d4c4 <_vfiprintf_r+0x970>
    d00c:	980b      	ldr	r0, [sp, #44]	; 0x2c
    d00e:	46cb      	mov	fp, r9
    d010:	0933      	lsrs	r3, r6, #4
    d012:	f006 010f 	and.w	r1, r6, #15
    d016:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
    d01a:	093a      	lsrs	r2, r7, #4
    d01c:	461e      	mov	r6, r3
    d01e:	4617      	mov	r7, r2
    d020:	5c43      	ldrb	r3, [r0, r1]
    d022:	f80b 3d01 	strb.w	r3, [fp, #-1]!
    d026:	ea56 0307 	orrs.w	r3, r6, r7
    d02a:	d1f1      	bne.n	d010 <_vfiprintf_r+0x4bc>
    d02c:	eba9 030b 	sub.w	r3, r9, fp
    d030:	9305      	str	r3, [sp, #20]
    d032:	e6e1      	b.n	cdf8 <_vfiprintf_r+0x2a4>
    d034:	2800      	cmp	r0, #0
    d036:	f040 83c0 	bne.w	d7ba <_vfiprintf_r+0xc66>
    d03a:	0699      	lsls	r1, r3, #26
    d03c:	f100 8367 	bmi.w	d70e <_vfiprintf_r+0xbba>
    d040:	06da      	lsls	r2, r3, #27
    d042:	f100 80f1 	bmi.w	d228 <_vfiprintf_r+0x6d4>
    d046:	065b      	lsls	r3, r3, #25
    d048:	f140 80ee 	bpl.w	d228 <_vfiprintf_r+0x6d4>
    d04c:	9a07      	ldr	r2, [sp, #28]
    d04e:	6813      	ldr	r3, [r2, #0]
    d050:	3204      	adds	r2, #4
    d052:	9207      	str	r2, [sp, #28]
    d054:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    d058:	801a      	strh	r2, [r3, #0]
    d05a:	e5b8      	b.n	cbce <_vfiprintf_r+0x7a>
    d05c:	9807      	ldr	r0, [sp, #28]
    d05e:	4a3d      	ldr	r2, [pc, #244]	; (d154 <_vfiprintf_r+0x600>)
    d060:	9608      	str	r6, [sp, #32]
    d062:	920b      	str	r2, [sp, #44]	; 0x2c
    d064:	6806      	ldr	r6, [r0, #0]
    d066:	2278      	movs	r2, #120	; 0x78
    d068:	2130      	movs	r1, #48	; 0x30
    d06a:	3004      	adds	r0, #4
    d06c:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
    d070:	f043 0302 	orr.w	r3, r3, #2
    d074:	9007      	str	r0, [sp, #28]
    d076:	2700      	movs	r7, #0
    d078:	f88d 1038 	strb.w	r1, [sp, #56]	; 0x38
    d07c:	2202      	movs	r2, #2
    d07e:	e69c      	b.n	cdba <_vfiprintf_r+0x266>
    d080:	9608      	str	r6, [sp, #32]
    d082:	2800      	cmp	r0, #0
    d084:	d099      	beq.n	cfba <_vfiprintf_r+0x466>
    d086:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
    d08a:	e796      	b.n	cfba <_vfiprintf_r+0x466>
    d08c:	f898 2000 	ldrb.w	r2, [r8]
    d090:	2d00      	cmp	r5, #0
    d092:	f47f add1 	bne.w	cc38 <_vfiprintf_r+0xe4>
    d096:	2001      	movs	r0, #1
    d098:	2520      	movs	r5, #32
    d09a:	e5cd      	b.n	cc38 <_vfiprintf_r+0xe4>
    d09c:	f043 0301 	orr.w	r3, r3, #1
    d0a0:	f898 2000 	ldrb.w	r2, [r8]
    d0a4:	e5c8      	b.n	cc38 <_vfiprintf_r+0xe4>
    d0a6:	9608      	str	r6, [sp, #32]
    d0a8:	2800      	cmp	r0, #0
    d0aa:	f040 8393 	bne.w	d7d4 <_vfiprintf_r+0xc80>
    d0ae:	4929      	ldr	r1, [pc, #164]	; (d154 <_vfiprintf_r+0x600>)
    d0b0:	910b      	str	r1, [sp, #44]	; 0x2c
    d0b2:	069f      	lsls	r7, r3, #26
    d0b4:	f100 82e8 	bmi.w	d688 <_vfiprintf_r+0xb34>
    d0b8:	9807      	ldr	r0, [sp, #28]
    d0ba:	06de      	lsls	r6, r3, #27
    d0bc:	4601      	mov	r1, r0
    d0be:	f100 8270 	bmi.w	d5a2 <_vfiprintf_r+0xa4e>
    d0c2:	065d      	lsls	r5, r3, #25
    d0c4:	f140 826d 	bpl.w	d5a2 <_vfiprintf_r+0xa4e>
    d0c8:	3104      	adds	r1, #4
    d0ca:	8806      	ldrh	r6, [r0, #0]
    d0cc:	9107      	str	r1, [sp, #28]
    d0ce:	2700      	movs	r7, #0
    d0d0:	07d8      	lsls	r0, r3, #31
    d0d2:	f140 8222 	bpl.w	d51a <_vfiprintf_r+0x9c6>
    d0d6:	ea56 0107 	orrs.w	r1, r6, r7
    d0da:	f000 821e 	beq.w	d51a <_vfiprintf_r+0x9c6>
    d0de:	2130      	movs	r1, #48	; 0x30
    d0e0:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
    d0e4:	f043 0302 	orr.w	r3, r3, #2
    d0e8:	f88d 1038 	strb.w	r1, [sp, #56]	; 0x38
    d0ec:	2202      	movs	r2, #2
    d0ee:	e664      	b.n	cdba <_vfiprintf_r+0x266>
    d0f0:	9608      	str	r6, [sp, #32]
    d0f2:	2800      	cmp	r0, #0
    d0f4:	f040 836b 	bne.w	d7ce <_vfiprintf_r+0xc7a>
    d0f8:	4917      	ldr	r1, [pc, #92]	; (d158 <_vfiprintf_r+0x604>)
    d0fa:	910b      	str	r1, [sp, #44]	; 0x2c
    d0fc:	e7d9      	b.n	d0b2 <_vfiprintf_r+0x55e>
    d0fe:	9907      	ldr	r1, [sp, #28]
    d100:	9608      	str	r6, [sp, #32]
    d102:	680a      	ldr	r2, [r1, #0]
    d104:	f88d 2048 	strb.w	r2, [sp, #72]	; 0x48
    d108:	f04f 0000 	mov.w	r0, #0
    d10c:	460a      	mov	r2, r1
    d10e:	f88d 0037 	strb.w	r0, [sp, #55]	; 0x37
    d112:	3204      	adds	r2, #4
    d114:	2001      	movs	r0, #1
    d116:	9001      	str	r0, [sp, #4]
    d118:	9207      	str	r2, [sp, #28]
    d11a:	9005      	str	r0, [sp, #20]
    d11c:	f10d 0b48 	add.w	fp, sp, #72	; 0x48
    d120:	9302      	str	r3, [sp, #8]
    d122:	2400      	movs	r4, #0
    d124:	e670      	b.n	ce08 <_vfiprintf_r+0x2b4>
    d126:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d12a:	f898 2000 	ldrb.w	r2, [r8]
    d12e:	e583      	b.n	cc38 <_vfiprintf_r+0xe4>
    d130:	f898 2000 	ldrb.w	r2, [r8]
    d134:	2a6c      	cmp	r2, #108	; 0x6c
    d136:	bf03      	ittte	eq
    d138:	f898 2001 	ldrbeq.w	r2, [r8, #1]
    d13c:	f043 0320 	orreq.w	r3, r3, #32
    d140:	f108 0801 	addeq.w	r8, r8, #1
    d144:	f043 0310 	orrne.w	r3, r3, #16
    d148:	e576      	b.n	cc38 <_vfiprintf_r+0xe4>
    d14a:	bf00      	nop
    d14c:	00012a90 	.word	0x00012a90
    d150:	00012aa0 	.word	0x00012aa0
    d154:	00012a50 	.word	0x00012a50
    d158:	00012a3c 	.word	0x00012a3c
    d15c:	9907      	ldr	r1, [sp, #28]
    d15e:	680e      	ldr	r6, [r1, #0]
    d160:	460a      	mov	r2, r1
    d162:	2e00      	cmp	r6, #0
    d164:	f102 0204 	add.w	r2, r2, #4
    d168:	f6ff ae0f 	blt.w	cd8a <_vfiprintf_r+0x236>
    d16c:	9207      	str	r2, [sp, #28]
    d16e:	f898 2000 	ldrb.w	r2, [r8]
    d172:	e561      	b.n	cc38 <_vfiprintf_r+0xe4>
    d174:	f898 2000 	ldrb.w	r2, [r8]
    d178:	2001      	movs	r0, #1
    d17a:	252b      	movs	r5, #43	; 0x2b
    d17c:	e55c      	b.n	cc38 <_vfiprintf_r+0xe4>
    d17e:	9907      	ldr	r1, [sp, #28]
    d180:	9608      	str	r6, [sp, #32]
    d182:	f8d1 b000 	ldr.w	fp, [r1]
    d186:	f04f 0200 	mov.w	r2, #0
    d18a:	f88d 2037 	strb.w	r2, [sp, #55]	; 0x37
    d18e:	1d0e      	adds	r6, r1, #4
    d190:	f1bb 0f00 	cmp.w	fp, #0
    d194:	f000 82e5 	beq.w	d762 <_vfiprintf_r+0xc0e>
    d198:	1c67      	adds	r7, r4, #1
    d19a:	f000 82c4 	beq.w	d726 <_vfiprintf_r+0xbd2>
    d19e:	4622      	mov	r2, r4
    d1a0:	2100      	movs	r1, #0
    d1a2:	4658      	mov	r0, fp
    d1a4:	9301      	str	r3, [sp, #4]
    d1a6:	f7f3 fb6b 	bl	880 <memchr>
    d1aa:	9b01      	ldr	r3, [sp, #4]
    d1ac:	2800      	cmp	r0, #0
    d1ae:	f000 82e5 	beq.w	d77c <_vfiprintf_r+0xc28>
    d1b2:	eba0 020b 	sub.w	r2, r0, fp
    d1b6:	9205      	str	r2, [sp, #20]
    d1b8:	9607      	str	r6, [sp, #28]
    d1ba:	9302      	str	r3, [sp, #8]
    d1bc:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
    d1c0:	2400      	movs	r4, #0
    d1c2:	e619      	b.n	cdf8 <_vfiprintf_r+0x2a4>
    d1c4:	f898 2000 	ldrb.w	r2, [r8]
    d1c8:	2a2a      	cmp	r2, #42	; 0x2a
    d1ca:	f108 0701 	add.w	r7, r8, #1
    d1ce:	f000 82e9 	beq.w	d7a4 <_vfiprintf_r+0xc50>
    d1d2:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
    d1d6:	2909      	cmp	r1, #9
    d1d8:	46b8      	mov	r8, r7
    d1da:	f04f 0400 	mov.w	r4, #0
    d1de:	f63f ad2d 	bhi.w	cc3c <_vfiprintf_r+0xe8>
    d1e2:	f818 2b01 	ldrb.w	r2, [r8], #1
    d1e6:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    d1ea:	eb01 0444 	add.w	r4, r1, r4, lsl #1
    d1ee:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
    d1f2:	2909      	cmp	r1, #9
    d1f4:	d9f5      	bls.n	d1e2 <_vfiprintf_r+0x68e>
    d1f6:	e521      	b.n	cc3c <_vfiprintf_r+0xe8>
    d1f8:	f043 0320 	orr.w	r3, r3, #32
    d1fc:	f898 2000 	ldrb.w	r2, [r8]
    d200:	e51a      	b.n	cc38 <_vfiprintf_r+0xe4>
    d202:	9608      	str	r6, [sp, #32]
    d204:	2800      	cmp	r0, #0
    d206:	f040 82db 	bne.w	d7c0 <_vfiprintf_r+0xc6c>
    d20a:	2a00      	cmp	r2, #0
    d20c:	f000 80e7 	beq.w	d3de <_vfiprintf_r+0x88a>
    d210:	2101      	movs	r1, #1
    d212:	f88d 2048 	strb.w	r2, [sp, #72]	; 0x48
    d216:	f04f 0200 	mov.w	r2, #0
    d21a:	9101      	str	r1, [sp, #4]
    d21c:	f88d 2037 	strb.w	r2, [sp, #55]	; 0x37
    d220:	9105      	str	r1, [sp, #20]
    d222:	f10d 0b48 	add.w	fp, sp, #72	; 0x48
    d226:	e77b      	b.n	d120 <_vfiprintf_r+0x5cc>
    d228:	9a07      	ldr	r2, [sp, #28]
    d22a:	6813      	ldr	r3, [r2, #0]
    d22c:	3204      	adds	r2, #4
    d22e:	9207      	str	r2, [sp, #28]
    d230:	9a03      	ldr	r2, [sp, #12]
    d232:	601a      	str	r2, [r3, #0]
    d234:	e4cb      	b.n	cbce <_vfiprintf_r+0x7a>
    d236:	aa0f      	add	r2, sp, #60	; 0x3c
    d238:	9904      	ldr	r1, [sp, #16]
    d23a:	4620      	mov	r0, r4
    d23c:	f7ff fc40 	bl	cac0 <__sprint_r.part.0>
    d240:	2800      	cmp	r0, #0
    d242:	f040 8139 	bne.w	d4b8 <_vfiprintf_r+0x964>
    d246:	9910      	ldr	r1, [sp, #64]	; 0x40
    d248:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d24a:	f101 0c01 	add.w	ip, r1, #1
    d24e:	46ce      	mov	lr, r9
    d250:	e5ff      	b.n	ce52 <_vfiprintf_r+0x2fe>
    d252:	9910      	ldr	r1, [sp, #64]	; 0x40
    d254:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d256:	1c48      	adds	r0, r1, #1
    d258:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
    d25c:	2d00      	cmp	r5, #0
    d25e:	f43f ae22 	beq.w	cea6 <_vfiprintf_r+0x352>
    d262:	3201      	adds	r2, #1
    d264:	f10d 0537 	add.w	r5, sp, #55	; 0x37
    d268:	2101      	movs	r1, #1
    d26a:	2807      	cmp	r0, #7
    d26c:	9211      	str	r2, [sp, #68]	; 0x44
    d26e:	9010      	str	r0, [sp, #64]	; 0x40
    d270:	f8ca 5000 	str.w	r5, [sl]
    d274:	f8ca 1004 	str.w	r1, [sl, #4]
    d278:	f340 8108 	ble.w	d48c <_vfiprintf_r+0x938>
    d27c:	2a00      	cmp	r2, #0
    d27e:	f040 81bc 	bne.w	d5fa <_vfiprintf_r+0xaa6>
    d282:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d284:	2b00      	cmp	r3, #0
    d286:	f43f ae1f 	beq.w	cec8 <_vfiprintf_r+0x374>
    d28a:	ab0e      	add	r3, sp, #56	; 0x38
    d28c:	2202      	movs	r2, #2
    d28e:	4608      	mov	r0, r1
    d290:	931c      	str	r3, [sp, #112]	; 0x70
    d292:	921d      	str	r2, [sp, #116]	; 0x74
    d294:	46ca      	mov	sl, r9
    d296:	4601      	mov	r1, r0
    d298:	f10a 0a08 	add.w	sl, sl, #8
    d29c:	3001      	adds	r0, #1
    d29e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d2a0:	2b80      	cmp	r3, #128	; 0x80
    d2a2:	f43f ae19 	beq.w	ced8 <_vfiprintf_r+0x384>
    d2a6:	9b05      	ldr	r3, [sp, #20]
    d2a8:	1ae4      	subs	r4, r4, r3
    d2aa:	2c00      	cmp	r4, #0
    d2ac:	dd2e      	ble.n	d30c <_vfiprintf_r+0x7b8>
    d2ae:	2c10      	cmp	r4, #16
    d2b0:	4db3      	ldr	r5, [pc, #716]	; (d580 <_vfiprintf_r+0xa2c>)
    d2b2:	dd1e      	ble.n	d2f2 <_vfiprintf_r+0x79e>
    d2b4:	46d6      	mov	lr, sl
    d2b6:	2610      	movs	r6, #16
    d2b8:	9f06      	ldr	r7, [sp, #24]
    d2ba:	f8dd a010 	ldr.w	sl, [sp, #16]
    d2be:	e006      	b.n	d2ce <_vfiprintf_r+0x77a>
    d2c0:	1c88      	adds	r0, r1, #2
    d2c2:	f10e 0e08 	add.w	lr, lr, #8
    d2c6:	4619      	mov	r1, r3
    d2c8:	3c10      	subs	r4, #16
    d2ca:	2c10      	cmp	r4, #16
    d2cc:	dd10      	ble.n	d2f0 <_vfiprintf_r+0x79c>
    d2ce:	1c4b      	adds	r3, r1, #1
    d2d0:	3210      	adds	r2, #16
    d2d2:	2b07      	cmp	r3, #7
    d2d4:	9211      	str	r2, [sp, #68]	; 0x44
    d2d6:	e88e 0060 	stmia.w	lr, {r5, r6}
    d2da:	9310      	str	r3, [sp, #64]	; 0x40
    d2dc:	ddf0      	ble.n	d2c0 <_vfiprintf_r+0x76c>
    d2de:	2a00      	cmp	r2, #0
    d2e0:	d165      	bne.n	d3ae <_vfiprintf_r+0x85a>
    d2e2:	3c10      	subs	r4, #16
    d2e4:	2c10      	cmp	r4, #16
    d2e6:	f04f 0001 	mov.w	r0, #1
    d2ea:	4611      	mov	r1, r2
    d2ec:	46ce      	mov	lr, r9
    d2ee:	dcee      	bgt.n	d2ce <_vfiprintf_r+0x77a>
    d2f0:	46f2      	mov	sl, lr
    d2f2:	4422      	add	r2, r4
    d2f4:	2807      	cmp	r0, #7
    d2f6:	9211      	str	r2, [sp, #68]	; 0x44
    d2f8:	f8ca 5000 	str.w	r5, [sl]
    d2fc:	f8ca 4004 	str.w	r4, [sl, #4]
    d300:	9010      	str	r0, [sp, #64]	; 0x40
    d302:	f300 8085 	bgt.w	d410 <_vfiprintf_r+0x8bc>
    d306:	f10a 0a08 	add.w	sl, sl, #8
    d30a:	3001      	adds	r0, #1
    d30c:	9905      	ldr	r1, [sp, #20]
    d30e:	f8ca b000 	str.w	fp, [sl]
    d312:	440a      	add	r2, r1
    d314:	2807      	cmp	r0, #7
    d316:	9211      	str	r2, [sp, #68]	; 0x44
    d318:	f8ca 1004 	str.w	r1, [sl, #4]
    d31c:	9010      	str	r0, [sp, #64]	; 0x40
    d31e:	f340 8082 	ble.w	d426 <_vfiprintf_r+0x8d2>
    d322:	2a00      	cmp	r2, #0
    d324:	f040 8118 	bne.w	d558 <_vfiprintf_r+0xa04>
    d328:	9b02      	ldr	r3, [sp, #8]
    d32a:	9210      	str	r2, [sp, #64]	; 0x40
    d32c:	0758      	lsls	r0, r3, #29
    d32e:	d535      	bpl.n	d39c <_vfiprintf_r+0x848>
    d330:	9b08      	ldr	r3, [sp, #32]
    d332:	9901      	ldr	r1, [sp, #4]
    d334:	1a5c      	subs	r4, r3, r1
    d336:	2c00      	cmp	r4, #0
    d338:	f340 80e7 	ble.w	d50a <_vfiprintf_r+0x9b6>
    d33c:	46ca      	mov	sl, r9
    d33e:	2c10      	cmp	r4, #16
    d340:	f340 8218 	ble.w	d774 <_vfiprintf_r+0xc20>
    d344:	9910      	ldr	r1, [sp, #64]	; 0x40
    d346:	4e8f      	ldr	r6, [pc, #572]	; (d584 <_vfiprintf_r+0xa30>)
    d348:	9f06      	ldr	r7, [sp, #24]
    d34a:	f8dd b010 	ldr.w	fp, [sp, #16]
    d34e:	2510      	movs	r5, #16
    d350:	e006      	b.n	d360 <_vfiprintf_r+0x80c>
    d352:	1c88      	adds	r0, r1, #2
    d354:	f10a 0a08 	add.w	sl, sl, #8
    d358:	4619      	mov	r1, r3
    d35a:	3c10      	subs	r4, #16
    d35c:	2c10      	cmp	r4, #16
    d35e:	dd11      	ble.n	d384 <_vfiprintf_r+0x830>
    d360:	1c4b      	adds	r3, r1, #1
    d362:	3210      	adds	r2, #16
    d364:	2b07      	cmp	r3, #7
    d366:	9211      	str	r2, [sp, #68]	; 0x44
    d368:	f8ca 6000 	str.w	r6, [sl]
    d36c:	f8ca 5004 	str.w	r5, [sl, #4]
    d370:	9310      	str	r3, [sp, #64]	; 0x40
    d372:	ddee      	ble.n	d352 <_vfiprintf_r+0x7fe>
    d374:	bb42      	cbnz	r2, d3c8 <_vfiprintf_r+0x874>
    d376:	3c10      	subs	r4, #16
    d378:	2c10      	cmp	r4, #16
    d37a:	f04f 0001 	mov.w	r0, #1
    d37e:	4611      	mov	r1, r2
    d380:	46ca      	mov	sl, r9
    d382:	dced      	bgt.n	d360 <_vfiprintf_r+0x80c>
    d384:	4422      	add	r2, r4
    d386:	2807      	cmp	r0, #7
    d388:	9211      	str	r2, [sp, #68]	; 0x44
    d38a:	f8ca 6000 	str.w	r6, [sl]
    d38e:	f8ca 4004 	str.w	r4, [sl, #4]
    d392:	9010      	str	r0, [sp, #64]	; 0x40
    d394:	dd51      	ble.n	d43a <_vfiprintf_r+0x8e6>
    d396:	2a00      	cmp	r2, #0
    d398:	f040 819b 	bne.w	d6d2 <_vfiprintf_r+0xb7e>
    d39c:	9b03      	ldr	r3, [sp, #12]
    d39e:	9a08      	ldr	r2, [sp, #32]
    d3a0:	9901      	ldr	r1, [sp, #4]
    d3a2:	428a      	cmp	r2, r1
    d3a4:	bfac      	ite	ge
    d3a6:	189b      	addge	r3, r3, r2
    d3a8:	185b      	addlt	r3, r3, r1
    d3aa:	9303      	str	r3, [sp, #12]
    d3ac:	e04e      	b.n	d44c <_vfiprintf_r+0x8f8>
    d3ae:	aa0f      	add	r2, sp, #60	; 0x3c
    d3b0:	4651      	mov	r1, sl
    d3b2:	4638      	mov	r0, r7
    d3b4:	f7ff fb84 	bl	cac0 <__sprint_r.part.0>
    d3b8:	2800      	cmp	r0, #0
    d3ba:	f040 813f 	bne.w	d63c <_vfiprintf_r+0xae8>
    d3be:	9910      	ldr	r1, [sp, #64]	; 0x40
    d3c0:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d3c2:	1c48      	adds	r0, r1, #1
    d3c4:	46ce      	mov	lr, r9
    d3c6:	e77f      	b.n	d2c8 <_vfiprintf_r+0x774>
    d3c8:	aa0f      	add	r2, sp, #60	; 0x3c
    d3ca:	4659      	mov	r1, fp
    d3cc:	4638      	mov	r0, r7
    d3ce:	f7ff fb77 	bl	cac0 <__sprint_r.part.0>
    d3d2:	b960      	cbnz	r0, d3ee <_vfiprintf_r+0x89a>
    d3d4:	9910      	ldr	r1, [sp, #64]	; 0x40
    d3d6:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d3d8:	1c48      	adds	r0, r1, #1
    d3da:	46ca      	mov	sl, r9
    d3dc:	e7bd      	b.n	d35a <_vfiprintf_r+0x806>
    d3de:	9b11      	ldr	r3, [sp, #68]	; 0x44
    d3e0:	f8dd b010 	ldr.w	fp, [sp, #16]
    d3e4:	2b00      	cmp	r3, #0
    d3e6:	f040 81d4 	bne.w	d792 <_vfiprintf_r+0xc3e>
    d3ea:	2300      	movs	r3, #0
    d3ec:	9310      	str	r3, [sp, #64]	; 0x40
    d3ee:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
    d3f2:	f013 0f01 	tst.w	r3, #1
    d3f6:	f8bb 300c 	ldrh.w	r3, [fp, #12]
    d3fa:	d102      	bne.n	d402 <_vfiprintf_r+0x8ae>
    d3fc:	059a      	lsls	r2, r3, #22
    d3fe:	f140 80de 	bpl.w	d5be <_vfiprintf_r+0xa6a>
    d402:	065b      	lsls	r3, r3, #25
    d404:	f53f acb2 	bmi.w	cd6c <_vfiprintf_r+0x218>
    d408:	9803      	ldr	r0, [sp, #12]
    d40a:	b02d      	add	sp, #180	; 0xb4
    d40c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d410:	2a00      	cmp	r2, #0
    d412:	f040 8106 	bne.w	d622 <_vfiprintf_r+0xace>
    d416:	9a05      	ldr	r2, [sp, #20]
    d418:	921d      	str	r2, [sp, #116]	; 0x74
    d41a:	2301      	movs	r3, #1
    d41c:	9211      	str	r2, [sp, #68]	; 0x44
    d41e:	f8cd b070 	str.w	fp, [sp, #112]	; 0x70
    d422:	9310      	str	r3, [sp, #64]	; 0x40
    d424:	46ca      	mov	sl, r9
    d426:	f10a 0a08 	add.w	sl, sl, #8
    d42a:	9b02      	ldr	r3, [sp, #8]
    d42c:	0759      	lsls	r1, r3, #29
    d42e:	d504      	bpl.n	d43a <_vfiprintf_r+0x8e6>
    d430:	9b08      	ldr	r3, [sp, #32]
    d432:	9901      	ldr	r1, [sp, #4]
    d434:	1a5c      	subs	r4, r3, r1
    d436:	2c00      	cmp	r4, #0
    d438:	dc81      	bgt.n	d33e <_vfiprintf_r+0x7ea>
    d43a:	9b03      	ldr	r3, [sp, #12]
    d43c:	9908      	ldr	r1, [sp, #32]
    d43e:	9801      	ldr	r0, [sp, #4]
    d440:	4281      	cmp	r1, r0
    d442:	bfac      	ite	ge
    d444:	185b      	addge	r3, r3, r1
    d446:	181b      	addlt	r3, r3, r0
    d448:	9303      	str	r3, [sp, #12]
    d44a:	bb72      	cbnz	r2, d4aa <_vfiprintf_r+0x956>
    d44c:	2300      	movs	r3, #0
    d44e:	9310      	str	r3, [sp, #64]	; 0x40
    d450:	46ca      	mov	sl, r9
    d452:	f7ff bbbc 	b.w	cbce <_vfiprintf_r+0x7a>
    d456:	aa0f      	add	r2, sp, #60	; 0x3c
    d458:	9904      	ldr	r1, [sp, #16]
    d45a:	4620      	mov	r0, r4
    d45c:	f7ff fb30 	bl	cac0 <__sprint_r.part.0>
    d460:	bb50      	cbnz	r0, d4b8 <_vfiprintf_r+0x964>
    d462:	9910      	ldr	r1, [sp, #64]	; 0x40
    d464:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d466:	f101 0e01 	add.w	lr, r1, #1
    d46a:	46cc      	mov	ip, r9
    d46c:	e548      	b.n	cf00 <_vfiprintf_r+0x3ac>
    d46e:	2a00      	cmp	r2, #0
    d470:	f040 8140 	bne.w	d6f4 <_vfiprintf_r+0xba0>
    d474:	f89d 1037 	ldrb.w	r1, [sp, #55]	; 0x37
    d478:	2900      	cmp	r1, #0
    d47a:	f000 811b 	beq.w	d6b4 <_vfiprintf_r+0xb60>
    d47e:	2201      	movs	r2, #1
    d480:	f10d 0137 	add.w	r1, sp, #55	; 0x37
    d484:	4610      	mov	r0, r2
    d486:	921d      	str	r2, [sp, #116]	; 0x74
    d488:	911c      	str	r1, [sp, #112]	; 0x70
    d48a:	46ca      	mov	sl, r9
    d48c:	4601      	mov	r1, r0
    d48e:	f10a 0a08 	add.w	sl, sl, #8
    d492:	3001      	adds	r0, #1
    d494:	e507      	b.n	cea6 <_vfiprintf_r+0x352>
    d496:	9b02      	ldr	r3, [sp, #8]
    d498:	2a01      	cmp	r2, #1
    d49a:	f000 8098 	beq.w	d5ce <_vfiprintf_r+0xa7a>
    d49e:	2a02      	cmp	r2, #2
    d4a0:	d10d      	bne.n	d4be <_vfiprintf_r+0x96a>
    d4a2:	9302      	str	r3, [sp, #8]
    d4a4:	2600      	movs	r6, #0
    d4a6:	2700      	movs	r7, #0
    d4a8:	e5b0      	b.n	d00c <_vfiprintf_r+0x4b8>
    d4aa:	aa0f      	add	r2, sp, #60	; 0x3c
    d4ac:	9904      	ldr	r1, [sp, #16]
    d4ae:	9806      	ldr	r0, [sp, #24]
    d4b0:	f7ff fb06 	bl	cac0 <__sprint_r.part.0>
    d4b4:	2800      	cmp	r0, #0
    d4b6:	d0c9      	beq.n	d44c <_vfiprintf_r+0x8f8>
    d4b8:	f8dd b010 	ldr.w	fp, [sp, #16]
    d4bc:	e797      	b.n	d3ee <_vfiprintf_r+0x89a>
    d4be:	9302      	str	r3, [sp, #8]
    d4c0:	2600      	movs	r6, #0
    d4c2:	2700      	movs	r7, #0
    d4c4:	4649      	mov	r1, r9
    d4c6:	e000      	b.n	d4ca <_vfiprintf_r+0x976>
    d4c8:	4659      	mov	r1, fp
    d4ca:	08f2      	lsrs	r2, r6, #3
    d4cc:	ea42 7247 	orr.w	r2, r2, r7, lsl #29
    d4d0:	08f8      	lsrs	r0, r7, #3
    d4d2:	f006 0307 	and.w	r3, r6, #7
    d4d6:	4607      	mov	r7, r0
    d4d8:	4616      	mov	r6, r2
    d4da:	3330      	adds	r3, #48	; 0x30
    d4dc:	ea56 0207 	orrs.w	r2, r6, r7
    d4e0:	f801 3c01 	strb.w	r3, [r1, #-1]
    d4e4:	f101 3bff 	add.w	fp, r1, #4294967295	; 0xffffffff
    d4e8:	d1ee      	bne.n	d4c8 <_vfiprintf_r+0x974>
    d4ea:	9a02      	ldr	r2, [sp, #8]
    d4ec:	07d6      	lsls	r6, r2, #31
    d4ee:	f57f ad9d 	bpl.w	d02c <_vfiprintf_r+0x4d8>
    d4f2:	2b30      	cmp	r3, #48	; 0x30
    d4f4:	f43f ad9a 	beq.w	d02c <_vfiprintf_r+0x4d8>
    d4f8:	3902      	subs	r1, #2
    d4fa:	2330      	movs	r3, #48	; 0x30
    d4fc:	f80b 3c01 	strb.w	r3, [fp, #-1]
    d500:	eba9 0301 	sub.w	r3, r9, r1
    d504:	9305      	str	r3, [sp, #20]
    d506:	468b      	mov	fp, r1
    d508:	e476      	b.n	cdf8 <_vfiprintf_r+0x2a4>
    d50a:	9b03      	ldr	r3, [sp, #12]
    d50c:	9a08      	ldr	r2, [sp, #32]
    d50e:	428a      	cmp	r2, r1
    d510:	bfac      	ite	ge
    d512:	189b      	addge	r3, r3, r2
    d514:	185b      	addlt	r3, r3, r1
    d516:	9303      	str	r3, [sp, #12]
    d518:	e798      	b.n	d44c <_vfiprintf_r+0x8f8>
    d51a:	2202      	movs	r2, #2
    d51c:	e44d      	b.n	cdba <_vfiprintf_r+0x266>
    d51e:	2f00      	cmp	r7, #0
    d520:	bf08      	it	eq
    d522:	2e0a      	cmpeq	r6, #10
    d524:	d352      	bcc.n	d5cc <_vfiprintf_r+0xa78>
    d526:	46cb      	mov	fp, r9
    d528:	4630      	mov	r0, r6
    d52a:	4639      	mov	r1, r7
    d52c:	220a      	movs	r2, #10
    d52e:	2300      	movs	r3, #0
    d530:	f7f3 ffa4 	bl	147c <__aeabi_uldivmod>
    d534:	3230      	adds	r2, #48	; 0x30
    d536:	f80b 2d01 	strb.w	r2, [fp, #-1]!
    d53a:	4630      	mov	r0, r6
    d53c:	4639      	mov	r1, r7
    d53e:	2300      	movs	r3, #0
    d540:	220a      	movs	r2, #10
    d542:	f7f3 ff9b 	bl	147c <__aeabi_uldivmod>
    d546:	4606      	mov	r6, r0
    d548:	460f      	mov	r7, r1
    d54a:	ea56 0307 	orrs.w	r3, r6, r7
    d54e:	d1eb      	bne.n	d528 <_vfiprintf_r+0x9d4>
    d550:	e56c      	b.n	d02c <_vfiprintf_r+0x4d8>
    d552:	9405      	str	r4, [sp, #20]
    d554:	46cb      	mov	fp, r9
    d556:	e44f      	b.n	cdf8 <_vfiprintf_r+0x2a4>
    d558:	aa0f      	add	r2, sp, #60	; 0x3c
    d55a:	9904      	ldr	r1, [sp, #16]
    d55c:	9806      	ldr	r0, [sp, #24]
    d55e:	f7ff faaf 	bl	cac0 <__sprint_r.part.0>
    d562:	2800      	cmp	r0, #0
    d564:	d1a8      	bne.n	d4b8 <_vfiprintf_r+0x964>
    d566:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d568:	46ca      	mov	sl, r9
    d56a:	e75e      	b.n	d42a <_vfiprintf_r+0x8d6>
    d56c:	aa0f      	add	r2, sp, #60	; 0x3c
    d56e:	9904      	ldr	r1, [sp, #16]
    d570:	9806      	ldr	r0, [sp, #24]
    d572:	f7ff faa5 	bl	cac0 <__sprint_r.part.0>
    d576:	2800      	cmp	r0, #0
    d578:	d19e      	bne.n	d4b8 <_vfiprintf_r+0x964>
    d57a:	46ca      	mov	sl, r9
    d57c:	f7ff bbc0 	b.w	cd00 <_vfiprintf_r+0x1ac>
    d580:	00012aa0 	.word	0x00012aa0
    d584:	00012a90 	.word	0x00012a90
    d588:	3104      	adds	r1, #4
    d58a:	6816      	ldr	r6, [r2, #0]
    d58c:	9107      	str	r1, [sp, #28]
    d58e:	2201      	movs	r2, #1
    d590:	2700      	movs	r7, #0
    d592:	e412      	b.n	cdba <_vfiprintf_r+0x266>
    d594:	9807      	ldr	r0, [sp, #28]
    d596:	4601      	mov	r1, r0
    d598:	3104      	adds	r1, #4
    d59a:	6806      	ldr	r6, [r0, #0]
    d59c:	9107      	str	r1, [sp, #28]
    d59e:	2700      	movs	r7, #0
    d5a0:	e40b      	b.n	cdba <_vfiprintf_r+0x266>
    d5a2:	680e      	ldr	r6, [r1, #0]
    d5a4:	3104      	adds	r1, #4
    d5a6:	9107      	str	r1, [sp, #28]
    d5a8:	2700      	movs	r7, #0
    d5aa:	e591      	b.n	d0d0 <_vfiprintf_r+0x57c>
    d5ac:	9907      	ldr	r1, [sp, #28]
    d5ae:	680e      	ldr	r6, [r1, #0]
    d5b0:	460a      	mov	r2, r1
    d5b2:	17f7      	asrs	r7, r6, #31
    d5b4:	3204      	adds	r2, #4
    d5b6:	9207      	str	r2, [sp, #28]
    d5b8:	4630      	mov	r0, r6
    d5ba:	4639      	mov	r1, r7
    d5bc:	e50f      	b.n	cfde <_vfiprintf_r+0x48a>
    d5be:	f8db 0058 	ldr.w	r0, [fp, #88]	; 0x58
    d5c2:	f7fd fbbb 	bl	ad3c <__retarget_lock_release_recursive>
    d5c6:	f8bb 300c 	ldrh.w	r3, [fp, #12]
    d5ca:	e71a      	b.n	d402 <_vfiprintf_r+0x8ae>
    d5cc:	9b02      	ldr	r3, [sp, #8]
    d5ce:	9302      	str	r3, [sp, #8]
    d5d0:	f10d 0bb0 	add.w	fp, sp, #176	; 0xb0
    d5d4:	3630      	adds	r6, #48	; 0x30
    d5d6:	2301      	movs	r3, #1
    d5d8:	f80b 6d41 	strb.w	r6, [fp, #-65]!
    d5dc:	9305      	str	r3, [sp, #20]
    d5de:	e40b      	b.n	cdf8 <_vfiprintf_r+0x2a4>
    d5e0:	aa0f      	add	r2, sp, #60	; 0x3c
    d5e2:	9904      	ldr	r1, [sp, #16]
    d5e4:	9806      	ldr	r0, [sp, #24]
    d5e6:	f7ff fa6b 	bl	cac0 <__sprint_r.part.0>
    d5ea:	2800      	cmp	r0, #0
    d5ec:	f47f af64 	bne.w	d4b8 <_vfiprintf_r+0x964>
    d5f0:	9910      	ldr	r1, [sp, #64]	; 0x40
    d5f2:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d5f4:	1c48      	adds	r0, r1, #1
    d5f6:	46ca      	mov	sl, r9
    d5f8:	e651      	b.n	d29e <_vfiprintf_r+0x74a>
    d5fa:	aa0f      	add	r2, sp, #60	; 0x3c
    d5fc:	9904      	ldr	r1, [sp, #16]
    d5fe:	9806      	ldr	r0, [sp, #24]
    d600:	f7ff fa5e 	bl	cac0 <__sprint_r.part.0>
    d604:	2800      	cmp	r0, #0
    d606:	f47f af57 	bne.w	d4b8 <_vfiprintf_r+0x964>
    d60a:	9910      	ldr	r1, [sp, #64]	; 0x40
    d60c:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d60e:	1c48      	adds	r0, r1, #1
    d610:	46ca      	mov	sl, r9
    d612:	e448      	b.n	cea6 <_vfiprintf_r+0x352>
    d614:	2a00      	cmp	r2, #0
    d616:	f040 8091 	bne.w	d73c <_vfiprintf_r+0xbe8>
    d61a:	2001      	movs	r0, #1
    d61c:	4611      	mov	r1, r2
    d61e:	46ca      	mov	sl, r9
    d620:	e641      	b.n	d2a6 <_vfiprintf_r+0x752>
    d622:	aa0f      	add	r2, sp, #60	; 0x3c
    d624:	9904      	ldr	r1, [sp, #16]
    d626:	9806      	ldr	r0, [sp, #24]
    d628:	f7ff fa4a 	bl	cac0 <__sprint_r.part.0>
    d62c:	2800      	cmp	r0, #0
    d62e:	f47f af43 	bne.w	d4b8 <_vfiprintf_r+0x964>
    d632:	9810      	ldr	r0, [sp, #64]	; 0x40
    d634:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d636:	3001      	adds	r0, #1
    d638:	46ca      	mov	sl, r9
    d63a:	e667      	b.n	d30c <_vfiprintf_r+0x7b8>
    d63c:	46d3      	mov	fp, sl
    d63e:	e6d6      	b.n	d3ee <_vfiprintf_r+0x89a>
    d640:	9e07      	ldr	r6, [sp, #28]
    d642:	3607      	adds	r6, #7
    d644:	f026 0207 	bic.w	r2, r6, #7
    d648:	f102 0108 	add.w	r1, r2, #8
    d64c:	e9d2 6700 	ldrd	r6, r7, [r2]
    d650:	9107      	str	r1, [sp, #28]
    d652:	2201      	movs	r2, #1
    d654:	f7ff bbb1 	b.w	cdba <_vfiprintf_r+0x266>
    d658:	9e07      	ldr	r6, [sp, #28]
    d65a:	3607      	adds	r6, #7
    d65c:	f026 0607 	bic.w	r6, r6, #7
    d660:	e9d6 0100 	ldrd	r0, r1, [r6]
    d664:	f106 0208 	add.w	r2, r6, #8
    d668:	9207      	str	r2, [sp, #28]
    d66a:	4606      	mov	r6, r0
    d66c:	460f      	mov	r7, r1
    d66e:	e4b6      	b.n	cfde <_vfiprintf_r+0x48a>
    d670:	9e07      	ldr	r6, [sp, #28]
    d672:	3607      	adds	r6, #7
    d674:	f026 0207 	bic.w	r2, r6, #7
    d678:	f102 0108 	add.w	r1, r2, #8
    d67c:	e9d2 6700 	ldrd	r6, r7, [r2]
    d680:	9107      	str	r1, [sp, #28]
    d682:	2200      	movs	r2, #0
    d684:	f7ff bb99 	b.w	cdba <_vfiprintf_r+0x266>
    d688:	9e07      	ldr	r6, [sp, #28]
    d68a:	3607      	adds	r6, #7
    d68c:	f026 0107 	bic.w	r1, r6, #7
    d690:	f101 0008 	add.w	r0, r1, #8
    d694:	9007      	str	r0, [sp, #28]
    d696:	e9d1 6700 	ldrd	r6, r7, [r1]
    d69a:	e519      	b.n	d0d0 <_vfiprintf_r+0x57c>
    d69c:	46cb      	mov	fp, r9
    d69e:	f7ff bbab 	b.w	cdf8 <_vfiprintf_r+0x2a4>
    d6a2:	252d      	movs	r5, #45	; 0x2d
    d6a4:	4276      	negs	r6, r6
    d6a6:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
    d6aa:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
    d6ae:	2201      	movs	r2, #1
    d6b0:	f7ff bb88 	b.w	cdc4 <_vfiprintf_r+0x270>
    d6b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d6b6:	b9b3      	cbnz	r3, d6e6 <_vfiprintf_r+0xb92>
    d6b8:	4611      	mov	r1, r2
    d6ba:	2001      	movs	r0, #1
    d6bc:	46ca      	mov	sl, r9
    d6be:	e5f2      	b.n	d2a6 <_vfiprintf_r+0x752>
    d6c0:	f8db 0058 	ldr.w	r0, [fp, #88]	; 0x58
    d6c4:	f7fd fb3a 	bl	ad3c <__retarget_lock_release_recursive>
    d6c8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d6cc:	9303      	str	r3, [sp, #12]
    d6ce:	f7ff bb50 	b.w	cd72 <_vfiprintf_r+0x21e>
    d6d2:	aa0f      	add	r2, sp, #60	; 0x3c
    d6d4:	9904      	ldr	r1, [sp, #16]
    d6d6:	9806      	ldr	r0, [sp, #24]
    d6d8:	f7ff f9f2 	bl	cac0 <__sprint_r.part.0>
    d6dc:	2800      	cmp	r0, #0
    d6de:	f47f aeeb 	bne.w	d4b8 <_vfiprintf_r+0x964>
    d6e2:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d6e4:	e6a9      	b.n	d43a <_vfiprintf_r+0x8e6>
    d6e6:	ab0e      	add	r3, sp, #56	; 0x38
    d6e8:	2202      	movs	r2, #2
    d6ea:	931c      	str	r3, [sp, #112]	; 0x70
    d6ec:	921d      	str	r2, [sp, #116]	; 0x74
    d6ee:	2001      	movs	r0, #1
    d6f0:	46ca      	mov	sl, r9
    d6f2:	e5d0      	b.n	d296 <_vfiprintf_r+0x742>
    d6f4:	aa0f      	add	r2, sp, #60	; 0x3c
    d6f6:	9904      	ldr	r1, [sp, #16]
    d6f8:	9806      	ldr	r0, [sp, #24]
    d6fa:	f7ff f9e1 	bl	cac0 <__sprint_r.part.0>
    d6fe:	2800      	cmp	r0, #0
    d700:	f47f aeda 	bne.w	d4b8 <_vfiprintf_r+0x964>
    d704:	9910      	ldr	r1, [sp, #64]	; 0x40
    d706:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d708:	1c48      	adds	r0, r1, #1
    d70a:	46ca      	mov	sl, r9
    d70c:	e5a4      	b.n	d258 <_vfiprintf_r+0x704>
    d70e:	9a07      	ldr	r2, [sp, #28]
    d710:	9903      	ldr	r1, [sp, #12]
    d712:	6813      	ldr	r3, [r2, #0]
    d714:	17cd      	asrs	r5, r1, #31
    d716:	4608      	mov	r0, r1
    d718:	3204      	adds	r2, #4
    d71a:	4629      	mov	r1, r5
    d71c:	9207      	str	r2, [sp, #28]
    d71e:	e9c3 0100 	strd	r0, r1, [r3]
    d722:	f7ff ba54 	b.w	cbce <_vfiprintf_r+0x7a>
    d726:	4658      	mov	r0, fp
    d728:	9607      	str	r6, [sp, #28]
    d72a:	9302      	str	r3, [sp, #8]
    d72c:	f7f3 f9a8 	bl	a80 <strlen>
    d730:	2400      	movs	r4, #0
    d732:	9005      	str	r0, [sp, #20]
    d734:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
    d738:	f7ff bb5e 	b.w	cdf8 <_vfiprintf_r+0x2a4>
    d73c:	aa0f      	add	r2, sp, #60	; 0x3c
    d73e:	9904      	ldr	r1, [sp, #16]
    d740:	9806      	ldr	r0, [sp, #24]
    d742:	f7ff f9bd 	bl	cac0 <__sprint_r.part.0>
    d746:	2800      	cmp	r0, #0
    d748:	f47f aeb6 	bne.w	d4b8 <_vfiprintf_r+0x964>
    d74c:	9910      	ldr	r1, [sp, #64]	; 0x40
    d74e:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d750:	1c48      	adds	r0, r1, #1
    d752:	46ca      	mov	sl, r9
    d754:	e5a7      	b.n	d2a6 <_vfiprintf_r+0x752>
    d756:	9910      	ldr	r1, [sp, #64]	; 0x40
    d758:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d75a:	4e20      	ldr	r6, [pc, #128]	; (d7dc <_vfiprintf_r+0xc88>)
    d75c:	3101      	adds	r1, #1
    d75e:	f7ff bb90 	b.w	ce82 <_vfiprintf_r+0x32e>
    d762:	2c06      	cmp	r4, #6
    d764:	bf28      	it	cs
    d766:	2406      	movcs	r4, #6
    d768:	9405      	str	r4, [sp, #20]
    d76a:	9607      	str	r6, [sp, #28]
    d76c:	9401      	str	r4, [sp, #4]
    d76e:	f8df b070 	ldr.w	fp, [pc, #112]	; d7e0 <_vfiprintf_r+0xc8c>
    d772:	e4d5      	b.n	d120 <_vfiprintf_r+0x5cc>
    d774:	9810      	ldr	r0, [sp, #64]	; 0x40
    d776:	4e19      	ldr	r6, [pc, #100]	; (d7dc <_vfiprintf_r+0xc88>)
    d778:	3001      	adds	r0, #1
    d77a:	e603      	b.n	d384 <_vfiprintf_r+0x830>
    d77c:	9405      	str	r4, [sp, #20]
    d77e:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
    d782:	9607      	str	r6, [sp, #28]
    d784:	9302      	str	r3, [sp, #8]
    d786:	4604      	mov	r4, r0
    d788:	f7ff bb36 	b.w	cdf8 <_vfiprintf_r+0x2a4>
    d78c:	4686      	mov	lr, r0
    d78e:	f7ff bbce 	b.w	cf2e <_vfiprintf_r+0x3da>
    d792:	9806      	ldr	r0, [sp, #24]
    d794:	aa0f      	add	r2, sp, #60	; 0x3c
    d796:	4659      	mov	r1, fp
    d798:	f7ff f992 	bl	cac0 <__sprint_r.part.0>
    d79c:	2800      	cmp	r0, #0
    d79e:	f43f ae24 	beq.w	d3ea <_vfiprintf_r+0x896>
    d7a2:	e624      	b.n	d3ee <_vfiprintf_r+0x89a>
    d7a4:	9907      	ldr	r1, [sp, #28]
    d7a6:	f898 2001 	ldrb.w	r2, [r8, #1]
    d7aa:	680c      	ldr	r4, [r1, #0]
    d7ac:	3104      	adds	r1, #4
    d7ae:	ea44 74e4 	orr.w	r4, r4, r4, asr #31
    d7b2:	46b8      	mov	r8, r7
    d7b4:	9107      	str	r1, [sp, #28]
    d7b6:	f7ff ba3f 	b.w	cc38 <_vfiprintf_r+0xe4>
    d7ba:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
    d7be:	e43c      	b.n	d03a <_vfiprintf_r+0x4e6>
    d7c0:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
    d7c4:	e521      	b.n	d20a <_vfiprintf_r+0x6b6>
    d7c6:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
    d7ca:	f7ff bbf4 	b.w	cfb6 <_vfiprintf_r+0x462>
    d7ce:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
    d7d2:	e491      	b.n	d0f8 <_vfiprintf_r+0x5a4>
    d7d4:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
    d7d8:	e469      	b.n	d0ae <_vfiprintf_r+0x55a>
    d7da:	bf00      	nop
    d7dc:	00012a90 	.word	0x00012a90
    d7e0:	00012a64 	.word	0x00012a64

0000d7e4 <__sbprintf>:
    d7e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    d7e8:	460c      	mov	r4, r1
    d7ea:	f5ad 6d8d 	sub.w	sp, sp, #1128	; 0x468
    d7ee:	8989      	ldrh	r1, [r1, #12]
    d7f0:	6e66      	ldr	r6, [r4, #100]	; 0x64
    d7f2:	89e5      	ldrh	r5, [r4, #14]
    d7f4:	9619      	str	r6, [sp, #100]	; 0x64
    d7f6:	f021 0102 	bic.w	r1, r1, #2
    d7fa:	4606      	mov	r6, r0
    d7fc:	69e0      	ldr	r0, [r4, #28]
    d7fe:	f8ad 100c 	strh.w	r1, [sp, #12]
    d802:	4617      	mov	r7, r2
    d804:	f44f 6180 	mov.w	r1, #1024	; 0x400
    d808:	6a62      	ldr	r2, [r4, #36]	; 0x24
    d80a:	f8ad 500e 	strh.w	r5, [sp, #14]
    d80e:	4698      	mov	r8, r3
    d810:	ad1a      	add	r5, sp, #104	; 0x68
    d812:	2300      	movs	r3, #0
    d814:	9007      	str	r0, [sp, #28]
    d816:	a816      	add	r0, sp, #88	; 0x58
    d818:	9209      	str	r2, [sp, #36]	; 0x24
    d81a:	9306      	str	r3, [sp, #24]
    d81c:	9500      	str	r5, [sp, #0]
    d81e:	9504      	str	r5, [sp, #16]
    d820:	9102      	str	r1, [sp, #8]
    d822:	9105      	str	r1, [sp, #20]
    d824:	f7fd fa84 	bl	ad30 <__retarget_lock_init_recursive>
    d828:	4643      	mov	r3, r8
    d82a:	463a      	mov	r2, r7
    d82c:	4669      	mov	r1, sp
    d82e:	4630      	mov	r0, r6
    d830:	f7ff f990 	bl	cb54 <_vfiprintf_r>
    d834:	1e05      	subs	r5, r0, #0
    d836:	db07      	blt.n	d848 <__sbprintf+0x64>
    d838:	4630      	mov	r0, r6
    d83a:	4669      	mov	r1, sp
    d83c:	f7fc fea0 	bl	a580 <_fflush_r>
    d840:	2800      	cmp	r0, #0
    d842:	bf18      	it	ne
    d844:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
    d848:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    d84c:	065b      	lsls	r3, r3, #25
    d84e:	d503      	bpl.n	d858 <__sbprintf+0x74>
    d850:	89a3      	ldrh	r3, [r4, #12]
    d852:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d856:	81a3      	strh	r3, [r4, #12]
    d858:	9816      	ldr	r0, [sp, #88]	; 0x58
    d85a:	f7fd fa6b 	bl	ad34 <__retarget_lock_close_recursive>
    d85e:	4628      	mov	r0, r5
    d860:	f50d 6d8d 	add.w	sp, sp, #1128	; 0x468
    d864:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000d868 <_vfprintf_r>:
    d868:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d86c:	b0c3      	sub	sp, #268	; 0x10c
    d86e:	461d      	mov	r5, r3
    d870:	468a      	mov	sl, r1
    d872:	4691      	mov	r9, r2
    d874:	4604      	mov	r4, r0
    d876:	9008      	str	r0, [sp, #32]
    d878:	f002 fc8a 	bl	10190 <_localeconv_r>
    d87c:	6803      	ldr	r3, [r0, #0]
    d87e:	9315      	str	r3, [sp, #84]	; 0x54
    d880:	4618      	mov	r0, r3
    d882:	f7f3 f8fd 	bl	a80 <strlen>
    d886:	950e      	str	r5, [sp, #56]	; 0x38
    d888:	9014      	str	r0, [sp, #80]	; 0x50
    d88a:	b11c      	cbz	r4, d894 <_vfprintf_r+0x2c>
    d88c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    d88e:	2b00      	cmp	r3, #0
    d890:	f000 8262 	beq.w	dd58 <_vfprintf_r+0x4f0>
    d894:	f8da 3064 	ldr.w	r3, [sl, #100]	; 0x64
    d898:	f9ba 200c 	ldrsh.w	r2, [sl, #12]
    d89c:	f013 0f01 	tst.w	r3, #1
    d8a0:	b293      	uxth	r3, r2
    d8a2:	d102      	bne.n	d8aa <_vfprintf_r+0x42>
    d8a4:	0599      	lsls	r1, r3, #22
    d8a6:	f140 8278 	bpl.w	dd9a <_vfprintf_r+0x532>
    d8aa:	049f      	lsls	r7, r3, #18
    d8ac:	d40a      	bmi.n	d8c4 <_vfprintf_r+0x5c>
    d8ae:	f8da 1064 	ldr.w	r1, [sl, #100]	; 0x64
    d8b2:	f442 5300 	orr.w	r3, r2, #8192	; 0x2000
    d8b6:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
    d8ba:	f8aa 300c 	strh.w	r3, [sl, #12]
    d8be:	f8ca 1064 	str.w	r1, [sl, #100]	; 0x64
    d8c2:	b29b      	uxth	r3, r3
    d8c4:	071e      	lsls	r6, r3, #28
    d8c6:	f140 8226 	bpl.w	dd16 <_vfprintf_r+0x4ae>
    d8ca:	f8da 2010 	ldr.w	r2, [sl, #16]
    d8ce:	2a00      	cmp	r2, #0
    d8d0:	f000 8221 	beq.w	dd16 <_vfprintf_r+0x4ae>
    d8d4:	f003 021a 	and.w	r2, r3, #26
    d8d8:	2a0a      	cmp	r2, #10
    d8da:	f000 8241 	beq.w	dd60 <_vfprintf_r+0x4f8>
    d8de:	ed9f 7b8e 	vldr	d7, [pc, #568]	; db18 <_vfprintf_r+0x2b0>
    d8e2:	2300      	movs	r3, #0
    d8e4:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
    d8e8:	9311      	str	r3, [sp, #68]	; 0x44
    d8ea:	9327      	str	r3, [sp, #156]	; 0x9c
    d8ec:	9326      	str	r3, [sp, #152]	; 0x98
    d8ee:	9316      	str	r3, [sp, #88]	; 0x58
    d8f0:	9317      	str	r3, [sp, #92]	; 0x5c
    d8f2:	930b      	str	r3, [sp, #44]	; 0x2c
    d8f4:	ab32      	add	r3, sp, #200	; 0xc8
    d8f6:	9325      	str	r3, [sp, #148]	; 0x94
    d8f8:	4698      	mov	r8, r3
    d8fa:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
    d8fe:	f899 3000 	ldrb.w	r3, [r9]
    d902:	464c      	mov	r4, r9
    d904:	b1eb      	cbz	r3, d942 <_vfprintf_r+0xda>
    d906:	2b25      	cmp	r3, #37	; 0x25
    d908:	d102      	bne.n	d910 <_vfprintf_r+0xa8>
    d90a:	e01a      	b.n	d942 <_vfprintf_r+0xda>
    d90c:	2b25      	cmp	r3, #37	; 0x25
    d90e:	d003      	beq.n	d918 <_vfprintf_r+0xb0>
    d910:	f814 3f01 	ldrb.w	r3, [r4, #1]!
    d914:	2b00      	cmp	r3, #0
    d916:	d1f9      	bne.n	d90c <_vfprintf_r+0xa4>
    d918:	eba4 0509 	sub.w	r5, r4, r9
    d91c:	b18d      	cbz	r5, d942 <_vfprintf_r+0xda>
    d91e:	9b26      	ldr	r3, [sp, #152]	; 0x98
    d920:	9a27      	ldr	r2, [sp, #156]	; 0x9c
    d922:	f8c8 9000 	str.w	r9, [r8]
    d926:	3301      	adds	r3, #1
    d928:	442a      	add	r2, r5
    d92a:	2b07      	cmp	r3, #7
    d92c:	f8c8 5004 	str.w	r5, [r8, #4]
    d930:	9227      	str	r2, [sp, #156]	; 0x9c
    d932:	9326      	str	r3, [sp, #152]	; 0x98
    d934:	f300 8205 	bgt.w	dd42 <_vfprintf_r+0x4da>
    d938:	f108 0808 	add.w	r8, r8, #8
    d93c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d93e:	442b      	add	r3, r5
    d940:	930b      	str	r3, [sp, #44]	; 0x2c
    d942:	7823      	ldrb	r3, [r4, #0]
    d944:	2b00      	cmp	r3, #0
    d946:	f000 83fe 	beq.w	e146 <_vfprintf_r+0x8de>
    d94a:	2300      	movs	r3, #0
    d94c:	461a      	mov	r2, r3
    d94e:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
    d952:	4619      	mov	r1, r3
    d954:	930c      	str	r3, [sp, #48]	; 0x30
    d956:	469b      	mov	fp, r3
    d958:	7866      	ldrb	r6, [r4, #1]
    d95a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d95e:	f104 0901 	add.w	r9, r4, #1
    d962:	9309      	str	r3, [sp, #36]	; 0x24
    d964:	f109 0901 	add.w	r9, r9, #1
    d968:	f1a6 0320 	sub.w	r3, r6, #32
    d96c:	2b58      	cmp	r3, #88	; 0x58
    d96e:	f200 83cd 	bhi.w	e10c <_vfprintf_r+0x8a4>
    d972:	e8df f013 	tbh	[pc, r3, lsl #1]
    d976:	02e5      	.short	0x02e5
    d978:	03cb03cb 	.word	0x03cb03cb
    d97c:	03cb0354 	.word	0x03cb0354
    d980:	03cb03cb 	.word	0x03cb03cb
    d984:	03cb03cb 	.word	0x03cb03cb
    d988:	035903cb 	.word	0x035903cb
    d98c:	03cb030d 	.word	0x03cb030d
    d990:	02ed021e 	.word	0x02ed021e
    d994:	030803cb 	.word	0x030803cb
    d998:	033f033f 	.word	0x033f033f
    d99c:	033f033f 	.word	0x033f033f
    d9a0:	033f033f 	.word	0x033f033f
    d9a4:	033f033f 	.word	0x033f033f
    d9a8:	03cb033f 	.word	0x03cb033f
    d9ac:	03cb03cb 	.word	0x03cb03cb
    d9b0:	03cb03cb 	.word	0x03cb03cb
    d9b4:	03cb03cb 	.word	0x03cb03cb
    d9b8:	03cb03cb 	.word	0x03cb03cb
    d9bc:	034e03cb 	.word	0x034e03cb
    d9c0:	03cb0367 	.word	0x03cb0367
    d9c4:	03cb0367 	.word	0x03cb0367
    d9c8:	03cb03cb 	.word	0x03cb03cb
    d9cc:	03b003cb 	.word	0x03b003cb
    d9d0:	03cb03cb 	.word	0x03cb03cb
    d9d4:	03cb006f 	.word	0x03cb006f
    d9d8:	03cb03cb 	.word	0x03cb03cb
    d9dc:	03cb03cb 	.word	0x03cb03cb
    d9e0:	03cb0059 	.word	0x03cb0059
    d9e4:	032303cb 	.word	0x032303cb
    d9e8:	03cb03cb 	.word	0x03cb03cb
    d9ec:	03cb03cb 	.word	0x03cb03cb
    d9f0:	03cb03cb 	.word	0x03cb03cb
    d9f4:	03cb03cb 	.word	0x03cb03cb
    d9f8:	03cb03cb 	.word	0x03cb03cb
    d9fc:	02780329 	.word	0x02780329
    da00:	03670367 	.word	0x03670367
    da04:	02bc0367 	.word	0x02bc0367
    da08:	03cb0278 	.word	0x03cb0278
    da0c:	02c103cb 	.word	0x02c103cb
    da10:	02ce03cb 	.word	0x02ce03cb
    da14:	03120071 	.word	0x03120071
    da18:	03cb024b 	.word	0x03cb024b
    da1c:	03cb0257 	.word	0x03cb0257
    da20:	03cb005b 	.word	0x03cb005b
    da24:	022303cb 	.word	0x022303cb
    da28:	f04b 0b10 	orr.w	fp, fp, #16
    da2c:	f01b 0f20 	tst.w	fp, #32
    da30:	f040 8361 	bne.w	e0f6 <_vfprintf_r+0x88e>
    da34:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    da36:	f01b 0f10 	tst.w	fp, #16
    da3a:	4613      	mov	r3, r2
    da3c:	f040 85ca 	bne.w	e5d4 <_vfprintf_r+0xd6c>
    da40:	f01b 0f40 	tst.w	fp, #64	; 0x40
    da44:	f000 85c6 	beq.w	e5d4 <_vfprintf_r+0xd6c>
    da48:	8814      	ldrh	r4, [r2, #0]
    da4a:	3204      	adds	r2, #4
    da4c:	2500      	movs	r5, #0
    da4e:	2301      	movs	r3, #1
    da50:	920e      	str	r2, [sp, #56]	; 0x38
    da52:	e014      	b.n	da7e <_vfprintf_r+0x216>
    da54:	f04b 0b10 	orr.w	fp, fp, #16
    da58:	f01b 0320 	ands.w	r3, fp, #32
    da5c:	f040 8340 	bne.w	e0e0 <_vfprintf_r+0x878>
    da60:	f01b 0210 	ands.w	r2, fp, #16
    da64:	f040 85a5 	bne.w	e5b2 <_vfprintf_r+0xd4a>
    da68:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
    da6c:	f000 85a1 	beq.w	e5b2 <_vfprintf_r+0xd4a>
    da70:	990e      	ldr	r1, [sp, #56]	; 0x38
    da72:	4613      	mov	r3, r2
    da74:	460a      	mov	r2, r1
    da76:	3204      	adds	r2, #4
    da78:	880c      	ldrh	r4, [r1, #0]
    da7a:	920e      	str	r2, [sp, #56]	; 0x38
    da7c:	2500      	movs	r5, #0
    da7e:	f04f 0a00 	mov.w	sl, #0
    da82:	f88d a077 	strb.w	sl, [sp, #119]	; 0x77
    da86:	9909      	ldr	r1, [sp, #36]	; 0x24
    da88:	1c4a      	adds	r2, r1, #1
    da8a:	f000 8210 	beq.w	deae <_vfprintf_r+0x646>
    da8e:	f02b 0280 	bic.w	r2, fp, #128	; 0x80
    da92:	9206      	str	r2, [sp, #24]
    da94:	ea54 0205 	orrs.w	r2, r4, r5
    da98:	f040 820f 	bne.w	deba <_vfprintf_r+0x652>
    da9c:	2900      	cmp	r1, #0
    da9e:	f040 847c 	bne.w	e39a <_vfprintf_r+0xb32>
    daa2:	2b00      	cmp	r3, #0
    daa4:	f040 853a 	bne.w	e51c <_vfprintf_r+0xcb4>
    daa8:	f01b 0301 	ands.w	r3, fp, #1
    daac:	930d      	str	r3, [sp, #52]	; 0x34
    daae:	f000 8676 	beq.w	e79e <_vfprintf_r+0xf36>
    dab2:	af42      	add	r7, sp, #264	; 0x108
    dab4:	2330      	movs	r3, #48	; 0x30
    dab6:	f807 3d41 	strb.w	r3, [r7, #-65]!
    daba:	9b09      	ldr	r3, [sp, #36]	; 0x24
    dabc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    dabe:	4293      	cmp	r3, r2
    dac0:	bfb8      	it	lt
    dac2:	4613      	movlt	r3, r2
    dac4:	9307      	str	r3, [sp, #28]
    dac6:	2300      	movs	r3, #0
    dac8:	9310      	str	r3, [sp, #64]	; 0x40
    daca:	f1ba 0f00 	cmp.w	sl, #0
    dace:	d002      	beq.n	dad6 <_vfprintf_r+0x26e>
    dad0:	9b07      	ldr	r3, [sp, #28]
    dad2:	3301      	adds	r3, #1
    dad4:	9307      	str	r3, [sp, #28]
    dad6:	9b06      	ldr	r3, [sp, #24]
    dad8:	f013 0302 	ands.w	r3, r3, #2
    dadc:	930f      	str	r3, [sp, #60]	; 0x3c
    dade:	d002      	beq.n	dae6 <_vfprintf_r+0x27e>
    dae0:	9b07      	ldr	r3, [sp, #28]
    dae2:	3302      	adds	r3, #2
    dae4:	9307      	str	r3, [sp, #28]
    dae6:	9b06      	ldr	r3, [sp, #24]
    dae8:	f013 0584 	ands.w	r5, r3, #132	; 0x84
    daec:	f040 8329 	bne.w	e142 <_vfprintf_r+0x8da>
    daf0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    daf2:	9a07      	ldr	r2, [sp, #28]
    daf4:	eba3 0b02 	sub.w	fp, r3, r2
    daf8:	f1bb 0f00 	cmp.w	fp, #0
    dafc:	f340 8321 	ble.w	e142 <_vfprintf_r+0x8da>
    db00:	f1bb 0f10 	cmp.w	fp, #16
    db04:	9927      	ldr	r1, [sp, #156]	; 0x9c
    db06:	9a26      	ldr	r2, [sp, #152]	; 0x98
    db08:	dd2c      	ble.n	db64 <_vfprintf_r+0x2fc>
    db0a:	4643      	mov	r3, r8
    db0c:	2410      	movs	r4, #16
    db0e:	46a8      	mov	r8, r5
    db10:	f8dd a020 	ldr.w	sl, [sp, #32]
    db14:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    db16:	e00a      	b.n	db2e <_vfprintf_r+0x2c6>
	...
    db20:	f1ab 0b10 	sub.w	fp, fp, #16
    db24:	f1bb 0f10 	cmp.w	fp, #16
    db28:	f103 0308 	add.w	r3, r3, #8
    db2c:	dd18      	ble.n	db60 <_vfprintf_r+0x2f8>
    db2e:	3201      	adds	r2, #1
    db30:	48b9      	ldr	r0, [pc, #740]	; (de18 <_vfprintf_r+0x5b0>)
    db32:	9226      	str	r2, [sp, #152]	; 0x98
    db34:	3110      	adds	r1, #16
    db36:	2a07      	cmp	r2, #7
    db38:	9127      	str	r1, [sp, #156]	; 0x9c
    db3a:	e883 0011 	stmia.w	r3, {r0, r4}
    db3e:	ddef      	ble.n	db20 <_vfprintf_r+0x2b8>
    db40:	aa25      	add	r2, sp, #148	; 0x94
    db42:	4629      	mov	r1, r5
    db44:	4650      	mov	r0, sl
    db46:	f7fe fffb 	bl	cb40 <__sprint_r>
    db4a:	2800      	cmp	r0, #0
    db4c:	f040 8374 	bne.w	e238 <_vfprintf_r+0x9d0>
    db50:	f1ab 0b10 	sub.w	fp, fp, #16
    db54:	f1bb 0f10 	cmp.w	fp, #16
    db58:	9927      	ldr	r1, [sp, #156]	; 0x9c
    db5a:	9a26      	ldr	r2, [sp, #152]	; 0x98
    db5c:	ab32      	add	r3, sp, #200	; 0xc8
    db5e:	dce6      	bgt.n	db2e <_vfprintf_r+0x2c6>
    db60:	4645      	mov	r5, r8
    db62:	4698      	mov	r8, r3
    db64:	3201      	adds	r2, #1
    db66:	4bac      	ldr	r3, [pc, #688]	; (de18 <_vfprintf_r+0x5b0>)
    db68:	9226      	str	r2, [sp, #152]	; 0x98
    db6a:	eb0b 0401 	add.w	r4, fp, r1
    db6e:	2a07      	cmp	r2, #7
    db70:	9427      	str	r4, [sp, #156]	; 0x9c
    db72:	e888 0808 	stmia.w	r8, {r3, fp}
    db76:	f300 84d6 	bgt.w	e526 <_vfprintf_r+0xcbe>
    db7a:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
    db7e:	f108 0808 	add.w	r8, r8, #8
    db82:	f1ba 0f00 	cmp.w	sl, #0
    db86:	d00e      	beq.n	dba6 <_vfprintf_r+0x33e>
    db88:	9b26      	ldr	r3, [sp, #152]	; 0x98
    db8a:	3301      	adds	r3, #1
    db8c:	3401      	adds	r4, #1
    db8e:	f10d 0177 	add.w	r1, sp, #119	; 0x77
    db92:	2201      	movs	r2, #1
    db94:	2b07      	cmp	r3, #7
    db96:	9427      	str	r4, [sp, #156]	; 0x9c
    db98:	9326      	str	r3, [sp, #152]	; 0x98
    db9a:	e888 0006 	stmia.w	r8, {r1, r2}
    db9e:	f300 8413 	bgt.w	e3c8 <_vfprintf_r+0xb60>
    dba2:	f108 0808 	add.w	r8, r8, #8
    dba6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    dba8:	b16b      	cbz	r3, dbc6 <_vfprintf_r+0x35e>
    dbaa:	9b26      	ldr	r3, [sp, #152]	; 0x98
    dbac:	3301      	adds	r3, #1
    dbae:	3402      	adds	r4, #2
    dbb0:	a91e      	add	r1, sp, #120	; 0x78
    dbb2:	2202      	movs	r2, #2
    dbb4:	2b07      	cmp	r3, #7
    dbb6:	9427      	str	r4, [sp, #156]	; 0x9c
    dbb8:	9326      	str	r3, [sp, #152]	; 0x98
    dbba:	e888 0006 	stmia.w	r8, {r1, r2}
    dbbe:	f300 840f 	bgt.w	e3e0 <_vfprintf_r+0xb78>
    dbc2:	f108 0808 	add.w	r8, r8, #8
    dbc6:	2d80      	cmp	r5, #128	; 0x80
    dbc8:	f000 8338 	beq.w	e23c <_vfprintf_r+0x9d4>
    dbcc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    dbce:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    dbd0:	eba3 0a02 	sub.w	sl, r3, r2
    dbd4:	f1ba 0f00 	cmp.w	sl, #0
    dbd8:	dd3b      	ble.n	dc52 <_vfprintf_r+0x3ea>
    dbda:	f1ba 0f10 	cmp.w	sl, #16
    dbde:	9b26      	ldr	r3, [sp, #152]	; 0x98
    dbe0:	4d8e      	ldr	r5, [pc, #568]	; (de1c <_vfprintf_r+0x5b4>)
    dbe2:	dd2b      	ble.n	dc3c <_vfprintf_r+0x3d4>
    dbe4:	4642      	mov	r2, r8
    dbe6:	4621      	mov	r1, r4
    dbe8:	46b0      	mov	r8, r6
    dbea:	f04f 0b10 	mov.w	fp, #16
    dbee:	462e      	mov	r6, r5
    dbf0:	9c08      	ldr	r4, [sp, #32]
    dbf2:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    dbf4:	e006      	b.n	dc04 <_vfprintf_r+0x39c>
    dbf6:	f1aa 0a10 	sub.w	sl, sl, #16
    dbfa:	f1ba 0f10 	cmp.w	sl, #16
    dbfe:	f102 0208 	add.w	r2, r2, #8
    dc02:	dd17      	ble.n	dc34 <_vfprintf_r+0x3cc>
    dc04:	3301      	adds	r3, #1
    dc06:	3110      	adds	r1, #16
    dc08:	2b07      	cmp	r3, #7
    dc0a:	9127      	str	r1, [sp, #156]	; 0x9c
    dc0c:	9326      	str	r3, [sp, #152]	; 0x98
    dc0e:	e882 0840 	stmia.w	r2, {r6, fp}
    dc12:	ddf0      	ble.n	dbf6 <_vfprintf_r+0x38e>
    dc14:	aa25      	add	r2, sp, #148	; 0x94
    dc16:	4629      	mov	r1, r5
    dc18:	4620      	mov	r0, r4
    dc1a:	f7fe ff91 	bl	cb40 <__sprint_r>
    dc1e:	2800      	cmp	r0, #0
    dc20:	f040 830a 	bne.w	e238 <_vfprintf_r+0x9d0>
    dc24:	f1aa 0a10 	sub.w	sl, sl, #16
    dc28:	f1ba 0f10 	cmp.w	sl, #16
    dc2c:	9927      	ldr	r1, [sp, #156]	; 0x9c
    dc2e:	9b26      	ldr	r3, [sp, #152]	; 0x98
    dc30:	aa32      	add	r2, sp, #200	; 0xc8
    dc32:	dce7      	bgt.n	dc04 <_vfprintf_r+0x39c>
    dc34:	4635      	mov	r5, r6
    dc36:	460c      	mov	r4, r1
    dc38:	4646      	mov	r6, r8
    dc3a:	4690      	mov	r8, r2
    dc3c:	3301      	adds	r3, #1
    dc3e:	4454      	add	r4, sl
    dc40:	2b07      	cmp	r3, #7
    dc42:	9427      	str	r4, [sp, #156]	; 0x9c
    dc44:	9326      	str	r3, [sp, #152]	; 0x98
    dc46:	e888 0420 	stmia.w	r8, {r5, sl}
    dc4a:	f300 83b2 	bgt.w	e3b2 <_vfprintf_r+0xb4a>
    dc4e:	f108 0808 	add.w	r8, r8, #8
    dc52:	9b06      	ldr	r3, [sp, #24]
    dc54:	05db      	lsls	r3, r3, #23
    dc56:	f100 828f 	bmi.w	e178 <_vfprintf_r+0x910>
    dc5a:	9b26      	ldr	r3, [sp, #152]	; 0x98
    dc5c:	990d      	ldr	r1, [sp, #52]	; 0x34
    dc5e:	f8c8 7000 	str.w	r7, [r8]
    dc62:	3301      	adds	r3, #1
    dc64:	440c      	add	r4, r1
    dc66:	2b07      	cmp	r3, #7
    dc68:	9427      	str	r4, [sp, #156]	; 0x9c
    dc6a:	f8c8 1004 	str.w	r1, [r8, #4]
    dc6e:	9326      	str	r3, [sp, #152]	; 0x98
    dc70:	f300 837e 	bgt.w	e370 <_vfprintf_r+0xb08>
    dc74:	f108 0808 	add.w	r8, r8, #8
    dc78:	9b06      	ldr	r3, [sp, #24]
    dc7a:	0759      	lsls	r1, r3, #29
    dc7c:	d53b      	bpl.n	dcf6 <_vfprintf_r+0x48e>
    dc7e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    dc80:	9a07      	ldr	r2, [sp, #28]
    dc82:	1a9d      	subs	r5, r3, r2
    dc84:	2d00      	cmp	r5, #0
    dc86:	dd36      	ble.n	dcf6 <_vfprintf_r+0x48e>
    dc88:	2d10      	cmp	r5, #16
    dc8a:	9b26      	ldr	r3, [sp, #152]	; 0x98
    dc8c:	dd21      	ble.n	dcd2 <_vfprintf_r+0x46a>
    dc8e:	2610      	movs	r6, #16
    dc90:	9f08      	ldr	r7, [sp, #32]
    dc92:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    dc96:	e004      	b.n	dca2 <_vfprintf_r+0x43a>
    dc98:	3d10      	subs	r5, #16
    dc9a:	2d10      	cmp	r5, #16
    dc9c:	f108 0808 	add.w	r8, r8, #8
    dca0:	dd17      	ble.n	dcd2 <_vfprintf_r+0x46a>
    dca2:	3301      	adds	r3, #1
    dca4:	4a5c      	ldr	r2, [pc, #368]	; (de18 <_vfprintf_r+0x5b0>)
    dca6:	9326      	str	r3, [sp, #152]	; 0x98
    dca8:	3410      	adds	r4, #16
    dcaa:	2b07      	cmp	r3, #7
    dcac:	9427      	str	r4, [sp, #156]	; 0x9c
    dcae:	e888 0044 	stmia.w	r8, {r2, r6}
    dcb2:	ddf1      	ble.n	dc98 <_vfprintf_r+0x430>
    dcb4:	aa25      	add	r2, sp, #148	; 0x94
    dcb6:	4651      	mov	r1, sl
    dcb8:	4638      	mov	r0, r7
    dcba:	f7fe ff41 	bl	cb40 <__sprint_r>
    dcbe:	2800      	cmp	r0, #0
    dcc0:	f040 8249 	bne.w	e156 <_vfprintf_r+0x8ee>
    dcc4:	3d10      	subs	r5, #16
    dcc6:	2d10      	cmp	r5, #16
    dcc8:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    dcca:	9b26      	ldr	r3, [sp, #152]	; 0x98
    dccc:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    dcd0:	dce7      	bgt.n	dca2 <_vfprintf_r+0x43a>
    dcd2:	3301      	adds	r3, #1
    dcd4:	4a50      	ldr	r2, [pc, #320]	; (de18 <_vfprintf_r+0x5b0>)
    dcd6:	9326      	str	r3, [sp, #152]	; 0x98
    dcd8:	442c      	add	r4, r5
    dcda:	2b07      	cmp	r3, #7
    dcdc:	9427      	str	r4, [sp, #156]	; 0x9c
    dcde:	e888 0024 	stmia.w	r8, {r2, r5}
    dce2:	dd08      	ble.n	dcf6 <_vfprintf_r+0x48e>
    dce4:	aa25      	add	r2, sp, #148	; 0x94
    dce6:	990a      	ldr	r1, [sp, #40]	; 0x28
    dce8:	9808      	ldr	r0, [sp, #32]
    dcea:	f7fe ff29 	bl	cb40 <__sprint_r>
    dcee:	2800      	cmp	r0, #0
    dcf0:	f040 8350 	bne.w	e394 <_vfprintf_r+0xb2c>
    dcf4:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    dcf6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dcf8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    dcfa:	9907      	ldr	r1, [sp, #28]
    dcfc:	428a      	cmp	r2, r1
    dcfe:	bfac      	ite	ge
    dd00:	189b      	addge	r3, r3, r2
    dd02:	185b      	addlt	r3, r3, r1
    dd04:	930b      	str	r3, [sp, #44]	; 0x2c
    dd06:	2c00      	cmp	r4, #0
    dd08:	f040 833c 	bne.w	e384 <_vfprintf_r+0xb1c>
    dd0c:	2300      	movs	r3, #0
    dd0e:	9326      	str	r3, [sp, #152]	; 0x98
    dd10:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    dd14:	e5f3      	b.n	d8fe <_vfprintf_r+0x96>
    dd16:	4651      	mov	r1, sl
    dd18:	9808      	ldr	r0, [sp, #32]
    dd1a:	f001 f977 	bl	f00c <__swsetup_r>
    dd1e:	2800      	cmp	r0, #0
    dd20:	d038      	beq.n	dd94 <_vfprintf_r+0x52c>
    dd22:	f8da 3064 	ldr.w	r3, [sl, #100]	; 0x64
    dd26:	07dd      	lsls	r5, r3, #31
    dd28:	d404      	bmi.n	dd34 <_vfprintf_r+0x4cc>
    dd2a:	f8ba 300c 	ldrh.w	r3, [sl, #12]
    dd2e:	059c      	lsls	r4, r3, #22
    dd30:	f140 85da 	bpl.w	e8e8 <_vfprintf_r+0x1080>
    dd34:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    dd38:	930b      	str	r3, [sp, #44]	; 0x2c
    dd3a:	980b      	ldr	r0, [sp, #44]	; 0x2c
    dd3c:	b043      	add	sp, #268	; 0x10c
    dd3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd42:	aa25      	add	r2, sp, #148	; 0x94
    dd44:	990a      	ldr	r1, [sp, #40]	; 0x28
    dd46:	9808      	ldr	r0, [sp, #32]
    dd48:	f7fe fefa 	bl	cb40 <__sprint_r>
    dd4c:	2800      	cmp	r0, #0
    dd4e:	f040 8321 	bne.w	e394 <_vfprintf_r+0xb2c>
    dd52:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    dd56:	e5f1      	b.n	d93c <_vfprintf_r+0xd4>
    dd58:	9808      	ldr	r0, [sp, #32]
    dd5a:	f7fc fc7b 	bl	a654 <__sinit>
    dd5e:	e599      	b.n	d894 <_vfprintf_r+0x2c>
    dd60:	f9ba 200e 	ldrsh.w	r2, [sl, #14]
    dd64:	2a00      	cmp	r2, #0
    dd66:	f6ff adba 	blt.w	d8de <_vfprintf_r+0x76>
    dd6a:	f8da 2064 	ldr.w	r2, [sl, #100]	; 0x64
    dd6e:	07d0      	lsls	r0, r2, #31
    dd70:	d405      	bmi.n	dd7e <_vfprintf_r+0x516>
    dd72:	0599      	lsls	r1, r3, #22
    dd74:	d403      	bmi.n	dd7e <_vfprintf_r+0x516>
    dd76:	f8da 0058 	ldr.w	r0, [sl, #88]	; 0x58
    dd7a:	f7fc ffdf 	bl	ad3c <__retarget_lock_release_recursive>
    dd7e:	462b      	mov	r3, r5
    dd80:	464a      	mov	r2, r9
    dd82:	4651      	mov	r1, sl
    dd84:	9808      	ldr	r0, [sp, #32]
    dd86:	f001 f839 	bl	edfc <__sbprintf>
    dd8a:	900b      	str	r0, [sp, #44]	; 0x2c
    dd8c:	980b      	ldr	r0, [sp, #44]	; 0x2c
    dd8e:	b043      	add	sp, #268	; 0x10c
    dd90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd94:	f8ba 300c 	ldrh.w	r3, [sl, #12]
    dd98:	e59c      	b.n	d8d4 <_vfprintf_r+0x6c>
    dd9a:	f8da 0058 	ldr.w	r0, [sl, #88]	; 0x58
    dd9e:	f7fc ffcb 	bl	ad38 <__retarget_lock_acquire_recursive>
    dda2:	f9ba 200c 	ldrsh.w	r2, [sl, #12]
    dda6:	b293      	uxth	r3, r2
    dda8:	e57f      	b.n	d8aa <_vfprintf_r+0x42>
    ddaa:	980c      	ldr	r0, [sp, #48]	; 0x30
    ddac:	930e      	str	r3, [sp, #56]	; 0x38
    ddae:	4240      	negs	r0, r0
    ddb0:	900c      	str	r0, [sp, #48]	; 0x30
    ddb2:	f04b 0b04 	orr.w	fp, fp, #4
    ddb6:	f899 6000 	ldrb.w	r6, [r9]
    ddba:	e5d3      	b.n	d964 <_vfprintf_r+0xfc>
    ddbc:	2a00      	cmp	r2, #0
    ddbe:	f040 87f7 	bne.w	edb0 <_vfprintf_r+0x1548>
    ddc2:	4b17      	ldr	r3, [pc, #92]	; (de20 <_vfprintf_r+0x5b8>)
    ddc4:	9316      	str	r3, [sp, #88]	; 0x58
    ddc6:	f01b 0f20 	tst.w	fp, #32
    ddca:	f040 84cd 	bne.w	e768 <_vfprintf_r+0xf00>
    ddce:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    ddd0:	f01b 0f10 	tst.w	fp, #16
    ddd4:	4613      	mov	r3, r2
    ddd6:	f040 83e7 	bne.w	e5a8 <_vfprintf_r+0xd40>
    ddda:	f01b 0f40 	tst.w	fp, #64	; 0x40
    ddde:	f000 83e3 	beq.w	e5a8 <_vfprintf_r+0xd40>
    dde2:	3304      	adds	r3, #4
    dde4:	8814      	ldrh	r4, [r2, #0]
    dde6:	930e      	str	r3, [sp, #56]	; 0x38
    dde8:	2500      	movs	r5, #0
    ddea:	f01b 0f01 	tst.w	fp, #1
    ddee:	f000 832b 	beq.w	e448 <_vfprintf_r+0xbe0>
    ddf2:	ea54 0305 	orrs.w	r3, r4, r5
    ddf6:	f000 8327 	beq.w	e448 <_vfprintf_r+0xbe0>
    ddfa:	2330      	movs	r3, #48	; 0x30
    ddfc:	f88d 3078 	strb.w	r3, [sp, #120]	; 0x78
    de00:	f88d 6079 	strb.w	r6, [sp, #121]	; 0x79
    de04:	f04b 0b02 	orr.w	fp, fp, #2
    de08:	2302      	movs	r3, #2
    de0a:	e638      	b.n	da7e <_vfprintf_r+0x216>
    de0c:	f04b 0b20 	orr.w	fp, fp, #32
    de10:	f899 6000 	ldrb.w	r6, [r9]
    de14:	e5a6      	b.n	d964 <_vfprintf_r+0xfc>
    de16:	bf00      	nop
    de18:	00012ab0 	.word	0x00012ab0
    de1c:	00012ac0 	.word	0x00012ac0
    de20:	00012a50 	.word	0x00012a50
    de24:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    de26:	6817      	ldr	r7, [r2, #0]
    de28:	2400      	movs	r4, #0
    de2a:	f88d 4077 	strb.w	r4, [sp, #119]	; 0x77
    de2e:	1d15      	adds	r5, r2, #4
    de30:	2f00      	cmp	r7, #0
    de32:	f000 865d 	beq.w	eaf0 <_vfprintf_r+0x1288>
    de36:	9a09      	ldr	r2, [sp, #36]	; 0x24
    de38:	1c53      	adds	r3, r2, #1
    de3a:	f000 85db 	beq.w	e9f4 <_vfprintf_r+0x118c>
    de3e:	4621      	mov	r1, r4
    de40:	4638      	mov	r0, r7
    de42:	f7f2 fd1d 	bl	880 <memchr>
    de46:	2800      	cmp	r0, #0
    de48:	f000 86da 	beq.w	ec00 <_vfprintf_r+0x1398>
    de4c:	1bc3      	subs	r3, r0, r7
    de4e:	930d      	str	r3, [sp, #52]	; 0x34
    de50:	9409      	str	r4, [sp, #36]	; 0x24
    de52:	950e      	str	r5, [sp, #56]	; 0x38
    de54:	f8cd b018 	str.w	fp, [sp, #24]
    de58:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    de5c:	9307      	str	r3, [sp, #28]
    de5e:	9410      	str	r4, [sp, #64]	; 0x40
    de60:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
    de64:	e631      	b.n	daca <_vfprintf_r+0x262>
    de66:	2a00      	cmp	r2, #0
    de68:	f040 87ad 	bne.w	edc6 <_vfprintf_r+0x155e>
    de6c:	f01b 0f20 	tst.w	fp, #32
    de70:	f040 8488 	bne.w	e784 <_vfprintf_r+0xf1c>
    de74:	f01b 0f10 	tst.w	fp, #16
    de78:	f040 83a3 	bne.w	e5c2 <_vfprintf_r+0xd5a>
    de7c:	f01b 0f40 	tst.w	fp, #64	; 0x40
    de80:	f000 839f 	beq.w	e5c2 <_vfprintf_r+0xd5a>
    de84:	990e      	ldr	r1, [sp, #56]	; 0x38
    de86:	f9b1 4000 	ldrsh.w	r4, [r1]
    de8a:	3104      	adds	r1, #4
    de8c:	17e5      	asrs	r5, r4, #31
    de8e:	4622      	mov	r2, r4
    de90:	462b      	mov	r3, r5
    de92:	910e      	str	r1, [sp, #56]	; 0x38
    de94:	2a00      	cmp	r2, #0
    de96:	f173 0300 	sbcs.w	r3, r3, #0
    de9a:	f2c0 8490 	blt.w	e7be <_vfprintf_r+0xf56>
    de9e:	9909      	ldr	r1, [sp, #36]	; 0x24
    dea0:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
    dea4:	1c4a      	adds	r2, r1, #1
    dea6:	f04f 0301 	mov.w	r3, #1
    deaa:	f47f adf0 	bne.w	da8e <_vfprintf_r+0x226>
    deae:	ea54 0205 	orrs.w	r2, r4, r5
    deb2:	f000 8274 	beq.w	e39e <_vfprintf_r+0xb36>
    deb6:	f8cd b018 	str.w	fp, [sp, #24]
    deba:	2b01      	cmp	r3, #1
    debc:	f000 8310 	beq.w	e4e0 <_vfprintf_r+0xc78>
    dec0:	2b02      	cmp	r3, #2
    dec2:	f040 829d 	bne.w	e400 <_vfprintf_r+0xb98>
    dec6:	9816      	ldr	r0, [sp, #88]	; 0x58
    dec8:	af32      	add	r7, sp, #200	; 0xc8
    deca:	0923      	lsrs	r3, r4, #4
    decc:	f004 010f 	and.w	r1, r4, #15
    ded0:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
    ded4:	092a      	lsrs	r2, r5, #4
    ded6:	461c      	mov	r4, r3
    ded8:	4615      	mov	r5, r2
    deda:	5c43      	ldrb	r3, [r0, r1]
    dedc:	f807 3d01 	strb.w	r3, [r7, #-1]!
    dee0:	ea54 0305 	orrs.w	r3, r4, r5
    dee4:	d1f1      	bne.n	deca <_vfprintf_r+0x662>
    dee6:	ab32      	add	r3, sp, #200	; 0xc8
    dee8:	1bdb      	subs	r3, r3, r7
    deea:	930d      	str	r3, [sp, #52]	; 0x34
    deec:	e5e5      	b.n	daba <_vfprintf_r+0x252>
    deee:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
    def2:	f899 6000 	ldrb.w	r6, [r9]
    def6:	e535      	b.n	d964 <_vfprintf_r+0xfc>
    def8:	f899 6000 	ldrb.w	r6, [r9]
    defc:	2e6c      	cmp	r6, #108	; 0x6c
    defe:	bf03      	ittte	eq
    df00:	f899 6001 	ldrbeq.w	r6, [r9, #1]
    df04:	f04b 0b20 	orreq.w	fp, fp, #32
    df08:	f109 0901 	addeq.w	r9, r9, #1
    df0c:	f04b 0b10 	orrne.w	fp, fp, #16
    df10:	e528      	b.n	d964 <_vfprintf_r+0xfc>
    df12:	2a00      	cmp	r2, #0
    df14:	f040 8767 	bne.w	ede6 <_vfprintf_r+0x157e>
    df18:	f01b 0f20 	tst.w	fp, #32
    df1c:	f040 854e 	bne.w	e9bc <_vfprintf_r+0x1154>
    df20:	f01b 0f10 	tst.w	fp, #16
    df24:	f040 8105 	bne.w	e132 <_vfprintf_r+0x8ca>
    df28:	f01b 0f40 	tst.w	fp, #64	; 0x40
    df2c:	f000 8101 	beq.w	e132 <_vfprintf_r+0x8ca>
    df30:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    df32:	6813      	ldr	r3, [r2, #0]
    df34:	3204      	adds	r2, #4
    df36:	920e      	str	r2, [sp, #56]	; 0x38
    df38:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
    df3c:	801a      	strh	r2, [r3, #0]
    df3e:	e4de      	b.n	d8fe <_vfprintf_r+0x96>
    df40:	f899 6000 	ldrb.w	r6, [r9]
    df44:	2900      	cmp	r1, #0
    df46:	f47f ad0d 	bne.w	d964 <_vfprintf_r+0xfc>
    df4a:	2201      	movs	r2, #1
    df4c:	2120      	movs	r1, #32
    df4e:	e509      	b.n	d964 <_vfprintf_r+0xfc>
    df50:	f899 6000 	ldrb.w	r6, [r9]
    df54:	2e2a      	cmp	r6, #42	; 0x2a
    df56:	f109 0001 	add.w	r0, r9, #1
    df5a:	f000 8707 	beq.w	ed6c <_vfprintf_r+0x1504>
    df5e:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
    df62:	2b09      	cmp	r3, #9
    df64:	4681      	mov	r9, r0
    df66:	bf98      	it	ls
    df68:	2000      	movls	r0, #0
    df6a:	f200 865b 	bhi.w	ec24 <_vfprintf_r+0x13bc>
    df6e:	f819 6b01 	ldrb.w	r6, [r9], #1
    df72:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    df76:	eb03 0040 	add.w	r0, r3, r0, lsl #1
    df7a:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
    df7e:	2b09      	cmp	r3, #9
    df80:	d9f5      	bls.n	df6e <_vfprintf_r+0x706>
    df82:	9009      	str	r0, [sp, #36]	; 0x24
    df84:	e4f0      	b.n	d968 <_vfprintf_r+0x100>
    df86:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
    df8a:	f899 6000 	ldrb.w	r6, [r9]
    df8e:	e4e9      	b.n	d964 <_vfprintf_r+0xfc>
    df90:	f899 6000 	ldrb.w	r6, [r9]
    df94:	2201      	movs	r2, #1
    df96:	212b      	movs	r1, #43	; 0x2b
    df98:	e4e4      	b.n	d964 <_vfprintf_r+0xfc>
    df9a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    df9c:	4bb2      	ldr	r3, [pc, #712]	; (e268 <_vfprintf_r+0xa00>)
    df9e:	6814      	ldr	r4, [r2, #0]
    dfa0:	9316      	str	r3, [sp, #88]	; 0x58
    dfa2:	2678      	movs	r6, #120	; 0x78
    dfa4:	2330      	movs	r3, #48	; 0x30
    dfa6:	3204      	adds	r2, #4
    dfa8:	f88d 3078 	strb.w	r3, [sp, #120]	; 0x78
    dfac:	f04b 0b02 	orr.w	fp, fp, #2
    dfb0:	920e      	str	r2, [sp, #56]	; 0x38
    dfb2:	2500      	movs	r5, #0
    dfb4:	f88d 6079 	strb.w	r6, [sp, #121]	; 0x79
    dfb8:	2302      	movs	r3, #2
    dfba:	e560      	b.n	da7e <_vfprintf_r+0x216>
    dfbc:	2a00      	cmp	r2, #0
    dfbe:	f040 870e 	bne.w	edde <_vfprintf_r+0x1576>
    dfc2:	4baa      	ldr	r3, [pc, #680]	; (e26c <_vfprintf_r+0xa04>)
    dfc4:	9316      	str	r3, [sp, #88]	; 0x58
    dfc6:	e6fe      	b.n	ddc6 <_vfprintf_r+0x55e>
    dfc8:	990e      	ldr	r1, [sp, #56]	; 0x38
    dfca:	f8cd b018 	str.w	fp, [sp, #24]
    dfce:	680a      	ldr	r2, [r1, #0]
    dfd0:	f88d 20a0 	strb.w	r2, [sp, #160]	; 0xa0
    dfd4:	2300      	movs	r3, #0
    dfd6:	460a      	mov	r2, r1
    dfd8:	469a      	mov	sl, r3
    dfda:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
    dfde:	3204      	adds	r2, #4
    dfe0:	2301      	movs	r3, #1
    dfe2:	9307      	str	r3, [sp, #28]
    dfe4:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
    dfe8:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
    dfec:	920e      	str	r2, [sp, #56]	; 0x38
    dfee:	930d      	str	r3, [sp, #52]	; 0x34
    dff0:	af28      	add	r7, sp, #160	; 0xa0
    dff2:	e570      	b.n	dad6 <_vfprintf_r+0x26e>
    dff4:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
    dff8:	2000      	movs	r0, #0
    dffa:	f819 6b01 	ldrb.w	r6, [r9], #1
    dffe:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    e002:	eb03 0040 	add.w	r0, r3, r0, lsl #1
    e006:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
    e00a:	2b09      	cmp	r3, #9
    e00c:	d9f5      	bls.n	dffa <_vfprintf_r+0x792>
    e00e:	900c      	str	r0, [sp, #48]	; 0x30
    e010:	e4aa      	b.n	d968 <_vfprintf_r+0x100>
    e012:	2a00      	cmp	r2, #0
    e014:	f040 86df 	bne.w	edd6 <_vfprintf_r+0x156e>
    e018:	f04b 0b10 	orr.w	fp, fp, #16
    e01c:	e726      	b.n	de6c <_vfprintf_r+0x604>
    e01e:	f04b 0b01 	orr.w	fp, fp, #1
    e022:	f899 6000 	ldrb.w	r6, [r9]
    e026:	e49d      	b.n	d964 <_vfprintf_r+0xfc>
    e028:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    e02a:	6823      	ldr	r3, [r4, #0]
    e02c:	930c      	str	r3, [sp, #48]	; 0x30
    e02e:	4618      	mov	r0, r3
    e030:	2800      	cmp	r0, #0
    e032:	4623      	mov	r3, r4
    e034:	f103 0304 	add.w	r3, r3, #4
    e038:	f6ff aeb7 	blt.w	ddaa <_vfprintf_r+0x542>
    e03c:	930e      	str	r3, [sp, #56]	; 0x38
    e03e:	f899 6000 	ldrb.w	r6, [r9]
    e042:	e48f      	b.n	d964 <_vfprintf_r+0xfc>
    e044:	2a00      	cmp	r2, #0
    e046:	f040 86b7 	bne.w	edb8 <_vfprintf_r+0x1550>
    e04a:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    e04c:	f01b 0f08 	tst.w	fp, #8
    e050:	f105 0507 	add.w	r5, r5, #7
    e054:	f000 843d 	beq.w	e8d2 <_vfprintf_r+0x106a>
    e058:	f025 0307 	bic.w	r3, r5, #7
    e05c:	ed93 7b00 	vldr	d7, [r3]
    e060:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
    e064:	f103 0208 	add.w	r2, r3, #8
    e068:	920e      	str	r2, [sp, #56]	; 0x38
    e06a:	e9dd 1212 	ldrd	r1, r2, [sp, #72]	; 0x48
    e06e:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
    e072:	9118      	str	r1, [sp, #96]	; 0x60
    e074:	9319      	str	r3, [sp, #100]	; 0x64
    e076:	e9dd 4518 	ldrd	r4, r5, [sp, #96]	; 0x60
    e07a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    e07e:	4620      	mov	r0, r4
    e080:	4629      	mov	r1, r5
    e082:	4b7b      	ldr	r3, [pc, #492]	; (e270 <_vfprintf_r+0xa08>)
    e084:	f7f3 f9bc 	bl	1400 <__aeabi_dcmpun>
    e088:	2800      	cmp	r0, #0
    e08a:	f040 83a2 	bne.w	e7d2 <_vfprintf_r+0xf6a>
    e08e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    e092:	4b77      	ldr	r3, [pc, #476]	; (e270 <_vfprintf_r+0xa08>)
    e094:	4620      	mov	r0, r4
    e096:	4629      	mov	r1, r5
    e098:	f7f3 f994 	bl	13c4 <__aeabi_dcmple>
    e09c:	2800      	cmp	r0, #0
    e09e:	f040 8398 	bne.w	e7d2 <_vfprintf_r+0xf6a>
    e0a2:	2200      	movs	r2, #0
    e0a4:	2300      	movs	r3, #0
    e0a6:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    e0aa:	f7f3 f981 	bl	13b0 <__aeabi_dcmplt>
    e0ae:	2800      	cmp	r0, #0
    e0b0:	f040 8438 	bne.w	e924 <_vfprintf_r+0x10bc>
    e0b4:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
    e0b8:	4f6e      	ldr	r7, [pc, #440]	; (e274 <_vfprintf_r+0xa0c>)
    e0ba:	4b6f      	ldr	r3, [pc, #444]	; (e278 <_vfprintf_r+0xa10>)
    e0bc:	2203      	movs	r2, #3
    e0be:	2100      	movs	r1, #0
    e0c0:	f02b 0080 	bic.w	r0, fp, #128	; 0x80
    e0c4:	9207      	str	r2, [sp, #28]
    e0c6:	9109      	str	r1, [sp, #36]	; 0x24
    e0c8:	9006      	str	r0, [sp, #24]
    e0ca:	2e47      	cmp	r6, #71	; 0x47
    e0cc:	bfd8      	it	le
    e0ce:	461f      	movle	r7, r3
    e0d0:	920d      	str	r2, [sp, #52]	; 0x34
    e0d2:	9110      	str	r1, [sp, #64]	; 0x40
    e0d4:	e4f9      	b.n	daca <_vfprintf_r+0x262>
    e0d6:	f04b 0b08 	orr.w	fp, fp, #8
    e0da:	f899 6000 	ldrb.w	r6, [r9]
    e0de:	e441      	b.n	d964 <_vfprintf_r+0xfc>
    e0e0:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    e0e2:	3507      	adds	r5, #7
    e0e4:	f025 0307 	bic.w	r3, r5, #7
    e0e8:	f103 0208 	add.w	r2, r3, #8
    e0ec:	e9d3 4500 	ldrd	r4, r5, [r3]
    e0f0:	920e      	str	r2, [sp, #56]	; 0x38
    e0f2:	2300      	movs	r3, #0
    e0f4:	e4c3      	b.n	da7e <_vfprintf_r+0x216>
    e0f6:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    e0f8:	3507      	adds	r5, #7
    e0fa:	f025 0307 	bic.w	r3, r5, #7
    e0fe:	f103 0208 	add.w	r2, r3, #8
    e102:	e9d3 4500 	ldrd	r4, r5, [r3]
    e106:	920e      	str	r2, [sp, #56]	; 0x38
    e108:	2301      	movs	r3, #1
    e10a:	e4b8      	b.n	da7e <_vfprintf_r+0x216>
    e10c:	2a00      	cmp	r2, #0
    e10e:	f040 865e 	bne.w	edce <_vfprintf_r+0x1566>
    e112:	b1c6      	cbz	r6, e146 <_vfprintf_r+0x8de>
    e114:	2300      	movs	r3, #0
    e116:	2201      	movs	r2, #1
    e118:	469a      	mov	sl, r3
    e11a:	9207      	str	r2, [sp, #28]
    e11c:	f88d 60a0 	strb.w	r6, [sp, #160]	; 0xa0
    e120:	f8cd b018 	str.w	fp, [sp, #24]
    e124:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
    e128:	9309      	str	r3, [sp, #36]	; 0x24
    e12a:	9310      	str	r3, [sp, #64]	; 0x40
    e12c:	920d      	str	r2, [sp, #52]	; 0x34
    e12e:	af28      	add	r7, sp, #160	; 0xa0
    e130:	e4d1      	b.n	dad6 <_vfprintf_r+0x26e>
    e132:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    e134:	6813      	ldr	r3, [r2, #0]
    e136:	3204      	adds	r2, #4
    e138:	920e      	str	r2, [sp, #56]	; 0x38
    e13a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    e13c:	601a      	str	r2, [r3, #0]
    e13e:	f7ff bbde 	b.w	d8fe <_vfprintf_r+0x96>
    e142:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e144:	e51d      	b.n	db82 <_vfprintf_r+0x31a>
    e146:	9b27      	ldr	r3, [sp, #156]	; 0x9c
    e148:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    e14c:	2b00      	cmp	r3, #0
    e14e:	f040 856d 	bne.w	ec2c <_vfprintf_r+0x13c4>
    e152:	2300      	movs	r3, #0
    e154:	9326      	str	r3, [sp, #152]	; 0x98
    e156:	f8da 3064 	ldr.w	r3, [sl, #100]	; 0x64
    e15a:	f013 0f01 	tst.w	r3, #1
    e15e:	f8ba 300c 	ldrh.w	r3, [sl, #12]
    e162:	d102      	bne.n	e16a <_vfprintf_r+0x902>
    e164:	059a      	lsls	r2, r3, #22
    e166:	f140 8248 	bpl.w	e5fa <_vfprintf_r+0xd92>
    e16a:	065b      	lsls	r3, r3, #25
    e16c:	f53f ade2 	bmi.w	dd34 <_vfprintf_r+0x4cc>
    e170:	980b      	ldr	r0, [sp, #44]	; 0x2c
    e172:	b043      	add	sp, #268	; 0x10c
    e174:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e178:	2e65      	cmp	r6, #101	; 0x65
    e17a:	f340 80b1 	ble.w	e2e0 <_vfprintf_r+0xa78>
    e17e:	2200      	movs	r2, #0
    e180:	2300      	movs	r3, #0
    e182:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    e186:	f7f3 f909 	bl	139c <__aeabi_dcmpeq>
    e18a:	2800      	cmp	r0, #0
    e18c:	f000 815f 	beq.w	e44e <_vfprintf_r+0xbe6>
    e190:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e192:	4a3a      	ldr	r2, [pc, #232]	; (e27c <_vfprintf_r+0xa14>)
    e194:	f8c8 2000 	str.w	r2, [r8]
    e198:	3301      	adds	r3, #1
    e19a:	3401      	adds	r4, #1
    e19c:	2201      	movs	r2, #1
    e19e:	2b07      	cmp	r3, #7
    e1a0:	9427      	str	r4, [sp, #156]	; 0x9c
    e1a2:	9326      	str	r3, [sp, #152]	; 0x98
    e1a4:	f8c8 2004 	str.w	r2, [r8, #4]
    e1a8:	f300 83c5 	bgt.w	e936 <_vfprintf_r+0x10ce>
    e1ac:	f108 0808 	add.w	r8, r8, #8
    e1b0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    e1b2:	9a11      	ldr	r2, [sp, #68]	; 0x44
    e1b4:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e1b6:	4293      	cmp	r3, r2
    e1b8:	db03      	blt.n	e1c2 <_vfprintf_r+0x95a>
    e1ba:	9b06      	ldr	r3, [sp, #24]
    e1bc:	07df      	lsls	r7, r3, #31
    e1be:	f57f ad5b 	bpl.w	dc78 <_vfprintf_r+0x410>
    e1c2:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e1c4:	9914      	ldr	r1, [sp, #80]	; 0x50
    e1c6:	9a15      	ldr	r2, [sp, #84]	; 0x54
    e1c8:	f8c8 2000 	str.w	r2, [r8]
    e1cc:	3301      	adds	r3, #1
    e1ce:	440c      	add	r4, r1
    e1d0:	2b07      	cmp	r3, #7
    e1d2:	f8c8 1004 	str.w	r1, [r8, #4]
    e1d6:	9427      	str	r4, [sp, #156]	; 0x9c
    e1d8:	9326      	str	r3, [sp, #152]	; 0x98
    e1da:	f300 83fe 	bgt.w	e9da <_vfprintf_r+0x1172>
    e1de:	f108 0808 	add.w	r8, r8, #8
    e1e2:	9b11      	ldr	r3, [sp, #68]	; 0x44
    e1e4:	1e5e      	subs	r6, r3, #1
    e1e6:	2e00      	cmp	r6, #0
    e1e8:	f77f ad46 	ble.w	dc78 <_vfprintf_r+0x410>
    e1ec:	2e10      	cmp	r6, #16
    e1ee:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e1f0:	4d23      	ldr	r5, [pc, #140]	; (e280 <_vfprintf_r+0xa18>)
    e1f2:	f340 81cf 	ble.w	e594 <_vfprintf_r+0xd2c>
    e1f6:	2710      	movs	r7, #16
    e1f8:	f8dd a020 	ldr.w	sl, [sp, #32]
    e1fc:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    e200:	e005      	b.n	e20e <_vfprintf_r+0x9a6>
    e202:	f108 0808 	add.w	r8, r8, #8
    e206:	3e10      	subs	r6, #16
    e208:	2e10      	cmp	r6, #16
    e20a:	f340 81c3 	ble.w	e594 <_vfprintf_r+0xd2c>
    e20e:	3301      	adds	r3, #1
    e210:	3410      	adds	r4, #16
    e212:	2b07      	cmp	r3, #7
    e214:	9427      	str	r4, [sp, #156]	; 0x9c
    e216:	9326      	str	r3, [sp, #152]	; 0x98
    e218:	e888 00a0 	stmia.w	r8, {r5, r7}
    e21c:	ddf1      	ble.n	e202 <_vfprintf_r+0x99a>
    e21e:	aa25      	add	r2, sp, #148	; 0x94
    e220:	4659      	mov	r1, fp
    e222:	4650      	mov	r0, sl
    e224:	f7fe fc8c 	bl	cb40 <__sprint_r>
    e228:	2800      	cmp	r0, #0
    e22a:	f040 83d3 	bne.w	e9d4 <_vfprintf_r+0x116c>
    e22e:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e230:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e232:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e236:	e7e6      	b.n	e206 <_vfprintf_r+0x99e>
    e238:	46aa      	mov	sl, r5
    e23a:	e78c      	b.n	e156 <_vfprintf_r+0x8ee>
    e23c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    e23e:	9a07      	ldr	r2, [sp, #28]
    e240:	eba3 0a02 	sub.w	sl, r3, r2
    e244:	f1ba 0f00 	cmp.w	sl, #0
    e248:	f77f acc0 	ble.w	dbcc <_vfprintf_r+0x364>
    e24c:	f1ba 0f10 	cmp.w	sl, #16
    e250:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e252:	4d0b      	ldr	r5, [pc, #44]	; (e280 <_vfprintf_r+0xa18>)
    e254:	dd38      	ble.n	e2c8 <_vfprintf_r+0xa60>
    e256:	4642      	mov	r2, r8
    e258:	4621      	mov	r1, r4
    e25a:	46b0      	mov	r8, r6
    e25c:	f04f 0b10 	mov.w	fp, #16
    e260:	462e      	mov	r6, r5
    e262:	9c08      	ldr	r4, [sp, #32]
    e264:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    e266:	e014      	b.n	e292 <_vfprintf_r+0xa2a>
    e268:	00012a50 	.word	0x00012a50
    e26c:	00012a3c 	.word	0x00012a3c
    e270:	7fefffff 	.word	0x7fefffff
    e274:	00012a30 	.word	0x00012a30
    e278:	00012a2c 	.word	0x00012a2c
    e27c:	00012a6c 	.word	0x00012a6c
    e280:	00012ac0 	.word	0x00012ac0
    e284:	f1aa 0a10 	sub.w	sl, sl, #16
    e288:	f1ba 0f10 	cmp.w	sl, #16
    e28c:	f102 0208 	add.w	r2, r2, #8
    e290:	dd16      	ble.n	e2c0 <_vfprintf_r+0xa58>
    e292:	3301      	adds	r3, #1
    e294:	3110      	adds	r1, #16
    e296:	2b07      	cmp	r3, #7
    e298:	9127      	str	r1, [sp, #156]	; 0x9c
    e29a:	9326      	str	r3, [sp, #152]	; 0x98
    e29c:	e882 0840 	stmia.w	r2, {r6, fp}
    e2a0:	ddf0      	ble.n	e284 <_vfprintf_r+0xa1c>
    e2a2:	aa25      	add	r2, sp, #148	; 0x94
    e2a4:	4629      	mov	r1, r5
    e2a6:	4620      	mov	r0, r4
    e2a8:	f7fe fc4a 	bl	cb40 <__sprint_r>
    e2ac:	2800      	cmp	r0, #0
    e2ae:	d1c3      	bne.n	e238 <_vfprintf_r+0x9d0>
    e2b0:	f1aa 0a10 	sub.w	sl, sl, #16
    e2b4:	f1ba 0f10 	cmp.w	sl, #16
    e2b8:	9927      	ldr	r1, [sp, #156]	; 0x9c
    e2ba:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e2bc:	aa32      	add	r2, sp, #200	; 0xc8
    e2be:	dce8      	bgt.n	e292 <_vfprintf_r+0xa2a>
    e2c0:	4635      	mov	r5, r6
    e2c2:	460c      	mov	r4, r1
    e2c4:	4646      	mov	r6, r8
    e2c6:	4690      	mov	r8, r2
    e2c8:	3301      	adds	r3, #1
    e2ca:	4454      	add	r4, sl
    e2cc:	2b07      	cmp	r3, #7
    e2ce:	9427      	str	r4, [sp, #156]	; 0x9c
    e2d0:	9326      	str	r3, [sp, #152]	; 0x98
    e2d2:	e888 0420 	stmia.w	r8, {r5, sl}
    e2d6:	f300 8265 	bgt.w	e7a4 <_vfprintf_r+0xf3c>
    e2da:	f108 0808 	add.w	r8, r8, #8
    e2de:	e475      	b.n	dbcc <_vfprintf_r+0x364>
    e2e0:	9b11      	ldr	r3, [sp, #68]	; 0x44
    e2e2:	9e26      	ldr	r6, [sp, #152]	; 0x98
    e2e4:	2b01      	cmp	r3, #1
    e2e6:	f340 81fe 	ble.w	e6e6 <_vfprintf_r+0xe7e>
    e2ea:	3601      	adds	r6, #1
    e2ec:	3401      	adds	r4, #1
    e2ee:	2301      	movs	r3, #1
    e2f0:	2e07      	cmp	r6, #7
    e2f2:	9427      	str	r4, [sp, #156]	; 0x9c
    e2f4:	9626      	str	r6, [sp, #152]	; 0x98
    e2f6:	f8c8 7000 	str.w	r7, [r8]
    e2fa:	f8c8 3004 	str.w	r3, [r8, #4]
    e2fe:	f300 820f 	bgt.w	e720 <_vfprintf_r+0xeb8>
    e302:	f108 0808 	add.w	r8, r8, #8
    e306:	9a14      	ldr	r2, [sp, #80]	; 0x50
    e308:	9b15      	ldr	r3, [sp, #84]	; 0x54
    e30a:	f8c8 3000 	str.w	r3, [r8]
    e30e:	3601      	adds	r6, #1
    e310:	4414      	add	r4, r2
    e312:	2e07      	cmp	r6, #7
    e314:	9427      	str	r4, [sp, #156]	; 0x9c
    e316:	9626      	str	r6, [sp, #152]	; 0x98
    e318:	f8c8 2004 	str.w	r2, [r8, #4]
    e31c:	f300 820d 	bgt.w	e73a <_vfprintf_r+0xed2>
    e320:	f108 0808 	add.w	r8, r8, #8
    e324:	2300      	movs	r3, #0
    e326:	2200      	movs	r2, #0
    e328:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    e32c:	f7f3 f836 	bl	139c <__aeabi_dcmpeq>
    e330:	9b11      	ldr	r3, [sp, #68]	; 0x44
    e332:	2800      	cmp	r0, #0
    e334:	f040 8106 	bne.w	e544 <_vfprintf_r+0xcdc>
    e338:	3b01      	subs	r3, #1
    e33a:	3601      	adds	r6, #1
    e33c:	3701      	adds	r7, #1
    e33e:	441c      	add	r4, r3
    e340:	2e07      	cmp	r6, #7
    e342:	9626      	str	r6, [sp, #152]	; 0x98
    e344:	9427      	str	r4, [sp, #156]	; 0x9c
    e346:	f8c8 7000 	str.w	r7, [r8]
    e34a:	f8c8 3004 	str.w	r3, [r8, #4]
    e34e:	f300 81da 	bgt.w	e706 <_vfprintf_r+0xe9e>
    e352:	f108 0808 	add.w	r8, r8, #8
    e356:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    e358:	f8c8 2004 	str.w	r2, [r8, #4]
    e35c:	3601      	adds	r6, #1
    e35e:	4414      	add	r4, r2
    e360:	ab21      	add	r3, sp, #132	; 0x84
    e362:	2e07      	cmp	r6, #7
    e364:	9427      	str	r4, [sp, #156]	; 0x9c
    e366:	9626      	str	r6, [sp, #152]	; 0x98
    e368:	f8c8 3000 	str.w	r3, [r8]
    e36c:	f77f ac82 	ble.w	dc74 <_vfprintf_r+0x40c>
    e370:	aa25      	add	r2, sp, #148	; 0x94
    e372:	990a      	ldr	r1, [sp, #40]	; 0x28
    e374:	9808      	ldr	r0, [sp, #32]
    e376:	f7fe fbe3 	bl	cb40 <__sprint_r>
    e37a:	b958      	cbnz	r0, e394 <_vfprintf_r+0xb2c>
    e37c:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e37e:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e382:	e479      	b.n	dc78 <_vfprintf_r+0x410>
    e384:	aa25      	add	r2, sp, #148	; 0x94
    e386:	990a      	ldr	r1, [sp, #40]	; 0x28
    e388:	9808      	ldr	r0, [sp, #32]
    e38a:	f7fe fbd9 	bl	cb40 <__sprint_r>
    e38e:	2800      	cmp	r0, #0
    e390:	f43f acbc 	beq.w	dd0c <_vfprintf_r+0x4a4>
    e394:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    e398:	e6dd      	b.n	e156 <_vfprintf_r+0x8ee>
    e39a:	f8dd b018 	ldr.w	fp, [sp, #24]
    e39e:	2b01      	cmp	r3, #1
    e3a0:	f000 8121 	beq.w	e5e6 <_vfprintf_r+0xd7e>
    e3a4:	2b02      	cmp	r3, #2
    e3a6:	d127      	bne.n	e3f8 <_vfprintf_r+0xb90>
    e3a8:	f8cd b018 	str.w	fp, [sp, #24]
    e3ac:	2400      	movs	r4, #0
    e3ae:	2500      	movs	r5, #0
    e3b0:	e589      	b.n	dec6 <_vfprintf_r+0x65e>
    e3b2:	aa25      	add	r2, sp, #148	; 0x94
    e3b4:	990a      	ldr	r1, [sp, #40]	; 0x28
    e3b6:	9808      	ldr	r0, [sp, #32]
    e3b8:	f7fe fbc2 	bl	cb40 <__sprint_r>
    e3bc:	2800      	cmp	r0, #0
    e3be:	d1e9      	bne.n	e394 <_vfprintf_r+0xb2c>
    e3c0:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e3c2:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e3c6:	e444      	b.n	dc52 <_vfprintf_r+0x3ea>
    e3c8:	aa25      	add	r2, sp, #148	; 0x94
    e3ca:	990a      	ldr	r1, [sp, #40]	; 0x28
    e3cc:	9808      	ldr	r0, [sp, #32]
    e3ce:	f7fe fbb7 	bl	cb40 <__sprint_r>
    e3d2:	2800      	cmp	r0, #0
    e3d4:	d1de      	bne.n	e394 <_vfprintf_r+0xb2c>
    e3d6:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e3d8:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e3dc:	f7ff bbe3 	b.w	dba6 <_vfprintf_r+0x33e>
    e3e0:	aa25      	add	r2, sp, #148	; 0x94
    e3e2:	990a      	ldr	r1, [sp, #40]	; 0x28
    e3e4:	9808      	ldr	r0, [sp, #32]
    e3e6:	f7fe fbab 	bl	cb40 <__sprint_r>
    e3ea:	2800      	cmp	r0, #0
    e3ec:	d1d2      	bne.n	e394 <_vfprintf_r+0xb2c>
    e3ee:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e3f0:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e3f4:	f7ff bbe7 	b.w	dbc6 <_vfprintf_r+0x35e>
    e3f8:	f8cd b018 	str.w	fp, [sp, #24]
    e3fc:	2400      	movs	r4, #0
    e3fe:	2500      	movs	r5, #0
    e400:	a932      	add	r1, sp, #200	; 0xc8
    e402:	e000      	b.n	e406 <_vfprintf_r+0xb9e>
    e404:	4639      	mov	r1, r7
    e406:	08e2      	lsrs	r2, r4, #3
    e408:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
    e40c:	08e8      	lsrs	r0, r5, #3
    e40e:	f004 0307 	and.w	r3, r4, #7
    e412:	4605      	mov	r5, r0
    e414:	4614      	mov	r4, r2
    e416:	3330      	adds	r3, #48	; 0x30
    e418:	ea54 0205 	orrs.w	r2, r4, r5
    e41c:	f801 3c01 	strb.w	r3, [r1, #-1]
    e420:	f101 37ff 	add.w	r7, r1, #4294967295	; 0xffffffff
    e424:	d1ee      	bne.n	e404 <_vfprintf_r+0xb9c>
    e426:	9a06      	ldr	r2, [sp, #24]
    e428:	07d2      	lsls	r2, r2, #31
    e42a:	f57f ad5c 	bpl.w	dee6 <_vfprintf_r+0x67e>
    e42e:	2b30      	cmp	r3, #48	; 0x30
    e430:	f43f ad59 	beq.w	dee6 <_vfprintf_r+0x67e>
    e434:	2330      	movs	r3, #48	; 0x30
    e436:	3902      	subs	r1, #2
    e438:	f807 3c01 	strb.w	r3, [r7, #-1]
    e43c:	ab32      	add	r3, sp, #200	; 0xc8
    e43e:	1a5b      	subs	r3, r3, r1
    e440:	930d      	str	r3, [sp, #52]	; 0x34
    e442:	460f      	mov	r7, r1
    e444:	f7ff bb39 	b.w	daba <_vfprintf_r+0x252>
    e448:	2302      	movs	r3, #2
    e44a:	f7ff bb18 	b.w	da7e <_vfprintf_r+0x216>
    e44e:	991f      	ldr	r1, [sp, #124]	; 0x7c
    e450:	2900      	cmp	r1, #0
    e452:	f340 827b 	ble.w	e94c <_vfprintf_r+0x10e4>
    e456:	9b10      	ldr	r3, [sp, #64]	; 0x40
    e458:	9a11      	ldr	r2, [sp, #68]	; 0x44
    e45a:	4293      	cmp	r3, r2
    e45c:	bfa8      	it	ge
    e45e:	4613      	movge	r3, r2
    e460:	2b00      	cmp	r3, #0
    e462:	461e      	mov	r6, r3
    e464:	dd0d      	ble.n	e482 <_vfprintf_r+0xc1a>
    e466:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e468:	f8c8 7000 	str.w	r7, [r8]
    e46c:	3301      	adds	r3, #1
    e46e:	4434      	add	r4, r6
    e470:	2b07      	cmp	r3, #7
    e472:	9427      	str	r4, [sp, #156]	; 0x9c
    e474:	f8c8 6004 	str.w	r6, [r8, #4]
    e478:	9326      	str	r3, [sp, #152]	; 0x98
    e47a:	f300 832d 	bgt.w	ead8 <_vfprintf_r+0x1270>
    e47e:	f108 0808 	add.w	r8, r8, #8
    e482:	9b10      	ldr	r3, [sp, #64]	; 0x40
    e484:	2e00      	cmp	r6, #0
    e486:	bfa8      	it	ge
    e488:	1b9b      	subge	r3, r3, r6
    e48a:	2b00      	cmp	r3, #0
    e48c:	461e      	mov	r6, r3
    e48e:	f340 80d0 	ble.w	e632 <_vfprintf_r+0xdca>
    e492:	2e10      	cmp	r6, #16
    e494:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e496:	4dba      	ldr	r5, [pc, #744]	; (e780 <_vfprintf_r+0xf18>)
    e498:	f340 80b7 	ble.w	e60a <_vfprintf_r+0xda2>
    e49c:	4622      	mov	r2, r4
    e49e:	f04f 0a10 	mov.w	sl, #16
    e4a2:	f8dd b020 	ldr.w	fp, [sp, #32]
    e4a6:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    e4a8:	e005      	b.n	e4b6 <_vfprintf_r+0xc4e>
    e4aa:	f108 0808 	add.w	r8, r8, #8
    e4ae:	3e10      	subs	r6, #16
    e4b0:	2e10      	cmp	r6, #16
    e4b2:	f340 80a9 	ble.w	e608 <_vfprintf_r+0xda0>
    e4b6:	3301      	adds	r3, #1
    e4b8:	3210      	adds	r2, #16
    e4ba:	2b07      	cmp	r3, #7
    e4bc:	9227      	str	r2, [sp, #156]	; 0x9c
    e4be:	9326      	str	r3, [sp, #152]	; 0x98
    e4c0:	e888 0420 	stmia.w	r8, {r5, sl}
    e4c4:	ddf1      	ble.n	e4aa <_vfprintf_r+0xc42>
    e4c6:	aa25      	add	r2, sp, #148	; 0x94
    e4c8:	4621      	mov	r1, r4
    e4ca:	4658      	mov	r0, fp
    e4cc:	f7fe fb38 	bl	cb40 <__sprint_r>
    e4d0:	2800      	cmp	r0, #0
    e4d2:	f040 832b 	bne.w	eb2c <_vfprintf_r+0x12c4>
    e4d6:	9a27      	ldr	r2, [sp, #156]	; 0x9c
    e4d8:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e4da:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e4de:	e7e6      	b.n	e4ae <_vfprintf_r+0xc46>
    e4e0:	2d00      	cmp	r5, #0
    e4e2:	bf08      	it	eq
    e4e4:	2c0a      	cmpeq	r4, #10
    e4e6:	d37c      	bcc.n	e5e2 <_vfprintf_r+0xd7a>
    e4e8:	af32      	add	r7, sp, #200	; 0xc8
    e4ea:	4620      	mov	r0, r4
    e4ec:	4629      	mov	r1, r5
    e4ee:	220a      	movs	r2, #10
    e4f0:	2300      	movs	r3, #0
    e4f2:	f7f2 ffc3 	bl	147c <__aeabi_uldivmod>
    e4f6:	3230      	adds	r2, #48	; 0x30
    e4f8:	f807 2d01 	strb.w	r2, [r7, #-1]!
    e4fc:	4620      	mov	r0, r4
    e4fe:	4629      	mov	r1, r5
    e500:	2300      	movs	r3, #0
    e502:	220a      	movs	r2, #10
    e504:	f7f2 ffba 	bl	147c <__aeabi_uldivmod>
    e508:	4604      	mov	r4, r0
    e50a:	460d      	mov	r5, r1
    e50c:	ea54 0305 	orrs.w	r3, r4, r5
    e510:	d1eb      	bne.n	e4ea <_vfprintf_r+0xc82>
    e512:	ab32      	add	r3, sp, #200	; 0xc8
    e514:	1bdb      	subs	r3, r3, r7
    e516:	930d      	str	r3, [sp, #52]	; 0x34
    e518:	f7ff bacf 	b.w	daba <_vfprintf_r+0x252>
    e51c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    e51e:	930d      	str	r3, [sp, #52]	; 0x34
    e520:	af32      	add	r7, sp, #200	; 0xc8
    e522:	f7ff baca 	b.w	daba <_vfprintf_r+0x252>
    e526:	aa25      	add	r2, sp, #148	; 0x94
    e528:	990a      	ldr	r1, [sp, #40]	; 0x28
    e52a:	9808      	ldr	r0, [sp, #32]
    e52c:	f7fe fb08 	bl	cb40 <__sprint_r>
    e530:	2800      	cmp	r0, #0
    e532:	f47f af2f 	bne.w	e394 <_vfprintf_r+0xb2c>
    e536:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
    e53a:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e53c:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e540:	f7ff bb1f 	b.w	db82 <_vfprintf_r+0x31a>
    e544:	1e5f      	subs	r7, r3, #1
    e546:	2f00      	cmp	r7, #0
    e548:	f77f af05 	ble.w	e356 <_vfprintf_r+0xaee>
    e54c:	2f10      	cmp	r7, #16
    e54e:	4d8c      	ldr	r5, [pc, #560]	; (e780 <_vfprintf_r+0xf18>)
    e550:	f340 8100 	ble.w	e754 <_vfprintf_r+0xeec>
    e554:	f04f 0a10 	mov.w	sl, #16
    e558:	f8dd b020 	ldr.w	fp, [sp, #32]
    e55c:	e005      	b.n	e56a <_vfprintf_r+0xd02>
    e55e:	f108 0808 	add.w	r8, r8, #8
    e562:	3f10      	subs	r7, #16
    e564:	2f10      	cmp	r7, #16
    e566:	f340 80f5 	ble.w	e754 <_vfprintf_r+0xeec>
    e56a:	3601      	adds	r6, #1
    e56c:	3410      	adds	r4, #16
    e56e:	2e07      	cmp	r6, #7
    e570:	9427      	str	r4, [sp, #156]	; 0x9c
    e572:	9626      	str	r6, [sp, #152]	; 0x98
    e574:	e888 0420 	stmia.w	r8, {r5, sl}
    e578:	ddf1      	ble.n	e55e <_vfprintf_r+0xcf6>
    e57a:	aa25      	add	r2, sp, #148	; 0x94
    e57c:	990a      	ldr	r1, [sp, #40]	; 0x28
    e57e:	4658      	mov	r0, fp
    e580:	f7fe fade 	bl	cb40 <__sprint_r>
    e584:	2800      	cmp	r0, #0
    e586:	f47f af05 	bne.w	e394 <_vfprintf_r+0xb2c>
    e58a:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e58c:	9e26      	ldr	r6, [sp, #152]	; 0x98
    e58e:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e592:	e7e6      	b.n	e562 <_vfprintf_r+0xcfa>
    e594:	3301      	adds	r3, #1
    e596:	4434      	add	r4, r6
    e598:	2b07      	cmp	r3, #7
    e59a:	9427      	str	r4, [sp, #156]	; 0x9c
    e59c:	9326      	str	r3, [sp, #152]	; 0x98
    e59e:	e888 0060 	stmia.w	r8, {r5, r6}
    e5a2:	f77f ab67 	ble.w	dc74 <_vfprintf_r+0x40c>
    e5a6:	e6e3      	b.n	e370 <_vfprintf_r+0xb08>
    e5a8:	681c      	ldr	r4, [r3, #0]
    e5aa:	3304      	adds	r3, #4
    e5ac:	930e      	str	r3, [sp, #56]	; 0x38
    e5ae:	2500      	movs	r5, #0
    e5b0:	e41b      	b.n	ddea <_vfprintf_r+0x582>
    e5b2:	990e      	ldr	r1, [sp, #56]	; 0x38
    e5b4:	460a      	mov	r2, r1
    e5b6:	3204      	adds	r2, #4
    e5b8:	680c      	ldr	r4, [r1, #0]
    e5ba:	920e      	str	r2, [sp, #56]	; 0x38
    e5bc:	2500      	movs	r5, #0
    e5be:	f7ff ba5e 	b.w	da7e <_vfprintf_r+0x216>
    e5c2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    e5c4:	6814      	ldr	r4, [r2, #0]
    e5c6:	4613      	mov	r3, r2
    e5c8:	3304      	adds	r3, #4
    e5ca:	17e5      	asrs	r5, r4, #31
    e5cc:	930e      	str	r3, [sp, #56]	; 0x38
    e5ce:	4622      	mov	r2, r4
    e5d0:	462b      	mov	r3, r5
    e5d2:	e45f      	b.n	de94 <_vfprintf_r+0x62c>
    e5d4:	3204      	adds	r2, #4
    e5d6:	681c      	ldr	r4, [r3, #0]
    e5d8:	920e      	str	r2, [sp, #56]	; 0x38
    e5da:	2301      	movs	r3, #1
    e5dc:	2500      	movs	r5, #0
    e5de:	f7ff ba4e 	b.w	da7e <_vfprintf_r+0x216>
    e5e2:	f8dd b018 	ldr.w	fp, [sp, #24]
    e5e6:	f8cd b018 	str.w	fp, [sp, #24]
    e5ea:	af42      	add	r7, sp, #264	; 0x108
    e5ec:	3430      	adds	r4, #48	; 0x30
    e5ee:	2301      	movs	r3, #1
    e5f0:	f807 4d41 	strb.w	r4, [r7, #-65]!
    e5f4:	930d      	str	r3, [sp, #52]	; 0x34
    e5f6:	f7ff ba60 	b.w	daba <_vfprintf_r+0x252>
    e5fa:	f8da 0058 	ldr.w	r0, [sl, #88]	; 0x58
    e5fe:	f7fc fb9d 	bl	ad3c <__retarget_lock_release_recursive>
    e602:	f8ba 300c 	ldrh.w	r3, [sl, #12]
    e606:	e5b0      	b.n	e16a <_vfprintf_r+0x902>
    e608:	4614      	mov	r4, r2
    e60a:	3301      	adds	r3, #1
    e60c:	4434      	add	r4, r6
    e60e:	2b07      	cmp	r3, #7
    e610:	9427      	str	r4, [sp, #156]	; 0x9c
    e612:	9326      	str	r3, [sp, #152]	; 0x98
    e614:	e888 0060 	stmia.w	r8, {r5, r6}
    e618:	f340 8174 	ble.w	e904 <_vfprintf_r+0x109c>
    e61c:	aa25      	add	r2, sp, #148	; 0x94
    e61e:	990a      	ldr	r1, [sp, #40]	; 0x28
    e620:	9808      	ldr	r0, [sp, #32]
    e622:	f7fe fa8d 	bl	cb40 <__sprint_r>
    e626:	2800      	cmp	r0, #0
    e628:	f47f aeb4 	bne.w	e394 <_vfprintf_r+0xb2c>
    e62c:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e62e:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e632:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    e634:	9a11      	ldr	r2, [sp, #68]	; 0x44
    e636:	4293      	cmp	r3, r2
    e638:	f280 815f 	bge.w	e8fa <_vfprintf_r+0x1092>
    e63c:	9a26      	ldr	r2, [sp, #152]	; 0x98
    e63e:	9814      	ldr	r0, [sp, #80]	; 0x50
    e640:	9915      	ldr	r1, [sp, #84]	; 0x54
    e642:	f8c8 1000 	str.w	r1, [r8]
    e646:	3201      	adds	r2, #1
    e648:	4404      	add	r4, r0
    e64a:	2a07      	cmp	r2, #7
    e64c:	9427      	str	r4, [sp, #156]	; 0x9c
    e64e:	f8c8 0004 	str.w	r0, [r8, #4]
    e652:	9226      	str	r2, [sp, #152]	; 0x98
    e654:	f300 8159 	bgt.w	e90a <_vfprintf_r+0x10a2>
    e658:	f108 0808 	add.w	r8, r8, #8
    e65c:	9a11      	ldr	r2, [sp, #68]	; 0x44
    e65e:	9910      	ldr	r1, [sp, #64]	; 0x40
    e660:	1ad3      	subs	r3, r2, r3
    e662:	1a56      	subs	r6, r2, r1
    e664:	429e      	cmp	r6, r3
    e666:	bfa8      	it	ge
    e668:	461e      	movge	r6, r3
    e66a:	2e00      	cmp	r6, #0
    e66c:	dd0e      	ble.n	e68c <_vfprintf_r+0xe24>
    e66e:	9a26      	ldr	r2, [sp, #152]	; 0x98
    e670:	f8c8 6004 	str.w	r6, [r8, #4]
    e674:	3201      	adds	r2, #1
    e676:	440f      	add	r7, r1
    e678:	4434      	add	r4, r6
    e67a:	2a07      	cmp	r2, #7
    e67c:	f8c8 7000 	str.w	r7, [r8]
    e680:	9427      	str	r4, [sp, #156]	; 0x9c
    e682:	9226      	str	r2, [sp, #152]	; 0x98
    e684:	f300 8243 	bgt.w	eb0e <_vfprintf_r+0x12a6>
    e688:	f108 0808 	add.w	r8, r8, #8
    e68c:	2e00      	cmp	r6, #0
    e68e:	bfac      	ite	ge
    e690:	1b9e      	subge	r6, r3, r6
    e692:	461e      	movlt	r6, r3
    e694:	2e00      	cmp	r6, #0
    e696:	f77f aaef 	ble.w	dc78 <_vfprintf_r+0x410>
    e69a:	2e10      	cmp	r6, #16
    e69c:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e69e:	4d38      	ldr	r5, [pc, #224]	; (e780 <_vfprintf_r+0xf18>)
    e6a0:	f77f af78 	ble.w	e594 <_vfprintf_r+0xd2c>
    e6a4:	2710      	movs	r7, #16
    e6a6:	f8dd a020 	ldr.w	sl, [sp, #32]
    e6aa:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    e6ae:	e005      	b.n	e6bc <_vfprintf_r+0xe54>
    e6b0:	f108 0808 	add.w	r8, r8, #8
    e6b4:	3e10      	subs	r6, #16
    e6b6:	2e10      	cmp	r6, #16
    e6b8:	f77f af6c 	ble.w	e594 <_vfprintf_r+0xd2c>
    e6bc:	3301      	adds	r3, #1
    e6be:	3410      	adds	r4, #16
    e6c0:	2b07      	cmp	r3, #7
    e6c2:	9427      	str	r4, [sp, #156]	; 0x9c
    e6c4:	9326      	str	r3, [sp, #152]	; 0x98
    e6c6:	e888 00a0 	stmia.w	r8, {r5, r7}
    e6ca:	ddf1      	ble.n	e6b0 <_vfprintf_r+0xe48>
    e6cc:	aa25      	add	r2, sp, #148	; 0x94
    e6ce:	4659      	mov	r1, fp
    e6d0:	4650      	mov	r0, sl
    e6d2:	f7fe fa35 	bl	cb40 <__sprint_r>
    e6d6:	2800      	cmp	r0, #0
    e6d8:	f040 817c 	bne.w	e9d4 <_vfprintf_r+0x116c>
    e6dc:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e6de:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e6e0:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e6e4:	e7e6      	b.n	e6b4 <_vfprintf_r+0xe4c>
    e6e6:	9b06      	ldr	r3, [sp, #24]
    e6e8:	07d8      	lsls	r0, r3, #31
    e6ea:	f53f adfe 	bmi.w	e2ea <_vfprintf_r+0xa82>
    e6ee:	3601      	adds	r6, #1
    e6f0:	3401      	adds	r4, #1
    e6f2:	2301      	movs	r3, #1
    e6f4:	2e07      	cmp	r6, #7
    e6f6:	9427      	str	r4, [sp, #156]	; 0x9c
    e6f8:	9626      	str	r6, [sp, #152]	; 0x98
    e6fa:	f8c8 7000 	str.w	r7, [r8]
    e6fe:	f8c8 3004 	str.w	r3, [r8, #4]
    e702:	f77f ae26 	ble.w	e352 <_vfprintf_r+0xaea>
    e706:	aa25      	add	r2, sp, #148	; 0x94
    e708:	990a      	ldr	r1, [sp, #40]	; 0x28
    e70a:	9808      	ldr	r0, [sp, #32]
    e70c:	f7fe fa18 	bl	cb40 <__sprint_r>
    e710:	2800      	cmp	r0, #0
    e712:	f47f ae3f 	bne.w	e394 <_vfprintf_r+0xb2c>
    e716:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e718:	9e26      	ldr	r6, [sp, #152]	; 0x98
    e71a:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e71e:	e61a      	b.n	e356 <_vfprintf_r+0xaee>
    e720:	aa25      	add	r2, sp, #148	; 0x94
    e722:	990a      	ldr	r1, [sp, #40]	; 0x28
    e724:	9808      	ldr	r0, [sp, #32]
    e726:	f7fe fa0b 	bl	cb40 <__sprint_r>
    e72a:	2800      	cmp	r0, #0
    e72c:	f47f ae32 	bne.w	e394 <_vfprintf_r+0xb2c>
    e730:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e732:	9e26      	ldr	r6, [sp, #152]	; 0x98
    e734:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e738:	e5e5      	b.n	e306 <_vfprintf_r+0xa9e>
    e73a:	aa25      	add	r2, sp, #148	; 0x94
    e73c:	990a      	ldr	r1, [sp, #40]	; 0x28
    e73e:	9808      	ldr	r0, [sp, #32]
    e740:	f7fe f9fe 	bl	cb40 <__sprint_r>
    e744:	2800      	cmp	r0, #0
    e746:	f47f ae25 	bne.w	e394 <_vfprintf_r+0xb2c>
    e74a:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e74c:	9e26      	ldr	r6, [sp, #152]	; 0x98
    e74e:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e752:	e5e7      	b.n	e324 <_vfprintf_r+0xabc>
    e754:	3601      	adds	r6, #1
    e756:	443c      	add	r4, r7
    e758:	2e07      	cmp	r6, #7
    e75a:	9427      	str	r4, [sp, #156]	; 0x9c
    e75c:	9626      	str	r6, [sp, #152]	; 0x98
    e75e:	e888 00a0 	stmia.w	r8, {r5, r7}
    e762:	f77f adf6 	ble.w	e352 <_vfprintf_r+0xaea>
    e766:	e7ce      	b.n	e706 <_vfprintf_r+0xe9e>
    e768:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    e76a:	3507      	adds	r5, #7
    e76c:	f025 0307 	bic.w	r3, r5, #7
    e770:	f103 0208 	add.w	r2, r3, #8
    e774:	920e      	str	r2, [sp, #56]	; 0x38
    e776:	e9d3 4500 	ldrd	r4, r5, [r3]
    e77a:	f7ff bb36 	b.w	ddea <_vfprintf_r+0x582>
    e77e:	bf00      	nop
    e780:	00012ac0 	.word	0x00012ac0
    e784:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    e786:	3507      	adds	r5, #7
    e788:	f025 0507 	bic.w	r5, r5, #7
    e78c:	e9d5 2300 	ldrd	r2, r3, [r5]
    e790:	f105 0108 	add.w	r1, r5, #8
    e794:	910e      	str	r1, [sp, #56]	; 0x38
    e796:	4614      	mov	r4, r2
    e798:	461d      	mov	r5, r3
    e79a:	f7ff bb7b 	b.w	de94 <_vfprintf_r+0x62c>
    e79e:	af32      	add	r7, sp, #200	; 0xc8
    e7a0:	f7ff b98b 	b.w	daba <_vfprintf_r+0x252>
    e7a4:	aa25      	add	r2, sp, #148	; 0x94
    e7a6:	990a      	ldr	r1, [sp, #40]	; 0x28
    e7a8:	9808      	ldr	r0, [sp, #32]
    e7aa:	f7fe f9c9 	bl	cb40 <__sprint_r>
    e7ae:	2800      	cmp	r0, #0
    e7b0:	f47f adf0 	bne.w	e394 <_vfprintf_r+0xb2c>
    e7b4:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e7b6:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e7ba:	f7ff ba07 	b.w	dbcc <_vfprintf_r+0x364>
    e7be:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
    e7c2:	4264      	negs	r4, r4
    e7c4:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
    e7c8:	f88d a077 	strb.w	sl, [sp, #119]	; 0x77
    e7cc:	2301      	movs	r3, #1
    e7ce:	f7ff b95a 	b.w	da86 <_vfprintf_r+0x21e>
    e7d2:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    e7d6:	4602      	mov	r2, r0
    e7d8:	460b      	mov	r3, r1
    e7da:	f7f2 fe11 	bl	1400 <__aeabi_dcmpun>
    e7de:	2800      	cmp	r0, #0
    e7e0:	f040 828d 	bne.w	ecfe <_vfprintf_r+0x1496>
    e7e4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    e7e6:	3301      	adds	r3, #1
    e7e8:	f026 0a20 	bic.w	sl, r6, #32
    e7ec:	f000 80a0 	beq.w	e930 <_vfprintf_r+0x10c8>
    e7f0:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
    e7f4:	d104      	bne.n	e800 <_vfprintf_r+0xf98>
    e7f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    e7f8:	2b00      	cmp	r3, #0
    e7fa:	bf08      	it	eq
    e7fc:	2301      	moveq	r3, #1
    e7fe:	9309      	str	r3, [sp, #36]	; 0x24
    e800:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    e802:	f44b 7280 	orr.w	r2, fp, #256	; 0x100
    e806:	2b00      	cmp	r3, #0
    e808:	9206      	str	r2, [sp, #24]
    e80a:	f2c0 81aa 	blt.w	eb62 <_vfprintf_r+0x12fa>
    e80e:	ed9d 7b12 	vldr	d7, [sp, #72]	; 0x48
    e812:	ed8d 7b1a 	vstr	d7, [sp, #104]	; 0x68
    e816:	2300      	movs	r3, #0
    e818:	930f      	str	r3, [sp, #60]	; 0x3c
    e81a:	2e66      	cmp	r6, #102	; 0x66
    e81c:	f000 8189 	beq.w	eb32 <_vfprintf_r+0x12ca>
    e820:	2e46      	cmp	r6, #70	; 0x46
    e822:	f000 81db 	beq.w	ebdc <_vfprintf_r+0x1374>
    e826:	f1ba 0f45 	cmp.w	sl, #69	; 0x45
    e82a:	bf0a      	itet	eq
    e82c:	9b09      	ldreq	r3, [sp, #36]	; 0x24
    e82e:	9d09      	ldrne	r5, [sp, #36]	; 0x24
    e830:	1c5d      	addeq	r5, r3, #1
    e832:	a823      	add	r0, sp, #140	; 0x8c
    e834:	a920      	add	r1, sp, #128	; 0x80
    e836:	aa1f      	add	r2, sp, #124	; 0x7c
    e838:	2302      	movs	r3, #2
    e83a:	9004      	str	r0, [sp, #16]
    e83c:	9202      	str	r2, [sp, #8]
    e83e:	9300      	str	r3, [sp, #0]
    e840:	9501      	str	r5, [sp, #4]
    e842:	9103      	str	r1, [sp, #12]
    e844:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
    e848:	9808      	ldr	r0, [sp, #32]
    e84a:	f000 fcf1 	bl	f230 <_dtoa_r>
    e84e:	2e67      	cmp	r6, #103	; 0x67
    e850:	4607      	mov	r7, r0
    e852:	f040 81aa 	bne.w	ebaa <_vfprintf_r+0x1342>
    e856:	f01b 0f01 	tst.w	fp, #1
    e85a:	f000 8246 	beq.w	ecea <_vfprintf_r+0x1482>
    e85e:	197c      	adds	r4, r7, r5
    e860:	2200      	movs	r2, #0
    e862:	2300      	movs	r3, #0
    e864:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
    e868:	f7f2 fd98 	bl	139c <__aeabi_dcmpeq>
    e86c:	2800      	cmp	r0, #0
    e86e:	f040 8131 	bne.w	ead4 <_vfprintf_r+0x126c>
    e872:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    e874:	42a3      	cmp	r3, r4
    e876:	d206      	bcs.n	e886 <_vfprintf_r+0x101e>
    e878:	2130      	movs	r1, #48	; 0x30
    e87a:	1c5a      	adds	r2, r3, #1
    e87c:	9223      	str	r2, [sp, #140]	; 0x8c
    e87e:	7019      	strb	r1, [r3, #0]
    e880:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    e882:	429c      	cmp	r4, r3
    e884:	d8f9      	bhi.n	e87a <_vfprintf_r+0x1012>
    e886:	1bdb      	subs	r3, r3, r7
    e888:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
    e88c:	9311      	str	r3, [sp, #68]	; 0x44
    e88e:	f000 80c4 	beq.w	ea1a <_vfprintf_r+0x11b2>
    e892:	2e65      	cmp	r6, #101	; 0x65
    e894:	f340 8289 	ble.w	edaa <_vfprintf_r+0x1542>
    e898:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    e89a:	9310      	str	r3, [sp, #64]	; 0x40
    e89c:	2e66      	cmp	r6, #102	; 0x66
    e89e:	f000 8176 	beq.w	eb8e <_vfprintf_r+0x1326>
    e8a2:	9b11      	ldr	r3, [sp, #68]	; 0x44
    e8a4:	9a10      	ldr	r2, [sp, #64]	; 0x40
    e8a6:	4619      	mov	r1, r3
    e8a8:	4291      	cmp	r1, r2
    e8aa:	f300 8163 	bgt.w	eb74 <_vfprintf_r+0x130c>
    e8ae:	f01b 0f01 	tst.w	fp, #1
    e8b2:	f040 8211 	bne.w	ecd8 <_vfprintf_r+0x1470>
    e8b6:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    e8ba:	9307      	str	r3, [sp, #28]
    e8bc:	920d      	str	r2, [sp, #52]	; 0x34
    e8be:	2667      	movs	r6, #103	; 0x67
    e8c0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    e8c2:	2b00      	cmp	r3, #0
    e8c4:	f040 80a1 	bne.w	ea0a <_vfprintf_r+0x11a2>
    e8c8:	9309      	str	r3, [sp, #36]	; 0x24
    e8ca:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
    e8ce:	f7ff b8fc 	b.w	daca <_vfprintf_r+0x262>
    e8d2:	f025 0507 	bic.w	r5, r5, #7
    e8d6:	ed95 7b00 	vldr	d7, [r5]
    e8da:	f105 0308 	add.w	r3, r5, #8
    e8de:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
    e8e2:	930e      	str	r3, [sp, #56]	; 0x38
    e8e4:	f7ff bbc1 	b.w	e06a <_vfprintf_r+0x802>
    e8e8:	f8da 0058 	ldr.w	r0, [sl, #88]	; 0x58
    e8ec:	f7fc fa26 	bl	ad3c <__retarget_lock_release_recursive>
    e8f0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    e8f4:	930b      	str	r3, [sp, #44]	; 0x2c
    e8f6:	f7ff ba20 	b.w	dd3a <_vfprintf_r+0x4d2>
    e8fa:	9a06      	ldr	r2, [sp, #24]
    e8fc:	07d5      	lsls	r5, r2, #31
    e8fe:	f57f aead 	bpl.w	e65c <_vfprintf_r+0xdf4>
    e902:	e69b      	b.n	e63c <_vfprintf_r+0xdd4>
    e904:	f108 0808 	add.w	r8, r8, #8
    e908:	e693      	b.n	e632 <_vfprintf_r+0xdca>
    e90a:	aa25      	add	r2, sp, #148	; 0x94
    e90c:	990a      	ldr	r1, [sp, #40]	; 0x28
    e90e:	9808      	ldr	r0, [sp, #32]
    e910:	f7fe f916 	bl	cb40 <__sprint_r>
    e914:	2800      	cmp	r0, #0
    e916:	f47f ad3d 	bne.w	e394 <_vfprintf_r+0xb2c>
    e91a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    e91c:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e91e:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e922:	e69b      	b.n	e65c <_vfprintf_r+0xdf4>
    e924:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
    e928:	f88d a077 	strb.w	sl, [sp, #119]	; 0x77
    e92c:	f7ff bbc4 	b.w	e0b8 <_vfprintf_r+0x850>
    e930:	2306      	movs	r3, #6
    e932:	9309      	str	r3, [sp, #36]	; 0x24
    e934:	e764      	b.n	e800 <_vfprintf_r+0xf98>
    e936:	aa25      	add	r2, sp, #148	; 0x94
    e938:	990a      	ldr	r1, [sp, #40]	; 0x28
    e93a:	9808      	ldr	r0, [sp, #32]
    e93c:	f7fe f900 	bl	cb40 <__sprint_r>
    e940:	2800      	cmp	r0, #0
    e942:	f47f ad27 	bne.w	e394 <_vfprintf_r+0xb2c>
    e946:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e94a:	e431      	b.n	e1b0 <_vfprintf_r+0x948>
    e94c:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e94e:	4ab2      	ldr	r2, [pc, #712]	; (ec18 <_vfprintf_r+0x13b0>)
    e950:	f8c8 2000 	str.w	r2, [r8]
    e954:	3301      	adds	r3, #1
    e956:	3401      	adds	r4, #1
    e958:	2201      	movs	r2, #1
    e95a:	2b07      	cmp	r3, #7
    e95c:	9427      	str	r4, [sp, #156]	; 0x9c
    e95e:	9326      	str	r3, [sp, #152]	; 0x98
    e960:	f8c8 2004 	str.w	r2, [r8, #4]
    e964:	f300 812d 	bgt.w	ebc2 <_vfprintf_r+0x135a>
    e968:	f108 0808 	add.w	r8, r8, #8
    e96c:	b929      	cbnz	r1, e97a <_vfprintf_r+0x1112>
    e96e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    e970:	b91b      	cbnz	r3, e97a <_vfprintf_r+0x1112>
    e972:	9b06      	ldr	r3, [sp, #24]
    e974:	07de      	lsls	r6, r3, #31
    e976:	f57f a97f 	bpl.w	dc78 <_vfprintf_r+0x410>
    e97a:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e97c:	9814      	ldr	r0, [sp, #80]	; 0x50
    e97e:	9a15      	ldr	r2, [sp, #84]	; 0x54
    e980:	f8c8 2000 	str.w	r2, [r8]
    e984:	3301      	adds	r3, #1
    e986:	4602      	mov	r2, r0
    e988:	4422      	add	r2, r4
    e98a:	2b07      	cmp	r3, #7
    e98c:	9227      	str	r2, [sp, #156]	; 0x9c
    e98e:	f8c8 0004 	str.w	r0, [r8, #4]
    e992:	9326      	str	r3, [sp, #152]	; 0x98
    e994:	f300 817a 	bgt.w	ec8c <_vfprintf_r+0x1424>
    e998:	f108 0808 	add.w	r8, r8, #8
    e99c:	2900      	cmp	r1, #0
    e99e:	f2c0 814f 	blt.w	ec40 <_vfprintf_r+0x13d8>
    e9a2:	9911      	ldr	r1, [sp, #68]	; 0x44
    e9a4:	f8c8 7000 	str.w	r7, [r8]
    e9a8:	3301      	adds	r3, #1
    e9aa:	188c      	adds	r4, r1, r2
    e9ac:	2b07      	cmp	r3, #7
    e9ae:	9427      	str	r4, [sp, #156]	; 0x9c
    e9b0:	9326      	str	r3, [sp, #152]	; 0x98
    e9b2:	f8c8 1004 	str.w	r1, [r8, #4]
    e9b6:	f77f a95d 	ble.w	dc74 <_vfprintf_r+0x40c>
    e9ba:	e4d9      	b.n	e370 <_vfprintf_r+0xb08>
    e9bc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    e9be:	990b      	ldr	r1, [sp, #44]	; 0x2c
    e9c0:	6813      	ldr	r3, [r2, #0]
    e9c2:	17cd      	asrs	r5, r1, #31
    e9c4:	4608      	mov	r0, r1
    e9c6:	3204      	adds	r2, #4
    e9c8:	4629      	mov	r1, r5
    e9ca:	920e      	str	r2, [sp, #56]	; 0x38
    e9cc:	e9c3 0100 	strd	r0, r1, [r3]
    e9d0:	f7fe bf95 	b.w	d8fe <_vfprintf_r+0x96>
    e9d4:	46da      	mov	sl, fp
    e9d6:	f7ff bbbe 	b.w	e156 <_vfprintf_r+0x8ee>
    e9da:	aa25      	add	r2, sp, #148	; 0x94
    e9dc:	990a      	ldr	r1, [sp, #40]	; 0x28
    e9de:	9808      	ldr	r0, [sp, #32]
    e9e0:	f7fe f8ae 	bl	cb40 <__sprint_r>
    e9e4:	2800      	cmp	r0, #0
    e9e6:	f47f acd5 	bne.w	e394 <_vfprintf_r+0xb2c>
    e9ea:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e9ec:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e9f0:	f7ff bbf7 	b.w	e1e2 <_vfprintf_r+0x97a>
    e9f4:	4638      	mov	r0, r7
    e9f6:	9409      	str	r4, [sp, #36]	; 0x24
    e9f8:	f7f2 f842 	bl	a80 <strlen>
    e9fc:	950e      	str	r5, [sp, #56]	; 0x38
    e9fe:	900d      	str	r0, [sp, #52]	; 0x34
    ea00:	f8cd b018 	str.w	fp, [sp, #24]
    ea04:	4603      	mov	r3, r0
    ea06:	f7ff ba27 	b.w	de58 <_vfprintf_r+0x5f0>
    ea0a:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
    ea0e:	2300      	movs	r3, #0
    ea10:	f88d a077 	strb.w	sl, [sp, #119]	; 0x77
    ea14:	9309      	str	r3, [sp, #36]	; 0x24
    ea16:	f7ff b85b 	b.w	dad0 <_vfprintf_r+0x268>
    ea1a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    ea1c:	9310      	str	r3, [sp, #64]	; 0x40
    ea1e:	461a      	mov	r2, r3
    ea20:	3303      	adds	r3, #3
    ea22:	db04      	blt.n	ea2e <_vfprintf_r+0x11c6>
    ea24:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ea26:	4619      	mov	r1, r3
    ea28:	4291      	cmp	r1, r2
    ea2a:	f6bf af3a 	bge.w	e8a2 <_vfprintf_r+0x103a>
    ea2e:	3e02      	subs	r6, #2
    ea30:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ea32:	f88d 6084 	strb.w	r6, [sp, #132]	; 0x84
    ea36:	3b01      	subs	r3, #1
    ea38:	2b00      	cmp	r3, #0
    ea3a:	931f      	str	r3, [sp, #124]	; 0x7c
    ea3c:	bfbd      	ittte	lt
    ea3e:	9b10      	ldrlt	r3, [sp, #64]	; 0x40
    ea40:	f1c3 0301 	rsblt	r3, r3, #1
    ea44:	222d      	movlt	r2, #45	; 0x2d
    ea46:	222b      	movge	r2, #43	; 0x2b
    ea48:	2b09      	cmp	r3, #9
    ea4a:	f88d 2085 	strb.w	r2, [sp, #133]	; 0x85
    ea4e:	f340 814e 	ble.w	ecee <_vfprintf_r+0x1486>
    ea52:	f10d 0493 	add.w	r4, sp, #147	; 0x93
    ea56:	4620      	mov	r0, r4
    ea58:	4d70      	ldr	r5, [pc, #448]	; (ec1c <_vfprintf_r+0x13b4>)
    ea5a:	e000      	b.n	ea5e <_vfprintf_r+0x11f6>
    ea5c:	4610      	mov	r0, r2
    ea5e:	fb85 1203 	smull	r1, r2, r5, r3
    ea62:	17d9      	asrs	r1, r3, #31
    ea64:	ebc1 01a2 	rsb	r1, r1, r2, asr #2
    ea68:	eb01 0281 	add.w	r2, r1, r1, lsl #2
    ea6c:	eba3 0242 	sub.w	r2, r3, r2, lsl #1
    ea70:	3230      	adds	r2, #48	; 0x30
    ea72:	2909      	cmp	r1, #9
    ea74:	f800 2c01 	strb.w	r2, [r0, #-1]
    ea78:	460b      	mov	r3, r1
    ea7a:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    ea7e:	dced      	bgt.n	ea5c <_vfprintf_r+0x11f4>
    ea80:	3330      	adds	r3, #48	; 0x30
    ea82:	3802      	subs	r0, #2
    ea84:	b2d9      	uxtb	r1, r3
    ea86:	4284      	cmp	r4, r0
    ea88:	f802 1c01 	strb.w	r1, [r2, #-1]
    ea8c:	f240 8198 	bls.w	edc0 <_vfprintf_r+0x1558>
    ea90:	f10d 0086 	add.w	r0, sp, #134	; 0x86
    ea94:	4613      	mov	r3, r2
    ea96:	e001      	b.n	ea9c <_vfprintf_r+0x1234>
    ea98:	f813 1b01 	ldrb.w	r1, [r3], #1
    ea9c:	f800 1b01 	strb.w	r1, [r0], #1
    eaa0:	42a3      	cmp	r3, r4
    eaa2:	d1f9      	bne.n	ea98 <_vfprintf_r+0x1230>
    eaa4:	3301      	adds	r3, #1
    eaa6:	1a9b      	subs	r3, r3, r2
    eaa8:	f10d 0286 	add.w	r2, sp, #134	; 0x86
    eaac:	4413      	add	r3, r2
    eaae:	aa21      	add	r2, sp, #132	; 0x84
    eab0:	1a9b      	subs	r3, r3, r2
    eab2:	9a11      	ldr	r2, [sp, #68]	; 0x44
    eab4:	9317      	str	r3, [sp, #92]	; 0x5c
    eab6:	2a01      	cmp	r2, #1
    eab8:	4413      	add	r3, r2
    eaba:	930d      	str	r3, [sp, #52]	; 0x34
    eabc:	f340 814c 	ble.w	ed58 <_vfprintf_r+0x14f0>
    eac0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    eac2:	9a14      	ldr	r2, [sp, #80]	; 0x50
    eac4:	4413      	add	r3, r2
    eac6:	930d      	str	r3, [sp, #52]	; 0x34
    eac8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    eacc:	9307      	str	r3, [sp, #28]
    eace:	2300      	movs	r3, #0
    ead0:	9310      	str	r3, [sp, #64]	; 0x40
    ead2:	e6f5      	b.n	e8c0 <_vfprintf_r+0x1058>
    ead4:	4623      	mov	r3, r4
    ead6:	e6d6      	b.n	e886 <_vfprintf_r+0x101e>
    ead8:	aa25      	add	r2, sp, #148	; 0x94
    eada:	990a      	ldr	r1, [sp, #40]	; 0x28
    eadc:	9808      	ldr	r0, [sp, #32]
    eade:	f7fe f82f 	bl	cb40 <__sprint_r>
    eae2:	2800      	cmp	r0, #0
    eae4:	f47f ac56 	bne.w	e394 <_vfprintf_r+0xb2c>
    eae8:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    eaea:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    eaee:	e4c8      	b.n	e482 <_vfprintf_r+0xc1a>
    eaf0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    eaf2:	9710      	str	r7, [sp, #64]	; 0x40
    eaf4:	2b06      	cmp	r3, #6
    eaf6:	bf28      	it	cs
    eaf8:	2306      	movcs	r3, #6
    eafa:	9709      	str	r7, [sp, #36]	; 0x24
    eafc:	46ba      	mov	sl, r7
    eafe:	9307      	str	r3, [sp, #28]
    eb00:	950e      	str	r5, [sp, #56]	; 0x38
    eb02:	f8cd b018 	str.w	fp, [sp, #24]
    eb06:	930d      	str	r3, [sp, #52]	; 0x34
    eb08:	4f45      	ldr	r7, [pc, #276]	; (ec20 <_vfprintf_r+0x13b8>)
    eb0a:	f7fe bfde 	b.w	daca <_vfprintf_r+0x262>
    eb0e:	aa25      	add	r2, sp, #148	; 0x94
    eb10:	990a      	ldr	r1, [sp, #40]	; 0x28
    eb12:	9808      	ldr	r0, [sp, #32]
    eb14:	f7fe f814 	bl	cb40 <__sprint_r>
    eb18:	2800      	cmp	r0, #0
    eb1a:	f47f ac3b 	bne.w	e394 <_vfprintf_r+0xb2c>
    eb1e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    eb20:	9a11      	ldr	r2, [sp, #68]	; 0x44
    eb22:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    eb24:	1ad3      	subs	r3, r2, r3
    eb26:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    eb2a:	e5af      	b.n	e68c <_vfprintf_r+0xe24>
    eb2c:	46a2      	mov	sl, r4
    eb2e:	f7ff bb12 	b.w	e156 <_vfprintf_r+0x8ee>
    eb32:	9d09      	ldr	r5, [sp, #36]	; 0x24
    eb34:	9501      	str	r5, [sp, #4]
    eb36:	a823      	add	r0, sp, #140	; 0x8c
    eb38:	a920      	add	r1, sp, #128	; 0x80
    eb3a:	aa1f      	add	r2, sp, #124	; 0x7c
    eb3c:	2303      	movs	r3, #3
    eb3e:	9004      	str	r0, [sp, #16]
    eb40:	9202      	str	r2, [sp, #8]
    eb42:	9300      	str	r3, [sp, #0]
    eb44:	9103      	str	r1, [sp, #12]
    eb46:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
    eb4a:	9808      	ldr	r0, [sp, #32]
    eb4c:	f000 fb70 	bl	f230 <_dtoa_r>
    eb50:	4607      	mov	r7, r0
    eb52:	1944      	adds	r4, r0, r5
    eb54:	783b      	ldrb	r3, [r7, #0]
    eb56:	2b30      	cmp	r3, #48	; 0x30
    eb58:	f000 80de 	beq.w	ed18 <_vfprintf_r+0x14b0>
    eb5c:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
    eb5e:	442c      	add	r4, r5
    eb60:	e67e      	b.n	e860 <_vfprintf_r+0xff8>
    eb62:	e9dd 1212 	ldrd	r1, r2, [sp, #72]	; 0x48
    eb66:	f102 4300 	add.w	r3, r2, #2147483648	; 0x80000000
    eb6a:	931b      	str	r3, [sp, #108]	; 0x6c
    eb6c:	232d      	movs	r3, #45	; 0x2d
    eb6e:	911a      	str	r1, [sp, #104]	; 0x68
    eb70:	930f      	str	r3, [sp, #60]	; 0x3c
    eb72:	e652      	b.n	e81a <_vfprintf_r+0xfb2>
    eb74:	9a14      	ldr	r2, [sp, #80]	; 0x50
    eb76:	9b11      	ldr	r3, [sp, #68]	; 0x44
    eb78:	4413      	add	r3, r2
    eb7a:	9a10      	ldr	r2, [sp, #64]	; 0x40
    eb7c:	930d      	str	r3, [sp, #52]	; 0x34
    eb7e:	2a00      	cmp	r2, #0
    eb80:	f340 80e2 	ble.w	ed48 <_vfprintf_r+0x14e0>
    eb84:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    eb88:	9307      	str	r3, [sp, #28]
    eb8a:	2667      	movs	r6, #103	; 0x67
    eb8c:	e698      	b.n	e8c0 <_vfprintf_r+0x1058>
    eb8e:	2b00      	cmp	r3, #0
    eb90:	f340 80f9 	ble.w	ed86 <_vfprintf_r+0x151e>
    eb94:	9a09      	ldr	r2, [sp, #36]	; 0x24
    eb96:	2a00      	cmp	r2, #0
    eb98:	f040 80cc 	bne.w	ed34 <_vfprintf_r+0x14cc>
    eb9c:	f01b 0f01 	tst.w	fp, #1
    eba0:	f040 80c8 	bne.w	ed34 <_vfprintf_r+0x14cc>
    eba4:	9307      	str	r3, [sp, #28]
    eba6:	930d      	str	r3, [sp, #52]	; 0x34
    eba8:	e68a      	b.n	e8c0 <_vfprintf_r+0x1058>
    ebaa:	2e47      	cmp	r6, #71	; 0x47
    ebac:	f47f ae57 	bne.w	e85e <_vfprintf_r+0xff6>
    ebb0:	f01b 0f01 	tst.w	fp, #1
    ebb4:	f000 80f1 	beq.w	ed9a <_vfprintf_r+0x1532>
    ebb8:	2e46      	cmp	r6, #70	; 0x46
    ebba:	eb07 0405 	add.w	r4, r7, r5
    ebbe:	d0c9      	beq.n	eb54 <_vfprintf_r+0x12ec>
    ebc0:	e64e      	b.n	e860 <_vfprintf_r+0xff8>
    ebc2:	aa25      	add	r2, sp, #148	; 0x94
    ebc4:	990a      	ldr	r1, [sp, #40]	; 0x28
    ebc6:	9808      	ldr	r0, [sp, #32]
    ebc8:	f7fd ffba 	bl	cb40 <__sprint_r>
    ebcc:	2800      	cmp	r0, #0
    ebce:	f47f abe1 	bne.w	e394 <_vfprintf_r+0xb2c>
    ebd2:	991f      	ldr	r1, [sp, #124]	; 0x7c
    ebd4:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    ebd6:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    ebda:	e6c7      	b.n	e96c <_vfprintf_r+0x1104>
    ebdc:	9c09      	ldr	r4, [sp, #36]	; 0x24
    ebde:	9401      	str	r4, [sp, #4]
    ebe0:	a823      	add	r0, sp, #140	; 0x8c
    ebe2:	a920      	add	r1, sp, #128	; 0x80
    ebe4:	aa1f      	add	r2, sp, #124	; 0x7c
    ebe6:	2303      	movs	r3, #3
    ebe8:	9004      	str	r0, [sp, #16]
    ebea:	9202      	str	r2, [sp, #8]
    ebec:	9300      	str	r3, [sp, #0]
    ebee:	9103      	str	r1, [sp, #12]
    ebf0:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
    ebf4:	9808      	ldr	r0, [sp, #32]
    ebf6:	f000 fb1b 	bl	f230 <_dtoa_r>
    ebfa:	4625      	mov	r5, r4
    ebfc:	4607      	mov	r7, r0
    ebfe:	e7db      	b.n	ebb8 <_vfprintf_r+0x1350>
    ec00:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ec02:	9307      	str	r3, [sp, #28]
    ec04:	930d      	str	r3, [sp, #52]	; 0x34
    ec06:	9009      	str	r0, [sp, #36]	; 0x24
    ec08:	950e      	str	r5, [sp, #56]	; 0x38
    ec0a:	f8cd b018 	str.w	fp, [sp, #24]
    ec0e:	9010      	str	r0, [sp, #64]	; 0x40
    ec10:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
    ec14:	f7fe bf59 	b.w	daca <_vfprintf_r+0x262>
    ec18:	00012a6c 	.word	0x00012a6c
    ec1c:	66666667 	.word	0x66666667
    ec20:	00012a64 	.word	0x00012a64
    ec24:	2300      	movs	r3, #0
    ec26:	9309      	str	r3, [sp, #36]	; 0x24
    ec28:	f7fe be9e 	b.w	d968 <_vfprintf_r+0x100>
    ec2c:	9808      	ldr	r0, [sp, #32]
    ec2e:	aa25      	add	r2, sp, #148	; 0x94
    ec30:	4651      	mov	r1, sl
    ec32:	f7fd ff85 	bl	cb40 <__sprint_r>
    ec36:	2800      	cmp	r0, #0
    ec38:	f43f aa8b 	beq.w	e152 <_vfprintf_r+0x8ea>
    ec3c:	f7ff ba8b 	b.w	e156 <_vfprintf_r+0x8ee>
    ec40:	424e      	negs	r6, r1
    ec42:	3110      	adds	r1, #16
    ec44:	4d6a      	ldr	r5, [pc, #424]	; (edf0 <_vfprintf_r+0x1588>)
    ec46:	da2f      	bge.n	eca8 <_vfprintf_r+0x1440>
    ec48:	2410      	movs	r4, #16
    ec4a:	f8dd a020 	ldr.w	sl, [sp, #32]
    ec4e:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    ec52:	e004      	b.n	ec5e <_vfprintf_r+0x13f6>
    ec54:	f108 0808 	add.w	r8, r8, #8
    ec58:	3e10      	subs	r6, #16
    ec5a:	2e10      	cmp	r6, #16
    ec5c:	dd24      	ble.n	eca8 <_vfprintf_r+0x1440>
    ec5e:	3301      	adds	r3, #1
    ec60:	3210      	adds	r2, #16
    ec62:	2b07      	cmp	r3, #7
    ec64:	9227      	str	r2, [sp, #156]	; 0x9c
    ec66:	9326      	str	r3, [sp, #152]	; 0x98
    ec68:	f8c8 5000 	str.w	r5, [r8]
    ec6c:	f8c8 4004 	str.w	r4, [r8, #4]
    ec70:	ddf0      	ble.n	ec54 <_vfprintf_r+0x13ec>
    ec72:	aa25      	add	r2, sp, #148	; 0x94
    ec74:	4659      	mov	r1, fp
    ec76:	4650      	mov	r0, sl
    ec78:	f7fd ff62 	bl	cb40 <__sprint_r>
    ec7c:	2800      	cmp	r0, #0
    ec7e:	f47f aea9 	bne.w	e9d4 <_vfprintf_r+0x116c>
    ec82:	9a27      	ldr	r2, [sp, #156]	; 0x9c
    ec84:	9b26      	ldr	r3, [sp, #152]	; 0x98
    ec86:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    ec8a:	e7e5      	b.n	ec58 <_vfprintf_r+0x13f0>
    ec8c:	aa25      	add	r2, sp, #148	; 0x94
    ec8e:	990a      	ldr	r1, [sp, #40]	; 0x28
    ec90:	9808      	ldr	r0, [sp, #32]
    ec92:	f7fd ff55 	bl	cb40 <__sprint_r>
    ec96:	2800      	cmp	r0, #0
    ec98:	f47f ab7c 	bne.w	e394 <_vfprintf_r+0xb2c>
    ec9c:	991f      	ldr	r1, [sp, #124]	; 0x7c
    ec9e:	9a27      	ldr	r2, [sp, #156]	; 0x9c
    eca0:	9b26      	ldr	r3, [sp, #152]	; 0x98
    eca2:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    eca6:	e679      	b.n	e99c <_vfprintf_r+0x1134>
    eca8:	3301      	adds	r3, #1
    ecaa:	4432      	add	r2, r6
    ecac:	2b07      	cmp	r3, #7
    ecae:	e888 0060 	stmia.w	r8, {r5, r6}
    ecb2:	9227      	str	r2, [sp, #156]	; 0x9c
    ecb4:	9326      	str	r3, [sp, #152]	; 0x98
    ecb6:	f108 0808 	add.w	r8, r8, #8
    ecba:	f77f ae72 	ble.w	e9a2 <_vfprintf_r+0x113a>
    ecbe:	aa25      	add	r2, sp, #148	; 0x94
    ecc0:	990a      	ldr	r1, [sp, #40]	; 0x28
    ecc2:	9808      	ldr	r0, [sp, #32]
    ecc4:	f7fd ff3c 	bl	cb40 <__sprint_r>
    ecc8:	2800      	cmp	r0, #0
    ecca:	f47f ab63 	bne.w	e394 <_vfprintf_r+0xb2c>
    ecce:	9a27      	ldr	r2, [sp, #156]	; 0x9c
    ecd0:	9b26      	ldr	r3, [sp, #152]	; 0x98
    ecd2:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    ecd6:	e664      	b.n	e9a2 <_vfprintf_r+0x113a>
    ecd8:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ecda:	9a14      	ldr	r2, [sp, #80]	; 0x50
    ecdc:	4413      	add	r3, r2
    ecde:	930d      	str	r3, [sp, #52]	; 0x34
    ece0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    ece4:	9307      	str	r3, [sp, #28]
    ece6:	2667      	movs	r6, #103	; 0x67
    ece8:	e5ea      	b.n	e8c0 <_vfprintf_r+0x1058>
    ecea:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    ecec:	e5cb      	b.n	e886 <_vfprintf_r+0x101e>
    ecee:	3330      	adds	r3, #48	; 0x30
    ecf0:	2230      	movs	r2, #48	; 0x30
    ecf2:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
    ecf6:	f88d 2086 	strb.w	r2, [sp, #134]	; 0x86
    ecfa:	ab22      	add	r3, sp, #136	; 0x88
    ecfc:	e6d7      	b.n	eaae <_vfprintf_r+0x1246>
    ecfe:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    ed00:	4f3c      	ldr	r7, [pc, #240]	; (edf4 <_vfprintf_r+0x158c>)
    ed02:	2b00      	cmp	r3, #0
    ed04:	bfb6      	itet	lt
    ed06:	f04f 0a2d 	movlt.w	sl, #45	; 0x2d
    ed0a:	f89d a077 	ldrbge.w	sl, [sp, #119]	; 0x77
    ed0e:	f88d a077 	strblt.w	sl, [sp, #119]	; 0x77
    ed12:	4b39      	ldr	r3, [pc, #228]	; (edf8 <_vfprintf_r+0x1590>)
    ed14:	f7ff b9d2 	b.w	e0bc <_vfprintf_r+0x854>
    ed18:	2200      	movs	r2, #0
    ed1a:	2300      	movs	r3, #0
    ed1c:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
    ed20:	f7f2 fb3c 	bl	139c <__aeabi_dcmpeq>
    ed24:	2800      	cmp	r0, #0
    ed26:	f47f af19 	bne.w	eb5c <_vfprintf_r+0x12f4>
    ed2a:	f1c5 0501 	rsb	r5, r5, #1
    ed2e:	951f      	str	r5, [sp, #124]	; 0x7c
    ed30:	442c      	add	r4, r5
    ed32:	e595      	b.n	e860 <_vfprintf_r+0xff8>
    ed34:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ed36:	9a14      	ldr	r2, [sp, #80]	; 0x50
    ed38:	4413      	add	r3, r2
    ed3a:	9a09      	ldr	r2, [sp, #36]	; 0x24
    ed3c:	441a      	add	r2, r3
    ed3e:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    ed42:	920d      	str	r2, [sp, #52]	; 0x34
    ed44:	9307      	str	r3, [sp, #28]
    ed46:	e5bb      	b.n	e8c0 <_vfprintf_r+0x1058>
    ed48:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ed4a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    ed4c:	f1c3 0301 	rsb	r3, r3, #1
    ed50:	441a      	add	r2, r3
    ed52:	4613      	mov	r3, r2
    ed54:	920d      	str	r2, [sp, #52]	; 0x34
    ed56:	e715      	b.n	eb84 <_vfprintf_r+0x131c>
    ed58:	f01b 0301 	ands.w	r3, fp, #1
    ed5c:	9310      	str	r3, [sp, #64]	; 0x40
    ed5e:	f47f aeaf 	bne.w	eac0 <_vfprintf_r+0x1258>
    ed62:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    ed64:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    ed68:	9307      	str	r3, [sp, #28]
    ed6a:	e5a9      	b.n	e8c0 <_vfprintf_r+0x1058>
    ed6c:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    ed6e:	f899 6001 	ldrb.w	r6, [r9, #1]
    ed72:	6823      	ldr	r3, [r4, #0]
    ed74:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
    ed78:	9309      	str	r3, [sp, #36]	; 0x24
    ed7a:	4623      	mov	r3, r4
    ed7c:	3304      	adds	r3, #4
    ed7e:	4681      	mov	r9, r0
    ed80:	930e      	str	r3, [sp, #56]	; 0x38
    ed82:	f7fe bdef 	b.w	d964 <_vfprintf_r+0xfc>
    ed86:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ed88:	b913      	cbnz	r3, ed90 <_vfprintf_r+0x1528>
    ed8a:	f01b 0f01 	tst.w	fp, #1
    ed8e:	d002      	beq.n	ed96 <_vfprintf_r+0x152e>
    ed90:	9b14      	ldr	r3, [sp, #80]	; 0x50
    ed92:	3301      	adds	r3, #1
    ed94:	e7d1      	b.n	ed3a <_vfprintf_r+0x14d2>
    ed96:	2301      	movs	r3, #1
    ed98:	e704      	b.n	eba4 <_vfprintf_r+0x133c>
    ed9a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    ed9c:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
    eda0:	eba3 0307 	sub.w	r3, r3, r7
    eda4:	9311      	str	r3, [sp, #68]	; 0x44
    eda6:	f43f ae38 	beq.w	ea1a <_vfprintf_r+0x11b2>
    edaa:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    edac:	9310      	str	r3, [sp, #64]	; 0x40
    edae:	e63f      	b.n	ea30 <_vfprintf_r+0x11c8>
    edb0:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
    edb4:	f7ff b805 	b.w	ddc2 <_vfprintf_r+0x55a>
    edb8:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
    edbc:	f7ff b945 	b.w	e04a <_vfprintf_r+0x7e2>
    edc0:	f10d 0386 	add.w	r3, sp, #134	; 0x86
    edc4:	e673      	b.n	eaae <_vfprintf_r+0x1246>
    edc6:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
    edca:	f7ff b84f 	b.w	de6c <_vfprintf_r+0x604>
    edce:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
    edd2:	f7ff b99e 	b.w	e112 <_vfprintf_r+0x8aa>
    edd6:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
    edda:	f7ff b91d 	b.w	e018 <_vfprintf_r+0x7b0>
    edde:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
    ede2:	f7ff b8ee 	b.w	dfc2 <_vfprintf_r+0x75a>
    ede6:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
    edea:	f7ff b895 	b.w	df18 <_vfprintf_r+0x6b0>
    edee:	bf00      	nop
    edf0:	00012ac0 	.word	0x00012ac0
    edf4:	00012a38 	.word	0x00012a38
    edf8:	00012a34 	.word	0x00012a34

0000edfc <__sbprintf>:
    edfc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ee00:	460c      	mov	r4, r1
    ee02:	f5ad 6d8d 	sub.w	sp, sp, #1128	; 0x468
    ee06:	8989      	ldrh	r1, [r1, #12]
    ee08:	6e66      	ldr	r6, [r4, #100]	; 0x64
    ee0a:	89e5      	ldrh	r5, [r4, #14]
    ee0c:	9619      	str	r6, [sp, #100]	; 0x64
    ee0e:	f021 0102 	bic.w	r1, r1, #2
    ee12:	4606      	mov	r6, r0
    ee14:	69e0      	ldr	r0, [r4, #28]
    ee16:	f8ad 100c 	strh.w	r1, [sp, #12]
    ee1a:	4617      	mov	r7, r2
    ee1c:	f44f 6180 	mov.w	r1, #1024	; 0x400
    ee20:	6a62      	ldr	r2, [r4, #36]	; 0x24
    ee22:	f8ad 500e 	strh.w	r5, [sp, #14]
    ee26:	4698      	mov	r8, r3
    ee28:	ad1a      	add	r5, sp, #104	; 0x68
    ee2a:	2300      	movs	r3, #0
    ee2c:	9007      	str	r0, [sp, #28]
    ee2e:	a816      	add	r0, sp, #88	; 0x58
    ee30:	9209      	str	r2, [sp, #36]	; 0x24
    ee32:	9306      	str	r3, [sp, #24]
    ee34:	9500      	str	r5, [sp, #0]
    ee36:	9504      	str	r5, [sp, #16]
    ee38:	9102      	str	r1, [sp, #8]
    ee3a:	9105      	str	r1, [sp, #20]
    ee3c:	f7fb ff78 	bl	ad30 <__retarget_lock_init_recursive>
    ee40:	4643      	mov	r3, r8
    ee42:	463a      	mov	r2, r7
    ee44:	4669      	mov	r1, sp
    ee46:	4630      	mov	r0, r6
    ee48:	f7fe fd0e 	bl	d868 <_vfprintf_r>
    ee4c:	1e05      	subs	r5, r0, #0
    ee4e:	db07      	blt.n	ee60 <__sbprintf+0x64>
    ee50:	4630      	mov	r0, r6
    ee52:	4669      	mov	r1, sp
    ee54:	f7fb fb94 	bl	a580 <_fflush_r>
    ee58:	2800      	cmp	r0, #0
    ee5a:	bf18      	it	ne
    ee5c:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
    ee60:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    ee64:	065b      	lsls	r3, r3, #25
    ee66:	d503      	bpl.n	ee70 <__sbprintf+0x74>
    ee68:	89a3      	ldrh	r3, [r4, #12]
    ee6a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    ee6e:	81a3      	strh	r3, [r4, #12]
    ee70:	9816      	ldr	r0, [sp, #88]	; 0x58
    ee72:	f7fb ff5f 	bl	ad34 <__retarget_lock_close_recursive>
    ee76:	4628      	mov	r0, r5
    ee78:	f50d 6d8d 	add.w	sp, sp, #1128	; 0x468
    ee7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000ee80 <_vsnprintf_r>:
    ee80:	b570      	push	{r4, r5, r6, lr}
    ee82:	1e14      	subs	r4, r2, #0
    ee84:	b09a      	sub	sp, #104	; 0x68
    ee86:	4605      	mov	r5, r0
    ee88:	db2e      	blt.n	eee8 <_vsnprintf_r+0x68>
    ee8a:	461a      	mov	r2, r3
    ee8c:	f44f 7302 	mov.w	r3, #520	; 0x208
    ee90:	9100      	str	r1, [sp, #0]
    ee92:	9104      	str	r1, [sp, #16]
    ee94:	f8ad 300c 	strh.w	r3, [sp, #12]
    ee98:	d011      	beq.n	eebe <_vsnprintf_r+0x3e>
    ee9a:	3c01      	subs	r4, #1
    ee9c:	f64f 76ff 	movw	r6, #65535	; 0xffff
    eea0:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    eea2:	9402      	str	r4, [sp, #8]
    eea4:	4669      	mov	r1, sp
    eea6:	9405      	str	r4, [sp, #20]
    eea8:	f8ad 600e 	strh.w	r6, [sp, #14]
    eeac:	f7fc fbbc 	bl	b628 <_svfprintf_r>
    eeb0:	1c42      	adds	r2, r0, #1
    eeb2:	db12      	blt.n	eeda <_vsnprintf_r+0x5a>
    eeb4:	9b00      	ldr	r3, [sp, #0]
    eeb6:	2200      	movs	r2, #0
    eeb8:	701a      	strb	r2, [r3, #0]
    eeba:	b01a      	add	sp, #104	; 0x68
    eebc:	bd70      	pop	{r4, r5, r6, pc}
    eebe:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    eec0:	9402      	str	r4, [sp, #8]
    eec2:	f64f 76ff 	movw	r6, #65535	; 0xffff
    eec6:	4669      	mov	r1, sp
    eec8:	9405      	str	r4, [sp, #20]
    eeca:	f8ad 600e 	strh.w	r6, [sp, #14]
    eece:	f7fc fbab 	bl	b628 <_svfprintf_r>
    eed2:	1c43      	adds	r3, r0, #1
    eed4:	db04      	blt.n	eee0 <_vsnprintf_r+0x60>
    eed6:	b01a      	add	sp, #104	; 0x68
    eed8:	bd70      	pop	{r4, r5, r6, pc}
    eeda:	238b      	movs	r3, #139	; 0x8b
    eedc:	602b      	str	r3, [r5, #0]
    eede:	e7e9      	b.n	eeb4 <_vsnprintf_r+0x34>
    eee0:	238b      	movs	r3, #139	; 0x8b
    eee2:	602b      	str	r3, [r5, #0]
    eee4:	b01a      	add	sp, #104	; 0x68
    eee6:	bd70      	pop	{r4, r5, r6, pc}
    eee8:	238b      	movs	r3, #139	; 0x8b
    eeea:	6003      	str	r3, [r0, #0]
    eeec:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    eef0:	e7f1      	b.n	eed6 <_vsnprintf_r+0x56>
    eef2:	bf00      	nop

0000eef4 <vsnprintf>:
    eef4:	b510      	push	{r4, lr}
    eef6:	b082      	sub	sp, #8
    eef8:	4c05      	ldr	r4, [pc, #20]	; (ef10 <vsnprintf+0x1c>)
    eefa:	9300      	str	r3, [sp, #0]
    eefc:	6824      	ldr	r4, [r4, #0]
    eefe:	4613      	mov	r3, r2
    ef00:	460a      	mov	r2, r1
    ef02:	4601      	mov	r1, r0
    ef04:	4620      	mov	r0, r4
    ef06:	f7ff ffbb 	bl	ee80 <_vsnprintf_r>
    ef0a:	b002      	add	sp, #8
    ef0c:	bd10      	pop	{r4, pc}
    ef0e:	bf00      	nop
    ef10:	200001c0 	.word	0x200001c0

0000ef14 <__swbuf_r>:
    ef14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ef16:	460d      	mov	r5, r1
    ef18:	4614      	mov	r4, r2
    ef1a:	4606      	mov	r6, r0
    ef1c:	b110      	cbz	r0, ef24 <__swbuf_r+0x10>
    ef1e:	6b83      	ldr	r3, [r0, #56]	; 0x38
    ef20:	2b00      	cmp	r3, #0
    ef22:	d04b      	beq.n	efbc <__swbuf_r+0xa8>
    ef24:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    ef28:	69a3      	ldr	r3, [r4, #24]
    ef2a:	60a3      	str	r3, [r4, #8]
    ef2c:	b291      	uxth	r1, r2
    ef2e:	0708      	lsls	r0, r1, #28
    ef30:	d539      	bpl.n	efa6 <__swbuf_r+0x92>
    ef32:	6923      	ldr	r3, [r4, #16]
    ef34:	2b00      	cmp	r3, #0
    ef36:	d036      	beq.n	efa6 <__swbuf_r+0x92>
    ef38:	b2ed      	uxtb	r5, r5
    ef3a:	0489      	lsls	r1, r1, #18
    ef3c:	462f      	mov	r7, r5
    ef3e:	d515      	bpl.n	ef6c <__swbuf_r+0x58>
    ef40:	6822      	ldr	r2, [r4, #0]
    ef42:	6961      	ldr	r1, [r4, #20]
    ef44:	1ad3      	subs	r3, r2, r3
    ef46:	428b      	cmp	r3, r1
    ef48:	da1c      	bge.n	ef84 <__swbuf_r+0x70>
    ef4a:	3301      	adds	r3, #1
    ef4c:	68a1      	ldr	r1, [r4, #8]
    ef4e:	1c50      	adds	r0, r2, #1
    ef50:	3901      	subs	r1, #1
    ef52:	60a1      	str	r1, [r4, #8]
    ef54:	6020      	str	r0, [r4, #0]
    ef56:	7015      	strb	r5, [r2, #0]
    ef58:	6962      	ldr	r2, [r4, #20]
    ef5a:	429a      	cmp	r2, r3
    ef5c:	d01a      	beq.n	ef94 <__swbuf_r+0x80>
    ef5e:	89a3      	ldrh	r3, [r4, #12]
    ef60:	07db      	lsls	r3, r3, #31
    ef62:	d501      	bpl.n	ef68 <__swbuf_r+0x54>
    ef64:	2d0a      	cmp	r5, #10
    ef66:	d015      	beq.n	ef94 <__swbuf_r+0x80>
    ef68:	4638      	mov	r0, r7
    ef6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ef6c:	6e61      	ldr	r1, [r4, #100]	; 0x64
    ef6e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    ef72:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
    ef76:	81a2      	strh	r2, [r4, #12]
    ef78:	6822      	ldr	r2, [r4, #0]
    ef7a:	6661      	str	r1, [r4, #100]	; 0x64
    ef7c:	6961      	ldr	r1, [r4, #20]
    ef7e:	1ad3      	subs	r3, r2, r3
    ef80:	428b      	cmp	r3, r1
    ef82:	dbe2      	blt.n	ef4a <__swbuf_r+0x36>
    ef84:	4621      	mov	r1, r4
    ef86:	4630      	mov	r0, r6
    ef88:	f7fb fafa 	bl	a580 <_fflush_r>
    ef8c:	b940      	cbnz	r0, efa0 <__swbuf_r+0x8c>
    ef8e:	6822      	ldr	r2, [r4, #0]
    ef90:	2301      	movs	r3, #1
    ef92:	e7db      	b.n	ef4c <__swbuf_r+0x38>
    ef94:	4621      	mov	r1, r4
    ef96:	4630      	mov	r0, r6
    ef98:	f7fb faf2 	bl	a580 <_fflush_r>
    ef9c:	2800      	cmp	r0, #0
    ef9e:	d0e3      	beq.n	ef68 <__swbuf_r+0x54>
    efa0:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    efa4:	e7e0      	b.n	ef68 <__swbuf_r+0x54>
    efa6:	4621      	mov	r1, r4
    efa8:	4630      	mov	r0, r6
    efaa:	f000 f82f 	bl	f00c <__swsetup_r>
    efae:	2800      	cmp	r0, #0
    efb0:	d1f6      	bne.n	efa0 <__swbuf_r+0x8c>
    efb2:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    efb6:	6923      	ldr	r3, [r4, #16]
    efb8:	b291      	uxth	r1, r2
    efba:	e7bd      	b.n	ef38 <__swbuf_r+0x24>
    efbc:	f7fb fb4a 	bl	a654 <__sinit>
    efc0:	e7b0      	b.n	ef24 <__swbuf_r+0x10>
    efc2:	bf00      	nop

0000efc4 <__ascii_wctomb>:
    efc4:	b121      	cbz	r1, efd0 <__ascii_wctomb+0xc>
    efc6:	2aff      	cmp	r2, #255	; 0xff
    efc8:	d804      	bhi.n	efd4 <__ascii_wctomb+0x10>
    efca:	700a      	strb	r2, [r1, #0]
    efcc:	2001      	movs	r0, #1
    efce:	4770      	bx	lr
    efd0:	4608      	mov	r0, r1
    efd2:	4770      	bx	lr
    efd4:	238a      	movs	r3, #138	; 0x8a
    efd6:	6003      	str	r3, [r0, #0]
    efd8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    efdc:	4770      	bx	lr
    efde:	bf00      	nop

0000efe0 <_write_r>:
    efe0:	b570      	push	{r4, r5, r6, lr}
    efe2:	460d      	mov	r5, r1
    efe4:	4c08      	ldr	r4, [pc, #32]	; (f008 <_write_r+0x28>)
    efe6:	4611      	mov	r1, r2
    efe8:	4606      	mov	r6, r0
    efea:	461a      	mov	r2, r3
    efec:	4628      	mov	r0, r5
    efee:	2300      	movs	r3, #0
    eff0:	6023      	str	r3, [r4, #0]
    eff2:	f7f4 fa7f 	bl	34f4 <_write>
    eff6:	1c43      	adds	r3, r0, #1
    eff8:	d000      	beq.n	effc <_write_r+0x1c>
    effa:	bd70      	pop	{r4, r5, r6, pc}
    effc:	6823      	ldr	r3, [r4, #0]
    effe:	2b00      	cmp	r3, #0
    f000:	d0fb      	beq.n	effa <_write_r+0x1a>
    f002:	6033      	str	r3, [r6, #0]
    f004:	bd70      	pop	{r4, r5, r6, pc}
    f006:	bf00      	nop
    f008:	2000304c 	.word	0x2000304c

0000f00c <__swsetup_r>:
    f00c:	b538      	push	{r3, r4, r5, lr}
    f00e:	4b30      	ldr	r3, [pc, #192]	; (f0d0 <__swsetup_r+0xc4>)
    f010:	681b      	ldr	r3, [r3, #0]
    f012:	4605      	mov	r5, r0
    f014:	460c      	mov	r4, r1
    f016:	b113      	cbz	r3, f01e <__swsetup_r+0x12>
    f018:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    f01a:	2a00      	cmp	r2, #0
    f01c:	d038      	beq.n	f090 <__swsetup_r+0x84>
    f01e:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    f022:	b293      	uxth	r3, r2
    f024:	0718      	lsls	r0, r3, #28
    f026:	d50c      	bpl.n	f042 <__swsetup_r+0x36>
    f028:	6920      	ldr	r0, [r4, #16]
    f02a:	b1a8      	cbz	r0, f058 <__swsetup_r+0x4c>
    f02c:	f013 0201 	ands.w	r2, r3, #1
    f030:	d01e      	beq.n	f070 <__swsetup_r+0x64>
    f032:	6963      	ldr	r3, [r4, #20]
    f034:	2200      	movs	r2, #0
    f036:	425b      	negs	r3, r3
    f038:	61a3      	str	r3, [r4, #24]
    f03a:	60a2      	str	r2, [r4, #8]
    f03c:	b1f0      	cbz	r0, f07c <__swsetup_r+0x70>
    f03e:	2000      	movs	r0, #0
    f040:	bd38      	pop	{r3, r4, r5, pc}
    f042:	06d9      	lsls	r1, r3, #27
    f044:	d53c      	bpl.n	f0c0 <__swsetup_r+0xb4>
    f046:	0758      	lsls	r0, r3, #29
    f048:	d426      	bmi.n	f098 <__swsetup_r+0x8c>
    f04a:	6920      	ldr	r0, [r4, #16]
    f04c:	f042 0308 	orr.w	r3, r2, #8
    f050:	81a3      	strh	r3, [r4, #12]
    f052:	b29b      	uxth	r3, r3
    f054:	2800      	cmp	r0, #0
    f056:	d1e9      	bne.n	f02c <__swsetup_r+0x20>
    f058:	f403 7220 	and.w	r2, r3, #640	; 0x280
    f05c:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    f060:	d0e4      	beq.n	f02c <__swsetup_r+0x20>
    f062:	4628      	mov	r0, r5
    f064:	4621      	mov	r1, r4
    f066:	f7fb fe99 	bl	ad9c <__smakebuf_r>
    f06a:	89a3      	ldrh	r3, [r4, #12]
    f06c:	6920      	ldr	r0, [r4, #16]
    f06e:	e7dd      	b.n	f02c <__swsetup_r+0x20>
    f070:	0799      	lsls	r1, r3, #30
    f072:	bf58      	it	pl
    f074:	6962      	ldrpl	r2, [r4, #20]
    f076:	60a2      	str	r2, [r4, #8]
    f078:	2800      	cmp	r0, #0
    f07a:	d1e0      	bne.n	f03e <__swsetup_r+0x32>
    f07c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    f080:	061a      	lsls	r2, r3, #24
    f082:	d5dd      	bpl.n	f040 <__swsetup_r+0x34>
    f084:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    f088:	81a3      	strh	r3, [r4, #12]
    f08a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    f08e:	bd38      	pop	{r3, r4, r5, pc}
    f090:	4618      	mov	r0, r3
    f092:	f7fb fadf 	bl	a654 <__sinit>
    f096:	e7c2      	b.n	f01e <__swsetup_r+0x12>
    f098:	6b21      	ldr	r1, [r4, #48]	; 0x30
    f09a:	b151      	cbz	r1, f0b2 <__swsetup_r+0xa6>
    f09c:	f104 0340 	add.w	r3, r4, #64	; 0x40
    f0a0:	4299      	cmp	r1, r3
    f0a2:	d004      	beq.n	f0ae <__swsetup_r+0xa2>
    f0a4:	4628      	mov	r0, r5
    f0a6:	f7f3 fc3e 	bl	2926 <__wrap__free_r>
    f0aa:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    f0ae:	2300      	movs	r3, #0
    f0b0:	6323      	str	r3, [r4, #48]	; 0x30
    f0b2:	2300      	movs	r3, #0
    f0b4:	6920      	ldr	r0, [r4, #16]
    f0b6:	6063      	str	r3, [r4, #4]
    f0b8:	f022 0224 	bic.w	r2, r2, #36	; 0x24
    f0bc:	6020      	str	r0, [r4, #0]
    f0be:	e7c5      	b.n	f04c <__swsetup_r+0x40>
    f0c0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    f0c4:	2309      	movs	r3, #9
    f0c6:	602b      	str	r3, [r5, #0]
    f0c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    f0cc:	81a2      	strh	r2, [r4, #12]
    f0ce:	bd38      	pop	{r3, r4, r5, pc}
    f0d0:	200001c0 	.word	0x200001c0

0000f0d4 <abort>:
    f0d4:	b508      	push	{r3, lr}
    f0d6:	2006      	movs	r0, #6
    f0d8:	f001 fbbe 	bl	10858 <raise>
    f0dc:	2001      	movs	r0, #1
    f0de:	f7f4 fcc1 	bl	3a64 <_exit>
    f0e2:	bf00      	nop

0000f0e4 <_close_r>:
    f0e4:	b538      	push	{r3, r4, r5, lr}
    f0e6:	4c07      	ldr	r4, [pc, #28]	; (f104 <_close_r+0x20>)
    f0e8:	2300      	movs	r3, #0
    f0ea:	4605      	mov	r5, r0
    f0ec:	4608      	mov	r0, r1
    f0ee:	6023      	str	r3, [r4, #0]
    f0f0:	f7f4 f9ae 	bl	3450 <_close>
    f0f4:	1c43      	adds	r3, r0, #1
    f0f6:	d000      	beq.n	f0fa <_close_r+0x16>
    f0f8:	bd38      	pop	{r3, r4, r5, pc}
    f0fa:	6823      	ldr	r3, [r4, #0]
    f0fc:	2b00      	cmp	r3, #0
    f0fe:	d0fb      	beq.n	f0f8 <_close_r+0x14>
    f100:	602b      	str	r3, [r5, #0]
    f102:	bd38      	pop	{r3, r4, r5, pc}
    f104:	2000304c 	.word	0x2000304c

0000f108 <quorem>:
    f108:	6902      	ldr	r2, [r0, #16]
    f10a:	690b      	ldr	r3, [r1, #16]
    f10c:	4293      	cmp	r3, r2
    f10e:	f300 808d 	bgt.w	f22c <quorem+0x124>
    f112:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f116:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    f11a:	f101 0714 	add.w	r7, r1, #20
    f11e:	f100 0b14 	add.w	fp, r0, #20
    f122:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
    f126:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
    f12a:	ea4f 0488 	mov.w	r4, r8, lsl #2
    f12e:	b083      	sub	sp, #12
    f130:	3201      	adds	r2, #1
    f132:	fbb3 f9f2 	udiv	r9, r3, r2
    f136:	eb0b 0304 	add.w	r3, fp, r4
    f13a:	9400      	str	r4, [sp, #0]
    f13c:	eb07 0a04 	add.w	sl, r7, r4
    f140:	9301      	str	r3, [sp, #4]
    f142:	f1b9 0f00 	cmp.w	r9, #0
    f146:	d039      	beq.n	f1bc <quorem+0xb4>
    f148:	2500      	movs	r5, #0
    f14a:	462e      	mov	r6, r5
    f14c:	46bc      	mov	ip, r7
    f14e:	46de      	mov	lr, fp
    f150:	f85c 4b04 	ldr.w	r4, [ip], #4
    f154:	f8de 3000 	ldr.w	r3, [lr]
    f158:	b2a2      	uxth	r2, r4
    f15a:	fb09 5502 	mla	r5, r9, r2, r5
    f15e:	0c22      	lsrs	r2, r4, #16
    f160:	0c2c      	lsrs	r4, r5, #16
    f162:	fb09 4202 	mla	r2, r9, r2, r4
    f166:	b2ad      	uxth	r5, r5
    f168:	1b75      	subs	r5, r6, r5
    f16a:	b296      	uxth	r6, r2
    f16c:	ebc6 4613 	rsb	r6, r6, r3, lsr #16
    f170:	fa15 f383 	uxtah	r3, r5, r3
    f174:	eb06 4623 	add.w	r6, r6, r3, asr #16
    f178:	b29b      	uxth	r3, r3
    f17a:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
    f17e:	45e2      	cmp	sl, ip
    f180:	ea4f 4512 	mov.w	r5, r2, lsr #16
    f184:	f84e 3b04 	str.w	r3, [lr], #4
    f188:	ea4f 4626 	mov.w	r6, r6, asr #16
    f18c:	d2e0      	bcs.n	f150 <quorem+0x48>
    f18e:	9b00      	ldr	r3, [sp, #0]
    f190:	f85b 3003 	ldr.w	r3, [fp, r3]
    f194:	b993      	cbnz	r3, f1bc <quorem+0xb4>
    f196:	9c01      	ldr	r4, [sp, #4]
    f198:	1f23      	subs	r3, r4, #4
    f19a:	459b      	cmp	fp, r3
    f19c:	d20c      	bcs.n	f1b8 <quorem+0xb0>
    f19e:	f854 3c04 	ldr.w	r3, [r4, #-4]
    f1a2:	b94b      	cbnz	r3, f1b8 <quorem+0xb0>
    f1a4:	f1a4 0308 	sub.w	r3, r4, #8
    f1a8:	e002      	b.n	f1b0 <quorem+0xa8>
    f1aa:	681a      	ldr	r2, [r3, #0]
    f1ac:	3b04      	subs	r3, #4
    f1ae:	b91a      	cbnz	r2, f1b8 <quorem+0xb0>
    f1b0:	459b      	cmp	fp, r3
    f1b2:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    f1b6:	d3f8      	bcc.n	f1aa <quorem+0xa2>
    f1b8:	f8c0 8010 	str.w	r8, [r0, #16]
    f1bc:	4604      	mov	r4, r0
    f1be:	f001 fa09 	bl	105d4 <__mcmp>
    f1c2:	2800      	cmp	r0, #0
    f1c4:	db2e      	blt.n	f224 <quorem+0x11c>
    f1c6:	f109 0901 	add.w	r9, r9, #1
    f1ca:	465d      	mov	r5, fp
    f1cc:	2300      	movs	r3, #0
    f1ce:	f857 1b04 	ldr.w	r1, [r7], #4
    f1d2:	6828      	ldr	r0, [r5, #0]
    f1d4:	b28a      	uxth	r2, r1
    f1d6:	1a9a      	subs	r2, r3, r2
    f1d8:	0c0b      	lsrs	r3, r1, #16
    f1da:	fa12 f280 	uxtah	r2, r2, r0
    f1de:	ebc3 4310 	rsb	r3, r3, r0, lsr #16
    f1e2:	eb03 4322 	add.w	r3, r3, r2, asr #16
    f1e6:	b292      	uxth	r2, r2
    f1e8:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    f1ec:	45ba      	cmp	sl, r7
    f1ee:	f845 2b04 	str.w	r2, [r5], #4
    f1f2:	ea4f 4323 	mov.w	r3, r3, asr #16
    f1f6:	d2ea      	bcs.n	f1ce <quorem+0xc6>
    f1f8:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
    f1fc:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
    f200:	b982      	cbnz	r2, f224 <quorem+0x11c>
    f202:	1f1a      	subs	r2, r3, #4
    f204:	4593      	cmp	fp, r2
    f206:	d20b      	bcs.n	f220 <quorem+0x118>
    f208:	f853 2c04 	ldr.w	r2, [r3, #-4]
    f20c:	b942      	cbnz	r2, f220 <quorem+0x118>
    f20e:	3b08      	subs	r3, #8
    f210:	e002      	b.n	f218 <quorem+0x110>
    f212:	681a      	ldr	r2, [r3, #0]
    f214:	3b04      	subs	r3, #4
    f216:	b91a      	cbnz	r2, f220 <quorem+0x118>
    f218:	459b      	cmp	fp, r3
    f21a:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    f21e:	d3f8      	bcc.n	f212 <quorem+0x10a>
    f220:	f8c4 8010 	str.w	r8, [r4, #16]
    f224:	4648      	mov	r0, r9
    f226:	b003      	add	sp, #12
    f228:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f22c:	2000      	movs	r0, #0
    f22e:	4770      	bx	lr

0000f230 <_dtoa_r>:
    f230:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f234:	6c01      	ldr	r1, [r0, #64]	; 0x40
    f236:	b09b      	sub	sp, #108	; 0x6c
    f238:	4604      	mov	r4, r0
    f23a:	9e27      	ldr	r6, [sp, #156]	; 0x9c
    f23c:	4692      	mov	sl, r2
    f23e:	469b      	mov	fp, r3
    f240:	b141      	cbz	r1, f254 <_dtoa_r+0x24>
    f242:	6c42      	ldr	r2, [r0, #68]	; 0x44
    f244:	604a      	str	r2, [r1, #4]
    f246:	2301      	movs	r3, #1
    f248:	4093      	lsls	r3, r2
    f24a:	608b      	str	r3, [r1, #8]
    f24c:	f000 ffea 	bl	10224 <_Bfree>
    f250:	2300      	movs	r3, #0
    f252:	6423      	str	r3, [r4, #64]	; 0x40
    f254:	f1bb 0f00 	cmp.w	fp, #0
    f258:	465d      	mov	r5, fp
    f25a:	db35      	blt.n	f2c8 <_dtoa_r+0x98>
    f25c:	2300      	movs	r3, #0
    f25e:	6033      	str	r3, [r6, #0]
    f260:	4b9d      	ldr	r3, [pc, #628]	; (f4d8 <_dtoa_r+0x2a8>)
    f262:	43ab      	bics	r3, r5
    f264:	d015      	beq.n	f292 <_dtoa_r+0x62>
    f266:	2200      	movs	r2, #0
    f268:	2300      	movs	r3, #0
    f26a:	4650      	mov	r0, sl
    f26c:	4659      	mov	r1, fp
    f26e:	f7f2 f895 	bl	139c <__aeabi_dcmpeq>
    f272:	4680      	mov	r8, r0
    f274:	2800      	cmp	r0, #0
    f276:	d02d      	beq.n	f2d4 <_dtoa_r+0xa4>
    f278:	9a26      	ldr	r2, [sp, #152]	; 0x98
    f27a:	2301      	movs	r3, #1
    f27c:	6013      	str	r3, [r2, #0]
    f27e:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    f280:	2b00      	cmp	r3, #0
    f282:	f000 80bd 	beq.w	f400 <_dtoa_r+0x1d0>
    f286:	4895      	ldr	r0, [pc, #596]	; (f4dc <_dtoa_r+0x2ac>)
    f288:	6018      	str	r0, [r3, #0]
    f28a:	3801      	subs	r0, #1
    f28c:	b01b      	add	sp, #108	; 0x6c
    f28e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f292:	9a26      	ldr	r2, [sp, #152]	; 0x98
    f294:	f242 730f 	movw	r3, #9999	; 0x270f
    f298:	6013      	str	r3, [r2, #0]
    f29a:	f1ba 0f00 	cmp.w	sl, #0
    f29e:	d10d      	bne.n	f2bc <_dtoa_r+0x8c>
    f2a0:	f3c5 0513 	ubfx	r5, r5, #0, #20
    f2a4:	b955      	cbnz	r5, f2bc <_dtoa_r+0x8c>
    f2a6:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    f2a8:	488d      	ldr	r0, [pc, #564]	; (f4e0 <_dtoa_r+0x2b0>)
    f2aa:	2b00      	cmp	r3, #0
    f2ac:	d0ee      	beq.n	f28c <_dtoa_r+0x5c>
    f2ae:	f100 0308 	add.w	r3, r0, #8
    f2b2:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    f2b4:	6013      	str	r3, [r2, #0]
    f2b6:	b01b      	add	sp, #108	; 0x6c
    f2b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f2bc:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    f2be:	4889      	ldr	r0, [pc, #548]	; (f4e4 <_dtoa_r+0x2b4>)
    f2c0:	2b00      	cmp	r3, #0
    f2c2:	d0e3      	beq.n	f28c <_dtoa_r+0x5c>
    f2c4:	1cc3      	adds	r3, r0, #3
    f2c6:	e7f4      	b.n	f2b2 <_dtoa_r+0x82>
    f2c8:	2301      	movs	r3, #1
    f2ca:	f02b 4500 	bic.w	r5, fp, #2147483648	; 0x80000000
    f2ce:	6033      	str	r3, [r6, #0]
    f2d0:	46ab      	mov	fp, r5
    f2d2:	e7c5      	b.n	f260 <_dtoa_r+0x30>
    f2d4:	aa18      	add	r2, sp, #96	; 0x60
    f2d6:	ab19      	add	r3, sp, #100	; 0x64
    f2d8:	9201      	str	r2, [sp, #4]
    f2da:	9300      	str	r3, [sp, #0]
    f2dc:	4652      	mov	r2, sl
    f2de:	465b      	mov	r3, fp
    f2e0:	4620      	mov	r0, r4
    f2e2:	f001 fa17 	bl	10714 <__d2b>
    f2e6:	0d2b      	lsrs	r3, r5, #20
    f2e8:	4681      	mov	r9, r0
    f2ea:	d071      	beq.n	f3d0 <_dtoa_r+0x1a0>
    f2ec:	f3cb 0213 	ubfx	r2, fp, #0, #20
    f2f0:	f042 517f 	orr.w	r1, r2, #1069547520	; 0x3fc00000
    f2f4:	9f18      	ldr	r7, [sp, #96]	; 0x60
    f2f6:	f8cd 8050 	str.w	r8, [sp, #80]	; 0x50
    f2fa:	4650      	mov	r0, sl
    f2fc:	f2a3 36ff 	subw	r6, r3, #1023	; 0x3ff
    f300:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
    f304:	2200      	movs	r2, #0
    f306:	4b78      	ldr	r3, [pc, #480]	; (f4e8 <_dtoa_r+0x2b8>)
    f308:	f7f1 fc2c 	bl	b64 <__aeabi_dsub>
    f30c:	a36c      	add	r3, pc, #432	; (adr r3, f4c0 <_dtoa_r+0x290>)
    f30e:	e9d3 2300 	ldrd	r2, r3, [r3]
    f312:	f7f1 fddb 	bl	ecc <__aeabi_dmul>
    f316:	a36c      	add	r3, pc, #432	; (adr r3, f4c8 <_dtoa_r+0x298>)
    f318:	e9d3 2300 	ldrd	r2, r3, [r3]
    f31c:	f7f1 fc24 	bl	b68 <__adddf3>
    f320:	e9cd 0102 	strd	r0, r1, [sp, #8]
    f324:	4630      	mov	r0, r6
    f326:	f7f1 fd6b 	bl	e00 <__aeabi_i2d>
    f32a:	a369      	add	r3, pc, #420	; (adr r3, f4d0 <_dtoa_r+0x2a0>)
    f32c:	e9d3 2300 	ldrd	r2, r3, [r3]
    f330:	f7f1 fdcc 	bl	ecc <__aeabi_dmul>
    f334:	4602      	mov	r2, r0
    f336:	460b      	mov	r3, r1
    f338:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    f33c:	f7f1 fc14 	bl	b68 <__adddf3>
    f340:	e9cd 0104 	strd	r0, r1, [sp, #16]
    f344:	f7f2 f872 	bl	142c <__aeabi_d2iz>
    f348:	2200      	movs	r2, #0
    f34a:	9002      	str	r0, [sp, #8]
    f34c:	2300      	movs	r3, #0
    f34e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    f352:	f7f2 f82d 	bl	13b0 <__aeabi_dcmplt>
    f356:	2800      	cmp	r0, #0
    f358:	f040 8173 	bne.w	f642 <_dtoa_r+0x412>
    f35c:	9d02      	ldr	r5, [sp, #8]
    f35e:	2d16      	cmp	r5, #22
    f360:	f200 815d 	bhi.w	f61e <_dtoa_r+0x3ee>
    f364:	4b61      	ldr	r3, [pc, #388]	; (f4ec <_dtoa_r+0x2bc>)
    f366:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
    f36a:	e9d3 0100 	ldrd	r0, r1, [r3]
    f36e:	4652      	mov	r2, sl
    f370:	465b      	mov	r3, fp
    f372:	f7f2 f83b 	bl	13ec <__aeabi_dcmpgt>
    f376:	2800      	cmp	r0, #0
    f378:	f000 81c5 	beq.w	f706 <_dtoa_r+0x4d6>
    f37c:	1e6b      	subs	r3, r5, #1
    f37e:	9302      	str	r3, [sp, #8]
    f380:	2300      	movs	r3, #0
    f382:	930e      	str	r3, [sp, #56]	; 0x38
    f384:	1bbf      	subs	r7, r7, r6
    f386:	1e7b      	subs	r3, r7, #1
    f388:	9308      	str	r3, [sp, #32]
    f38a:	f100 8154 	bmi.w	f636 <_dtoa_r+0x406>
    f38e:	2300      	movs	r3, #0
    f390:	930b      	str	r3, [sp, #44]	; 0x2c
    f392:	9b02      	ldr	r3, [sp, #8]
    f394:	2b00      	cmp	r3, #0
    f396:	f2c0 8145 	blt.w	f624 <_dtoa_r+0x3f4>
    f39a:	9a08      	ldr	r2, [sp, #32]
    f39c:	930d      	str	r3, [sp, #52]	; 0x34
    f39e:	4611      	mov	r1, r2
    f3a0:	4419      	add	r1, r3
    f3a2:	2300      	movs	r3, #0
    f3a4:	9108      	str	r1, [sp, #32]
    f3a6:	9306      	str	r3, [sp, #24]
    f3a8:	9b24      	ldr	r3, [sp, #144]	; 0x90
    f3aa:	2b09      	cmp	r3, #9
    f3ac:	d82a      	bhi.n	f404 <_dtoa_r+0x1d4>
    f3ae:	2b05      	cmp	r3, #5
    f3b0:	f340 863c 	ble.w	1002c <_dtoa_r+0xdfc>
    f3b4:	3b04      	subs	r3, #4
    f3b6:	9324      	str	r3, [sp, #144]	; 0x90
    f3b8:	2500      	movs	r5, #0
    f3ba:	9b24      	ldr	r3, [sp, #144]	; 0x90
    f3bc:	3b02      	subs	r3, #2
    f3be:	2b03      	cmp	r3, #3
    f3c0:	f200 863c 	bhi.w	1003c <_dtoa_r+0xe0c>
    f3c4:	e8df f013 	tbh	[pc, r3, lsl #1]
    f3c8:	02ca03d5 	.word	0x02ca03d5
    f3cc:	046203e0 	.word	0x046203e0
    f3d0:	9f18      	ldr	r7, [sp, #96]	; 0x60
    f3d2:	9e19      	ldr	r6, [sp, #100]	; 0x64
    f3d4:	443e      	add	r6, r7
    f3d6:	f206 4332 	addw	r3, r6, #1074	; 0x432
    f3da:	2b20      	cmp	r3, #32
    f3dc:	f340 818e 	ble.w	f6fc <_dtoa_r+0x4cc>
    f3e0:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
    f3e4:	f206 4012 	addw	r0, r6, #1042	; 0x412
    f3e8:	409d      	lsls	r5, r3
    f3ea:	fa2a f000 	lsr.w	r0, sl, r0
    f3ee:	4328      	orrs	r0, r5
    f3f0:	f7f1 fcf6 	bl	de0 <__aeabi_ui2d>
    f3f4:	2301      	movs	r3, #1
    f3f6:	3e01      	subs	r6, #1
    f3f8:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
    f3fc:	9314      	str	r3, [sp, #80]	; 0x50
    f3fe:	e781      	b.n	f304 <_dtoa_r+0xd4>
    f400:	483b      	ldr	r0, [pc, #236]	; (f4f0 <_dtoa_r+0x2c0>)
    f402:	e743      	b.n	f28c <_dtoa_r+0x5c>
    f404:	2100      	movs	r1, #0
    f406:	6461      	str	r1, [r4, #68]	; 0x44
    f408:	4620      	mov	r0, r4
    f40a:	9125      	str	r1, [sp, #148]	; 0x94
    f40c:	f000 fee4 	bl	101d8 <_Balloc>
    f410:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    f414:	930a      	str	r3, [sp, #40]	; 0x28
    f416:	9a25      	ldr	r2, [sp, #148]	; 0x94
    f418:	930f      	str	r3, [sp, #60]	; 0x3c
    f41a:	2301      	movs	r3, #1
    f41c:	9004      	str	r0, [sp, #16]
    f41e:	6420      	str	r0, [r4, #64]	; 0x40
    f420:	9224      	str	r2, [sp, #144]	; 0x90
    f422:	930c      	str	r3, [sp, #48]	; 0x30
    f424:	9b19      	ldr	r3, [sp, #100]	; 0x64
    f426:	2b00      	cmp	r3, #0
    f428:	f2c0 80d9 	blt.w	f5de <_dtoa_r+0x3ae>
    f42c:	9a02      	ldr	r2, [sp, #8]
    f42e:	2a0e      	cmp	r2, #14
    f430:	f300 80d5 	bgt.w	f5de <_dtoa_r+0x3ae>
    f434:	4b2d      	ldr	r3, [pc, #180]	; (f4ec <_dtoa_r+0x2bc>)
    f436:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    f43a:	ed93 7b00 	vldr	d7, [r3]
    f43e:	9b25      	ldr	r3, [sp, #148]	; 0x94
    f440:	2b00      	cmp	r3, #0
    f442:	ed8d 7b08 	vstr	d7, [sp, #32]
    f446:	f2c0 83bb 	blt.w	fbc0 <_dtoa_r+0x990>
    f44a:	e9dd 5608 	ldrd	r5, r6, [sp, #32]
    f44e:	4650      	mov	r0, sl
    f450:	462a      	mov	r2, r5
    f452:	4633      	mov	r3, r6
    f454:	4659      	mov	r1, fp
    f456:	f7f1 fe63 	bl	1120 <__aeabi_ddiv>
    f45a:	f7f1 ffe7 	bl	142c <__aeabi_d2iz>
    f45e:	4680      	mov	r8, r0
    f460:	f7f1 fcce 	bl	e00 <__aeabi_i2d>
    f464:	462a      	mov	r2, r5
    f466:	4633      	mov	r3, r6
    f468:	f7f1 fd30 	bl	ecc <__aeabi_dmul>
    f46c:	460b      	mov	r3, r1
    f46e:	4602      	mov	r2, r0
    f470:	4659      	mov	r1, fp
    f472:	4650      	mov	r0, sl
    f474:	f7f1 fb76 	bl	b64 <__aeabi_dsub>
    f478:	9d04      	ldr	r5, [sp, #16]
    f47a:	f108 0330 	add.w	r3, r8, #48	; 0x30
    f47e:	702b      	strb	r3, [r5, #0]
    f480:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f482:	2b01      	cmp	r3, #1
    f484:	4606      	mov	r6, r0
    f486:	460f      	mov	r7, r1
    f488:	f105 0501 	add.w	r5, r5, #1
    f48c:	d068      	beq.n	f560 <_dtoa_r+0x330>
    f48e:	2200      	movs	r2, #0
    f490:	4b18      	ldr	r3, [pc, #96]	; (f4f4 <_dtoa_r+0x2c4>)
    f492:	f7f1 fd1b 	bl	ecc <__aeabi_dmul>
    f496:	2200      	movs	r2, #0
    f498:	2300      	movs	r3, #0
    f49a:	4606      	mov	r6, r0
    f49c:	460f      	mov	r7, r1
    f49e:	f7f1 ff7d 	bl	139c <__aeabi_dcmpeq>
    f4a2:	2800      	cmp	r0, #0
    f4a4:	f040 8088 	bne.w	f5b8 <_dtoa_r+0x388>
    f4a8:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
    f4ac:	f04f 0a00 	mov.w	sl, #0
    f4b0:	f8df b040 	ldr.w	fp, [pc, #64]	; f4f4 <_dtoa_r+0x2c4>
    f4b4:	940c      	str	r4, [sp, #48]	; 0x30
    f4b6:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
    f4ba:	e028      	b.n	f50e <_dtoa_r+0x2de>
    f4bc:	f3af 8000 	nop.w
    f4c0:	636f4361 	.word	0x636f4361
    f4c4:	3fd287a7 	.word	0x3fd287a7
    f4c8:	8b60c8b3 	.word	0x8b60c8b3
    f4cc:	3fc68a28 	.word	0x3fc68a28
    f4d0:	509f79fb 	.word	0x509f79fb
    f4d4:	3fd34413 	.word	0x3fd34413
    f4d8:	7ff00000 	.word	0x7ff00000
    f4dc:	00012a6d 	.word	0x00012a6d
    f4e0:	00012bd4 	.word	0x00012bd4
    f4e4:	00012be0 	.word	0x00012be0
    f4e8:	3ff80000 	.word	0x3ff80000
    f4ec:	00012c10 	.word	0x00012c10
    f4f0:	00012a6c 	.word	0x00012a6c
    f4f4:	40240000 	.word	0x40240000
    f4f8:	f7f1 fce8 	bl	ecc <__aeabi_dmul>
    f4fc:	2200      	movs	r2, #0
    f4fe:	2300      	movs	r3, #0
    f500:	4606      	mov	r6, r0
    f502:	460f      	mov	r7, r1
    f504:	f7f1 ff4a 	bl	139c <__aeabi_dcmpeq>
    f508:	2800      	cmp	r0, #0
    f50a:	f040 83c2 	bne.w	fc92 <_dtoa_r+0xa62>
    f50e:	4642      	mov	r2, r8
    f510:	464b      	mov	r3, r9
    f512:	4630      	mov	r0, r6
    f514:	4639      	mov	r1, r7
    f516:	f7f1 fe03 	bl	1120 <__aeabi_ddiv>
    f51a:	f7f1 ff87 	bl	142c <__aeabi_d2iz>
    f51e:	4604      	mov	r4, r0
    f520:	f7f1 fc6e 	bl	e00 <__aeabi_i2d>
    f524:	4642      	mov	r2, r8
    f526:	464b      	mov	r3, r9
    f528:	f7f1 fcd0 	bl	ecc <__aeabi_dmul>
    f52c:	4602      	mov	r2, r0
    f52e:	460b      	mov	r3, r1
    f530:	4630      	mov	r0, r6
    f532:	4639      	mov	r1, r7
    f534:	f7f1 fb16 	bl	b64 <__aeabi_dsub>
    f538:	f104 0e30 	add.w	lr, r4, #48	; 0x30
    f53c:	9e04      	ldr	r6, [sp, #16]
    f53e:	f805 eb01 	strb.w	lr, [r5], #1
    f542:	eba5 0e06 	sub.w	lr, r5, r6
    f546:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    f548:	45b6      	cmp	lr, r6
    f54a:	e9cd 0106 	strd	r0, r1, [sp, #24]
    f54e:	4652      	mov	r2, sl
    f550:	465b      	mov	r3, fp
    f552:	d1d1      	bne.n	f4f8 <_dtoa_r+0x2c8>
    f554:	46a0      	mov	r8, r4
    f556:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
    f55a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    f55c:	4606      	mov	r6, r0
    f55e:	460f      	mov	r7, r1
    f560:	4632      	mov	r2, r6
    f562:	463b      	mov	r3, r7
    f564:	4630      	mov	r0, r6
    f566:	4639      	mov	r1, r7
    f568:	f7f1 fafe 	bl	b68 <__adddf3>
    f56c:	4606      	mov	r6, r0
    f56e:	460f      	mov	r7, r1
    f570:	4602      	mov	r2, r0
    f572:	460b      	mov	r3, r1
    f574:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    f578:	f7f1 ff1a 	bl	13b0 <__aeabi_dcmplt>
    f57c:	b948      	cbnz	r0, f592 <_dtoa_r+0x362>
    f57e:	4632      	mov	r2, r6
    f580:	463b      	mov	r3, r7
    f582:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    f586:	f7f1 ff09 	bl	139c <__aeabi_dcmpeq>
    f58a:	b1a8      	cbz	r0, f5b8 <_dtoa_r+0x388>
    f58c:	f018 0f01 	tst.w	r8, #1
    f590:	d012      	beq.n	f5b8 <_dtoa_r+0x388>
    f592:	f815 8c01 	ldrb.w	r8, [r5, #-1]
    f596:	9a04      	ldr	r2, [sp, #16]
    f598:	1e6b      	subs	r3, r5, #1
    f59a:	e004      	b.n	f5a6 <_dtoa_r+0x376>
    f59c:	429a      	cmp	r2, r3
    f59e:	f000 8402 	beq.w	fda6 <_dtoa_r+0xb76>
    f5a2:	f813 8d01 	ldrb.w	r8, [r3, #-1]!
    f5a6:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
    f5aa:	f103 0501 	add.w	r5, r3, #1
    f5ae:	d0f5      	beq.n	f59c <_dtoa_r+0x36c>
    f5b0:	f108 0801 	add.w	r8, r8, #1
    f5b4:	f883 8000 	strb.w	r8, [r3]
    f5b8:	4649      	mov	r1, r9
    f5ba:	4620      	mov	r0, r4
    f5bc:	f000 fe32 	bl	10224 <_Bfree>
    f5c0:	2200      	movs	r2, #0
    f5c2:	9b02      	ldr	r3, [sp, #8]
    f5c4:	702a      	strb	r2, [r5, #0]
    f5c6:	9a26      	ldr	r2, [sp, #152]	; 0x98
    f5c8:	3301      	adds	r3, #1
    f5ca:	6013      	str	r3, [r2, #0]
    f5cc:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    f5ce:	2b00      	cmp	r3, #0
    f5d0:	f000 839c 	beq.w	fd0c <_dtoa_r+0xadc>
    f5d4:	9804      	ldr	r0, [sp, #16]
    f5d6:	601d      	str	r5, [r3, #0]
    f5d8:	b01b      	add	sp, #108	; 0x6c
    f5da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f5de:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    f5e0:	2a00      	cmp	r2, #0
    f5e2:	d03e      	beq.n	f662 <_dtoa_r+0x432>
    f5e4:	9a24      	ldr	r2, [sp, #144]	; 0x90
    f5e6:	2a01      	cmp	r2, #1
    f5e8:	f340 8312 	ble.w	fc10 <_dtoa_r+0x9e0>
    f5ec:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f5ee:	9a06      	ldr	r2, [sp, #24]
    f5f0:	1e5f      	subs	r7, r3, #1
    f5f2:	42ba      	cmp	r2, r7
    f5f4:	f2c0 838d 	blt.w	fd12 <_dtoa_r+0xae2>
    f5f8:	1bd7      	subs	r7, r2, r7
    f5fa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f5fc:	2b00      	cmp	r3, #0
    f5fe:	f2c0 8485 	blt.w	ff0c <_dtoa_r+0xcdc>
    f602:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    f604:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f606:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f608:	441a      	add	r2, r3
    f60a:	920b      	str	r2, [sp, #44]	; 0x2c
    f60c:	9a08      	ldr	r2, [sp, #32]
    f60e:	2101      	movs	r1, #1
    f610:	441a      	add	r2, r3
    f612:	4620      	mov	r0, r4
    f614:	9208      	str	r2, [sp, #32]
    f616:	f000 fe9f 	bl	10358 <__i2b>
    f61a:	4606      	mov	r6, r0
    f61c:	e024      	b.n	f668 <_dtoa_r+0x438>
    f61e:	2301      	movs	r3, #1
    f620:	930e      	str	r3, [sp, #56]	; 0x38
    f622:	e6af      	b.n	f384 <_dtoa_r+0x154>
    f624:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f626:	9b02      	ldr	r3, [sp, #8]
    f628:	1ad2      	subs	r2, r2, r3
    f62a:	425b      	negs	r3, r3
    f62c:	9306      	str	r3, [sp, #24]
    f62e:	2300      	movs	r3, #0
    f630:	920b      	str	r2, [sp, #44]	; 0x2c
    f632:	930d      	str	r3, [sp, #52]	; 0x34
    f634:	e6b8      	b.n	f3a8 <_dtoa_r+0x178>
    f636:	f1c7 0301 	rsb	r3, r7, #1
    f63a:	930b      	str	r3, [sp, #44]	; 0x2c
    f63c:	2300      	movs	r3, #0
    f63e:	9308      	str	r3, [sp, #32]
    f640:	e6a7      	b.n	f392 <_dtoa_r+0x162>
    f642:	9d02      	ldr	r5, [sp, #8]
    f644:	4628      	mov	r0, r5
    f646:	f7f1 fbdb 	bl	e00 <__aeabi_i2d>
    f64a:	4602      	mov	r2, r0
    f64c:	460b      	mov	r3, r1
    f64e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    f652:	f7f1 fea3 	bl	139c <__aeabi_dcmpeq>
    f656:	2800      	cmp	r0, #0
    f658:	f47f ae80 	bne.w	f35c <_dtoa_r+0x12c>
    f65c:	1e6b      	subs	r3, r5, #1
    f65e:	9302      	str	r3, [sp, #8]
    f660:	e67c      	b.n	f35c <_dtoa_r+0x12c>
    f662:	9f06      	ldr	r7, [sp, #24]
    f664:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    f666:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    f668:	2d00      	cmp	r5, #0
    f66a:	dd0c      	ble.n	f686 <_dtoa_r+0x456>
    f66c:	9908      	ldr	r1, [sp, #32]
    f66e:	2900      	cmp	r1, #0
    f670:	460b      	mov	r3, r1
    f672:	dd08      	ble.n	f686 <_dtoa_r+0x456>
    f674:	42a9      	cmp	r1, r5
    f676:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f678:	bfa8      	it	ge
    f67a:	462b      	movge	r3, r5
    f67c:	1ad2      	subs	r2, r2, r3
    f67e:	1aed      	subs	r5, r5, r3
    f680:	1acb      	subs	r3, r1, r3
    f682:	920b      	str	r2, [sp, #44]	; 0x2c
    f684:	9308      	str	r3, [sp, #32]
    f686:	9b06      	ldr	r3, [sp, #24]
    f688:	b1d3      	cbz	r3, f6c0 <_dtoa_r+0x490>
    f68a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    f68c:	2b00      	cmp	r3, #0
    f68e:	f000 82b8 	beq.w	fc02 <_dtoa_r+0x9d2>
    f692:	2f00      	cmp	r7, #0
    f694:	dd10      	ble.n	f6b8 <_dtoa_r+0x488>
    f696:	4631      	mov	r1, r6
    f698:	463a      	mov	r2, r7
    f69a:	4620      	mov	r0, r4
    f69c:	f000 fef8 	bl	10490 <__pow5mult>
    f6a0:	464a      	mov	r2, r9
    f6a2:	4601      	mov	r1, r0
    f6a4:	4606      	mov	r6, r0
    f6a6:	4620      	mov	r0, r4
    f6a8:	f000 fe60 	bl	1036c <__multiply>
    f6ac:	4649      	mov	r1, r9
    f6ae:	4680      	mov	r8, r0
    f6b0:	4620      	mov	r0, r4
    f6b2:	f000 fdb7 	bl	10224 <_Bfree>
    f6b6:	46c1      	mov	r9, r8
    f6b8:	9b06      	ldr	r3, [sp, #24]
    f6ba:	1bda      	subs	r2, r3, r7
    f6bc:	f040 82a2 	bne.w	fc04 <_dtoa_r+0x9d4>
    f6c0:	2101      	movs	r1, #1
    f6c2:	4620      	mov	r0, r4
    f6c4:	f000 fe48 	bl	10358 <__i2b>
    f6c8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    f6ca:	9006      	str	r0, [sp, #24]
    f6cc:	2b00      	cmp	r3, #0
    f6ce:	dd1c      	ble.n	f70a <_dtoa_r+0x4da>
    f6d0:	4601      	mov	r1, r0
    f6d2:	461a      	mov	r2, r3
    f6d4:	4620      	mov	r0, r4
    f6d6:	f000 fedb 	bl	10490 <__pow5mult>
    f6da:	9b24      	ldr	r3, [sp, #144]	; 0x90
    f6dc:	9006      	str	r0, [sp, #24]
    f6de:	2b01      	cmp	r3, #1
    f6e0:	f340 8255 	ble.w	fb8e <_dtoa_r+0x95e>
    f6e4:	f04f 0800 	mov.w	r8, #0
    f6e8:	9a06      	ldr	r2, [sp, #24]
    f6ea:	6913      	ldr	r3, [r2, #16]
    f6ec:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    f6f0:	6918      	ldr	r0, [r3, #16]
    f6f2:	f000 fde1 	bl	102b8 <__hi0bits>
    f6f6:	f1c0 0020 	rsb	r0, r0, #32
    f6fa:	e010      	b.n	f71e <_dtoa_r+0x4ee>
    f6fc:	f1c3 0520 	rsb	r5, r3, #32
    f700:	fa0a f005 	lsl.w	r0, sl, r5
    f704:	e674      	b.n	f3f0 <_dtoa_r+0x1c0>
    f706:	900e      	str	r0, [sp, #56]	; 0x38
    f708:	e63c      	b.n	f384 <_dtoa_r+0x154>
    f70a:	9b24      	ldr	r3, [sp, #144]	; 0x90
    f70c:	2b01      	cmp	r3, #1
    f70e:	f340 8288 	ble.w	fc22 <_dtoa_r+0x9f2>
    f712:	f04f 0800 	mov.w	r8, #0
    f716:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    f718:	2001      	movs	r0, #1
    f71a:	2b00      	cmp	r3, #0
    f71c:	d1e4      	bne.n	f6e8 <_dtoa_r+0x4b8>
    f71e:	9a08      	ldr	r2, [sp, #32]
    f720:	4410      	add	r0, r2
    f722:	f010 001f 	ands.w	r0, r0, #31
    f726:	f000 80a0 	beq.w	f86a <_dtoa_r+0x63a>
    f72a:	f1c0 0320 	rsb	r3, r0, #32
    f72e:	2b04      	cmp	r3, #4
    f730:	f340 847f 	ble.w	10032 <_dtoa_r+0xe02>
    f734:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f736:	f1c0 001c 	rsb	r0, r0, #28
    f73a:	4403      	add	r3, r0
    f73c:	930b      	str	r3, [sp, #44]	; 0x2c
    f73e:	4613      	mov	r3, r2
    f740:	4403      	add	r3, r0
    f742:	4405      	add	r5, r0
    f744:	9308      	str	r3, [sp, #32]
    f746:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f748:	2b00      	cmp	r3, #0
    f74a:	dd05      	ble.n	f758 <_dtoa_r+0x528>
    f74c:	4649      	mov	r1, r9
    f74e:	461a      	mov	r2, r3
    f750:	4620      	mov	r0, r4
    f752:	f000 feed 	bl	10530 <__lshift>
    f756:	4681      	mov	r9, r0
    f758:	9b08      	ldr	r3, [sp, #32]
    f75a:	2b00      	cmp	r3, #0
    f75c:	dd05      	ble.n	f76a <_dtoa_r+0x53a>
    f75e:	461a      	mov	r2, r3
    f760:	9906      	ldr	r1, [sp, #24]
    f762:	4620      	mov	r0, r4
    f764:	f000 fee4 	bl	10530 <__lshift>
    f768:	9006      	str	r0, [sp, #24]
    f76a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    f76c:	2b00      	cmp	r3, #0
    f76e:	f040 8085 	bne.w	f87c <_dtoa_r+0x64c>
    f772:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f774:	2b00      	cmp	r3, #0
    f776:	f340 8267 	ble.w	fc48 <_dtoa_r+0xa18>
    f77a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    f77c:	2b00      	cmp	r3, #0
    f77e:	f000 8097 	beq.w	f8b0 <_dtoa_r+0x680>
    f782:	2d00      	cmp	r5, #0
    f784:	dd05      	ble.n	f792 <_dtoa_r+0x562>
    f786:	4631      	mov	r1, r6
    f788:	462a      	mov	r2, r5
    f78a:	4620      	mov	r0, r4
    f78c:	f000 fed0 	bl	10530 <__lshift>
    f790:	4606      	mov	r6, r0
    f792:	f1b8 0f00 	cmp.w	r8, #0
    f796:	f040 8338 	bne.w	fe0a <_dtoa_r+0xbda>
    f79a:	46b0      	mov	r8, r6
    f79c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f79e:	9a04      	ldr	r2, [sp, #16]
    f7a0:	3b01      	subs	r3, #1
    f7a2:	18d3      	adds	r3, r2, r3
    f7a4:	930b      	str	r3, [sp, #44]	; 0x2c
    f7a6:	f00a 0301 	and.w	r3, sl, #1
    f7aa:	930c      	str	r3, [sp, #48]	; 0x30
    f7ac:	4617      	mov	r7, r2
    f7ae:	f8dd b018 	ldr.w	fp, [sp, #24]
    f7b2:	4648      	mov	r0, r9
    f7b4:	4659      	mov	r1, fp
    f7b6:	f7ff fca7 	bl	f108 <quorem>
    f7ba:	4631      	mov	r1, r6
    f7bc:	4605      	mov	r5, r0
    f7be:	4648      	mov	r0, r9
    f7c0:	f000 ff08 	bl	105d4 <__mcmp>
    f7c4:	4642      	mov	r2, r8
    f7c6:	4659      	mov	r1, fp
    f7c8:	4682      	mov	sl, r0
    f7ca:	4620      	mov	r0, r4
    f7cc:	f000 ff1e 	bl	1060c <__mdiff>
    f7d0:	68c2      	ldr	r2, [r0, #12]
    f7d2:	4683      	mov	fp, r0
    f7d4:	f105 0330 	add.w	r3, r5, #48	; 0x30
    f7d8:	2a00      	cmp	r2, #0
    f7da:	f040 822d 	bne.w	fc38 <_dtoa_r+0xa08>
    f7de:	4601      	mov	r1, r0
    f7e0:	4648      	mov	r0, r9
    f7e2:	9308      	str	r3, [sp, #32]
    f7e4:	f000 fef6 	bl	105d4 <__mcmp>
    f7e8:	4659      	mov	r1, fp
    f7ea:	900a      	str	r0, [sp, #40]	; 0x28
    f7ec:	4620      	mov	r0, r4
    f7ee:	f000 fd19 	bl	10224 <_Bfree>
    f7f2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    f7f4:	9b08      	ldr	r3, [sp, #32]
    f7f6:	b932      	cbnz	r2, f806 <_dtoa_r+0x5d6>
    f7f8:	9924      	ldr	r1, [sp, #144]	; 0x90
    f7fa:	b921      	cbnz	r1, f806 <_dtoa_r+0x5d6>
    f7fc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    f7fe:	2a00      	cmp	r2, #0
    f800:	f000 83dd 	beq.w	ffbe <_dtoa_r+0xd8e>
    f804:	9a24      	ldr	r2, [sp, #144]	; 0x90
    f806:	f1ba 0f00 	cmp.w	sl, #0
    f80a:	f2c0 829e 	blt.w	fd4a <_dtoa_r+0xb1a>
    f80e:	d105      	bne.n	f81c <_dtoa_r+0x5ec>
    f810:	9924      	ldr	r1, [sp, #144]	; 0x90
    f812:	b919      	cbnz	r1, f81c <_dtoa_r+0x5ec>
    f814:	990c      	ldr	r1, [sp, #48]	; 0x30
    f816:	2900      	cmp	r1, #0
    f818:	f000 8297 	beq.w	fd4a <_dtoa_r+0xb1a>
    f81c:	2a00      	cmp	r2, #0
    f81e:	f300 8308 	bgt.w	fe32 <_dtoa_r+0xc02>
    f822:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f824:	703b      	strb	r3, [r7, #0]
    f826:	f107 0a01 	add.w	sl, r7, #1
    f82a:	4297      	cmp	r7, r2
    f82c:	4655      	mov	r5, sl
    f82e:	f000 8309 	beq.w	fe44 <_dtoa_r+0xc14>
    f832:	4649      	mov	r1, r9
    f834:	2300      	movs	r3, #0
    f836:	220a      	movs	r2, #10
    f838:	4620      	mov	r0, r4
    f83a:	f000 fcfd 	bl	10238 <__multadd>
    f83e:	4546      	cmp	r6, r8
    f840:	4681      	mov	r9, r0
    f842:	4631      	mov	r1, r6
    f844:	f04f 0300 	mov.w	r3, #0
    f848:	f04f 020a 	mov.w	r2, #10
    f84c:	4620      	mov	r0, r4
    f84e:	f000 81ed 	beq.w	fc2c <_dtoa_r+0x9fc>
    f852:	f000 fcf1 	bl	10238 <__multadd>
    f856:	4641      	mov	r1, r8
    f858:	4606      	mov	r6, r0
    f85a:	2300      	movs	r3, #0
    f85c:	220a      	movs	r2, #10
    f85e:	4620      	mov	r0, r4
    f860:	f000 fcea 	bl	10238 <__multadd>
    f864:	4657      	mov	r7, sl
    f866:	4680      	mov	r8, r0
    f868:	e7a1      	b.n	f7ae <_dtoa_r+0x57e>
    f86a:	201c      	movs	r0, #28
    f86c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f86e:	4403      	add	r3, r0
    f870:	930b      	str	r3, [sp, #44]	; 0x2c
    f872:	9b08      	ldr	r3, [sp, #32]
    f874:	4403      	add	r3, r0
    f876:	4405      	add	r5, r0
    f878:	9308      	str	r3, [sp, #32]
    f87a:	e764      	b.n	f746 <_dtoa_r+0x516>
    f87c:	9906      	ldr	r1, [sp, #24]
    f87e:	4648      	mov	r0, r9
    f880:	f000 fea8 	bl	105d4 <__mcmp>
    f884:	2800      	cmp	r0, #0
    f886:	f6bf af74 	bge.w	f772 <_dtoa_r+0x542>
    f88a:	9f02      	ldr	r7, [sp, #8]
    f88c:	4649      	mov	r1, r9
    f88e:	2300      	movs	r3, #0
    f890:	220a      	movs	r2, #10
    f892:	4620      	mov	r0, r4
    f894:	3f01      	subs	r7, #1
    f896:	9702      	str	r7, [sp, #8]
    f898:	f000 fcce 	bl	10238 <__multadd>
    f89c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    f89e:	4681      	mov	r9, r0
    f8a0:	2b00      	cmp	r3, #0
    f8a2:	f040 83a9 	bne.w	fff8 <_dtoa_r+0xdc8>
    f8a6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    f8a8:	2b00      	cmp	r3, #0
    f8aa:	f340 83b2 	ble.w	10012 <_dtoa_r+0xde2>
    f8ae:	930a      	str	r3, [sp, #40]	; 0x28
    f8b0:	f8dd 8010 	ldr.w	r8, [sp, #16]
    f8b4:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    f8b6:	f8dd b018 	ldr.w	fp, [sp, #24]
    f8ba:	4645      	mov	r5, r8
    f8bc:	e002      	b.n	f8c4 <_dtoa_r+0x694>
    f8be:	f000 fcbb 	bl	10238 <__multadd>
    f8c2:	4681      	mov	r9, r0
    f8c4:	4659      	mov	r1, fp
    f8c6:	4648      	mov	r0, r9
    f8c8:	f7ff fc1e 	bl	f108 <quorem>
    f8cc:	f100 0a30 	add.w	sl, r0, #48	; 0x30
    f8d0:	f805 ab01 	strb.w	sl, [r5], #1
    f8d4:	eba5 0308 	sub.w	r3, r5, r8
    f8d8:	42bb      	cmp	r3, r7
    f8da:	f04f 020a 	mov.w	r2, #10
    f8de:	f04f 0300 	mov.w	r3, #0
    f8e2:	4649      	mov	r1, r9
    f8e4:	4620      	mov	r0, r4
    f8e6:	dbea      	blt.n	f8be <_dtoa_r+0x68e>
    f8e8:	9b04      	ldr	r3, [sp, #16]
    f8ea:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    f8ec:	2a01      	cmp	r2, #1
    f8ee:	bfac      	ite	ge
    f8f0:	189b      	addge	r3, r3, r2
    f8f2:	3301      	addlt	r3, #1
    f8f4:	461d      	mov	r5, r3
    f8f6:	f04f 0b00 	mov.w	fp, #0
    f8fa:	4649      	mov	r1, r9
    f8fc:	2201      	movs	r2, #1
    f8fe:	4620      	mov	r0, r4
    f900:	f000 fe16 	bl	10530 <__lshift>
    f904:	9906      	ldr	r1, [sp, #24]
    f906:	4681      	mov	r9, r0
    f908:	f000 fe64 	bl	105d4 <__mcmp>
    f90c:	2800      	cmp	r0, #0
    f90e:	f340 8237 	ble.w	fd80 <_dtoa_r+0xb50>
    f912:	f815 2c01 	ldrb.w	r2, [r5, #-1]
    f916:	9904      	ldr	r1, [sp, #16]
    f918:	1e6b      	subs	r3, r5, #1
    f91a:	e004      	b.n	f926 <_dtoa_r+0x6f6>
    f91c:	428b      	cmp	r3, r1
    f91e:	f000 81ae 	beq.w	fc7e <_dtoa_r+0xa4e>
    f922:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    f926:	2a39      	cmp	r2, #57	; 0x39
    f928:	f103 0501 	add.w	r5, r3, #1
    f92c:	d0f6      	beq.n	f91c <_dtoa_r+0x6ec>
    f92e:	3201      	adds	r2, #1
    f930:	701a      	strb	r2, [r3, #0]
    f932:	9906      	ldr	r1, [sp, #24]
    f934:	4620      	mov	r0, r4
    f936:	f000 fc75 	bl	10224 <_Bfree>
    f93a:	2e00      	cmp	r6, #0
    f93c:	f43f ae3c 	beq.w	f5b8 <_dtoa_r+0x388>
    f940:	f1bb 0f00 	cmp.w	fp, #0
    f944:	d005      	beq.n	f952 <_dtoa_r+0x722>
    f946:	45b3      	cmp	fp, r6
    f948:	d003      	beq.n	f952 <_dtoa_r+0x722>
    f94a:	4659      	mov	r1, fp
    f94c:	4620      	mov	r0, r4
    f94e:	f000 fc69 	bl	10224 <_Bfree>
    f952:	4631      	mov	r1, r6
    f954:	4620      	mov	r0, r4
    f956:	f000 fc65 	bl	10224 <_Bfree>
    f95a:	e62d      	b.n	f5b8 <_dtoa_r+0x388>
    f95c:	2300      	movs	r3, #0
    f95e:	930c      	str	r3, [sp, #48]	; 0x30
    f960:	9b02      	ldr	r3, [sp, #8]
    f962:	9a25      	ldr	r2, [sp, #148]	; 0x94
    f964:	4413      	add	r3, r2
    f966:	930f      	str	r3, [sp, #60]	; 0x3c
    f968:	3301      	adds	r3, #1
    f96a:	2b01      	cmp	r3, #1
    f96c:	461f      	mov	r7, r3
    f96e:	461e      	mov	r6, r3
    f970:	930a      	str	r3, [sp, #40]	; 0x28
    f972:	bfb8      	it	lt
    f974:	2701      	movlt	r7, #1
    f976:	2100      	movs	r1, #0
    f978:	2f17      	cmp	r7, #23
    f97a:	6461      	str	r1, [r4, #68]	; 0x44
    f97c:	d90a      	bls.n	f994 <_dtoa_r+0x764>
    f97e:	2201      	movs	r2, #1
    f980:	2304      	movs	r3, #4
    f982:	005b      	lsls	r3, r3, #1
    f984:	f103 0014 	add.w	r0, r3, #20
    f988:	4287      	cmp	r7, r0
    f98a:	4611      	mov	r1, r2
    f98c:	f102 0201 	add.w	r2, r2, #1
    f990:	d2f7      	bcs.n	f982 <_dtoa_r+0x752>
    f992:	6461      	str	r1, [r4, #68]	; 0x44
    f994:	4620      	mov	r0, r4
    f996:	f000 fc1f 	bl	101d8 <_Balloc>
    f99a:	2e0e      	cmp	r6, #14
    f99c:	9004      	str	r0, [sp, #16]
    f99e:	6420      	str	r0, [r4, #64]	; 0x40
    f9a0:	f63f ad40 	bhi.w	f424 <_dtoa_r+0x1f4>
    f9a4:	2d00      	cmp	r5, #0
    f9a6:	f43f ad3d 	beq.w	f424 <_dtoa_r+0x1f4>
    f9aa:	9902      	ldr	r1, [sp, #8]
    f9ac:	2900      	cmp	r1, #0
    f9ae:	e9cd ab10 	strd	sl, fp, [sp, #64]	; 0x40
    f9b2:	f340 8202 	ble.w	fdba <_dtoa_r+0xb8a>
    f9b6:	4bb9      	ldr	r3, [pc, #740]	; (fc9c <_dtoa_r+0xa6c>)
    f9b8:	f001 020f 	and.w	r2, r1, #15
    f9bc:	110d      	asrs	r5, r1, #4
    f9be:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    f9c2:	06e9      	lsls	r1, r5, #27
    f9c4:	e9d3 6700 	ldrd	r6, r7, [r3]
    f9c8:	f140 81ab 	bpl.w	fd22 <_dtoa_r+0xaf2>
    f9cc:	4bb4      	ldr	r3, [pc, #720]	; (fca0 <_dtoa_r+0xa70>)
    f9ce:	4650      	mov	r0, sl
    f9d0:	4659      	mov	r1, fp
    f9d2:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
    f9d6:	f7f1 fba3 	bl	1120 <__aeabi_ddiv>
    f9da:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
    f9de:	f005 050f 	and.w	r5, r5, #15
    f9e2:	f04f 0a03 	mov.w	sl, #3
    f9e6:	b18d      	cbz	r5, fa0c <_dtoa_r+0x7dc>
    f9e8:	f8df 82b4 	ldr.w	r8, [pc, #692]	; fca0 <_dtoa_r+0xa70>
    f9ec:	07ea      	lsls	r2, r5, #31
    f9ee:	d509      	bpl.n	fa04 <_dtoa_r+0x7d4>
    f9f0:	4630      	mov	r0, r6
    f9f2:	4639      	mov	r1, r7
    f9f4:	e9d8 2300 	ldrd	r2, r3, [r8]
    f9f8:	f7f1 fa68 	bl	ecc <__aeabi_dmul>
    f9fc:	f10a 0a01 	add.w	sl, sl, #1
    fa00:	4606      	mov	r6, r0
    fa02:	460f      	mov	r7, r1
    fa04:	106d      	asrs	r5, r5, #1
    fa06:	f108 0808 	add.w	r8, r8, #8
    fa0a:	d1ef      	bne.n	f9ec <_dtoa_r+0x7bc>
    fa0c:	463b      	mov	r3, r7
    fa0e:	4632      	mov	r2, r6
    fa10:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    fa14:	f7f1 fb84 	bl	1120 <__aeabi_ddiv>
    fa18:	4607      	mov	r7, r0
    fa1a:	4688      	mov	r8, r1
    fa1c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    fa1e:	b143      	cbz	r3, fa32 <_dtoa_r+0x802>
    fa20:	2200      	movs	r2, #0
    fa22:	4ba0      	ldr	r3, [pc, #640]	; (fca4 <_dtoa_r+0xa74>)
    fa24:	4638      	mov	r0, r7
    fa26:	4641      	mov	r1, r8
    fa28:	f7f1 fcc2 	bl	13b0 <__aeabi_dcmplt>
    fa2c:	2800      	cmp	r0, #0
    fa2e:	f040 827f 	bne.w	ff30 <_dtoa_r+0xd00>
    fa32:	4650      	mov	r0, sl
    fa34:	f7f1 f9e4 	bl	e00 <__aeabi_i2d>
    fa38:	463a      	mov	r2, r7
    fa3a:	4643      	mov	r3, r8
    fa3c:	f7f1 fa46 	bl	ecc <__aeabi_dmul>
    fa40:	4b99      	ldr	r3, [pc, #612]	; (fca8 <_dtoa_r+0xa78>)
    fa42:	2200      	movs	r2, #0
    fa44:	f7f1 f890 	bl	b68 <__adddf3>
    fa48:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fa4a:	4682      	mov	sl, r0
    fa4c:	f1a1 7b50 	sub.w	fp, r1, #54525952	; 0x3400000
    fa50:	2b00      	cmp	r3, #0
    fa52:	f000 813f 	beq.w	fcd4 <_dtoa_r+0xaa4>
    fa56:	9b02      	ldr	r3, [sp, #8]
    fa58:	9315      	str	r3, [sp, #84]	; 0x54
    fa5a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fa5c:	9312      	str	r3, [sp, #72]	; 0x48
    fa5e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    fa60:	2b00      	cmp	r3, #0
    fa62:	f000 81f7 	beq.w	fe54 <_dtoa_r+0xc24>
    fa66:	9a12      	ldr	r2, [sp, #72]	; 0x48
    fa68:	4b8c      	ldr	r3, [pc, #560]	; (fc9c <_dtoa_r+0xa6c>)
    fa6a:	4990      	ldr	r1, [pc, #576]	; (fcac <_dtoa_r+0xa7c>)
    fa6c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    fa70:	e953 2302 	ldrd	r2, r3, [r3, #-8]
    fa74:	2000      	movs	r0, #0
    fa76:	f7f1 fb53 	bl	1120 <__aeabi_ddiv>
    fa7a:	4652      	mov	r2, sl
    fa7c:	465b      	mov	r3, fp
    fa7e:	f7f1 f871 	bl	b64 <__aeabi_dsub>
    fa82:	4682      	mov	sl, r0
    fa84:	468b      	mov	fp, r1
    fa86:	4638      	mov	r0, r7
    fa88:	4641      	mov	r1, r8
    fa8a:	f7f1 fccf 	bl	142c <__aeabi_d2iz>
    fa8e:	4605      	mov	r5, r0
    fa90:	f7f1 f9b6 	bl	e00 <__aeabi_i2d>
    fa94:	4602      	mov	r2, r0
    fa96:	460b      	mov	r3, r1
    fa98:	4638      	mov	r0, r7
    fa9a:	4641      	mov	r1, r8
    fa9c:	f7f1 f862 	bl	b64 <__aeabi_dsub>
    faa0:	3530      	adds	r5, #48	; 0x30
    faa2:	fa5f f885 	uxtb.w	r8, r5
    faa6:	9d04      	ldr	r5, [sp, #16]
    faa8:	4606      	mov	r6, r0
    faaa:	460f      	mov	r7, r1
    faac:	f885 8000 	strb.w	r8, [r5]
    fab0:	4602      	mov	r2, r0
    fab2:	460b      	mov	r3, r1
    fab4:	4650      	mov	r0, sl
    fab6:	4659      	mov	r1, fp
    fab8:	3501      	adds	r5, #1
    faba:	f7f1 fc97 	bl	13ec <__aeabi_dcmpgt>
    fabe:	2800      	cmp	r0, #0
    fac0:	d154      	bne.n	fb6c <_dtoa_r+0x93c>
    fac2:	4632      	mov	r2, r6
    fac4:	463b      	mov	r3, r7
    fac6:	2000      	movs	r0, #0
    fac8:	4976      	ldr	r1, [pc, #472]	; (fca4 <_dtoa_r+0xa74>)
    faca:	f7f1 f84b 	bl	b64 <__aeabi_dsub>
    face:	4602      	mov	r2, r0
    fad0:	460b      	mov	r3, r1
    fad2:	4650      	mov	r0, sl
    fad4:	4659      	mov	r1, fp
    fad6:	f7f1 fc89 	bl	13ec <__aeabi_dcmpgt>
    fada:	2800      	cmp	r0, #0
    fadc:	f040 8268 	bne.w	ffb0 <_dtoa_r+0xd80>
    fae0:	9a12      	ldr	r2, [sp, #72]	; 0x48
    fae2:	2a01      	cmp	r2, #1
    fae4:	f000 815b 	beq.w	fd9e <_dtoa_r+0xb6e>
    fae8:	9b12      	ldr	r3, [sp, #72]	; 0x48
    faea:	9a04      	ldr	r2, [sp, #16]
    faec:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
    faf0:	4413      	add	r3, r2
    faf2:	4699      	mov	r9, r3
    faf4:	e00d      	b.n	fb12 <_dtoa_r+0x8e2>
    faf6:	2000      	movs	r0, #0
    faf8:	496a      	ldr	r1, [pc, #424]	; (fca4 <_dtoa_r+0xa74>)
    fafa:	f7f1 f833 	bl	b64 <__aeabi_dsub>
    fafe:	4652      	mov	r2, sl
    fb00:	465b      	mov	r3, fp
    fb02:	f7f1 fc55 	bl	13b0 <__aeabi_dcmplt>
    fb06:	2800      	cmp	r0, #0
    fb08:	f040 8250 	bne.w	ffac <_dtoa_r+0xd7c>
    fb0c:	454d      	cmp	r5, r9
    fb0e:	f000 8144 	beq.w	fd9a <_dtoa_r+0xb6a>
    fb12:	4650      	mov	r0, sl
    fb14:	4659      	mov	r1, fp
    fb16:	2200      	movs	r2, #0
    fb18:	4b65      	ldr	r3, [pc, #404]	; (fcb0 <_dtoa_r+0xa80>)
    fb1a:	f7f1 f9d7 	bl	ecc <__aeabi_dmul>
    fb1e:	2200      	movs	r2, #0
    fb20:	4b63      	ldr	r3, [pc, #396]	; (fcb0 <_dtoa_r+0xa80>)
    fb22:	4682      	mov	sl, r0
    fb24:	468b      	mov	fp, r1
    fb26:	4630      	mov	r0, r6
    fb28:	4639      	mov	r1, r7
    fb2a:	f7f1 f9cf 	bl	ecc <__aeabi_dmul>
    fb2e:	460f      	mov	r7, r1
    fb30:	4606      	mov	r6, r0
    fb32:	f7f1 fc7b 	bl	142c <__aeabi_d2iz>
    fb36:	4680      	mov	r8, r0
    fb38:	f7f1 f962 	bl	e00 <__aeabi_i2d>
    fb3c:	4602      	mov	r2, r0
    fb3e:	460b      	mov	r3, r1
    fb40:	4630      	mov	r0, r6
    fb42:	4639      	mov	r1, r7
    fb44:	f7f1 f80e 	bl	b64 <__aeabi_dsub>
    fb48:	f108 0830 	add.w	r8, r8, #48	; 0x30
    fb4c:	fa5f f888 	uxtb.w	r8, r8
    fb50:	4652      	mov	r2, sl
    fb52:	465b      	mov	r3, fp
    fb54:	f805 8b01 	strb.w	r8, [r5], #1
    fb58:	4606      	mov	r6, r0
    fb5a:	460f      	mov	r7, r1
    fb5c:	f7f1 fc28 	bl	13b0 <__aeabi_dcmplt>
    fb60:	4632      	mov	r2, r6
    fb62:	463b      	mov	r3, r7
    fb64:	2800      	cmp	r0, #0
    fb66:	d0c6      	beq.n	faf6 <_dtoa_r+0x8c6>
    fb68:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
    fb6c:	9b15      	ldr	r3, [sp, #84]	; 0x54
    fb6e:	9302      	str	r3, [sp, #8]
    fb70:	e522      	b.n	f5b8 <_dtoa_r+0x388>
    fb72:	2300      	movs	r3, #0
    fb74:	930c      	str	r3, [sp, #48]	; 0x30
    fb76:	9b25      	ldr	r3, [sp, #148]	; 0x94
    fb78:	2b00      	cmp	r3, #0
    fb7a:	f340 80d9 	ble.w	fd30 <_dtoa_r+0xb00>
    fb7e:	461f      	mov	r7, r3
    fb80:	461e      	mov	r6, r3
    fb82:	930f      	str	r3, [sp, #60]	; 0x3c
    fb84:	930a      	str	r3, [sp, #40]	; 0x28
    fb86:	e6f6      	b.n	f976 <_dtoa_r+0x746>
    fb88:	2301      	movs	r3, #1
    fb8a:	930c      	str	r3, [sp, #48]	; 0x30
    fb8c:	e7f3      	b.n	fb76 <_dtoa_r+0x946>
    fb8e:	f1ba 0f00 	cmp.w	sl, #0
    fb92:	f47f ada7 	bne.w	f6e4 <_dtoa_r+0x4b4>
    fb96:	f3cb 0313 	ubfx	r3, fp, #0, #20
    fb9a:	2b00      	cmp	r3, #0
    fb9c:	f47f adb9 	bne.w	f712 <_dtoa_r+0x4e2>
    fba0:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
    fba4:	0d3f      	lsrs	r7, r7, #20
    fba6:	053f      	lsls	r7, r7, #20
    fba8:	2f00      	cmp	r7, #0
    fbaa:	f000 8205 	beq.w	ffb8 <_dtoa_r+0xd88>
    fbae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fbb0:	3301      	adds	r3, #1
    fbb2:	930b      	str	r3, [sp, #44]	; 0x2c
    fbb4:	9b08      	ldr	r3, [sp, #32]
    fbb6:	3301      	adds	r3, #1
    fbb8:	9308      	str	r3, [sp, #32]
    fbba:	f04f 0801 	mov.w	r8, #1
    fbbe:	e5aa      	b.n	f716 <_dtoa_r+0x4e6>
    fbc0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fbc2:	2b00      	cmp	r3, #0
    fbc4:	f73f ac41 	bgt.w	f44a <_dtoa_r+0x21a>
    fbc8:	f040 809c 	bne.w	fd04 <_dtoa_r+0xad4>
    fbcc:	2200      	movs	r2, #0
    fbce:	4b39      	ldr	r3, [pc, #228]	; (fcb4 <_dtoa_r+0xa84>)
    fbd0:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    fbd4:	f7f1 f97a 	bl	ecc <__aeabi_dmul>
    fbd8:	465b      	mov	r3, fp
    fbda:	4652      	mov	r2, sl
    fbdc:	f7f1 fbfc 	bl	13d8 <__aeabi_dcmpge>
    fbe0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fbe2:	9306      	str	r3, [sp, #24]
    fbe4:	461e      	mov	r6, r3
    fbe6:	2800      	cmp	r0, #0
    fbe8:	d041      	beq.n	fc6e <_dtoa_r+0xa3e>
    fbea:	9b25      	ldr	r3, [sp, #148]	; 0x94
    fbec:	9d04      	ldr	r5, [sp, #16]
    fbee:	43db      	mvns	r3, r3
    fbf0:	9302      	str	r3, [sp, #8]
    fbf2:	9906      	ldr	r1, [sp, #24]
    fbf4:	4620      	mov	r0, r4
    fbf6:	f000 fb15 	bl	10224 <_Bfree>
    fbfa:	2e00      	cmp	r6, #0
    fbfc:	f43f acdc 	beq.w	f5b8 <_dtoa_r+0x388>
    fc00:	e6a7      	b.n	f952 <_dtoa_r+0x722>
    fc02:	9a06      	ldr	r2, [sp, #24]
    fc04:	4649      	mov	r1, r9
    fc06:	4620      	mov	r0, r4
    fc08:	f000 fc42 	bl	10490 <__pow5mult>
    fc0c:	4681      	mov	r9, r0
    fc0e:	e557      	b.n	f6c0 <_dtoa_r+0x490>
    fc10:	9a14      	ldr	r2, [sp, #80]	; 0x50
    fc12:	2a00      	cmp	r2, #0
    fc14:	f000 8180 	beq.w	ff18 <_dtoa_r+0xce8>
    fc18:	f203 4333 	addw	r3, r3, #1075	; 0x433
    fc1c:	9f06      	ldr	r7, [sp, #24]
    fc1e:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    fc20:	e4f1      	b.n	f606 <_dtoa_r+0x3d6>
    fc22:	f1ba 0f00 	cmp.w	sl, #0
    fc26:	f47f ad74 	bne.w	f712 <_dtoa_r+0x4e2>
    fc2a:	e7b4      	b.n	fb96 <_dtoa_r+0x966>
    fc2c:	f000 fb04 	bl	10238 <__multadd>
    fc30:	4657      	mov	r7, sl
    fc32:	4606      	mov	r6, r0
    fc34:	4680      	mov	r8, r0
    fc36:	e5ba      	b.n	f7ae <_dtoa_r+0x57e>
    fc38:	4601      	mov	r1, r0
    fc3a:	4620      	mov	r0, r4
    fc3c:	930a      	str	r3, [sp, #40]	; 0x28
    fc3e:	f000 faf1 	bl	10224 <_Bfree>
    fc42:	2201      	movs	r2, #1
    fc44:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fc46:	e5de      	b.n	f806 <_dtoa_r+0x5d6>
    fc48:	9b24      	ldr	r3, [sp, #144]	; 0x90
    fc4a:	2b02      	cmp	r3, #2
    fc4c:	f77f ad95 	ble.w	f77a <_dtoa_r+0x54a>
    fc50:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fc52:	2b00      	cmp	r3, #0
    fc54:	d1c9      	bne.n	fbea <_dtoa_r+0x9ba>
    fc56:	9906      	ldr	r1, [sp, #24]
    fc58:	2205      	movs	r2, #5
    fc5a:	4620      	mov	r0, r4
    fc5c:	f000 faec 	bl	10238 <__multadd>
    fc60:	4601      	mov	r1, r0
    fc62:	9006      	str	r0, [sp, #24]
    fc64:	4648      	mov	r0, r9
    fc66:	f000 fcb5 	bl	105d4 <__mcmp>
    fc6a:	2800      	cmp	r0, #0
    fc6c:	ddbd      	ble.n	fbea <_dtoa_r+0x9ba>
    fc6e:	9a02      	ldr	r2, [sp, #8]
    fc70:	9904      	ldr	r1, [sp, #16]
    fc72:	2331      	movs	r3, #49	; 0x31
    fc74:	3201      	adds	r2, #1
    fc76:	9202      	str	r2, [sp, #8]
    fc78:	700b      	strb	r3, [r1, #0]
    fc7a:	1c4d      	adds	r5, r1, #1
    fc7c:	e7b9      	b.n	fbf2 <_dtoa_r+0x9c2>
    fc7e:	9a02      	ldr	r2, [sp, #8]
    fc80:	3201      	adds	r2, #1
    fc82:	9202      	str	r2, [sp, #8]
    fc84:	9a04      	ldr	r2, [sp, #16]
    fc86:	2331      	movs	r3, #49	; 0x31
    fc88:	7013      	strb	r3, [r2, #0]
    fc8a:	e652      	b.n	f932 <_dtoa_r+0x702>
    fc8c:	2301      	movs	r3, #1
    fc8e:	930c      	str	r3, [sp, #48]	; 0x30
    fc90:	e666      	b.n	f960 <_dtoa_r+0x730>
    fc92:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
    fc96:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    fc98:	e48e      	b.n	f5b8 <_dtoa_r+0x388>
    fc9a:	bf00      	nop
    fc9c:	00012c10 	.word	0x00012c10
    fca0:	00012be8 	.word	0x00012be8
    fca4:	3ff00000 	.word	0x3ff00000
    fca8:	401c0000 	.word	0x401c0000
    fcac:	3fe00000 	.word	0x3fe00000
    fcb0:	40240000 	.word	0x40240000
    fcb4:	40140000 	.word	0x40140000
    fcb8:	4650      	mov	r0, sl
    fcba:	f7f1 f8a1 	bl	e00 <__aeabi_i2d>
    fcbe:	463a      	mov	r2, r7
    fcc0:	4643      	mov	r3, r8
    fcc2:	f7f1 f903 	bl	ecc <__aeabi_dmul>
    fcc6:	2200      	movs	r2, #0
    fcc8:	4bc5      	ldr	r3, [pc, #788]	; (ffe0 <_dtoa_r+0xdb0>)
    fcca:	f7f0 ff4d 	bl	b68 <__adddf3>
    fcce:	4682      	mov	sl, r0
    fcd0:	f1a1 7b50 	sub.w	fp, r1, #54525952	; 0x3400000
    fcd4:	4638      	mov	r0, r7
    fcd6:	2200      	movs	r2, #0
    fcd8:	4bc2      	ldr	r3, [pc, #776]	; (ffe4 <_dtoa_r+0xdb4>)
    fcda:	4641      	mov	r1, r8
    fcdc:	f7f0 ff42 	bl	b64 <__aeabi_dsub>
    fce0:	4652      	mov	r2, sl
    fce2:	465b      	mov	r3, fp
    fce4:	4606      	mov	r6, r0
    fce6:	460f      	mov	r7, r1
    fce8:	f7f1 fb80 	bl	13ec <__aeabi_dcmpgt>
    fcec:	2800      	cmp	r0, #0
    fcee:	f040 80ad 	bne.w	fe4c <_dtoa_r+0xc1c>
    fcf2:	4652      	mov	r2, sl
    fcf4:	f10b 4300 	add.w	r3, fp, #2147483648	; 0x80000000
    fcf8:	4630      	mov	r0, r6
    fcfa:	4639      	mov	r1, r7
    fcfc:	f7f1 fb58 	bl	13b0 <__aeabi_dcmplt>
    fd00:	2800      	cmp	r0, #0
    fd02:	d04c      	beq.n	fd9e <_dtoa_r+0xb6e>
    fd04:	2300      	movs	r3, #0
    fd06:	9306      	str	r3, [sp, #24]
    fd08:	461e      	mov	r6, r3
    fd0a:	e76e      	b.n	fbea <_dtoa_r+0x9ba>
    fd0c:	9804      	ldr	r0, [sp, #16]
    fd0e:	f7ff babd 	b.w	f28c <_dtoa_r+0x5c>
    fd12:	9b06      	ldr	r3, [sp, #24]
    fd14:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    fd16:	9706      	str	r7, [sp, #24]
    fd18:	1afb      	subs	r3, r7, r3
    fd1a:	441a      	add	r2, r3
    fd1c:	920d      	str	r2, [sp, #52]	; 0x34
    fd1e:	2700      	movs	r7, #0
    fd20:	e46b      	b.n	f5fa <_dtoa_r+0x3ca>
    fd22:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
    fd26:	f04f 0a02 	mov.w	sl, #2
    fd2a:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
    fd2e:	e65a      	b.n	f9e6 <_dtoa_r+0x7b6>
    fd30:	2100      	movs	r1, #0
    fd32:	2301      	movs	r3, #1
    fd34:	6461      	str	r1, [r4, #68]	; 0x44
    fd36:	4620      	mov	r0, r4
    fd38:	9325      	str	r3, [sp, #148]	; 0x94
    fd3a:	f000 fa4d 	bl	101d8 <_Balloc>
    fd3e:	9b25      	ldr	r3, [sp, #148]	; 0x94
    fd40:	9004      	str	r0, [sp, #16]
    fd42:	6420      	str	r0, [r4, #64]	; 0x40
    fd44:	930a      	str	r3, [sp, #40]	; 0x28
    fd46:	930f      	str	r3, [sp, #60]	; 0x3c
    fd48:	e62c      	b.n	f9a4 <_dtoa_r+0x774>
    fd4a:	2a00      	cmp	r2, #0
    fd4c:	469a      	mov	sl, r3
    fd4e:	dd11      	ble.n	fd74 <_dtoa_r+0xb44>
    fd50:	4649      	mov	r1, r9
    fd52:	2201      	movs	r2, #1
    fd54:	4620      	mov	r0, r4
    fd56:	f000 fbeb 	bl	10530 <__lshift>
    fd5a:	9906      	ldr	r1, [sp, #24]
    fd5c:	4681      	mov	r9, r0
    fd5e:	f000 fc39 	bl	105d4 <__mcmp>
    fd62:	2800      	cmp	r0, #0
    fd64:	f340 8134 	ble.w	ffd0 <_dtoa_r+0xda0>
    fd68:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
    fd6c:	f000 8104 	beq.w	ff78 <_dtoa_r+0xd48>
    fd70:	f105 0a31 	add.w	sl, r5, #49	; 0x31
    fd74:	46b3      	mov	fp, r6
    fd76:	f887 a000 	strb.w	sl, [r7]
    fd7a:	1c7d      	adds	r5, r7, #1
    fd7c:	4646      	mov	r6, r8
    fd7e:	e5d8      	b.n	f932 <_dtoa_r+0x702>
    fd80:	d104      	bne.n	fd8c <_dtoa_r+0xb5c>
    fd82:	f01a 0f01 	tst.w	sl, #1
    fd86:	d001      	beq.n	fd8c <_dtoa_r+0xb5c>
    fd88:	e5c3      	b.n	f912 <_dtoa_r+0x6e2>
    fd8a:	4615      	mov	r5, r2
    fd8c:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    fd90:	2b30      	cmp	r3, #48	; 0x30
    fd92:	f105 32ff 	add.w	r2, r5, #4294967295	; 0xffffffff
    fd96:	d0f8      	beq.n	fd8a <_dtoa_r+0xb5a>
    fd98:	e5cb      	b.n	f932 <_dtoa_r+0x702>
    fd9a:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
    fd9e:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
    fda2:	f7ff bb3f 	b.w	f424 <_dtoa_r+0x1f4>
    fda6:	9904      	ldr	r1, [sp, #16]
    fda8:	2230      	movs	r2, #48	; 0x30
    fdaa:	700a      	strb	r2, [r1, #0]
    fdac:	9a02      	ldr	r2, [sp, #8]
    fdae:	f815 8c01 	ldrb.w	r8, [r5, #-1]
    fdb2:	3201      	adds	r2, #1
    fdb4:	9202      	str	r2, [sp, #8]
    fdb6:	f7ff bbfb 	b.w	f5b0 <_dtoa_r+0x380>
    fdba:	f000 80b4 	beq.w	ff26 <_dtoa_r+0xcf6>
    fdbe:	9b02      	ldr	r3, [sp, #8]
    fdc0:	425d      	negs	r5, r3
    fdc2:	4b89      	ldr	r3, [pc, #548]	; (ffe8 <_dtoa_r+0xdb8>)
    fdc4:	f005 020f 	and.w	r2, r5, #15
    fdc8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    fdcc:	e9d3 2300 	ldrd	r2, r3, [r3]
    fdd0:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
    fdd4:	f7f1 f87a 	bl	ecc <__aeabi_dmul>
    fdd8:	112d      	asrs	r5, r5, #4
    fdda:	4607      	mov	r7, r0
    fddc:	4688      	mov	r8, r1
    fdde:	f000 811d 	beq.w	1001c <_dtoa_r+0xdec>
    fde2:	4e82      	ldr	r6, [pc, #520]	; (ffec <_dtoa_r+0xdbc>)
    fde4:	f04f 0a02 	mov.w	sl, #2
    fde8:	07eb      	lsls	r3, r5, #31
    fdea:	d509      	bpl.n	fe00 <_dtoa_r+0xbd0>
    fdec:	4638      	mov	r0, r7
    fdee:	4641      	mov	r1, r8
    fdf0:	e9d6 2300 	ldrd	r2, r3, [r6]
    fdf4:	f7f1 f86a 	bl	ecc <__aeabi_dmul>
    fdf8:	f10a 0a01 	add.w	sl, sl, #1
    fdfc:	4607      	mov	r7, r0
    fdfe:	4688      	mov	r8, r1
    fe00:	106d      	asrs	r5, r5, #1
    fe02:	f106 0608 	add.w	r6, r6, #8
    fe06:	d1ef      	bne.n	fde8 <_dtoa_r+0xbb8>
    fe08:	e608      	b.n	fa1c <_dtoa_r+0x7ec>
    fe0a:	6871      	ldr	r1, [r6, #4]
    fe0c:	4620      	mov	r0, r4
    fe0e:	f000 f9e3 	bl	101d8 <_Balloc>
    fe12:	6933      	ldr	r3, [r6, #16]
    fe14:	3302      	adds	r3, #2
    fe16:	009a      	lsls	r2, r3, #2
    fe18:	4605      	mov	r5, r0
    fe1a:	f106 010c 	add.w	r1, r6, #12
    fe1e:	300c      	adds	r0, #12
    fe20:	f7f0 fd7e 	bl	920 <memcpy>
    fe24:	4629      	mov	r1, r5
    fe26:	2201      	movs	r2, #1
    fe28:	4620      	mov	r0, r4
    fe2a:	f000 fb81 	bl	10530 <__lshift>
    fe2e:	4680      	mov	r8, r0
    fe30:	e4b4      	b.n	f79c <_dtoa_r+0x56c>
    fe32:	2b39      	cmp	r3, #57	; 0x39
    fe34:	f000 80a0 	beq.w	ff78 <_dtoa_r+0xd48>
    fe38:	3301      	adds	r3, #1
    fe3a:	46b3      	mov	fp, r6
    fe3c:	703b      	strb	r3, [r7, #0]
    fe3e:	1c7d      	adds	r5, r7, #1
    fe40:	4646      	mov	r6, r8
    fe42:	e576      	b.n	f932 <_dtoa_r+0x702>
    fe44:	46b3      	mov	fp, r6
    fe46:	469a      	mov	sl, r3
    fe48:	4646      	mov	r6, r8
    fe4a:	e556      	b.n	f8fa <_dtoa_r+0x6ca>
    fe4c:	2300      	movs	r3, #0
    fe4e:	9306      	str	r3, [sp, #24]
    fe50:	461e      	mov	r6, r3
    fe52:	e70c      	b.n	fc6e <_dtoa_r+0xa3e>
    fe54:	9b12      	ldr	r3, [sp, #72]	; 0x48
    fe56:	4964      	ldr	r1, [pc, #400]	; (ffe8 <_dtoa_r+0xdb8>)
    fe58:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
    fe5c:	4652      	mov	r2, sl
    fe5e:	465b      	mov	r3, fp
    fe60:	e951 0102 	ldrd	r0, r1, [r1, #-8]
    fe64:	f7f1 f832 	bl	ecc <__aeabi_dmul>
    fe68:	e9cd 0116 	strd	r0, r1, [sp, #88]	; 0x58
    fe6c:	4638      	mov	r0, r7
    fe6e:	4641      	mov	r1, r8
    fe70:	f7f1 fadc 	bl	142c <__aeabi_d2iz>
    fe74:	4605      	mov	r5, r0
    fe76:	f7f0 ffc3 	bl	e00 <__aeabi_i2d>
    fe7a:	460b      	mov	r3, r1
    fe7c:	4602      	mov	r2, r0
    fe7e:	4641      	mov	r1, r8
    fe80:	4638      	mov	r0, r7
    fe82:	f7f0 fe6f 	bl	b64 <__aeabi_dsub>
    fe86:	9b12      	ldr	r3, [sp, #72]	; 0x48
    fe88:	460f      	mov	r7, r1
    fe8a:	9904      	ldr	r1, [sp, #16]
    fe8c:	3530      	adds	r5, #48	; 0x30
    fe8e:	2b01      	cmp	r3, #1
    fe90:	700d      	strb	r5, [r1, #0]
    fe92:	4606      	mov	r6, r0
    fe94:	f101 0501 	add.w	r5, r1, #1
    fe98:	d026      	beq.n	fee8 <_dtoa_r+0xcb8>
    fe9a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    fe9c:	9a04      	ldr	r2, [sp, #16]
    fe9e:	f8df b154 	ldr.w	fp, [pc, #340]	; fff4 <_dtoa_r+0xdc4>
    fea2:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
    fea6:	4413      	add	r3, r2
    fea8:	f04f 0a00 	mov.w	sl, #0
    feac:	4699      	mov	r9, r3
    feae:	4652      	mov	r2, sl
    feb0:	465b      	mov	r3, fp
    feb2:	4630      	mov	r0, r6
    feb4:	4639      	mov	r1, r7
    feb6:	f7f1 f809 	bl	ecc <__aeabi_dmul>
    feba:	460f      	mov	r7, r1
    febc:	4606      	mov	r6, r0
    febe:	f7f1 fab5 	bl	142c <__aeabi_d2iz>
    fec2:	4680      	mov	r8, r0
    fec4:	f7f0 ff9c 	bl	e00 <__aeabi_i2d>
    fec8:	f108 0830 	add.w	r8, r8, #48	; 0x30
    fecc:	4602      	mov	r2, r0
    fece:	460b      	mov	r3, r1
    fed0:	4630      	mov	r0, r6
    fed2:	4639      	mov	r1, r7
    fed4:	f7f0 fe46 	bl	b64 <__aeabi_dsub>
    fed8:	f805 8b01 	strb.w	r8, [r5], #1
    fedc:	454d      	cmp	r5, r9
    fede:	4606      	mov	r6, r0
    fee0:	460f      	mov	r7, r1
    fee2:	d1e4      	bne.n	feae <_dtoa_r+0xc7e>
    fee4:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
    fee8:	4b41      	ldr	r3, [pc, #260]	; (fff0 <_dtoa_r+0xdc0>)
    feea:	2200      	movs	r2, #0
    feec:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
    fef0:	f7f0 fe3a 	bl	b68 <__adddf3>
    fef4:	4632      	mov	r2, r6
    fef6:	463b      	mov	r3, r7
    fef8:	f7f1 fa5a 	bl	13b0 <__aeabi_dcmplt>
    fefc:	2800      	cmp	r0, #0
    fefe:	d041      	beq.n	ff84 <_dtoa_r+0xd54>
    ff00:	9b15      	ldr	r3, [sp, #84]	; 0x54
    ff02:	9302      	str	r3, [sp, #8]
    ff04:	f815 8c01 	ldrb.w	r8, [r5, #-1]
    ff08:	f7ff bb45 	b.w	f596 <_dtoa_r+0x366>
    ff0c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ff0e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    ff10:	1a9d      	subs	r5, r3, r2
    ff12:	2300      	movs	r3, #0
    ff14:	f7ff bb77 	b.w	f606 <_dtoa_r+0x3d6>
    ff18:	9b18      	ldr	r3, [sp, #96]	; 0x60
    ff1a:	9f06      	ldr	r7, [sp, #24]
    ff1c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    ff1e:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
    ff22:	f7ff bb70 	b.w	f606 <_dtoa_r+0x3d6>
    ff26:	e9dd 7810 	ldrd	r7, r8, [sp, #64]	; 0x40
    ff2a:	f04f 0a02 	mov.w	sl, #2
    ff2e:	e575      	b.n	fa1c <_dtoa_r+0x7ec>
    ff30:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ff32:	2b00      	cmp	r3, #0
    ff34:	f43f aec0 	beq.w	fcb8 <_dtoa_r+0xa88>
    ff38:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    ff3a:	2d00      	cmp	r5, #0
    ff3c:	f77f af2f 	ble.w	fd9e <_dtoa_r+0xb6e>
    ff40:	2200      	movs	r2, #0
    ff42:	4b2c      	ldr	r3, [pc, #176]	; (fff4 <_dtoa_r+0xdc4>)
    ff44:	4638      	mov	r0, r7
    ff46:	4641      	mov	r1, r8
    ff48:	f7f0 ffc0 	bl	ecc <__aeabi_dmul>
    ff4c:	4607      	mov	r7, r0
    ff4e:	4688      	mov	r8, r1
    ff50:	f10a 0001 	add.w	r0, sl, #1
    ff54:	f7f0 ff54 	bl	e00 <__aeabi_i2d>
    ff58:	463a      	mov	r2, r7
    ff5a:	4643      	mov	r3, r8
    ff5c:	f7f0 ffb6 	bl	ecc <__aeabi_dmul>
    ff60:	4b1f      	ldr	r3, [pc, #124]	; (ffe0 <_dtoa_r+0xdb0>)
    ff62:	2200      	movs	r2, #0
    ff64:	f7f0 fe00 	bl	b68 <__adddf3>
    ff68:	9b02      	ldr	r3, [sp, #8]
    ff6a:	9512      	str	r5, [sp, #72]	; 0x48
    ff6c:	3b01      	subs	r3, #1
    ff6e:	4682      	mov	sl, r0
    ff70:	f1a1 7b50 	sub.w	fp, r1, #54525952	; 0x3400000
    ff74:	9315      	str	r3, [sp, #84]	; 0x54
    ff76:	e572      	b.n	fa5e <_dtoa_r+0x82e>
    ff78:	2239      	movs	r2, #57	; 0x39
    ff7a:	46b3      	mov	fp, r6
    ff7c:	703a      	strb	r2, [r7, #0]
    ff7e:	4646      	mov	r6, r8
    ff80:	1c7d      	adds	r5, r7, #1
    ff82:	e4c8      	b.n	f916 <_dtoa_r+0x6e6>
    ff84:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
    ff88:	2000      	movs	r0, #0
    ff8a:	4919      	ldr	r1, [pc, #100]	; (fff0 <_dtoa_r+0xdc0>)
    ff8c:	f7f0 fdea 	bl	b64 <__aeabi_dsub>
    ff90:	4632      	mov	r2, r6
    ff92:	463b      	mov	r3, r7
    ff94:	f7f1 fa2a 	bl	13ec <__aeabi_dcmpgt>
    ff98:	b908      	cbnz	r0, ff9e <_dtoa_r+0xd6e>
    ff9a:	e700      	b.n	fd9e <_dtoa_r+0xb6e>
    ff9c:	4615      	mov	r5, r2
    ff9e:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    ffa2:	2b30      	cmp	r3, #48	; 0x30
    ffa4:	f105 32ff 	add.w	r2, r5, #4294967295	; 0xffffffff
    ffa8:	d0f8      	beq.n	ff9c <_dtoa_r+0xd6c>
    ffaa:	e5df      	b.n	fb6c <_dtoa_r+0x93c>
    ffac:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
    ffb0:	9b15      	ldr	r3, [sp, #84]	; 0x54
    ffb2:	9302      	str	r3, [sp, #8]
    ffb4:	f7ff baef 	b.w	f596 <_dtoa_r+0x366>
    ffb8:	46b8      	mov	r8, r7
    ffba:	f7ff bbac 	b.w	f716 <_dtoa_r+0x4e6>
    ffbe:	2b39      	cmp	r3, #57	; 0x39
    ffc0:	46d3      	mov	fp, sl
    ffc2:	469a      	mov	sl, r3
    ffc4:	d0d8      	beq.n	ff78 <_dtoa_r+0xd48>
    ffc6:	f1bb 0f00 	cmp.w	fp, #0
    ffca:	f73f aed1 	bgt.w	fd70 <_dtoa_r+0xb40>
    ffce:	e6d1      	b.n	fd74 <_dtoa_r+0xb44>
    ffd0:	f47f aed0 	bne.w	fd74 <_dtoa_r+0xb44>
    ffd4:	f01a 0f01 	tst.w	sl, #1
    ffd8:	f43f aecc 	beq.w	fd74 <_dtoa_r+0xb44>
    ffdc:	e6c4      	b.n	fd68 <_dtoa_r+0xb38>
    ffde:	bf00      	nop
    ffe0:	401c0000 	.word	0x401c0000
    ffe4:	40140000 	.word	0x40140000
    ffe8:	00012c10 	.word	0x00012c10
    ffec:	00012be8 	.word	0x00012be8
    fff0:	3fe00000 	.word	0x3fe00000
    fff4:	40240000 	.word	0x40240000
    fff8:	4631      	mov	r1, r6
    fffa:	2300      	movs	r3, #0
    fffc:	220a      	movs	r2, #10
    fffe:	4620      	mov	r0, r4
   10000:	f000 f91a 	bl	10238 <__multadd>
   10004:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   10006:	2b00      	cmp	r3, #0
   10008:	4606      	mov	r6, r0
   1000a:	dd0a      	ble.n	10022 <_dtoa_r+0xdf2>
   1000c:	930a      	str	r3, [sp, #40]	; 0x28
   1000e:	f7ff bbb8 	b.w	f782 <_dtoa_r+0x552>
   10012:	9b24      	ldr	r3, [sp, #144]	; 0x90
   10014:	2b02      	cmp	r3, #2
   10016:	dc22      	bgt.n	1005e <_dtoa_r+0xe2e>
   10018:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1001a:	e448      	b.n	f8ae <_dtoa_r+0x67e>
   1001c:	f04f 0a02 	mov.w	sl, #2
   10020:	e4fc      	b.n	fa1c <_dtoa_r+0x7ec>
   10022:	9b24      	ldr	r3, [sp, #144]	; 0x90
   10024:	2b02      	cmp	r3, #2
   10026:	dc1a      	bgt.n	1005e <_dtoa_r+0xe2e>
   10028:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1002a:	e7ef      	b.n	1000c <_dtoa_r+0xddc>
   1002c:	2501      	movs	r5, #1
   1002e:	f7ff b9c4 	b.w	f3ba <_dtoa_r+0x18a>
   10032:	f43f ab88 	beq.w	f746 <_dtoa_r+0x516>
   10036:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
   1003a:	e417      	b.n	f86c <_dtoa_r+0x63c>
   1003c:	2500      	movs	r5, #0
   1003e:	6465      	str	r5, [r4, #68]	; 0x44
   10040:	4629      	mov	r1, r5
   10042:	4620      	mov	r0, r4
   10044:	f000 f8c8 	bl	101d8 <_Balloc>
   10048:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1004c:	930a      	str	r3, [sp, #40]	; 0x28
   1004e:	930f      	str	r3, [sp, #60]	; 0x3c
   10050:	2301      	movs	r3, #1
   10052:	9004      	str	r0, [sp, #16]
   10054:	9525      	str	r5, [sp, #148]	; 0x94
   10056:	6420      	str	r0, [r4, #64]	; 0x40
   10058:	930c      	str	r3, [sp, #48]	; 0x30
   1005a:	f7ff b9e3 	b.w	f424 <_dtoa_r+0x1f4>
   1005e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   10060:	930a      	str	r3, [sp, #40]	; 0x28
   10062:	e5f5      	b.n	fc50 <_dtoa_r+0xa20>

00010064 <__fputwc>:
   10064:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   10068:	b082      	sub	sp, #8
   1006a:	4680      	mov	r8, r0
   1006c:	4689      	mov	r9, r1
   1006e:	4614      	mov	r4, r2
   10070:	f7fa fe50 	bl	ad14 <__locale_mb_cur_max>
   10074:	2801      	cmp	r0, #1
   10076:	d036      	beq.n	100e6 <__fputwc+0x82>
   10078:	464a      	mov	r2, r9
   1007a:	f104 035c 	add.w	r3, r4, #92	; 0x5c
   1007e:	a901      	add	r1, sp, #4
   10080:	4640      	mov	r0, r8
   10082:	f000 fc85 	bl	10990 <_wcrtomb_r>
   10086:	1c42      	adds	r2, r0, #1
   10088:	4606      	mov	r6, r0
   1008a:	d025      	beq.n	100d8 <__fputwc+0x74>
   1008c:	b3a8      	cbz	r0, 100fa <__fputwc+0x96>
   1008e:	f89d e004 	ldrb.w	lr, [sp, #4]
   10092:	2500      	movs	r5, #0
   10094:	f10d 0a04 	add.w	sl, sp, #4
   10098:	e009      	b.n	100ae <__fputwc+0x4a>
   1009a:	6823      	ldr	r3, [r4, #0]
   1009c:	1c5a      	adds	r2, r3, #1
   1009e:	6022      	str	r2, [r4, #0]
   100a0:	f883 e000 	strb.w	lr, [r3]
   100a4:	3501      	adds	r5, #1
   100a6:	42b5      	cmp	r5, r6
   100a8:	d227      	bcs.n	100fa <__fputwc+0x96>
   100aa:	f815 e00a 	ldrb.w	lr, [r5, sl]
   100ae:	68a3      	ldr	r3, [r4, #8]
   100b0:	3b01      	subs	r3, #1
   100b2:	2b00      	cmp	r3, #0
   100b4:	60a3      	str	r3, [r4, #8]
   100b6:	daf0      	bge.n	1009a <__fputwc+0x36>
   100b8:	69a7      	ldr	r7, [r4, #24]
   100ba:	42bb      	cmp	r3, r7
   100bc:	4671      	mov	r1, lr
   100be:	4622      	mov	r2, r4
   100c0:	4640      	mov	r0, r8
   100c2:	db02      	blt.n	100ca <__fputwc+0x66>
   100c4:	f1be 0f0a 	cmp.w	lr, #10
   100c8:	d1e7      	bne.n	1009a <__fputwc+0x36>
   100ca:	f7fe ff23 	bl	ef14 <__swbuf_r>
   100ce:	1c43      	adds	r3, r0, #1
   100d0:	d1e8      	bne.n	100a4 <__fputwc+0x40>
   100d2:	b002      	add	sp, #8
   100d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   100d8:	89a3      	ldrh	r3, [r4, #12]
   100da:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   100de:	81a3      	strh	r3, [r4, #12]
   100e0:	b002      	add	sp, #8
   100e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   100e6:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
   100ea:	2bfe      	cmp	r3, #254	; 0xfe
   100ec:	d8c4      	bhi.n	10078 <__fputwc+0x14>
   100ee:	fa5f fe89 	uxtb.w	lr, r9
   100f2:	4606      	mov	r6, r0
   100f4:	f88d e004 	strb.w	lr, [sp, #4]
   100f8:	e7cb      	b.n	10092 <__fputwc+0x2e>
   100fa:	4648      	mov	r0, r9
   100fc:	b002      	add	sp, #8
   100fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   10102:	bf00      	nop

00010104 <_fputwc_r>:
   10104:	b530      	push	{r4, r5, lr}
   10106:	6e53      	ldr	r3, [r2, #100]	; 0x64
   10108:	f013 0f01 	tst.w	r3, #1
   1010c:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
   10110:	4614      	mov	r4, r2
   10112:	b083      	sub	sp, #12
   10114:	4605      	mov	r5, r0
   10116:	b29a      	uxth	r2, r3
   10118:	d101      	bne.n	1011e <_fputwc_r+0x1a>
   1011a:	0590      	lsls	r0, r2, #22
   1011c:	d51c      	bpl.n	10158 <_fputwc_r+0x54>
   1011e:	0490      	lsls	r0, r2, #18
   10120:	d406      	bmi.n	10130 <_fputwc_r+0x2c>
   10122:	6e62      	ldr	r2, [r4, #100]	; 0x64
   10124:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   10128:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
   1012c:	81a3      	strh	r3, [r4, #12]
   1012e:	6662      	str	r2, [r4, #100]	; 0x64
   10130:	4628      	mov	r0, r5
   10132:	4622      	mov	r2, r4
   10134:	f7ff ff96 	bl	10064 <__fputwc>
   10138:	6e63      	ldr	r3, [r4, #100]	; 0x64
   1013a:	07da      	lsls	r2, r3, #31
   1013c:	4605      	mov	r5, r0
   1013e:	d402      	bmi.n	10146 <_fputwc_r+0x42>
   10140:	89a3      	ldrh	r3, [r4, #12]
   10142:	059b      	lsls	r3, r3, #22
   10144:	d502      	bpl.n	1014c <_fputwc_r+0x48>
   10146:	4628      	mov	r0, r5
   10148:	b003      	add	sp, #12
   1014a:	bd30      	pop	{r4, r5, pc}
   1014c:	6da0      	ldr	r0, [r4, #88]	; 0x58
   1014e:	f7fa fdf5 	bl	ad3c <__retarget_lock_release_recursive>
   10152:	4628      	mov	r0, r5
   10154:	b003      	add	sp, #12
   10156:	bd30      	pop	{r4, r5, pc}
   10158:	6da0      	ldr	r0, [r4, #88]	; 0x58
   1015a:	9101      	str	r1, [sp, #4]
   1015c:	f7fa fdec 	bl	ad38 <__retarget_lock_acquire_recursive>
   10160:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   10164:	9901      	ldr	r1, [sp, #4]
   10166:	b29a      	uxth	r2, r3
   10168:	e7d9      	b.n	1011e <_fputwc_r+0x1a>
   1016a:	bf00      	nop

0001016c <_isatty_r>:
   1016c:	b538      	push	{r3, r4, r5, lr}
   1016e:	4c07      	ldr	r4, [pc, #28]	; (1018c <_isatty_r+0x20>)
   10170:	2300      	movs	r3, #0
   10172:	4605      	mov	r5, r0
   10174:	4608      	mov	r0, r1
   10176:	6023      	str	r3, [r4, #0]
   10178:	f7f3 fb7e 	bl	3878 <_isatty>
   1017c:	1c43      	adds	r3, r0, #1
   1017e:	d000      	beq.n	10182 <_isatty_r+0x16>
   10180:	bd38      	pop	{r3, r4, r5, pc}
   10182:	6823      	ldr	r3, [r4, #0]
   10184:	2b00      	cmp	r3, #0
   10186:	d0fb      	beq.n	10180 <_isatty_r+0x14>
   10188:	602b      	str	r3, [r5, #0]
   1018a:	bd38      	pop	{r3, r4, r5, pc}
   1018c:	2000304c 	.word	0x2000304c

00010190 <_localeconv_r>:
   10190:	4a04      	ldr	r2, [pc, #16]	; (101a4 <_localeconv_r+0x14>)
   10192:	4b05      	ldr	r3, [pc, #20]	; (101a8 <_localeconv_r+0x18>)
   10194:	6812      	ldr	r2, [r2, #0]
   10196:	6b50      	ldr	r0, [r2, #52]	; 0x34
   10198:	2800      	cmp	r0, #0
   1019a:	bf08      	it	eq
   1019c:	4618      	moveq	r0, r3
   1019e:	30f0      	adds	r0, #240	; 0xf0
   101a0:	4770      	bx	lr
   101a2:	bf00      	nop
   101a4:	200001c0 	.word	0x200001c0
   101a8:	200005f0 	.word	0x200005f0

000101ac <_lseek_r>:
   101ac:	b570      	push	{r4, r5, r6, lr}
   101ae:	460d      	mov	r5, r1
   101b0:	4c08      	ldr	r4, [pc, #32]	; (101d4 <_lseek_r+0x28>)
   101b2:	4611      	mov	r1, r2
   101b4:	4606      	mov	r6, r0
   101b6:	461a      	mov	r2, r3
   101b8:	4628      	mov	r0, r5
   101ba:	2300      	movs	r3, #0
   101bc:	6023      	str	r3, [r4, #0]
   101be:	f7f3 fb8e 	bl	38de <_lseek>
   101c2:	1c43      	adds	r3, r0, #1
   101c4:	d000      	beq.n	101c8 <_lseek_r+0x1c>
   101c6:	bd70      	pop	{r4, r5, r6, pc}
   101c8:	6823      	ldr	r3, [r4, #0]
   101ca:	2b00      	cmp	r3, #0
   101cc:	d0fb      	beq.n	101c6 <_lseek_r+0x1a>
   101ce:	6033      	str	r3, [r6, #0]
   101d0:	bd70      	pop	{r4, r5, r6, pc}
   101d2:	bf00      	nop
   101d4:	2000304c 	.word	0x2000304c

000101d8 <_Balloc>:
   101d8:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   101da:	b570      	push	{r4, r5, r6, lr}
   101dc:	4605      	mov	r5, r0
   101de:	460c      	mov	r4, r1
   101e0:	b14b      	cbz	r3, 101f6 <_Balloc+0x1e>
   101e2:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
   101e6:	b180      	cbz	r0, 1020a <_Balloc+0x32>
   101e8:	6802      	ldr	r2, [r0, #0]
   101ea:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
   101ee:	2300      	movs	r3, #0
   101f0:	6103      	str	r3, [r0, #16]
   101f2:	60c3      	str	r3, [r0, #12]
   101f4:	bd70      	pop	{r4, r5, r6, pc}
   101f6:	2221      	movs	r2, #33	; 0x21
   101f8:	2104      	movs	r1, #4
   101fa:	f7f2 fbe1 	bl	29c0 <__wrap__calloc_r>
   101fe:	64e8      	str	r0, [r5, #76]	; 0x4c
   10200:	4603      	mov	r3, r0
   10202:	2800      	cmp	r0, #0
   10204:	d1ed      	bne.n	101e2 <_Balloc+0xa>
   10206:	2000      	movs	r0, #0
   10208:	bd70      	pop	{r4, r5, r6, pc}
   1020a:	2101      	movs	r1, #1
   1020c:	fa01 f604 	lsl.w	r6, r1, r4
   10210:	1d72      	adds	r2, r6, #5
   10212:	4628      	mov	r0, r5
   10214:	0092      	lsls	r2, r2, #2
   10216:	f7f2 fbd3 	bl	29c0 <__wrap__calloc_r>
   1021a:	2800      	cmp	r0, #0
   1021c:	d0f3      	beq.n	10206 <_Balloc+0x2e>
   1021e:	6044      	str	r4, [r0, #4]
   10220:	6086      	str	r6, [r0, #8]
   10222:	e7e4      	b.n	101ee <_Balloc+0x16>

00010224 <_Bfree>:
   10224:	b131      	cbz	r1, 10234 <_Bfree+0x10>
   10226:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   10228:	684a      	ldr	r2, [r1, #4]
   1022a:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
   1022e:	6008      	str	r0, [r1, #0]
   10230:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   10234:	4770      	bx	lr
   10236:	bf00      	nop

00010238 <__multadd>:
   10238:	b5f0      	push	{r4, r5, r6, r7, lr}
   1023a:	690c      	ldr	r4, [r1, #16]
   1023c:	b083      	sub	sp, #12
   1023e:	460d      	mov	r5, r1
   10240:	4606      	mov	r6, r0
   10242:	f101 0e14 	add.w	lr, r1, #20
   10246:	2700      	movs	r7, #0
   10248:	f8de 0000 	ldr.w	r0, [lr]
   1024c:	b281      	uxth	r1, r0
   1024e:	fb02 3301 	mla	r3, r2, r1, r3
   10252:	0c01      	lsrs	r1, r0, #16
   10254:	0c18      	lsrs	r0, r3, #16
   10256:	fb02 0101 	mla	r1, r2, r1, r0
   1025a:	b29b      	uxth	r3, r3
   1025c:	3701      	adds	r7, #1
   1025e:	eb03 4301 	add.w	r3, r3, r1, lsl #16
   10262:	42bc      	cmp	r4, r7
   10264:	f84e 3b04 	str.w	r3, [lr], #4
   10268:	ea4f 4311 	mov.w	r3, r1, lsr #16
   1026c:	dcec      	bgt.n	10248 <__multadd+0x10>
   1026e:	b13b      	cbz	r3, 10280 <__multadd+0x48>
   10270:	68aa      	ldr	r2, [r5, #8]
   10272:	4294      	cmp	r4, r2
   10274:	da07      	bge.n	10286 <__multadd+0x4e>
   10276:	eb05 0284 	add.w	r2, r5, r4, lsl #2
   1027a:	3401      	adds	r4, #1
   1027c:	6153      	str	r3, [r2, #20]
   1027e:	612c      	str	r4, [r5, #16]
   10280:	4628      	mov	r0, r5
   10282:	b003      	add	sp, #12
   10284:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10286:	6869      	ldr	r1, [r5, #4]
   10288:	9301      	str	r3, [sp, #4]
   1028a:	3101      	adds	r1, #1
   1028c:	4630      	mov	r0, r6
   1028e:	f7ff ffa3 	bl	101d8 <_Balloc>
   10292:	692a      	ldr	r2, [r5, #16]
   10294:	3202      	adds	r2, #2
   10296:	f105 010c 	add.w	r1, r5, #12
   1029a:	4607      	mov	r7, r0
   1029c:	0092      	lsls	r2, r2, #2
   1029e:	300c      	adds	r0, #12
   102a0:	f7f0 fb3e 	bl	920 <memcpy>
   102a4:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
   102a6:	6869      	ldr	r1, [r5, #4]
   102a8:	9b01      	ldr	r3, [sp, #4]
   102aa:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
   102ae:	6028      	str	r0, [r5, #0]
   102b0:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
   102b4:	463d      	mov	r5, r7
   102b6:	e7de      	b.n	10276 <__multadd+0x3e>

000102b8 <__hi0bits>:
   102b8:	0c02      	lsrs	r2, r0, #16
   102ba:	0412      	lsls	r2, r2, #16
   102bc:	4603      	mov	r3, r0
   102be:	b9b2      	cbnz	r2, 102ee <__hi0bits+0x36>
   102c0:	0403      	lsls	r3, r0, #16
   102c2:	2010      	movs	r0, #16
   102c4:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
   102c8:	bf04      	itt	eq
   102ca:	021b      	lsleq	r3, r3, #8
   102cc:	3008      	addeq	r0, #8
   102ce:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
   102d2:	bf04      	itt	eq
   102d4:	011b      	lsleq	r3, r3, #4
   102d6:	3004      	addeq	r0, #4
   102d8:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
   102dc:	bf04      	itt	eq
   102de:	009b      	lsleq	r3, r3, #2
   102e0:	3002      	addeq	r0, #2
   102e2:	2b00      	cmp	r3, #0
   102e4:	db02      	blt.n	102ec <__hi0bits+0x34>
   102e6:	005b      	lsls	r3, r3, #1
   102e8:	d403      	bmi.n	102f2 <__hi0bits+0x3a>
   102ea:	2020      	movs	r0, #32
   102ec:	4770      	bx	lr
   102ee:	2000      	movs	r0, #0
   102f0:	e7e8      	b.n	102c4 <__hi0bits+0xc>
   102f2:	3001      	adds	r0, #1
   102f4:	4770      	bx	lr
   102f6:	bf00      	nop

000102f8 <__lo0bits>:
   102f8:	6803      	ldr	r3, [r0, #0]
   102fa:	f013 0207 	ands.w	r2, r3, #7
   102fe:	4601      	mov	r1, r0
   10300:	d007      	beq.n	10312 <__lo0bits+0x1a>
   10302:	07da      	lsls	r2, r3, #31
   10304:	d421      	bmi.n	1034a <__lo0bits+0x52>
   10306:	0798      	lsls	r0, r3, #30
   10308:	d421      	bmi.n	1034e <__lo0bits+0x56>
   1030a:	089b      	lsrs	r3, r3, #2
   1030c:	600b      	str	r3, [r1, #0]
   1030e:	2002      	movs	r0, #2
   10310:	4770      	bx	lr
   10312:	b298      	uxth	r0, r3
   10314:	b198      	cbz	r0, 1033e <__lo0bits+0x46>
   10316:	4610      	mov	r0, r2
   10318:	f013 0fff 	tst.w	r3, #255	; 0xff
   1031c:	bf04      	itt	eq
   1031e:	0a1b      	lsreq	r3, r3, #8
   10320:	3008      	addeq	r0, #8
   10322:	071a      	lsls	r2, r3, #28
   10324:	bf04      	itt	eq
   10326:	091b      	lsreq	r3, r3, #4
   10328:	3004      	addeq	r0, #4
   1032a:	079a      	lsls	r2, r3, #30
   1032c:	bf04      	itt	eq
   1032e:	089b      	lsreq	r3, r3, #2
   10330:	3002      	addeq	r0, #2
   10332:	07da      	lsls	r2, r3, #31
   10334:	d407      	bmi.n	10346 <__lo0bits+0x4e>
   10336:	085b      	lsrs	r3, r3, #1
   10338:	d104      	bne.n	10344 <__lo0bits+0x4c>
   1033a:	2020      	movs	r0, #32
   1033c:	4770      	bx	lr
   1033e:	0c1b      	lsrs	r3, r3, #16
   10340:	2010      	movs	r0, #16
   10342:	e7e9      	b.n	10318 <__lo0bits+0x20>
   10344:	3001      	adds	r0, #1
   10346:	600b      	str	r3, [r1, #0]
   10348:	4770      	bx	lr
   1034a:	2000      	movs	r0, #0
   1034c:	4770      	bx	lr
   1034e:	085b      	lsrs	r3, r3, #1
   10350:	600b      	str	r3, [r1, #0]
   10352:	2001      	movs	r0, #1
   10354:	4770      	bx	lr
   10356:	bf00      	nop

00010358 <__i2b>:
   10358:	b510      	push	{r4, lr}
   1035a:	460c      	mov	r4, r1
   1035c:	2101      	movs	r1, #1
   1035e:	f7ff ff3b 	bl	101d8 <_Balloc>
   10362:	2201      	movs	r2, #1
   10364:	6144      	str	r4, [r0, #20]
   10366:	6102      	str	r2, [r0, #16]
   10368:	bd10      	pop	{r4, pc}
   1036a:	bf00      	nop

0001036c <__multiply>:
   1036c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10370:	690c      	ldr	r4, [r1, #16]
   10372:	6915      	ldr	r5, [r2, #16]
   10374:	42ac      	cmp	r4, r5
   10376:	b083      	sub	sp, #12
   10378:	468b      	mov	fp, r1
   1037a:	4616      	mov	r6, r2
   1037c:	da04      	bge.n	10388 <__multiply+0x1c>
   1037e:	4622      	mov	r2, r4
   10380:	46b3      	mov	fp, r6
   10382:	462c      	mov	r4, r5
   10384:	460e      	mov	r6, r1
   10386:	4615      	mov	r5, r2
   10388:	f8db 3008 	ldr.w	r3, [fp, #8]
   1038c:	f8db 1004 	ldr.w	r1, [fp, #4]
   10390:	eb04 0805 	add.w	r8, r4, r5
   10394:	4598      	cmp	r8, r3
   10396:	bfc8      	it	gt
   10398:	3101      	addgt	r1, #1
   1039a:	f7ff ff1d 	bl	101d8 <_Balloc>
   1039e:	f100 0914 	add.w	r9, r0, #20
   103a2:	eb09 0a88 	add.w	sl, r9, r8, lsl #2
   103a6:	45d1      	cmp	r9, sl
   103a8:	9000      	str	r0, [sp, #0]
   103aa:	d205      	bcs.n	103b8 <__multiply+0x4c>
   103ac:	464b      	mov	r3, r9
   103ae:	2100      	movs	r1, #0
   103b0:	f843 1b04 	str.w	r1, [r3], #4
   103b4:	459a      	cmp	sl, r3
   103b6:	d8fb      	bhi.n	103b0 <__multiply+0x44>
   103b8:	f106 0c14 	add.w	ip, r6, #20
   103bc:	eb0c 0385 	add.w	r3, ip, r5, lsl #2
   103c0:	f10b 0b14 	add.w	fp, fp, #20
   103c4:	459c      	cmp	ip, r3
   103c6:	eb0b 0e84 	add.w	lr, fp, r4, lsl #2
   103ca:	d24c      	bcs.n	10466 <__multiply+0xfa>
   103cc:	f8cd a004 	str.w	sl, [sp, #4]
   103d0:	469a      	mov	sl, r3
   103d2:	f8dc 5000 	ldr.w	r5, [ip]
   103d6:	b2af      	uxth	r7, r5
   103d8:	b1ef      	cbz	r7, 10416 <__multiply+0xaa>
   103da:	2100      	movs	r1, #0
   103dc:	464d      	mov	r5, r9
   103de:	465e      	mov	r6, fp
   103e0:	460c      	mov	r4, r1
   103e2:	f856 2b04 	ldr.w	r2, [r6], #4
   103e6:	6828      	ldr	r0, [r5, #0]
   103e8:	b293      	uxth	r3, r2
   103ea:	b281      	uxth	r1, r0
   103ec:	fb07 1303 	mla	r3, r7, r3, r1
   103f0:	0c12      	lsrs	r2, r2, #16
   103f2:	0c01      	lsrs	r1, r0, #16
   103f4:	4423      	add	r3, r4
   103f6:	fb07 1102 	mla	r1, r7, r2, r1
   103fa:	eb01 4113 	add.w	r1, r1, r3, lsr #16
   103fe:	b29b      	uxth	r3, r3
   10400:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   10404:	45b6      	cmp	lr, r6
   10406:	f845 3b04 	str.w	r3, [r5], #4
   1040a:	ea4f 4411 	mov.w	r4, r1, lsr #16
   1040e:	d8e8      	bhi.n	103e2 <__multiply+0x76>
   10410:	602c      	str	r4, [r5, #0]
   10412:	f8dc 5000 	ldr.w	r5, [ip]
   10416:	0c2d      	lsrs	r5, r5, #16
   10418:	d01d      	beq.n	10456 <__multiply+0xea>
   1041a:	f8d9 3000 	ldr.w	r3, [r9]
   1041e:	4648      	mov	r0, r9
   10420:	461c      	mov	r4, r3
   10422:	4659      	mov	r1, fp
   10424:	2200      	movs	r2, #0
   10426:	880e      	ldrh	r6, [r1, #0]
   10428:	0c24      	lsrs	r4, r4, #16
   1042a:	fb05 4406 	mla	r4, r5, r6, r4
   1042e:	4422      	add	r2, r4
   10430:	b29b      	uxth	r3, r3
   10432:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   10436:	f840 3b04 	str.w	r3, [r0], #4
   1043a:	f851 3b04 	ldr.w	r3, [r1], #4
   1043e:	6804      	ldr	r4, [r0, #0]
   10440:	0c1b      	lsrs	r3, r3, #16
   10442:	b2a6      	uxth	r6, r4
   10444:	fb05 6303 	mla	r3, r5, r3, r6
   10448:	eb03 4312 	add.w	r3, r3, r2, lsr #16
   1044c:	458e      	cmp	lr, r1
   1044e:	ea4f 4213 	mov.w	r2, r3, lsr #16
   10452:	d8e8      	bhi.n	10426 <__multiply+0xba>
   10454:	6003      	str	r3, [r0, #0]
   10456:	f10c 0c04 	add.w	ip, ip, #4
   1045a:	45e2      	cmp	sl, ip
   1045c:	f109 0904 	add.w	r9, r9, #4
   10460:	d8b7      	bhi.n	103d2 <__multiply+0x66>
   10462:	f8dd a004 	ldr.w	sl, [sp, #4]
   10466:	f1b8 0f00 	cmp.w	r8, #0
   1046a:	dd0b      	ble.n	10484 <__multiply+0x118>
   1046c:	f85a 3c04 	ldr.w	r3, [sl, #-4]
   10470:	f1aa 0a04 	sub.w	sl, sl, #4
   10474:	b11b      	cbz	r3, 1047e <__multiply+0x112>
   10476:	e005      	b.n	10484 <__multiply+0x118>
   10478:	f85a 3d04 	ldr.w	r3, [sl, #-4]!
   1047c:	b913      	cbnz	r3, 10484 <__multiply+0x118>
   1047e:	f1b8 0801 	subs.w	r8, r8, #1
   10482:	d1f9      	bne.n	10478 <__multiply+0x10c>
   10484:	9800      	ldr	r0, [sp, #0]
   10486:	f8c0 8010 	str.w	r8, [r0, #16]
   1048a:	b003      	add	sp, #12
   1048c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00010490 <__pow5mult>:
   10490:	f012 0303 	ands.w	r3, r2, #3
   10494:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10498:	4614      	mov	r4, r2
   1049a:	4607      	mov	r7, r0
   1049c:	d12e      	bne.n	104fc <__pow5mult+0x6c>
   1049e:	460d      	mov	r5, r1
   104a0:	10a4      	asrs	r4, r4, #2
   104a2:	d01c      	beq.n	104de <__pow5mult+0x4e>
   104a4:	6cbe      	ldr	r6, [r7, #72]	; 0x48
   104a6:	b396      	cbz	r6, 1050e <__pow5mult+0x7e>
   104a8:	07e3      	lsls	r3, r4, #31
   104aa:	f04f 0800 	mov.w	r8, #0
   104ae:	d406      	bmi.n	104be <__pow5mult+0x2e>
   104b0:	1064      	asrs	r4, r4, #1
   104b2:	d014      	beq.n	104de <__pow5mult+0x4e>
   104b4:	6830      	ldr	r0, [r6, #0]
   104b6:	b1a8      	cbz	r0, 104e4 <__pow5mult+0x54>
   104b8:	4606      	mov	r6, r0
   104ba:	07e3      	lsls	r3, r4, #31
   104bc:	d5f8      	bpl.n	104b0 <__pow5mult+0x20>
   104be:	4632      	mov	r2, r6
   104c0:	4629      	mov	r1, r5
   104c2:	4638      	mov	r0, r7
   104c4:	f7ff ff52 	bl	1036c <__multiply>
   104c8:	b1b5      	cbz	r5, 104f8 <__pow5mult+0x68>
   104ca:	686a      	ldr	r2, [r5, #4]
   104cc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   104ce:	1064      	asrs	r4, r4, #1
   104d0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   104d4:	6029      	str	r1, [r5, #0]
   104d6:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
   104da:	4605      	mov	r5, r0
   104dc:	d1ea      	bne.n	104b4 <__pow5mult+0x24>
   104de:	4628      	mov	r0, r5
   104e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   104e4:	4632      	mov	r2, r6
   104e6:	4631      	mov	r1, r6
   104e8:	4638      	mov	r0, r7
   104ea:	f7ff ff3f 	bl	1036c <__multiply>
   104ee:	6030      	str	r0, [r6, #0]
   104f0:	f8c0 8000 	str.w	r8, [r0]
   104f4:	4606      	mov	r6, r0
   104f6:	e7e0      	b.n	104ba <__pow5mult+0x2a>
   104f8:	4605      	mov	r5, r0
   104fa:	e7d9      	b.n	104b0 <__pow5mult+0x20>
   104fc:	1e5a      	subs	r2, r3, #1
   104fe:	4d0b      	ldr	r5, [pc, #44]	; (1052c <__pow5mult+0x9c>)
   10500:	2300      	movs	r3, #0
   10502:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
   10506:	f7ff fe97 	bl	10238 <__multadd>
   1050a:	4605      	mov	r5, r0
   1050c:	e7c8      	b.n	104a0 <__pow5mult+0x10>
   1050e:	2101      	movs	r1, #1
   10510:	4638      	mov	r0, r7
   10512:	f7ff fe61 	bl	101d8 <_Balloc>
   10516:	f240 2171 	movw	r1, #625	; 0x271
   1051a:	2201      	movs	r2, #1
   1051c:	2300      	movs	r3, #0
   1051e:	6141      	str	r1, [r0, #20]
   10520:	6102      	str	r2, [r0, #16]
   10522:	4606      	mov	r6, r0
   10524:	64b8      	str	r0, [r7, #72]	; 0x48
   10526:	6003      	str	r3, [r0, #0]
   10528:	e7be      	b.n	104a8 <__pow5mult+0x18>
   1052a:	bf00      	nop
   1052c:	00012cd8 	.word	0x00012cd8

00010530 <__lshift>:
   10530:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10534:	4691      	mov	r9, r2
   10536:	690a      	ldr	r2, [r1, #16]
   10538:	688b      	ldr	r3, [r1, #8]
   1053a:	ea4f 1469 	mov.w	r4, r9, asr #5
   1053e:	eb04 0802 	add.w	r8, r4, r2
   10542:	f108 0501 	add.w	r5, r8, #1
   10546:	429d      	cmp	r5, r3
   10548:	460e      	mov	r6, r1
   1054a:	4607      	mov	r7, r0
   1054c:	6849      	ldr	r1, [r1, #4]
   1054e:	dd04      	ble.n	1055a <__lshift+0x2a>
   10550:	005b      	lsls	r3, r3, #1
   10552:	429d      	cmp	r5, r3
   10554:	f101 0101 	add.w	r1, r1, #1
   10558:	dcfa      	bgt.n	10550 <__lshift+0x20>
   1055a:	4638      	mov	r0, r7
   1055c:	f7ff fe3c 	bl	101d8 <_Balloc>
   10560:	2c00      	cmp	r4, #0
   10562:	f100 0314 	add.w	r3, r0, #20
   10566:	dd06      	ble.n	10576 <__lshift+0x46>
   10568:	eb03 0284 	add.w	r2, r3, r4, lsl #2
   1056c:	2100      	movs	r1, #0
   1056e:	f843 1b04 	str.w	r1, [r3], #4
   10572:	429a      	cmp	r2, r3
   10574:	d1fb      	bne.n	1056e <__lshift+0x3e>
   10576:	6934      	ldr	r4, [r6, #16]
   10578:	f106 0114 	add.w	r1, r6, #20
   1057c:	f019 091f 	ands.w	r9, r9, #31
   10580:	eb01 0e84 	add.w	lr, r1, r4, lsl #2
   10584:	d01d      	beq.n	105c2 <__lshift+0x92>
   10586:	f1c9 0c20 	rsb	ip, r9, #32
   1058a:	2200      	movs	r2, #0
   1058c:	680c      	ldr	r4, [r1, #0]
   1058e:	fa04 f409 	lsl.w	r4, r4, r9
   10592:	4314      	orrs	r4, r2
   10594:	f843 4b04 	str.w	r4, [r3], #4
   10598:	f851 2b04 	ldr.w	r2, [r1], #4
   1059c:	458e      	cmp	lr, r1
   1059e:	fa22 f20c 	lsr.w	r2, r2, ip
   105a2:	d8f3      	bhi.n	1058c <__lshift+0x5c>
   105a4:	601a      	str	r2, [r3, #0]
   105a6:	b10a      	cbz	r2, 105ac <__lshift+0x7c>
   105a8:	f108 0502 	add.w	r5, r8, #2
   105ac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   105ae:	6872      	ldr	r2, [r6, #4]
   105b0:	3d01      	subs	r5, #1
   105b2:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   105b6:	6105      	str	r5, [r0, #16]
   105b8:	6031      	str	r1, [r6, #0]
   105ba:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
   105be:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   105c2:	3b04      	subs	r3, #4
   105c4:	f851 2b04 	ldr.w	r2, [r1], #4
   105c8:	f843 2f04 	str.w	r2, [r3, #4]!
   105cc:	458e      	cmp	lr, r1
   105ce:	d8f9      	bhi.n	105c4 <__lshift+0x94>
   105d0:	e7ec      	b.n	105ac <__lshift+0x7c>
   105d2:	bf00      	nop

000105d4 <__mcmp>:
   105d4:	b430      	push	{r4, r5}
   105d6:	690b      	ldr	r3, [r1, #16]
   105d8:	4605      	mov	r5, r0
   105da:	6900      	ldr	r0, [r0, #16]
   105dc:	1ac0      	subs	r0, r0, r3
   105de:	d10f      	bne.n	10600 <__mcmp+0x2c>
   105e0:	009b      	lsls	r3, r3, #2
   105e2:	3514      	adds	r5, #20
   105e4:	3114      	adds	r1, #20
   105e6:	4419      	add	r1, r3
   105e8:	442b      	add	r3, r5
   105ea:	e001      	b.n	105f0 <__mcmp+0x1c>
   105ec:	429d      	cmp	r5, r3
   105ee:	d207      	bcs.n	10600 <__mcmp+0x2c>
   105f0:	f853 4d04 	ldr.w	r4, [r3, #-4]!
   105f4:	f851 2d04 	ldr.w	r2, [r1, #-4]!
   105f8:	4294      	cmp	r4, r2
   105fa:	d0f7      	beq.n	105ec <__mcmp+0x18>
   105fc:	d302      	bcc.n	10604 <__mcmp+0x30>
   105fe:	2001      	movs	r0, #1
   10600:	bc30      	pop	{r4, r5}
   10602:	4770      	bx	lr
   10604:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   10608:	e7fa      	b.n	10600 <__mcmp+0x2c>
   1060a:	bf00      	nop

0001060c <__mdiff>:
   1060c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10610:	690f      	ldr	r7, [r1, #16]
   10612:	460e      	mov	r6, r1
   10614:	6911      	ldr	r1, [r2, #16]
   10616:	1a7f      	subs	r7, r7, r1
   10618:	2f00      	cmp	r7, #0
   1061a:	4690      	mov	r8, r2
   1061c:	d117      	bne.n	1064e <__mdiff+0x42>
   1061e:	0089      	lsls	r1, r1, #2
   10620:	f106 0514 	add.w	r5, r6, #20
   10624:	f102 0e14 	add.w	lr, r2, #20
   10628:	186b      	adds	r3, r5, r1
   1062a:	4471      	add	r1, lr
   1062c:	e001      	b.n	10632 <__mdiff+0x26>
   1062e:	429d      	cmp	r5, r3
   10630:	d25c      	bcs.n	106ec <__mdiff+0xe0>
   10632:	f853 2d04 	ldr.w	r2, [r3, #-4]!
   10636:	f851 4d04 	ldr.w	r4, [r1, #-4]!
   1063a:	42a2      	cmp	r2, r4
   1063c:	d0f7      	beq.n	1062e <__mdiff+0x22>
   1063e:	d25e      	bcs.n	106fe <__mdiff+0xf2>
   10640:	4633      	mov	r3, r6
   10642:	462c      	mov	r4, r5
   10644:	4646      	mov	r6, r8
   10646:	4675      	mov	r5, lr
   10648:	4698      	mov	r8, r3
   1064a:	2701      	movs	r7, #1
   1064c:	e005      	b.n	1065a <__mdiff+0x4e>
   1064e:	db58      	blt.n	10702 <__mdiff+0xf6>
   10650:	f106 0514 	add.w	r5, r6, #20
   10654:	f108 0414 	add.w	r4, r8, #20
   10658:	2700      	movs	r7, #0
   1065a:	6871      	ldr	r1, [r6, #4]
   1065c:	f7ff fdbc 	bl	101d8 <_Balloc>
   10660:	f8d8 3010 	ldr.w	r3, [r8, #16]
   10664:	6936      	ldr	r6, [r6, #16]
   10666:	60c7      	str	r7, [r0, #12]
   10668:	eb04 0c83 	add.w	ip, r4, r3, lsl #2
   1066c:	46a6      	mov	lr, r4
   1066e:	eb05 0786 	add.w	r7, r5, r6, lsl #2
   10672:	f100 0414 	add.w	r4, r0, #20
   10676:	2300      	movs	r3, #0
   10678:	f85e 1b04 	ldr.w	r1, [lr], #4
   1067c:	f855 8b04 	ldr.w	r8, [r5], #4
   10680:	b28a      	uxth	r2, r1
   10682:	fa13 f388 	uxtah	r3, r3, r8
   10686:	0c09      	lsrs	r1, r1, #16
   10688:	1a9a      	subs	r2, r3, r2
   1068a:	ebc1 4318 	rsb	r3, r1, r8, lsr #16
   1068e:	eb03 4322 	add.w	r3, r3, r2, asr #16
   10692:	b292      	uxth	r2, r2
   10694:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
   10698:	45f4      	cmp	ip, lr
   1069a:	f844 2b04 	str.w	r2, [r4], #4
   1069e:	ea4f 4323 	mov.w	r3, r3, asr #16
   106a2:	d8e9      	bhi.n	10678 <__mdiff+0x6c>
   106a4:	42af      	cmp	r7, r5
   106a6:	d917      	bls.n	106d8 <__mdiff+0xcc>
   106a8:	46a4      	mov	ip, r4
   106aa:	46ae      	mov	lr, r5
   106ac:	f85e 2b04 	ldr.w	r2, [lr], #4
   106b0:	fa13 f382 	uxtah	r3, r3, r2
   106b4:	1419      	asrs	r1, r3, #16
   106b6:	eb01 4112 	add.w	r1, r1, r2, lsr #16
   106ba:	b29b      	uxth	r3, r3
   106bc:	ea43 4201 	orr.w	r2, r3, r1, lsl #16
   106c0:	4577      	cmp	r7, lr
   106c2:	f84c 2b04 	str.w	r2, [ip], #4
   106c6:	ea4f 4321 	mov.w	r3, r1, asr #16
   106ca:	d8ef      	bhi.n	106ac <__mdiff+0xa0>
   106cc:	43ed      	mvns	r5, r5
   106ce:	442f      	add	r7, r5
   106d0:	f027 0703 	bic.w	r7, r7, #3
   106d4:	3704      	adds	r7, #4
   106d6:	443c      	add	r4, r7
   106d8:	3c04      	subs	r4, #4
   106da:	b922      	cbnz	r2, 106e6 <__mdiff+0xda>
   106dc:	f854 3d04 	ldr.w	r3, [r4, #-4]!
   106e0:	3e01      	subs	r6, #1
   106e2:	2b00      	cmp	r3, #0
   106e4:	d0fa      	beq.n	106dc <__mdiff+0xd0>
   106e6:	6106      	str	r6, [r0, #16]
   106e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   106ec:	2100      	movs	r1, #0
   106ee:	f7ff fd73 	bl	101d8 <_Balloc>
   106f2:	2201      	movs	r2, #1
   106f4:	2300      	movs	r3, #0
   106f6:	6102      	str	r2, [r0, #16]
   106f8:	6143      	str	r3, [r0, #20]
   106fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   106fe:	4674      	mov	r4, lr
   10700:	e7ab      	b.n	1065a <__mdiff+0x4e>
   10702:	4633      	mov	r3, r6
   10704:	f106 0414 	add.w	r4, r6, #20
   10708:	f102 0514 	add.w	r5, r2, #20
   1070c:	4616      	mov	r6, r2
   1070e:	2701      	movs	r7, #1
   10710:	4698      	mov	r8, r3
   10712:	e7a2      	b.n	1065a <__mdiff+0x4e>

00010714 <__d2b>:
   10714:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   10718:	b083      	sub	sp, #12
   1071a:	2101      	movs	r1, #1
   1071c:	461c      	mov	r4, r3
   1071e:	f3c3 550a 	ubfx	r5, r3, #20, #11
   10722:	4617      	mov	r7, r2
   10724:	9e0a      	ldr	r6, [sp, #40]	; 0x28
   10726:	f7ff fd57 	bl	101d8 <_Balloc>
   1072a:	f3c4 0413 	ubfx	r4, r4, #0, #20
   1072e:	4681      	mov	r9, r0
   10730:	b10d      	cbz	r5, 10736 <__d2b+0x22>
   10732:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
   10736:	9401      	str	r4, [sp, #4]
   10738:	b31f      	cbz	r7, 10782 <__d2b+0x6e>
   1073a:	a802      	add	r0, sp, #8
   1073c:	f840 7d08 	str.w	r7, [r0, #-8]!
   10740:	f7ff fdda 	bl	102f8 <__lo0bits>
   10744:	2800      	cmp	r0, #0
   10746:	d135      	bne.n	107b4 <__d2b+0xa0>
   10748:	e89d 000c 	ldmia.w	sp, {r2, r3}
   1074c:	f8c9 2014 	str.w	r2, [r9, #20]
   10750:	2b00      	cmp	r3, #0
   10752:	bf0c      	ite	eq
   10754:	2101      	moveq	r1, #1
   10756:	2102      	movne	r1, #2
   10758:	f8c9 3018 	str.w	r3, [r9, #24]
   1075c:	f8c9 1010 	str.w	r1, [r9, #16]
   10760:	b9dd      	cbnz	r5, 1079a <__d2b+0x86>
   10762:	eb09 0381 	add.w	r3, r9, r1, lsl #2
   10766:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
   1076a:	6030      	str	r0, [r6, #0]
   1076c:	6918      	ldr	r0, [r3, #16]
   1076e:	f7ff fda3 	bl	102b8 <__hi0bits>
   10772:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   10774:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
   10778:	6018      	str	r0, [r3, #0]
   1077a:	4648      	mov	r0, r9
   1077c:	b003      	add	sp, #12
   1077e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   10782:	a801      	add	r0, sp, #4
   10784:	f7ff fdb8 	bl	102f8 <__lo0bits>
   10788:	9b01      	ldr	r3, [sp, #4]
   1078a:	f8c9 3014 	str.w	r3, [r9, #20]
   1078e:	2101      	movs	r1, #1
   10790:	3020      	adds	r0, #32
   10792:	f8c9 1010 	str.w	r1, [r9, #16]
   10796:	2d00      	cmp	r5, #0
   10798:	d0e3      	beq.n	10762 <__d2b+0x4e>
   1079a:	f2a5 4833 	subw	r8, r5, #1075	; 0x433
   1079e:	eb08 0300 	add.w	r3, r8, r0
   107a2:	6033      	str	r3, [r6, #0]
   107a4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   107a6:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
   107aa:	6018      	str	r0, [r3, #0]
   107ac:	4648      	mov	r0, r9
   107ae:	b003      	add	sp, #12
   107b0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   107b4:	e89d 000a 	ldmia.w	sp, {r1, r3}
   107b8:	f1c0 0220 	rsb	r2, r0, #32
   107bc:	fa03 f202 	lsl.w	r2, r3, r2
   107c0:	430a      	orrs	r2, r1
   107c2:	40c3      	lsrs	r3, r0
   107c4:	9301      	str	r3, [sp, #4]
   107c6:	f8c9 2014 	str.w	r2, [r9, #20]
   107ca:	e7c1      	b.n	10750 <__d2b+0x3c>

000107cc <_read_r>:
   107cc:	b570      	push	{r4, r5, r6, lr}
   107ce:	460d      	mov	r5, r1
   107d0:	4c08      	ldr	r4, [pc, #32]	; (107f4 <_read_r+0x28>)
   107d2:	4611      	mov	r1, r2
   107d4:	4606      	mov	r6, r0
   107d6:	461a      	mov	r2, r3
   107d8:	4628      	mov	r0, r5
   107da:	2300      	movs	r3, #0
   107dc:	6023      	str	r3, [r4, #0]
   107de:	f7f2 ff7b 	bl	36d8 <_read>
   107e2:	1c43      	adds	r3, r0, #1
   107e4:	d000      	beq.n	107e8 <_read_r+0x1c>
   107e6:	bd70      	pop	{r4, r5, r6, pc}
   107e8:	6823      	ldr	r3, [r4, #0]
   107ea:	2b00      	cmp	r3, #0
   107ec:	d0fb      	beq.n	107e6 <_read_r+0x1a>
   107ee:	6033      	str	r3, [r6, #0]
   107f0:	bd70      	pop	{r4, r5, r6, pc}
   107f2:	bf00      	nop
   107f4:	2000304c 	.word	0x2000304c

000107f8 <_raise_r>:
   107f8:	291f      	cmp	r1, #31
   107fa:	d828      	bhi.n	1084e <_raise_r+0x56>
   107fc:	b520      	push	{r5, lr}
   107fe:	f8d0 22dc 	ldr.w	r2, [r0, #732]	; 0x2dc
   10802:	b082      	sub	sp, #8
   10804:	4605      	mov	r5, r0
   10806:	b1aa      	cbz	r2, 10834 <_raise_r+0x3c>
   10808:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   1080c:	b193      	cbz	r3, 10834 <_raise_r+0x3c>
   1080e:	2b01      	cmp	r3, #1
   10810:	d00e      	beq.n	10830 <_raise_r+0x38>
   10812:	1c58      	adds	r0, r3, #1
   10814:	d007      	beq.n	10826 <_raise_r+0x2e>
   10816:	2500      	movs	r5, #0
   10818:	4608      	mov	r0, r1
   1081a:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
   1081e:	4798      	blx	r3
   10820:	4628      	mov	r0, r5
   10822:	b002      	add	sp, #8
   10824:	bd20      	pop	{r5, pc}
   10826:	2316      	movs	r3, #22
   10828:	2001      	movs	r0, #1
   1082a:	602b      	str	r3, [r5, #0]
   1082c:	b002      	add	sp, #8
   1082e:	bd20      	pop	{r5, pc}
   10830:	2000      	movs	r0, #0
   10832:	e7f6      	b.n	10822 <_raise_r+0x2a>
   10834:	4628      	mov	r0, r5
   10836:	9101      	str	r1, [sp, #4]
   10838:	f000 f82a 	bl	10890 <_getpid_r>
   1083c:	9901      	ldr	r1, [sp, #4]
   1083e:	460a      	mov	r2, r1
   10840:	4601      	mov	r1, r0
   10842:	4628      	mov	r0, r5
   10844:	b002      	add	sp, #8
   10846:	e8bd 4020 	ldmia.w	sp!, {r5, lr}
   1084a:	f000 b80d 	b.w	10868 <_kill_r>
   1084e:	2316      	movs	r3, #22
   10850:	6003      	str	r3, [r0, #0]
   10852:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   10856:	4770      	bx	lr

00010858 <raise>:
   10858:	4b02      	ldr	r3, [pc, #8]	; (10864 <raise+0xc>)
   1085a:	4601      	mov	r1, r0
   1085c:	6818      	ldr	r0, [r3, #0]
   1085e:	f7ff bfcb 	b.w	107f8 <_raise_r>
   10862:	bf00      	nop
   10864:	200001c0 	.word	0x200001c0

00010868 <_kill_r>:
   10868:	b538      	push	{r3, r4, r5, lr}
   1086a:	460b      	mov	r3, r1
   1086c:	4c07      	ldr	r4, [pc, #28]	; (1088c <_kill_r+0x24>)
   1086e:	4605      	mov	r5, r0
   10870:	4611      	mov	r1, r2
   10872:	4618      	mov	r0, r3
   10874:	2300      	movs	r3, #0
   10876:	6023      	str	r3, [r4, #0]
   10878:	f000 f8bc 	bl	109f4 <_kill>
   1087c:	1c43      	adds	r3, r0, #1
   1087e:	d000      	beq.n	10882 <_kill_r+0x1a>
   10880:	bd38      	pop	{r3, r4, r5, pc}
   10882:	6823      	ldr	r3, [r4, #0]
   10884:	2b00      	cmp	r3, #0
   10886:	d0fb      	beq.n	10880 <_kill_r+0x18>
   10888:	602b      	str	r3, [r5, #0]
   1088a:	bd38      	pop	{r3, r4, r5, pc}
   1088c:	2000304c 	.word	0x2000304c

00010890 <_getpid_r>:
   10890:	f000 b8a8 	b.w	109e4 <_getpid>

00010894 <__ssprint_r>:
   10894:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10898:	6893      	ldr	r3, [r2, #8]
   1089a:	b083      	sub	sp, #12
   1089c:	4690      	mov	r8, r2
   1089e:	2b00      	cmp	r3, #0
   108a0:	d070      	beq.n	10984 <__ssprint_r+0xf0>
   108a2:	4682      	mov	sl, r0
   108a4:	460c      	mov	r4, r1
   108a6:	6817      	ldr	r7, [r2, #0]
   108a8:	688d      	ldr	r5, [r1, #8]
   108aa:	6808      	ldr	r0, [r1, #0]
   108ac:	e042      	b.n	10934 <__ssprint_r+0xa0>
   108ae:	89a3      	ldrh	r3, [r4, #12]
   108b0:	f413 6f90 	tst.w	r3, #1152	; 0x480
   108b4:	d02e      	beq.n	10914 <__ssprint_r+0x80>
   108b6:	6965      	ldr	r5, [r4, #20]
   108b8:	6921      	ldr	r1, [r4, #16]
   108ba:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   108be:	eba0 0b01 	sub.w	fp, r0, r1
   108c2:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   108c6:	f10b 0001 	add.w	r0, fp, #1
   108ca:	106d      	asrs	r5, r5, #1
   108cc:	4430      	add	r0, r6
   108ce:	42a8      	cmp	r0, r5
   108d0:	462a      	mov	r2, r5
   108d2:	bf84      	itt	hi
   108d4:	4605      	movhi	r5, r0
   108d6:	462a      	movhi	r2, r5
   108d8:	055b      	lsls	r3, r3, #21
   108da:	d538      	bpl.n	1094e <__ssprint_r+0xba>
   108dc:	4611      	mov	r1, r2
   108de:	4650      	mov	r0, sl
   108e0:	f7f1 ff7c 	bl	27dc <__wrap__malloc_r>
   108e4:	2800      	cmp	r0, #0
   108e6:	d03c      	beq.n	10962 <__ssprint_r+0xce>
   108e8:	465a      	mov	r2, fp
   108ea:	6921      	ldr	r1, [r4, #16]
   108ec:	9001      	str	r0, [sp, #4]
   108ee:	f7f0 f817 	bl	920 <memcpy>
   108f2:	89a2      	ldrh	r2, [r4, #12]
   108f4:	9b01      	ldr	r3, [sp, #4]
   108f6:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
   108fa:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   108fe:	81a2      	strh	r2, [r4, #12]
   10900:	eba5 020b 	sub.w	r2, r5, fp
   10904:	eb03 000b 	add.w	r0, r3, fp
   10908:	6165      	str	r5, [r4, #20]
   1090a:	6123      	str	r3, [r4, #16]
   1090c:	6020      	str	r0, [r4, #0]
   1090e:	60a2      	str	r2, [r4, #8]
   10910:	4635      	mov	r5, r6
   10912:	46b3      	mov	fp, r6
   10914:	465a      	mov	r2, fp
   10916:	4649      	mov	r1, r9
   10918:	f7fa fd60 	bl	b3dc <memmove>
   1091c:	f8d8 3008 	ldr.w	r3, [r8, #8]
   10920:	68a2      	ldr	r2, [r4, #8]
   10922:	6820      	ldr	r0, [r4, #0]
   10924:	1b55      	subs	r5, r2, r5
   10926:	4458      	add	r0, fp
   10928:	1b9e      	subs	r6, r3, r6
   1092a:	60a5      	str	r5, [r4, #8]
   1092c:	6020      	str	r0, [r4, #0]
   1092e:	f8c8 6008 	str.w	r6, [r8, #8]
   10932:	b33e      	cbz	r6, 10984 <__ssprint_r+0xf0>
   10934:	687e      	ldr	r6, [r7, #4]
   10936:	463b      	mov	r3, r7
   10938:	3708      	adds	r7, #8
   1093a:	2e00      	cmp	r6, #0
   1093c:	d0fa      	beq.n	10934 <__ssprint_r+0xa0>
   1093e:	42ae      	cmp	r6, r5
   10940:	f8d3 9000 	ldr.w	r9, [r3]
   10944:	46ab      	mov	fp, r5
   10946:	d2b2      	bcs.n	108ae <__ssprint_r+0x1a>
   10948:	4635      	mov	r5, r6
   1094a:	46b3      	mov	fp, r6
   1094c:	e7e2      	b.n	10914 <__ssprint_r+0x80>
   1094e:	4650      	mov	r0, sl
   10950:	f7f1 ffae 	bl	28b0 <__wrap__realloc_r>
   10954:	4603      	mov	r3, r0
   10956:	2800      	cmp	r0, #0
   10958:	d1d2      	bne.n	10900 <__ssprint_r+0x6c>
   1095a:	6921      	ldr	r1, [r4, #16]
   1095c:	4650      	mov	r0, sl
   1095e:	f7f1 ffe2 	bl	2926 <__wrap__free_r>
   10962:	230c      	movs	r3, #12
   10964:	f8ca 3000 	str.w	r3, [sl]
   10968:	89a3      	ldrh	r3, [r4, #12]
   1096a:	2200      	movs	r2, #0
   1096c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   10970:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   10974:	81a3      	strh	r3, [r4, #12]
   10976:	f8c8 2008 	str.w	r2, [r8, #8]
   1097a:	f8c8 2004 	str.w	r2, [r8, #4]
   1097e:	b003      	add	sp, #12
   10980:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10984:	2000      	movs	r0, #0
   10986:	f8c8 0004 	str.w	r0, [r8, #4]
   1098a:	b003      	add	sp, #12
   1098c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00010990 <_wcrtomb_r>:
   10990:	b5f0      	push	{r4, r5, r6, r7, lr}
   10992:	4606      	mov	r6, r0
   10994:	b085      	sub	sp, #20
   10996:	461f      	mov	r7, r3
   10998:	b189      	cbz	r1, 109be <_wcrtomb_r+0x2e>
   1099a:	4c10      	ldr	r4, [pc, #64]	; (109dc <_wcrtomb_r+0x4c>)
   1099c:	4d10      	ldr	r5, [pc, #64]	; (109e0 <_wcrtomb_r+0x50>)
   1099e:	6824      	ldr	r4, [r4, #0]
   109a0:	6b64      	ldr	r4, [r4, #52]	; 0x34
   109a2:	2c00      	cmp	r4, #0
   109a4:	bf08      	it	eq
   109a6:	462c      	moveq	r4, r5
   109a8:	f8d4 40e0 	ldr.w	r4, [r4, #224]	; 0xe0
   109ac:	47a0      	blx	r4
   109ae:	1c43      	adds	r3, r0, #1
   109b0:	d103      	bne.n	109ba <_wcrtomb_r+0x2a>
   109b2:	2200      	movs	r2, #0
   109b4:	238a      	movs	r3, #138	; 0x8a
   109b6:	603a      	str	r2, [r7, #0]
   109b8:	6033      	str	r3, [r6, #0]
   109ba:	b005      	add	sp, #20
   109bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   109be:	460c      	mov	r4, r1
   109c0:	4906      	ldr	r1, [pc, #24]	; (109dc <_wcrtomb_r+0x4c>)
   109c2:	4a07      	ldr	r2, [pc, #28]	; (109e0 <_wcrtomb_r+0x50>)
   109c4:	6809      	ldr	r1, [r1, #0]
   109c6:	6b49      	ldr	r1, [r1, #52]	; 0x34
   109c8:	2900      	cmp	r1, #0
   109ca:	bf08      	it	eq
   109cc:	4611      	moveq	r1, r2
   109ce:	4622      	mov	r2, r4
   109d0:	f8d1 40e0 	ldr.w	r4, [r1, #224]	; 0xe0
   109d4:	a901      	add	r1, sp, #4
   109d6:	47a0      	blx	r4
   109d8:	e7e9      	b.n	109ae <_wcrtomb_r+0x1e>
   109da:	bf00      	nop
   109dc:	200001c0 	.word	0x200001c0
   109e0:	200005f0 	.word	0x200005f0

000109e4 <_getpid>:
   109e4:	4b02      	ldr	r3, [pc, #8]	; (109f0 <_getpid+0xc>)
   109e6:	2258      	movs	r2, #88	; 0x58
   109e8:	601a      	str	r2, [r3, #0]
   109ea:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   109ee:	4770      	bx	lr
   109f0:	2000304c 	.word	0x2000304c

000109f4 <_kill>:
   109f4:	4b02      	ldr	r3, [pc, #8]	; (10a00 <_kill+0xc>)
   109f6:	2258      	movs	r2, #88	; 0x58
   109f8:	601a      	str	r2, [r3, #0]
   109fa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   109fe:	4770      	bx	lr
   10a00:	2000304c 	.word	0x2000304c
   10a04:	65726854 	.word	0x65726854
   10a08:	203a6461 	.word	0x203a6461
   10a0c:	6c257830 	.word	0x6c257830
   10a10:	53202c58 	.word	0x53202c58
   10a14:	6b636174 	.word	0x6b636174
   10a18:	7a697320 	.word	0x7a697320
   10a1c:	25203a65 	.word	0x25203a65
   10a20:	2f20756c 	.word	0x2f20756c
   10a24:	756c2520 	.word	0x756c2520
   10a28:	00000a0d 	.word	0x00000a0d
   10a2c:	70616548 	.word	0x70616548
   10a30:	7a697320 	.word	0x7a697320
   10a34:	25203a65 	.word	0x25203a65
   10a38:	2f20756c 	.word	0x2f20756c
   10a3c:	756c2520 	.word	0x756c2520
   10a40:	74796220 	.word	0x74796220
   10a44:	0a0d7365 	.word	0x0a0d7365
   10a48:	00000000 	.word	0x00000000
   10a4c:	626d2f2e 	.word	0x626d2f2e
   10a50:	6f2d6465 	.word	0x6f2d6465
   10a54:	6c702f73 	.word	0x6c702f73
   10a58:	6f667461 	.word	0x6f667461
   10a5c:	532f6d72 	.word	0x532f6d72
   10a60:	6c676e69 	.word	0x6c676e69
   10a64:	6e6f7465 	.word	0x6e6f7465
   10a68:	2e727450 	.word	0x2e727450
   10a6c:	00000068 	.word	0x00000068
   10a70:	7274705f 	.word	0x7274705f
   10a74:	203d3d20 	.word	0x203d3d20
   10a78:	2a205428 	.word	0x2a205428
   10a7c:	645f2629 	.word	0x645f2629
   10a80:	00617461 	.word	0x00617461
   10a84:	626d2f2e 	.word	0x626d2f2e
   10a88:	6f2d6465 	.word	0x6f2d6465
   10a8c:	61682f73 	.word	0x61682f73
   10a90:	626d2f6c 	.word	0x626d2f6c
   10a94:	635f6465 	.word	0x635f6465
   10a98:	69746972 	.word	0x69746972
   10a9c:	5f6c6163 	.word	0x5f6c6163
   10aa0:	74636573 	.word	0x74636573
   10aa4:	5f6e6f69 	.word	0x5f6e6f69
   10aa8:	2e697061 	.word	0x2e697061
   10aac:	00000063 	.word	0x00000063
   10ab0:	65726121 	.word	0x65726121
   10ab4:	746e695f 	.word	0x746e695f
   10ab8:	75727265 	.word	0x75727265
   10abc:	5f737470 	.word	0x5f737470
   10ac0:	62616e65 	.word	0x62616e65
   10ac4:	2864656c 	.word	0x2864656c
   10ac8:	00000029 	.word	0x00000029
   10acc:	6c756f63 	.word	0x6c756f63
   10ad0:	6f6e2064 	.word	0x6f6e2064
   10ad4:	69702074 	.word	0x69702074
   10ad8:	74756f6e 	.word	0x74756f6e
   10adc:	00000000 	.word	0x00000000
   10ae0:	6d6e6970 	.word	0x6d6e6970
   10ae4:	6d207061 	.word	0x6d207061
   10ae8:	6d2d7369 	.word	0x6d2d7369
   10aec:	68637461 	.word	0x68637461
   10af0:	00000000 	.word	0x00000000
   10af4:	6d6e6970 	.word	0x6d6e6970
   10af8:	6e207061 	.word	0x6e207061
   10afc:	6620746f 	.word	0x6620746f
   10b00:	646e756f 	.word	0x646e756f
   10b04:	726f6620 	.word	0x726f6620
   10b08:	72657020 	.word	0x72657020
   10b0c:	65687069 	.word	0x65687069
   10b10:	006c6172 	.word	0x006c6172
   10b14:	6d6e6970 	.word	0x6d6e6970
   10b18:	6e207061 	.word	0x6e207061
   10b1c:	6620746f 	.word	0x6620746f
   10b20:	646e756f 	.word	0x646e756f
   10b24:	726f6620 	.word	0x726f6620
   10b28:	6e756620 	.word	0x6e756620
   10b2c:	6f697463 	.word	0x6f697463
   10b30:	0000006e 	.word	0x0000006e
   10b34:	70656544 	.word	0x70656544
   10b38:	65656c53 	.word	0x65656c53
   10b3c:	636f4c70 	.word	0x636f4c70
   10b40:	766f206b 	.word	0x766f206b
   10b44:	6c667265 	.word	0x6c667265
   10b48:	2820776f 	.word	0x2820776f
   10b4c:	5355203e 	.word	0x5355203e
   10b50:	5f545248 	.word	0x5f545248
   10b54:	2958414d 	.word	0x2958414d
   10b58:	00000000 	.word	0x00000000
   10b5c:	70656544 	.word	0x70656544
   10b60:	65656c53 	.word	0x65656c53
   10b64:	636f4c70 	.word	0x636f4c70
   10b68:	6e75206b 	.word	0x6e75206b
   10b6c:	66726564 	.word	0x66726564
   10b70:	20776f6c 	.word	0x20776f6c
   10b74:	30203c28 	.word	0x30203c28
   10b78:	00000029 	.word	0x00000029
   10b7c:	626d2f2e 	.word	0x626d2f2e
   10b80:	6f2d6465 	.word	0x6f2d6465
   10b84:	61682f73 	.word	0x61682f73
   10b88:	626d2f6c 	.word	0x626d2f6c
   10b8c:	745f6465 	.word	0x745f6465
   10b90:	656b6369 	.word	0x656b6369
   10b94:	70615f72 	.word	0x70615f72
   10b98:	00632e69 	.word	0x00632e69
   10b9c:	00000030 	.word	0x00000030
   10ba0:	6465626d 	.word	0x6465626d
   10ba4:	73736120 	.word	0x73736120
   10ba8:	61747265 	.word	0x61747265
   10bac:	6e6f6974 	.word	0x6e6f6974
   10bb0:	69616620 	.word	0x69616620
   10bb4:	3a64656c 	.word	0x3a64656c
   10bb8:	2c732520 	.word	0x2c732520
   10bbc:	6c696620 	.word	0x6c696620
   10bc0:	25203a65 	.word	0x25203a65
   10bc4:	6c202c73 	.word	0x6c202c73
   10bc8:	20656e69 	.word	0x20656e69
   10bcc:	0a206425 	.word	0x0a206425
   10bd0:	00000000 	.word	0x00000000
   10bd4:	626d2f2e 	.word	0x626d2f2e
   10bd8:	6f2d6465 	.word	0x6f2d6465
   10bdc:	6c702f73 	.word	0x6c702f73
   10be0:	6f667461 	.word	0x6f667461
   10be4:	6d2f6d72 	.word	0x6d2f6d72
   10be8:	5f646562 	.word	0x5f646562
   10bec:	74697263 	.word	0x74697263
   10bf0:	6c616369 	.word	0x6c616369
   10bf4:	0000632e 	.word	0x0000632e
   10bf8:	74697263 	.word	0x74697263
   10bfc:	6c616369 	.word	0x6c616369
   10c00:	6365735f 	.word	0x6365735f
   10c04:	6e6f6974 	.word	0x6e6f6974
   10c08:	6565725f 	.word	0x6565725f
   10c0c:	6172746e 	.word	0x6172746e
   10c10:	5f79636e 	.word	0x5f79636e
   10c14:	6e756f63 	.word	0x6e756f63
   10c18:	20726574 	.word	0x20726574
   10c1c:	4955203c 	.word	0x4955203c
   10c20:	3233544e 	.word	0x3233544e
   10c24:	58414d5f 	.word	0x58414d5f
   10c28:	00000000 	.word	0x00000000
   10c2c:	61746146 	.word	0x61746146
   10c30:	7552206c 	.word	0x7552206c
   10c34:	69742d6e 	.word	0x69742d6e
   10c38:	6520656d 	.word	0x6520656d
   10c3c:	726f7272 	.word	0x726f7272
   10c40:	00000000 	.word	0x00000000
   10c44:	2b2b0a0a 	.word	0x2b2b0a0a
   10c48:	65624d20 	.word	0x65624d20
   10c4c:	20534f64 	.word	0x20534f64
   10c50:	6f727245 	.word	0x6f727245
   10c54:	6e492072 	.word	0x6e492072
   10c58:	2b206f66 	.word	0x2b206f66
   10c5c:	72450a2b 	.word	0x72450a2b
   10c60:	20726f72 	.word	0x20726f72
   10c64:	74617453 	.word	0x74617453
   10c68:	203a7375 	.word	0x203a7375
   10c6c:	58257830 	.word	0x58257830
   10c70:	646f4320 	.word	0x646f4320
   10c74:	25203a65 	.word	0x25203a65
   10c78:	6f4d2064 	.word	0x6f4d2064
   10c7c:	656c7564 	.word	0x656c7564
   10c80:	6425203a 	.word	0x6425203a
   10c84:	7272450a 	.word	0x7272450a
   10c88:	4d20726f 	.word	0x4d20726f
   10c8c:	61737365 	.word	0x61737365
   10c90:	203a6567 	.word	0x203a6567
   10c94:	00000000 	.word	0x00000000
   10c98:	6e72654b 	.word	0x6e72654b
   10c9c:	45206c65 	.word	0x45206c65
   10ca0:	726f7272 	.word	0x726f7272
   10ca4:	7830203a 	.word	0x7830203a
   10ca8:	202c5825 	.word	0x202c5825
   10cac:	00000000 	.word	0x00000000
   10cb0:	65726854 	.word	0x65726854
   10cb4:	203a6461 	.word	0x203a6461
   10cb8:	58257830 	.word	0x58257830
   10cbc:	0000202c 	.word	0x0000202c
   10cc0:	6574754d 	.word	0x6574754d
   10cc4:	30203a78 	.word	0x30203a78
   10cc8:	2c582578 	.word	0x2c582578
   10ccc:	00000020 	.word	0x00000020
   10cd0:	616d6553 	.word	0x616d6553
   10cd4:	726f6870 	.word	0x726f6870
   10cd8:	30203a65 	.word	0x30203a65
   10cdc:	2c582578 	.word	0x2c582578
   10ce0:	00000020 	.word	0x00000020
   10ce4:	6f6d654d 	.word	0x6f6d654d
   10ce8:	6f507972 	.word	0x6f507972
   10cec:	203a6c6f 	.word	0x203a6c6f
   10cf0:	58257830 	.word	0x58257830
   10cf4:	0000202c 	.word	0x0000202c
   10cf8:	6e657645 	.word	0x6e657645
   10cfc:	616c4674 	.word	0x616c4674
   10d00:	203a7367 	.word	0x203a7367
   10d04:	58257830 	.word	0x58257830
   10d08:	0000202c 	.word	0x0000202c
   10d0c:	656d6954 	.word	0x656d6954
   10d10:	30203a72 	.word	0x30203a72
   10d14:	2c582578 	.word	0x2c582578
   10d18:	00000020 	.word	0x00000020
   10d1c:	7373654d 	.word	0x7373654d
   10d20:	51656761 	.word	0x51656761
   10d24:	65756575 	.word	0x65756575
   10d28:	7830203a 	.word	0x7830203a
   10d2c:	202c5825 	.word	0x202c5825
   10d30:	00000000 	.word	0x00000000
   10d34:	636f4c0a 	.word	0x636f4c0a
   10d38:	6f697461 	.word	0x6f697461
   10d3c:	30203a6e 	.word	0x30203a6e
   10d40:	00582578 	.word	0x00582578
   10d44:	7272450a 	.word	0x7272450a
   10d48:	5620726f 	.word	0x5620726f
   10d4c:	65756c61 	.word	0x65756c61
   10d50:	7830203a 	.word	0x7830203a
   10d54:	00005825 	.word	0x00005825
   10d58:	7275430a 	.word	0x7275430a
   10d5c:	746e6572 	.word	0x746e6572
   10d60:	72685420 	.word	0x72685420
   10d64:	3a646165 	.word	0x3a646165
   10d68:	3a644920 	.word	0x3a644920
   10d6c:	25783020 	.word	0x25783020
   10d70:	6e452058 	.word	0x6e452058
   10d74:	3a797274 	.word	0x3a797274
   10d78:	25783020 	.word	0x25783020
   10d7c:	74532058 	.word	0x74532058
   10d80:	536b6361 	.word	0x536b6361
   10d84:	3a657a69 	.word	0x3a657a69
   10d88:	25783020 	.word	0x25783020
   10d8c:	74532058 	.word	0x74532058
   10d90:	4d6b6361 	.word	0x4d6b6361
   10d94:	203a6d65 	.word	0x203a6d65
   10d98:	58257830 	.word	0x58257830
   10d9c:	3a505320 	.word	0x3a505320
   10da0:	25783020 	.word	0x25783020
   10da4:	00002058 	.word	0x00002058
   10da8:	202d2d0a 	.word	0x202d2d0a
   10dac:	6465624d 	.word	0x6465624d
   10db0:	4520534f 	.word	0x4520534f
   10db4:	726f7272 	.word	0x726f7272
   10db8:	666e4920 	.word	0x666e4920
   10dbc:	2d2d206f 	.word	0x2d2d206f
   10dc0:	0000000a 	.word	0x0000000a
   10dc4:	253a6d23 	.word	0x253a6d23
   10dc8:	70253b70 	.word	0x70253b70
   10dcc:	0a75252d 	.word	0x0a75252d
   10dd0:	00000000 	.word	0x00000000
   10dd4:	253a7223 	.word	0x253a7223
   10dd8:	70253b70 	.word	0x70253b70
   10ddc:	3b70252d 	.word	0x3b70252d
   10de0:	000a7525 	.word	0x000a7525
   10de4:	253a6323 	.word	0x253a6323
   10de8:	70253b70 	.word	0x70253b70
   10dec:	3b75252d 	.word	0x3b75252d
   10df0:	000a7525 	.word	0x000a7525
   10df4:	253a6623 	.word	0x253a6623
   10df8:	70253b70 	.word	0x70253b70
   10dfc:	0a70252d 	.word	0x0a70252d
   10e00:	00000000 	.word	0x00000000
   10e04:	00000a3f 	.word	0x00000a3f
   10e08:	626d2f2e 	.word	0x626d2f2e
   10e0c:	6f2d6465 	.word	0x6f2d6465
   10e10:	6c702f73 	.word	0x6c702f73
   10e14:	6f667461 	.word	0x6f667461
   10e18:	532f6d72 	.word	0x532f6d72
   10e1c:	6c676e69 	.word	0x6c676e69
   10e20:	6e6f7465 	.word	0x6e6f7465
   10e24:	2e727450 	.word	0x2e727450
   10e28:	00000068 	.word	0x00000068
   10e2c:	7274705f 	.word	0x7274705f
   10e30:	203d3d20 	.word	0x203d3d20
   10e34:	2a205428 	.word	0x2a205428
   10e38:	645f2629 	.word	0x645f2629
   10e3c:	00617461 	.word	0x00617461
   10e40:	6f727245 	.word	0x6f727245
   10e44:	202d2072 	.word	0x202d2072
   10e48:	74697277 	.word	0x74697277
   10e4c:	20676e69 	.word	0x20676e69
   10e50:	61206f74 	.word	0x61206f74
   10e54:	6c696620 	.word	0x6c696620
   10e58:	6e692065 	.word	0x6e692065
   10e5c:	206e6120 	.word	0x206e6120
   10e60:	20525349 	.word	0x20525349
   10e64:	6320726f 	.word	0x6320726f
   10e68:	69746972 	.word	0x69746972
   10e6c:	206c6163 	.word	0x206c6163
   10e70:	74636573 	.word	0x74636573
   10e74:	0d6e6f69 	.word	0x0d6e6f69
   10e78:	0000000a 	.word	0x0000000a
   10e7c:	0000000d 	.word	0x0000000d
   10e80:	6f727245 	.word	0x6f727245
   10e84:	202d2072 	.word	0x202d2072
   10e88:	64616572 	.word	0x64616572
   10e8c:	20676e69 	.word	0x20676e69
   10e90:	6d6f7266 	.word	0x6d6f7266
   10e94:	66206120 	.word	0x66206120
   10e98:	20656c69 	.word	0x20656c69
   10e9c:	61206e69 	.word	0x61206e69
   10ea0:	5349206e 	.word	0x5349206e
   10ea4:	726f2052 	.word	0x726f2052
   10ea8:	69726320 	.word	0x69726320
   10eac:	61636974 	.word	0x61636974
   10eb0:	6573206c 	.word	0x6573206c
   10eb4:	6f697463 	.word	0x6f697463
   10eb8:	000a0d6e 	.word	0x000a0d6e
   10ebc:	65637845 	.word	0x65637845
   10ec0:	6f697470 	.word	0x6f697470
   10ec4:	0000006e 	.word	0x0000006e
   10ec8:	626d2f2e 	.word	0x626d2f2e
   10ecc:	6f2d6465 	.word	0x6f2d6465
   10ed0:	6c702f73 	.word	0x6c702f73
   10ed4:	6f667461 	.word	0x6f667461
   10ed8:	6d2f6d72 	.word	0x6d2f6d72
   10edc:	5f646562 	.word	0x5f646562
   10ee0:	61746572 	.word	0x61746572
   10ee4:	74656772 	.word	0x74656772
   10ee8:	7070632e 	.word	0x7070632e
   10eec:	00000000 	.word	0x00000000
   10ef0:	3d3d2030 	.word	0x3d3d2030
   10ef4:	672a2820 	.word	0x672a2820
   10ef8:	64726175 	.word	0x64726175
   10efc:	6a626f5f 	.word	0x6a626f5f
   10f00:	20746365 	.word	0x20746365
   10f04:	58432026 	.word	0x58432026
   10f08:	55475f41 	.word	0x55475f41
   10f0c:	5f445241 	.word	0x5f445241
   10f10:	4b53414d 	.word	0x4b53414d
   10f14:	00000029 	.word	0x00000029
   10f18:	5f415843 	.word	0x5f415843
   10f1c:	52415547 	.word	0x52415547
   10f20:	4e495f44 	.word	0x4e495f44
   10f24:	495f5449 	.word	0x495f5449
   10f28:	52505f4e 	.word	0x52505f4e
   10f2c:	4552474f 	.word	0x4552474f
   10f30:	3d205353 	.word	0x3d205353
   10f34:	2a28203d 	.word	0x2a28203d
   10f38:	72617567 	.word	0x72617567
   10f3c:	626f5f64 	.word	0x626f5f64
   10f40:	7463656a 	.word	0x7463656a
   10f44:	43202620 	.word	0x43202620
   10f48:	475f4158 	.word	0x475f4158
   10f4c:	44524155 	.word	0x44524155
   10f50:	53414d5f 	.word	0x53414d5f
   10f54:	0000294b 	.word	0x0000294b
   10f58:	7265704f 	.word	0x7265704f
   10f5c:	726f7461 	.word	0x726f7461
   10f60:	77656e20 	.word	0x77656e20
   10f64:	74756f20 	.word	0x74756f20
   10f68:	20666f20 	.word	0x20666f20
   10f6c:	6f6d656d 	.word	0x6f6d656d
   10f70:	0a0d7972 	.word	0x0a0d7972
   10f74:	00000000 	.word	0x00000000
   10f78:	626d2f2e 	.word	0x626d2f2e
   10f7c:	6f2d6465 	.word	0x6f2d6465
   10f80:	6c702f73 	.word	0x6c702f73
   10f84:	6f667461 	.word	0x6f667461
   10f88:	532f6d72 	.word	0x532f6d72
   10f8c:	6c676e69 	.word	0x6c676e69
   10f90:	6e6f7465 	.word	0x6e6f7465
   10f94:	2e727450 	.word	0x2e727450
   10f98:	00000068 	.word	0x00000068
   10f9c:	7274705f 	.word	0x7274705f
   10fa0:	203d3d20 	.word	0x203d3d20
   10fa4:	2a205428 	.word	0x2a205428
   10fa8:	645f2629 	.word	0x645f2629
   10fac:	00617461 	.word	0x00617461
   10fb0:	626d2f2e 	.word	0x626d2f2e
   10fb4:	6f2d6465 	.word	0x6f2d6465
   10fb8:	6c702f73 	.word	0x6c702f73
   10fbc:	6f667461 	.word	0x6f667461
   10fc0:	6d2f6d72 	.word	0x6d2f6d72
   10fc4:	5f646562 	.word	0x5f646562
   10fc8:	74617473 	.word	0x74617473
   10fcc:	00632e73 	.word	0x00632e73
   10fd0:	74617473 	.word	0x74617473
   10fd4:	3d212073 	.word	0x3d212073
   10fd8:	4c554e20 	.word	0x4c554e20
   10fdc:	0000004c 	.word	0x0000004c
   10fe0:	65726874 	.word	0x65726874
   10fe4:	20736461 	.word	0x20736461
   10fe8:	4e203d21 	.word	0x4e203d21
   10fec:	004c4c55 	.word	0x004c4c55
   10ff0:	696c7061 	.word	0x696c7061
   10ff4:	69746163 	.word	0x69746163
   10ff8:	755f6e6f 	.word	0x755f6e6f
   10ffc:	6d616e6e 	.word	0x6d616e6e
   11000:	6d5f6465 	.word	0x6d5f6465
   11004:	78657475 	.word	0x78657475
   11008:	00000000 	.word	0x00000000
   1100c:	626d2f2e 	.word	0x626d2f2e
   11010:	6f2d6465 	.word	0x6f2d6465
   11014:	74722f73 	.word	0x74722f73
   11018:	4d2f736f 	.word	0x4d2f736f
   1101c:	78657475 	.word	0x78657475
   11020:	7070632e 	.word	0x7070632e
   11024:	00000000 	.word	0x00000000
   11028:	0064695f 	.word	0x0064695f
   1102c:	74617473 	.word	0x74617473
   11030:	3d207375 	.word	0x3d207375
   11034:	736f203d 	.word	0x736f203d
   11038:	6f727245 	.word	0x6f727245
   1103c:	6d695472 	.word	0x6d695472
   11040:	74756f65 	.word	0x74756f65
   11044:	207c7c20 	.word	0x207c7c20
   11048:	74617473 	.word	0x74617473
   1104c:	3d207375 	.word	0x3d207375
   11050:	736f203d 	.word	0x736f203d
   11054:	6f727245 	.word	0x6f727245
   11058:	73655272 	.word	0x73655272
   1105c:	6372756f 	.word	0x6372756f
   11060:	00000065 	.word	0x00000065
   11064:	202b2b0a 	.word	0x202b2b0a
   11068:	6465624d 	.word	0x6465624d
   1106c:	4620534f 	.word	0x4620534f
   11070:	746c7561 	.word	0x746c7561
   11074:	6e614820 	.word	0x6e614820
   11078:	72656c64 	.word	0x72656c64
   1107c:	0a2b2b20 	.word	0x0a2b2b20
   11080:	7561460a 	.word	0x7561460a
   11084:	7954746c 	.word	0x7954746c
   11088:	203a6570 	.word	0x203a6570
   1108c:	00000000 	.word	0x00000000
   11090:	4d6d654d 	.word	0x4d6d654d
   11094:	67616e61 	.word	0x67616e61
   11098:	75614665 	.word	0x75614665
   1109c:	0000746c 	.word	0x0000746c
   110a0:	46737542 	.word	0x46737542
   110a4:	746c7561 	.word	0x746c7561
   110a8:	00000000 	.word	0x00000000
   110ac:	67617355 	.word	0x67617355
   110b0:	75614665 	.word	0x75614665
   110b4:	0000746c 	.word	0x0000746c
   110b8:	64726148 	.word	0x64726148
   110bc:	6c756146 	.word	0x6c756146
   110c0:	00000074 	.word	0x00000074
   110c4:	6f430a0a 	.word	0x6f430a0a
   110c8:	7865746e 	.word	0x7865746e
   110cc:	00003a74 	.word	0x00003a74
   110d0:	2d2d0a0a 	.word	0x2d2d0a0a
   110d4:	65624d20 	.word	0x65624d20
   110d8:	20534f64 	.word	0x20534f64
   110dc:	6c756146 	.word	0x6c756146
   110e0:	61482074 	.word	0x61482074
   110e4:	656c646e 	.word	0x656c646e
   110e8:	2d2d2072 	.word	0x2d2d2072
   110ec:	00000a0a 	.word	0x00000a0a
   110f0:	65726e55 	.word	0x65726e55
   110f4:	65766f63 	.word	0x65766f63
   110f8:	6c626172 	.word	0x6c626172
   110fc:	61662065 	.word	0x61662065
   11100:	20746c75 	.word	0x20746c75
   11104:	61637865 	.word	0x61637865
   11108:	6f697470 	.word	0x6f697470
   1110c:	00002e6e 	.word	0x00002e6e
   11110:	2d25520a 	.word	0x2d25520a
   11114:	203a6434 	.word	0x203a6434
   11118:	58383025 	.word	0x58383025
   1111c:	00000000 	.word	0x00000000
   11120:	2050530a 	.word	0x2050530a
   11124:	203a2020 	.word	0x203a2020
   11128:	58383025 	.word	0x58383025
   1112c:	20524c0a 	.word	0x20524c0a
   11130:	203a2020 	.word	0x203a2020
   11134:	58383025 	.word	0x58383025
   11138:	2043500a 	.word	0x2043500a
   1113c:	203a2020 	.word	0x203a2020
   11140:	58383025 	.word	0x58383025
   11144:	5350780a 	.word	0x5350780a
   11148:	203a2052 	.word	0x203a2052
   1114c:	58383025 	.word	0x58383025
   11150:	5053500a 	.word	0x5053500a
   11154:	203a2020 	.word	0x203a2020
   11158:	58383025 	.word	0x58383025
   1115c:	50534d0a 	.word	0x50534d0a
   11160:	203a2020 	.word	0x203a2020
   11164:	58383025 	.word	0x58383025
   11168:	00000000 	.word	0x00000000
   1116c:	5550430a 	.word	0x5550430a
   11170:	203a4449 	.word	0x203a4449
   11174:	58383025 	.word	0x58383025
   11178:	00000000 	.word	0x00000000
   1117c:	5346480a 	.word	0x5346480a
   11180:	203a2052 	.word	0x203a2052
   11184:	58383025 	.word	0x58383025
   11188:	464d4d0a 	.word	0x464d4d0a
   1118c:	203a5253 	.word	0x203a5253
   11190:	58383025 	.word	0x58383025
   11194:	5346420a 	.word	0x5346420a
   11198:	203a2052 	.word	0x203a2052
   1119c:	58383025 	.word	0x58383025
   111a0:	5346550a 	.word	0x5346550a
   111a4:	203a2052 	.word	0x203a2052
   111a8:	58383025 	.word	0x58383025
   111ac:	5346440a 	.word	0x5346440a
   111b0:	203a2052 	.word	0x203a2052
   111b4:	58383025 	.word	0x58383025
   111b8:	5346410a 	.word	0x5346410a
   111bc:	203a2052 	.word	0x203a2052
   111c0:	58383025 	.word	0x58383025
   111c4:	00000000 	.word	0x00000000
   111c8:	464d4d0a 	.word	0x464d4d0a
   111cc:	203a5241 	.word	0x203a5241
   111d0:	58383025 	.word	0x58383025
   111d4:	00000000 	.word	0x00000000
   111d8:	4146420a 	.word	0x4146420a
   111dc:	203a2052 	.word	0x203a2052
   111e0:	58383025 	.word	0x58383025
   111e4:	00000000 	.word	0x00000000
   111e8:	646f4d0a 	.word	0x646f4d0a
   111ec:	203a2065 	.word	0x203a2065
   111f0:	65726854 	.word	0x65726854
   111f4:	00006461 	.word	0x00006461
   111f8:	6972500a 	.word	0x6972500a
   111fc:	203a2076 	.word	0x203a2076
   11200:	72657355 	.word	0x72657355
   11204:	00000000 	.word	0x00000000
   11208:	6972500a 	.word	0x6972500a
   1120c:	203a2076 	.word	0x203a2076
   11210:	76697250 	.word	0x76697250
   11214:	67656c69 	.word	0x67656c69
   11218:	00006465 	.word	0x00006465
   1121c:	646f4d0a 	.word	0x646f4d0a
   11220:	203a2065 	.word	0x203a2065
   11224:	646e6148 	.word	0x646e6148
   11228:	0072656c 	.word	0x0072656c
   1122c:	6174530a 	.word	0x6174530a
   11230:	203a6b63 	.word	0x203a6b63
   11234:	00505350 	.word	0x00505350
   11238:	6174530a 	.word	0x6174530a
   1123c:	203a6b63 	.word	0x203a6b63
   11240:	0050534d 	.word	0x0050534d
   11244:	6e69616d 	.word	0x6e69616d
   11248:	7268745f 	.word	0x7268745f
   1124c:	00646165 	.word	0x00646165
   11250:	20657250 	.word	0x20657250
   11254:	6e69616d 	.word	0x6e69616d
   11258:	72687420 	.word	0x72687420
   1125c:	20646165 	.word	0x20646165
   11260:	20746f6e 	.word	0x20746f6e
   11264:	61657263 	.word	0x61657263
   11268:	00646574 	.word	0x00646574
   1126c:	676e6973 	.word	0x676e6973
   11270:	6f74656c 	.word	0x6f74656c
   11274:	756d5f6e 	.word	0x756d5f6e
   11278:	00786574 	.word	0x00786574
   1127c:	6c6c616d 	.word	0x6c6c616d
   11280:	6d5f636f 	.word	0x6d5f636f
   11284:	78657475 	.word	0x78657475
   11288:	00000000 	.word	0x00000000
   1128c:	5f766e65 	.word	0x5f766e65
   11290:	6574756d 	.word	0x6574756d
   11294:	00000078 	.word	0x00000078
   11298:	49534d43 	.word	0x49534d43
   1129c:	54522d53 	.word	0x54522d53
   112a0:	6520534f 	.word	0x6520534f
   112a4:	726f7272 	.word	0x726f7272
   112a8:	7453203a 	.word	0x7453203a
   112ac:	206b6361 	.word	0x206b6361
   112b0:	7265766f 	.word	0x7265766f
   112b4:	776f6c66 	.word	0x776f6c66
   112b8:	00000000 	.word	0x00000000
   112bc:	49534d43 	.word	0x49534d43
   112c0:	54522d53 	.word	0x54522d53
   112c4:	6520534f 	.word	0x6520534f
   112c8:	726f7272 	.word	0x726f7272
   112cc:	5349203a 	.word	0x5349203a
   112d0:	75512052 	.word	0x75512052
   112d4:	20657565 	.word	0x20657565
   112d8:	7265766f 	.word	0x7265766f
   112dc:	776f6c66 	.word	0x776f6c66
   112e0:	00000000 	.word	0x00000000
   112e4:	49534d43 	.word	0x49534d43
   112e8:	54522d53 	.word	0x54522d53
   112ec:	6520534f 	.word	0x6520534f
   112f0:	726f7272 	.word	0x726f7272
   112f4:	7355203a 	.word	0x7355203a
   112f8:	54207265 	.word	0x54207265
   112fc:	72656d69 	.word	0x72656d69
   11300:	6c614320 	.word	0x6c614320
   11304:	6361626c 	.word	0x6361626c
   11308:	7551206b 	.word	0x7551206b
   1130c:	20657565 	.word	0x20657565
   11310:	7265766f 	.word	0x7265766f
   11314:	776f6c66 	.word	0x776f6c66
   11318:	00000000 	.word	0x00000000
   1131c:	49534d43 	.word	0x49534d43
   11320:	54522d53 	.word	0x54522d53
   11324:	6520534f 	.word	0x6520534f
   11328:	726f7272 	.word	0x726f7272
   1132c:	5453203a 	.word	0x5453203a
   11330:	2f432044 	.word	0x2f432044
   11334:	202b2b43 	.word	0x202b2b43
   11338:	7262696c 	.word	0x7262696c
   1133c:	20797261 	.word	0x20797261
   11340:	7362696c 	.word	0x7362696c
   11344:	65636170 	.word	0x65636170
   11348:	746f6e20 	.word	0x746f6e20
   1134c:	61766120 	.word	0x61766120
   11350:	62616c69 	.word	0x62616c69
   11354:	0000656c 	.word	0x0000656c
   11358:	49534d43 	.word	0x49534d43
   1135c:	54522d53 	.word	0x54522d53
   11360:	6520534f 	.word	0x6520534f
   11364:	726f7272 	.word	0x726f7272
   11368:	5453203a 	.word	0x5453203a
   1136c:	2f432044 	.word	0x2f432044
   11370:	202b2b43 	.word	0x202b2b43
   11374:	7262696c 	.word	0x7262696c
   11378:	20797261 	.word	0x20797261
   1137c:	6574756d 	.word	0x6574756d
   11380:	6e692078 	.word	0x6e692078
   11384:	61697469 	.word	0x61697469
   11388:	617a696c 	.word	0x617a696c
   1138c:	6e6f6974 	.word	0x6e6f6974
   11390:	69616620 	.word	0x69616620
   11394:	0064656c 	.word	0x0064656c
   11398:	49534d43 	.word	0x49534d43
   1139c:	54522d53 	.word	0x54522d53
   113a0:	6520534f 	.word	0x6520534f
   113a4:	726f7272 	.word	0x726f7272
   113a8:	6e55203a 	.word	0x6e55203a
   113ac:	776f6e6b 	.word	0x776f6e6b
   113b0:	0000006e 	.word	0x0000006e
   113b4:	70736e55 	.word	0x70736e55
   113b8:	66696365 	.word	0x66696365
   113bc:	20646569 	.word	0x20646569
   113c0:	534f5452 	.word	0x534f5452
   113c4:	72726520 	.word	0x72726520
   113c8:	0000726f 	.word	0x0000726f
   113cc:	7265704f 	.word	0x7265704f
   113d0:	6f697461 	.word	0x6f697461
   113d4:	6f6e206e 	.word	0x6f6e206e
   113d8:	6f632074 	.word	0x6f632074
   113dc:	656c706d 	.word	0x656c706d
   113e0:	20646574 	.word	0x20646574
   113e4:	68746977 	.word	0x68746977
   113e8:	74206e69 	.word	0x74206e69
   113ec:	74206568 	.word	0x74206568
   113f0:	6f656d69 	.word	0x6f656d69
   113f4:	70207475 	.word	0x70207475
   113f8:	6f697265 	.word	0x6f697265
   113fc:	00000064 	.word	0x00000064
   11400:	6f736552 	.word	0x6f736552
   11404:	65637275 	.word	0x65637275
   11408:	746f6e20 	.word	0x746f6e20
   1140c:	61766120 	.word	0x61766120
   11410:	62616c69 	.word	0x62616c69
   11414:	0000656c 	.word	0x0000656c
   11418:	61726150 	.word	0x61726150
   1141c:	6574656d 	.word	0x6574656d
   11420:	72652072 	.word	0x72652072
   11424:	00726f72 	.word	0x00726f72
   11428:	74737953 	.word	0x74737953
   1142c:	69206d65 	.word	0x69206d65
   11430:	756f2073 	.word	0x756f2073
   11434:	666f2074 	.word	0x666f2074
   11438:	6d656d20 	.word	0x6d656d20
   1143c:	0079726f 	.word	0x0079726f
   11440:	20746f4e 	.word	0x20746f4e
   11444:	6f6c6c61 	.word	0x6f6c6c61
   11448:	20646577 	.word	0x20646577
   1144c:	49206e69 	.word	0x49206e69
   11450:	63205253 	.word	0x63205253
   11454:	65746e6f 	.word	0x65746e6f
   11458:	00007478 	.word	0x00007478
   1145c:	6e6b6e55 	.word	0x6e6b6e55
   11460:	006e776f 	.word	0x006e776f
   11464:	20585452 	.word	0x20585452
   11468:	332e3556 	.word	0x332e3556
   1146c:	0000302e 	.word	0x0000302e
   11470:	656c6469 	.word	0x656c6469
   11474:	7268745f 	.word	0x7268745f
   11478:	00646165 	.word	0x00646165
   1147c:	656d6974 	.word	0x656d6974
   11480:	68745f72 	.word	0x68745f72
   11484:	64616572 	.word	0x64616572
   11488:	00000000 	.word	0x00000000

0001148c <osRtxConfig>:
   1148c:	00000007 000003e8 00000005 20000e30     ............0.. 
   1149c:	00000010 00000000 00000000 00000000     ................
	...
   114e0:	00001000 000125cc 000125f0 00012614     .....%...%...&..
   114f0:	00000004                                ....

000114f4 <os_cb_sections>:
	...
   1152c:	74785f67 46306c61 00716572 626d2f2e     g_xtal0Freq../mb
   1153c:	6f2d6465 61742f73 74656772 41542f73     ed-os/targets/TA
   1154c:	54454752 6572465f 61637365 542f656c     RGET_Freescale/T
   1155c:	45475241 434d5f54 72705855 6f737365     ARGET_MCUXpresso
   1156c:	55434d5f 41542f53 54454752 55434d5f     _MCUS/TARGET_MCU
   1157c:	34364b5f 72642f46 72657669 73662f73     _K64F/drivers/fs
   1158c:	6c635f6c 2e6b636f 00000063 74785f67     l_clock.c...g_xt
   1159c:	32336c61 71657246 00000000 7067636d     al32Freq....mcgp
   115ac:	63306c6c 00006b6c 666e6f63 00006769     ll0clk..config..
   115bc:	74736e69 65636e61 41203c20 59415252     instance < ARRAY
   115cc:	5a49535f 5f732845 69707364 65736142     _SIZE(s_dspiBase
   115dc:	00002973 626d2f2e 6f2d6465 61742f73     s).../mbed-os/ta
   115ec:	74656772 41542f73 54454752 6572465f     rgets/TARGET_Fre
   115fc:	61637365 542f656c 45475241 434d5f54     escale/TARGET_MC
   1160c:	72705855 6f737365 55434d5f 41542f53     UXpresso_MCUS/TA
   1161c:	54454752 55434d5f 34364b5f 72642f46     RGET_MCU_K64F/dr
   1162c:	72657669 73662f73 73645f6c 632e6970     ivers/fsl_dspi.c
   1163c:	00000000 7473616d 6f437265 6769666e     ....masterConfig
   1164c:	00000000 736c6166 00000065 76616c73     ....false...slav
   1165c:	6e6f4365 00676966 6d6d6f63 00646e61     eConfig.command.
   1166c:	646e6168 0000656c 6e617274 72656673     handle..transfer
   1167c:	00000000 73645f67 61486970 656c646e     ....g_dspiHandle
   1168c:	005d305b 73645f67 61486970 656c646e     [0].g_dspiHandle
   1169c:	005d315b 73645f67 61486970 656c646e     [1].g_dspiHandle
   116ac:	005d325b 74736e69 65636e61 46203c20     [2].instance < F
   116bc:	465f4c53 55544145 535f4552 455f434f     SL_FEATURE_SOC_E
   116cc:	5f414d44 4e554f43 00000054 626d2f2e     DMA_COUNT..../mb
   116dc:	6f2d6465 61742f73 74656772 41542f73     ed-os/targets/TA
   116ec:	54454752 6572465f 61637365 542f656c     RGET_Freescale/T
   116fc:	45475241 434d5f54 72705855 6f737365     ARGET_MCUXpresso
   1170c:	55434d5f 41542f53 54454752 55434d5f     _MCUS/TARGET_MCU
   1171c:	34364b5f 72642f46 72657669 73662f73     _K64F/drivers/fs
   1172c:	64655f6c 632e616d 00000000 6e616863     l_edma.c....chan
   1173c:	206c656e 5346203c 45465f4c 52555441     nel < FSL_FEATUR
   1174c:	44455f45 4d5f414d 4c55444f 48435f45     E_EDMA_MODULE_CH
   1175c:	454e4e41 0000004c 20646374 4e203d21     ANNEL...tcd != N
   1176c:	004c4c55 69752828 3233746e 7429745f     ULL.((uint32_t)t
   1177c:	26206463 31783020 20295546 30203d3d     cd & 0x1FU) == 0
   1178c:	00000000 666e6f63 21206769 554e203d     ....config != NU
   1179c:	00004c4c 69752828 3233746e 6e29745f     LL..((uint32_t)n
   117ac:	54747865 26206463 31783020 20295546     extTcd & 0x1FU) 
   117bc:	30203d3d 00000000 6b6e696c 68436465     == 0....linkedCh
   117cc:	656e6e61 203c206c 5f4c5346 54414546     annel < FSL_FEAT
   117dc:	5f455255 414d4445 444f4d5f 5f454c55     URE_EDMA_MODULE_
   117ec:	4e414843 004c454e 646e6168 2120656c     CHANNEL.handle !
   117fc:	554e203d 00004c4c 69752828 3233746e     = NULL..((uint32
   1180c:	7429745f 6f506463 26206c6f 31783020     _t)tcdPool & 0x1
   1181c:	20295546 30203d3d 00000000 41637273     FU) == 0....srcA
   1182c:	20726464 4e203d21 004c4c55 74736564     ddr != NULL.dest
   1183c:	72646441 203d2120 4c4c554e 00000000     Addr != NULL....
   1184c:	63727328 74646957 3d3d2068 29553120     (srcWidth == 1U)
   1185c:	207c7c20 63727328 74646957 3d3d2068      || (srcWidth ==
   1186c:	29553220 207c7c20 63727328 74646957      2U) || (srcWidt
   1187c:	3d3d2068 29553420 207c7c20 63727328     h == 4U) || (src
   1188c:	74646957 3d3d2068 55363120 7c7c2029     Width == 16U) ||
   1189c:	72732820 64695763 3d206874 3233203d      (srcWidth == 32
   118ac:	00002955 73656428 64695774 3d206874     U)..(destWidth =
   118bc:	5531203d 7c7c2029 65642820 69577473     = 1U) || (destWi
   118cc:	20687464 32203d3d 7c202955 6428207c     dth == 2U) || (d
   118dc:	57747365 68746469 203d3d20 20295534     estWidth == 4U) 
   118ec:	28207c7c 74736564 74646957 3d3d2068     || (destWidth ==
   118fc:	55363120 7c7c2029 65642820 69577473      16U) || (destWi
   1190c:	20687464 33203d3d 00295532 6e617274     dth == 32U).tran
   1191c:	72656673 65747942 20252073 65747962     sferBytes % byte
   1192c:	63614573 71655268 74736575 203d3d20     sEachRequest == 
   1193c:	00000030 74736e69 65636e61 46203c20     0...instance < F
   1194c:	465f4c53 55544145 535f4552 465f434f     SL_FEATURE_SOC_F
   1195c:	4358454c 435f4e41 544e554f 00000000     LEXCAN_COUNT....
   1196c:	626d2f2e 6f2d6465 61742f73 74656772     ./mbed-os/target
   1197c:	41542f73 54454752 6572465f 61637365     s/TARGET_Freesca
   1198c:	542f656c 45475241 434d5f54 72705855     le/TARGET_MCUXpr
   1199c:	6f737365 55434d5f 41542f53 54454752     esso_MCUS/TARGET
   119ac:	55434d5f 34364b5f 72642f46 72657669     _MCU_K64F/driver
   119bc:	73662f73 6c665f6c 61637865 00632e6e     s/fsl_flexcan.c.
   119cc:	6449626d 203c2078 5f4c5346 54414546     mbIdx < FSL_FEAT
   119dc:	5f455255 58454c46 5f4e4143 5f534148     URE_FLEXCAN_HAS_
   119ec:	5353454d 5f454741 46465542 4d5f5245     MESSAGE_BUFFER_M
   119fc:	4e5f5841 45424d55 62286e52 29657361     AX_NUMBERn(base)
   11a0c:	00000000 61622821 3e2d6573 2052434d     ....!(base->MCR 
   11a1c:	41432026 434d5f4e 444d5f52 4d5f5349     & CAN_MCR_MDIS_M
   11a2c:	294b5341 00000000 64756162 65746152     ASK)....baudRate
   11a3c:	7370425f 203d3c20 30303031 55303030     _Bps <= 1000000U
   11a4c:	00000000 44697270 3c207669 6f73203d     ....priDiv <= so
   11a5c:	65637275 636f6c43 7a485f6b 00000000     urceClock_Hz....
   11a6c:	666e6f63 00006769 6e6f6328 2d676966     config..(config-
   11a7c:	78616d3e 754e624d 203e206d 26202930     >maxMbNum > 0) &
   11a8c:	63282026 69666e6f 6d3e2d67 624d7861     & (config->maxMb
   11a9c:	206d754e 46203d3c 465f4c53 55544145     Num <= FSL_FEATU
   11aac:	465f4552 4358454c 485f4e41 4d5f5341     RE_FLEXCAN_HAS_M
   11abc:	41535345 425f4547 45464655 414d5f52     ESSAGE_BUFFER_MA
   11acc:	554e5f58 5245424d 6162286e 29296573     X_NUMBERn(base))
   11adc:	00000000 6b73616d 20786449 28203d3c     ....maskIdx <= (
   11aec:	65736162 434d3e2d 20262052 5f4e4143     base->MCR & CAN_
   11afc:	5f52434d 4d58414d 414d5f42 00294b53     MCR_MAXMB_MASK).
   11b0c:	6449626d 3d3c2078 61622820 3e2d6573     mbIdx <= (base->
   11b1c:	2052434d 41432026 434d5f4e 414d5f52     MCR & CAN_MCR_MA
   11b2c:	5f424d58 4b53414d 00000029 454c4621     XMB_MASK)...!FLE
   11b3c:	4e414358 4d73495f 63634f62 65697075     XCAN_IsMbOccupie
   11b4c:	61622864 202c6573 6449626d 00002978     d(base, mbIdx)..
   11b5c:	6f632828 6769666e 7c7c2029 61662820     ((config) || (fa
   11b6c:	2065736c 65203d3d 6c62616e 00292965     lse == enable)).
   11b7c:	6e6f6328 29676966 207c7c20 6c616628     (config) || (fal
   11b8c:	3d206573 6e65203d 656c6261 00000029     se == enable)...
   11b9c:	666e6f63 3e2d6769 69466469 7265746c     config->idFilter
   11bac:	206d754e 31203d3c 00003832 65732828     Num <= 128..((se
   11bbc:	5f707574 2d20626d 20293820 3228202d     tup_mb - 8) - (2
   11bcc:	72202a20 296e6666 203e2029 00000030      * rffn)) > 0...
   11bdc:	72467874 00656d61 72467874 2d656d61     txFrame.txFrame-
   11bec:	6e656c3e 20687467 38203d3c 00000000     >length <= 8....
   11bfc:	72467872 00656d61 646e6168 0000656c     rxFrame.handle..
   11c0c:	72656678 00000000 72656678 626d3e2d     xfer....xfer->mb
   11c1c:	20786449 28203d3c 65736162 434d3e2d     Idx <= (base->MC
   11c2c:	20262052 5f4e4143 5f52434d 4d58414d     R & CAN_MCR_MAXM
   11c3c:	414d5f42 00294b53 454c4621 4e414358     B_MASK).!FLEXCAN
   11c4c:	4d73495f 63634f62 65697075 61622864     _IsMbOccupied(ba
   11c5c:	202c6573 72656678 626d3e2d 29786449     se, xfer->mbIdx)
   11c6c:	00000000 6c665f73 61637865 6e61486e     ....s_flexcanHan
   11c7c:	5b656c64 00005d30 74736e69 65636e61     dle[0]..instance
   11c8c:	46203c20 465f4c53 55544145 535f4552      < FSL_FEATURE_S
   11c9c:	505f434f 435f5449 544e554f 00000000     OC_PIT_COUNT....
   11cac:	626d2f2e 6f2d6465 61742f73 74656772     ./mbed-os/target
   11cbc:	41542f73 54454752 6572465f 61637365     s/TARGET_Freesca
   11ccc:	542f656c 45475241 434d5f54 72705855     le/TARGET_MCUXpr
   11cdc:	6f737365 55434d5f 41542f53 54454752     esso_MCUS/TARGET
   11cec:	55434d5f 34364b5f 72642f46 72657669     _MCU_K64F/driver
   11cfc:	73662f73 69705f6c 00632e74 666e6f63     s/fsl_pit.c.conf
   11d0c:	00006769 74736e69 65636e61 46203c20     ig..instance < F
   11d1c:	465f4c53 55544145 535f4552 495f434f     SL_FEATURE_SOC_I
   11d2c:	435f5332 544e554f 00000000 626d2f2e     2S_COUNT...../mb
   11d3c:	6f2d6465 61742f73 74656772 41542f73     ed-os/targets/TA
   11d4c:	54454752 6572465f 61637365 542f656c     RGET_Freescale/T
   11d5c:	45475241 434d5f54 72705855 6f737365     ARGET_MCUXpresso
   11d6c:	55434d5f 41542f53 54454752 55434d5f     _MCUS/TARGET_MCU
   11d7c:	34364b5f 72642f46 72657669 73662f73     _K64F/drivers/fs
   11d8c:	61735f6c 00632e69 646e6168 0000656c     l_sai.c.handle..
   11d9c:	61735f73 6e614869 5b656c64 305b5d30     s_saiHandle[0][0
   11dac:	0000005d 61735f73 6e614869 5b656c64     ]...s_saiHandle[
   11dbc:	315b5d30 0000005d 65646e69 203c2078     0][1]...index < 
   11dcc:	00005534 626d2f2e 6f2d6465 61742f73     4U.../mbed-os/ta
   11ddc:	74656772 41542f73 54454752 6572465f     rgets/TARGET_Fre
   11dec:	61637365 542f656c 45475241 434d5f54     escale/TARGET_MC
   11dfc:	72705855 6f737365 55434d5f 41542f53     UXpresso_MCUS/TA
   11e0c:	54454752 55434d5f 34364b5f 72642f46     RGET_MCU_K64F/dr
   11e1c:	72657669 73662f73 64735f6c 682e6368     ivers/fsl_sdhc.h
   11e2c:	00000000 74736e69 65636e61 46203c20     ....instance < F
   11e3c:	465f4c53 55544145 535f4552 535f434f     SL_FEATURE_SOC_S
   11e4c:	5f434844 4e554f43 00000054 626d2f2e     DHC_COUNT..../mb
   11e5c:	6f2d6465 61742f73 74656772 41542f73     ed-os/targets/TA
   11e6c:	54454752 6572465f 61637365 542f656c     RGET_Freescale/T
   11e7c:	45475241 434d5f54 72705855 6f737365     ARGET_MCUXpresso
   11e8c:	55434d5f 41542f53 54454752 55434d5f     _MCUS/TARGET_MCU
   11e9c:	34364b5f 72642f46 72657669 73662f73     _K64F/drivers/fs
   11eac:	64735f6c 632e6368 00000000 646e6168     l_sdhc.c....hand
   11ebc:	3e2d656c 6d6d6f63 00646e61 646e6168     le->command.hand
   11ecc:	3e2d656c 61746164 00000000 666e6f63     le->data....conf
   11edc:	00006769 666e6f63 3e2d6769 4d616d64     ig..config->dmaM
   11eec:	2065646f 6b203d21 43484453 616d445f     ode != kSDHC_Dma
   11efc:	65646f4d 616d6441 00000031 6e6f6328     ModeAdma1...(con
   11f0c:	2d676966 6972773e 61576574 6d726574     fig->writeWaterm
   11f1c:	4c6b7261 6c657665 203d3e20 20295531     arkLevel >= 1U) 
   11f2c:	28202626 666e6f63 3e2d6769 74697277     && (config->writ
   11f3c:	74615765 616d7265 654c6b72 206c6576     eWatermarkLevel 
   11f4c:	31203d3c 29553832 00000000 6e6f6328     <= 128U)....(con
   11f5c:	2d676966 6165723e 74615764 616d7265     fig->readWaterma
   11f6c:	654c6b72 206c6576 31203d3e 26202955     rkLevel >= 1U) &
   11f7c:	63282026 69666e6f 723e2d67 57646165     & (config->readW
   11f8c:	72657461 6b72616d 6576654c 3d3c206c     atermarkLevel <=
   11f9c:	38323120 00002955 61706163 696c6962      128U)..capabili
   11fac:	00007974 43637273 6b636f6c 207a485f     ty..srcClock_Hz 
   11fbc:	30203d21 00000055 73756228 636f6c43     != 0U...(busCloc
   11fcc:	7a485f6b 203d2120 20295530 28202626     k_Hz != 0U) && (
   11fdc:	43737562 6b636f6c 207a485f 73203d3c     busClock_Hz <= s
   11fec:	6c436372 5f6b636f 00297a48 666e6f63     rcClock_Hz).conf
   11ffc:	3e2d6769 61746164 636f6c42 7a69536b     ig->dataBlockSiz
   1200c:	3d3c2065 44532820 425f4348 54414b4c     e <= (SDHC_BLKAT
   1201c:	425f5254 49534b4c 4d5f455a 204b5341     TR_BLKSIZE_MASK 
   1202c:	53203e3e 5f434844 414b4c42 5f525454     >> SDHC_BLKATTR_
   1203c:	534b4c42 5f455a49 46494853 00002954     BLKSIZE_SHIFT)..
   1204c:	666e6f63 3e2d6769 61746164 636f6c42     config->dataBloc
   1205c:	756f436b 3c20746e 5328203d 5f434844     kCount <= (SDHC_
   1206c:	414b4c42 5f525454 434b4c42 4d5f544e     BLKATTR_BLKCNT_M
   1207c:	204b5341 53203e3e 5f434844 414b4c42     ASK >> SDHC_BLKA
   1208c:	5f525454 434b4c42 535f544e 54464948     TTR_BLKCNT_SHIFT
   1209c:	00000029 666e6f63 3e2d6769 546b6361     )...config->ackT
   120ac:	6f656d69 6f437475 20746e75 28203d3c     imeoutCount <= (
   120bc:	43484453 434d4d5f 544f4f42 4f54445f     SDHC_MMCBOOT_DTO
   120cc:	43415643 414d5f4b 3e204b53 4453203e     CVACK_MASK >> SD
   120dc:	4d5f4348 4f42434d 445f544f 56434f54     HC_MMCBOOT_DTOCV
   120ec:	5f4b4341 46494853 00002954 666e6f63     ACK_SHIFT)..conf
   120fc:	3e2d6769 636f6c62 756f436b 3c20746e     ig->blockCount <
   1210c:	5328203d 5f434844 42434d4d 5f544f4f     = (SDHC_MMCBOOT_
   1211c:	544f4f42 434b4c42 4d5f544e 204b5341     BOOTBLKCNT_MASK 
   1212c:	53203e3e 5f434844 42434d4d 5f544f4f     >> SDHC_MMCBOOT_
   1213c:	544f4f42 434b4c42 535f544e 54464948     BOOTBLKCNT_SHIFT
   1214c:	00000029 6e617274 72656673 00000000     )...transfer....
   1215c:	646e6168 0000656c 6c6c6163 6b636162     handle..callback
   1216c:	00000000 64735f73 61486368 656c646e     ....s_sdhcHandle
   1217c:	005d305b 74736e69 65636e61 75203c20     [0].instance < u
   1218c:	41747261 79617272 6e756f43 00000074     artArrayCount...
   1219c:	626d2f2e 6f2d6465 61742f73 74656772     ./mbed-os/target
   121ac:	41542f73 54454752 6572465f 61637365     s/TARGET_Freesca
   121bc:	542f656c 45475241 434d5f54 72705855     le/TARGET_MCUXpr
   121cc:	6f737365 55434d5f 41542f53 54454752     esso_MCUS/TARGET
   121dc:	55434d5f 34364b5f 72642f46 72657669     _MCU_K64F/driver
   121ec:	73662f73 61755f6c 632e7472 00000000     s/fsl_uart.c....
   121fc:	646e6168 0000656c 666e6f63 00006769     handle..config..
   1220c:	666e6f63 3e2d6769 64756162 65746152     config->baudRate
   1221c:	7370425f 00000000 5f4c5346 54414546     _Bps....FSL_FEAT
   1222c:	5f455255 54524155 4649465f 49535f4f     URE_UART_FIFO_SI
   1223c:	286e455a 65736162 3d3e2029 6e6f6320     ZEn(base) >= con
   1224c:	2d676966 4678743e 576f6669 72657461     fig->txFifoWater
   1225c:	6b72616d 00000000 5f4c5346 54414546     mark....FSL_FEAT
   1226c:	5f455255 54524155 4649465f 49535f4f     URE_UART_FIFO_SI
   1227c:	286e455a 65736162 3d3e2029 6e6f6320     ZEn(base) >= con
   1228c:	2d676966 4678723e 576f6669 72657461     fig->rxFifoWater
   1229c:	6b72616d 00000000 64756162 65746152     mark....baudRate
   122ac:	7370425f 00000000 61746164 00000000     _Bps....data....
   122bc:	676e6972 66667542 00007265 72656678     ringBuffer..xfer
   122cc:	00000000 72656678 61643e2d 69536174     ....xfer->dataSi
   122dc:	0000657a 72656678 61643e2d 00006174     ze..xfer->data..
   122ec:	6e756f63 00000074 626d2f2e 6f2d6465     count..../mbed-o
   122fc:	61742f73 74656772 41542f73 54454752     s/targets/TARGET
   1230c:	6572465f 61637365 542f656c 45475241     _Freescale/TARGE
   1231c:	434d5f54 72705855 6f737365 55434d5f     T_MCUXpresso_MCU
   1232c:	41542f53 54454752 55434d5f 34364b5f     S/TARGET_MCU_K64
   1233c:	65732f46 6c616972 6970615f 0000632e     F/serial_api.c..
   1234c:	746e6928 6a626f29 65733e2d 6c616972     (int)obj->serial
   1235c:	646e692e 21207865 434e203d 00000000     .index != NC....
   1236c:	00000030 2523211f 00004442 01040102     0....!#%BD......
   1237c:	01080106 010b010a 01050103 01090107     ................
   1238c:	010b010a 21207874 7628203d 2a64696f     ....tx != (void*
   1239c:	00003029 74646977 3d3d2068 00003820     )0..width == 8..
   123ac:	21207872 7628203d 2a64696f 00003029     rx != (void*)0..
   123bc:	666e6f63 00006769 626d2f2e 6f2d6465     config.../mbed-o
   123cc:	61742f73 74656772 41542f73 54454752     s/targets/TARGET
   123dc:	6572465f 61637365 542f656c 45475241     _Freescale/TARGE
   123ec:	434d5f54 72705855 6f737365 55434d5f     T_MCUXpresso_MCU
   123fc:	41542f53 54454752 55434d5f 34364b5f     S/TARGET_MCU_K64
   1240c:	72642f46 72657669 73662f73 69705f6c     F/drivers/fsl_pi
   1241c:	00682e74 626d2f2e 6f2d6465 61742f73     t.h../mbed-os/ta
   1242c:	74656772 41542f73 54454752 6572465f     rgets/TARGET_Fre
   1243c:	61637365 542f656c 45475241 434d5f54     escale/TARGET_MC
   1244c:	72705855 6f737365 55434d5f 70612f53     UXpresso_MCUS/ap
   1245c:	70672f69 615f6f69 632e6970 00000000     i/gpio_api.c....
   1246c:	206e6970 28203d21 4e6e6950 29656d61     pin != (PinName)
   1247c:	0000434e 2d6a626f 6e69703e 203d2120     NC..obj->pin != 
   1248c:	6e695028 656d614e 00434e29 626d2f2e     (PinName)NC../mb
   1249c:	6f2d6465 61742f73 74656772 41542f73     ed-os/targets/TA
   124ac:	54454752 6572465f 61637365 542f656c     RGET_Freescale/T
   124bc:	45475241 434d5f54 72705855 6f737365     ARGET_MCUXpresso
   124cc:	55434d5f 70612f53 69702f69 70616d6e     _MCUS/api/pinmap
   124dc:	0000632e 206e6970 28203d21 4e6e6950     .c..pin != (PinN
   124ec:	29656d61 0000434e 10380009 1038000a     ame)NC....8...8.
   124fc:	1038000b 1038000c 1038000d              ..8...8...8.

00012508 <us_interface>:
   12508:	00009ea1 00009f71 00009f89 00009f9d     ....q...........
   12518:	00009fb1 0000a021 00009e61              ....!...a...

00012524 <us_data>:
   12524:	00012508 20000c70                       .%..p.. 

0001252c <_ZTVN4mbed10FileHandleE>:
	...
   1253c:	000039d7 000039d7 000039d7 000039d7     .9...9...9...9..
   1254c:	00002729 00002735 00001aa1 00001ac1     )'..5'..........
   1255c:	00002741 000019bd 000019e1 000019fd     A'..............
   1256c:	00001a19 00001a39 00001a45 00001a57     ....9...E...W...

0001257c <_ZTV12DirectSerial>:
	...
   12584:	00003c0d 00003c31 00003299 00003259     .<..1<...2..Y2..
   12594:	000031d1 000031fd 00002729 000031f1     .1...1..)'...1..
   125a4:	00001aa1 00001ac1 000031e3 000019bd     .........1......
   125b4:	000019e1 000019fd 00001a19 00001a39     ............9...
   125c4:	000032cd 00001a57                       .2..W...

000125cc <os_idle_thread_attr>:
   125cc:	00011470 00000000 20000e70 00000048     p.......p.. H...
   125dc:	20000f00 00000200 00000001 00000001     ... ............
   125ec:	00000000                                ....

000125f0 <os_timer_thread_attr>:
   125f0:	0001147c 00000000 20000eb8 00000048     |.......... H...
   12600:	20001100 00000300 00000028 00000001     ... ....(.......
   12610:	00000000                                ....

00012614 <os_timer_mq_attr>:
	...
   1261c:	20001400 00000034 20001434 00000050     ... 4...4.. P...

0001262c <osRtxUserSVC>:
   1262c:	00000000                                ....

00012630 <PinMap_UART_TX>:
   12630:	00001011 00000000 00000003 00002011     ............. ..
   12640:	00000003 00000003 00003007 00000000     .........0......
   12650:	00000003 00003003 00000002 00000003     .....0..........
   12660:	00002004 00000001 00000003 0000200f     . ........... ..
   12670:	00000004 00000003 0000100b 00000003     ................
   12680:	00000003 0000000e 00000000 00000003     ................
   12690:	00004018 00000004 00000003 00004004     .@...........@..
   126a0:	00000003 00000003 00004000 00000001     .........@......
   126b0:	00000003 ffffffff ffffffff 00000000     ................

000126c0 <PinMap_UART_RX>:
   126c0:	00001010 00000000 00000003 00004001     .............@..
   126d0:	00000001 00000003 00004005 00000003     .........@......
   126e0:	00000003 00004019 00000004 00000003     .....@..........
   126f0:	0000000f 00000000 00000003 00002010     ............. ..
   12700:	00000003 00000003 0000100a 00000003     ................
   12710:	00000003 00002003 00000001 00000003     ..... ..........
   12720:	0000200e 00000004 00000003 00003002     . ...........0..
   12730:	00000002 00000003 00003006 00000000     .........0......
   12740:	00000003 ffffffff ffffffff 00000000     ................

00012750 <g_defaultClockConfigRun>:
   12750:	00000207 00000007 00181300 00000201     ................
   12760:	01140000 02faf080 00800000 07270e00     ..............'.

00012770 <__func__.7523>:
   12770:	434f4c43 65475f4b 67634d74 43747845     CLOCK_GetMcgExtC
   12780:	72466b6c 00007165                       lkFreq..

00012788 <__func__.7568>:
   12788:	434f4c43 65475f4b 63734f74 43724530     CLOCK_GetOsc0ErC
   12798:	72466b6c 00007165                       lkFreq..

000127a0 <__func__.7576>:
   127a0:	434f4c43 65475f4b 33724574 6c436b32     CLOCK_GetEr32kCl
   127b0:	6572466b 00000071                       kFreq...

000127b8 <fllFactorTable.7651>:
   127b8:	02dc0280 05b80500 08950780 0b710a00     ..............q.

000127c8 <__func__.7666>:
   127c8:	434f4c43 65475f4b 6c6c5074 65724630     CLOCK_GetPll0Fre
   127d8:	00000071                                q...

000127dc <__func__.7714>:
   127dc:	434f4c43 6e455f4b 656c6261 306c6c50     CLOCK_EnablePll0
   127ec:	00000000                                ....

000127f0 <__func__.7850>:
   127f0:	434f4c43 65535f4b 65625074 65646f4d     CLOCK_SetPbeMode
   12800:	00000000                                ....

00012804 <__func__.7914>:
   12804:	434f4c43 6f425f4b 6f54746f 4d656550     CLOCK_BootToPeeM
   12814:	0065646f                                ode.

00012818 <__func__.8198>:
   12818:	30495053 6972445f 49726576 61485152     SPI0_DriverIRQHa
   12828:	656c646e 00000072                       ndler...

00012830 <__func__.8202>:
   12830:	31495053 6972445f 49726576 61485152     SPI1_DriverIRQHa
   12840:	656c646e 00000072                       ndler...

00012848 <__func__.8206>:
   12848:	32495053 6972445f 49726576 61485152     SPI2_DriverIRQHa
   12858:	656c646e 00000072                       ndler...

00012860 <__func__.8001>:
   12860:	414d4445 6e61485f 49656c64 00005152     EDMA_HandleIRQ..

00012870 <__func__.8066>:
   12870:	304e4143 6972445f 49726576 61485152     CAN0_DriverIRQHa
   12880:	656c646e 00000072                       ndler...

00012888 <__func__.7572>:
   12888:	5f544950 49746547 6174736e 0065636e     PIT_GetInstance.

00012898 <__func__.7577>:
   12898:	5f544950 74696e49 00000000              PIT_Init....

000128a4 <__func__.8050>:
   128a4:	30533249 5f78545f 76697244 52497265     I2S0_Tx_DriverIR
   128b4:	6e614851 72656c64 00000000              QHandler....

000128c0 <__func__.8054>:
   128c0:	30533249 5f78525f 76697244 52497265     I2S0_Rx_DriverIR
   128d0:	6e614851 72656c64 00000000              QHandler....

000128dc <__func__.8238>:
   128dc:	43484453 6972445f 49726576 61485152     SDHC_DriverIRQHa
   128ec:	656c646e 00000072                       ndler...

000128f4 <s_uartBases>:
   128f4:	4006a000 4006b000 4006c000 4006d000     ...@...@...@...@
   12904:	400ea000 400eb000                       ...@...@

0001290c <s_uartClock>:
   1290c:	1034000a 1034000b 1034000c 1034000d     ..4...4...4...4.
   1291c:	1028000a 1028000b                       ..(...(.

00012924 <__func__.7722>:
   12924:	54524155 7465475f 74736e49 65636e61     UART_GetInstance
   12934:	00000000                                ....

00012938 <__func__.7738>:
   12938:	54524155 696e495f 00000074              UART_Init...

00012944 <__func__.7756>:
   12944:	54524155 7465475f 61666544 43746c75     UART_GetDefaultC
   12954:	69666e6f 00000067                       onfig...

0001295c <__func__.7762>:
   1295c:	54524155 7465535f 64756142 65746152     UART_SetBaudRate
   1296c:	00000000                                ....

00012970 <uart_addrs>:
   12970:	4006a000 4006b000 4006c000 4006d000     ...@...@...@...@
   12980:	400ea000 400eb000                       ...@...@

00012988 <uart_clocks>:
   12988:	02020000 00000202                       ........

00012990 <info.9334>:
   12990:	000f4240 00000020                       @B.. ...

00012998 <__func__.9282>:
   12998:	5f544950 44746547 75616665 6f43746c     PIT_GetDefaultCo
   129a8:	6769666e 00000000                       nfig....

000129b0 <gpio_addrs>:
   129b0:	400ff000 400ff040 400ff080 400ff0c0     ...@@..@...@...@
   129c0:	400ff100                                ...@

000129c4 <port_addrs>:
   129c4:	40049000 4004a000 4004b000 4004c000     ...@...@...@...@
   129d4:	4004d000 7566202c 6974636e 203a6e6f     ...@, function: 
   129e4:	00000000 65737361 6f697472 2522206e     ....assertion "%
   129f4:	66202273 656c6961 66203a64 20656c69     s" failed: file 
   12a04:	22732522 696c202c 2520656e 25732564     "%s", line %d%s%
   12a14:	00000a73                                s...

00012a18 <_global_impure_ptr>:
   12a18:	200001c8 00000043 49534f50 00000058     ... C...POSIX...
   12a28:	0000002e 00464e49 00666e69 004e414e     ....INF.inf.NAN.
   12a38:	006e616e 33323130 37363534 42413938     nan.0123456789AB
   12a48:	46454443 00000000 33323130 37363534     CDEF....01234567
   12a58:	62613938 66656463 00000000 6c756e28     89abcdef....(nul
   12a68:	0000296c 00000030                       l)..0...

00012a70 <blanks.8346>:
   12a70:	20202020 20202020 20202020 20202020                     

00012a80 <zeroes.8347>:
   12a80:	30303030 30303030 30303030 30303030     0000000000000000

00012a90 <blanks.8340>:
   12a90:	20202020 20202020 20202020 20202020                     

00012aa0 <zeroes.8341>:
   12aa0:	30303030 30303030 30303030 30303030     0000000000000000

00012ab0 <blanks.8361>:
   12ab0:	20202020 20202020 20202020 20202020                     

00012ac0 <zeroes.8362>:
   12ac0:	30303030 30303030 30303030 30303030     0000000000000000

00012ad0 <_ctype_>:
   12ad0:	20202000 20202020 28282020 20282828     .         ((((( 
   12ae0:	20202020 20202020 20202020 20202020                     
   12af0:	10108820 10101010 10101010 10101010      ...............
   12b00:	04040410 04040404 10040404 10101010     ................
   12b10:	41411010 41414141 01010101 01010101     ..AAAAAA........
   12b20:	01010101 01010101 01010101 10101010     ................
   12b30:	42421010 42424242 02020202 02020202     ..BBBBBB........
   12b40:	02020202 02020202 02020202 10101010     ................
   12b50:	00000020 00000000 00000000 00000000      ...............
	...
   12bd4:	69666e49 7974696e 00000000 004e614e     Infinity....NaN.
   12be4:	00000000                                ....

00012be8 <__mprec_bigtens>:
   12be8:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
   12bf8:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
   12c08:	7f73bf3c 75154fdd                       <.s..O.u

00012c10 <__mprec_tens>:
   12c10:	00000000 3ff00000 00000000 40240000     .......?......$@
   12c20:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
   12c30:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
   12c40:	00000000 412e8480 00000000 416312d0     .......A......cA
   12c50:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
   12c60:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
   12c70:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
   12c80:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
   12c90:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
   12ca0:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
   12cb0:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
   12cc0:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
   12cd0:	79d99db4 44ea7843                       ...yCx.D

00012cd8 <p05.7178>:
   12cd8:	00000005 00000019 0000007d              ........}...

00012ce4 <_init>:
   12ce4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12ce6:	bf00      	nop
   12ce8:	bcf8      	pop	{r3, r4, r5, r6, r7}
   12cea:	bc08      	pop	{r3}
   12cec:	469e      	mov	lr, r3
   12cee:	4770      	bx	lr

00012cf0 <_fini>:
   12cf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12cf2:	bf00      	nop
   12cf4:	bcf8      	pop	{r3, r4, r5, r6, r7}
   12cf6:	bc08      	pop	{r3}
   12cf8:	469e      	mov	lr, r3
   12cfa:	4770      	bx	lr
