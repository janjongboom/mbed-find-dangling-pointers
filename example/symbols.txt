
example/example.elf:     file format elf32-littlearm


Disassembly of section .text:

00000410 <__do_global_dtors_aux>:
     410:	b510      	push	{r4, lr}
     412:	4c05      	ldr	r4, [pc, #20]	; (428 <__UVISOR_FLASH_OFFSET+0x18>)
     414:	7823      	ldrb	r3, [r4, #0]
     416:	b933      	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	4b04      	ldr	r3, [pc, #16]	; (42c <__UVISOR_FLASH_OFFSET+0x1c>)
     41a:	b113      	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	4804      	ldr	r0, [pc, #16]	; (430 <__UVISOR_FLASH_OFFSET+0x20>)
     41e:	f3af 8000 	nop.w
     422:	2301      	movs	r3, #1
     424:	7023      	strb	r3, [r4, #0]
     426:	bd10      	pop	{r4, pc}
     428:	20000b80 	.word	0x20000b80
     42c:	00000000 	.word	0x00000000
     430:	00012ca4 	.word	0x00012ca4

00000434 <frame_dummy>:
     434:	4b0c      	ldr	r3, [pc, #48]	; (468 <frame_dummy+0x34>)
     436:	b143      	cbz	r3, 44a <frame_dummy+0x16>
     438:	480c      	ldr	r0, [pc, #48]	; (46c <frame_dummy+0x38>)
     43a:	490d      	ldr	r1, [pc, #52]	; (470 <frame_dummy+0x3c>)
     43c:	b510      	push	{r4, lr}
     43e:	f3af 8000 	nop.w
     442:	480c      	ldr	r0, [pc, #48]	; (474 <frame_dummy+0x40>)
     444:	6803      	ldr	r3, [r0, #0]
     446:	b923      	cbnz	r3, 452 <frame_dummy+0x1e>
     448:	bd10      	pop	{r4, pc}
     44a:	480a      	ldr	r0, [pc, #40]	; (474 <frame_dummy+0x40>)
     44c:	6803      	ldr	r3, [r0, #0]
     44e:	b933      	cbnz	r3, 45e <frame_dummy+0x2a>
     450:	4770      	bx	lr
     452:	4b09      	ldr	r3, [pc, #36]	; (478 <frame_dummy+0x44>)
     454:	2b00      	cmp	r3, #0
     456:	d0f7      	beq.n	448 <frame_dummy+0x14>
     458:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     45c:	4718      	bx	r3
     45e:	4b06      	ldr	r3, [pc, #24]	; (478 <frame_dummy+0x44>)
     460:	2b00      	cmp	r3, #0
     462:	d0f5      	beq.n	450 <frame_dummy+0x1c>
     464:	4718      	bx	r3
     466:	bf00      	nop
     468:	00000000 	.word	0x00000000
     46c:	00012ca4 	.word	0x00012ca4
     470:	20000b84 	.word	0x20000b84
     474:	20000b6c 	.word	0x20000b6c
     478:	00000000 	.word	0x00000000

0000047c <_mainCRTStartup>:
     47c:	4b15      	ldr	r3, [pc, #84]	; (4d4 <_mainCRTStartup+0x58>)
     47e:	2b00      	cmp	r3, #0
     480:	bf08      	it	eq
     482:	4b13      	ldreq	r3, [pc, #76]	; (4d0 <_mainCRTStartup+0x54>)
     484:	469d      	mov	sp, r3
     486:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
     48a:	2100      	movs	r1, #0
     48c:	468b      	mov	fp, r1
     48e:	460f      	mov	r7, r1
     490:	4813      	ldr	r0, [pc, #76]	; (4e0 <_mainCRTStartup+0x64>)
     492:	4a14      	ldr	r2, [pc, #80]	; (4e4 <_mainCRTStartup+0x68>)
     494:	1a12      	subs	r2, r2, r0
     496:	f00a fff5 	bl	b484 <memset>
     49a:	4b0f      	ldr	r3, [pc, #60]	; (4d8 <_mainCRTStartup+0x5c>)
     49c:	2b00      	cmp	r3, #0
     49e:	d000      	beq.n	4a2 <_mainCRTStartup+0x26>
     4a0:	4798      	blx	r3
     4a2:	4b0e      	ldr	r3, [pc, #56]	; (4dc <_mainCRTStartup+0x60>)
     4a4:	2b00      	cmp	r3, #0
     4a6:	d000      	beq.n	4aa <_mainCRTStartup+0x2e>
     4a8:	4798      	blx	r3
     4aa:	2000      	movs	r0, #0
     4ac:	2100      	movs	r1, #0
     4ae:	0004      	movs	r4, r0
     4b0:	000d      	movs	r5, r1
     4b2:	480d      	ldr	r0, [pc, #52]	; (4e8 <_mainCRTStartup+0x6c>)
     4b4:	2800      	cmp	r0, #0
     4b6:	d002      	beq.n	4be <_mainCRTStartup+0x42>
     4b8:	480c      	ldr	r0, [pc, #48]	; (4ec <_mainCRTStartup+0x70>)
     4ba:	f003 faef 	bl	3a9c <__wrap_atexit>
     4be:	f00a fbf1 	bl	aca4 <__libc_init_array>
     4c2:	0020      	movs	r0, r4
     4c4:	0029      	movs	r1, r5
     4c6:	f003 fe97 	bl	41f8 <__wrap_main>
     4ca:	f003 fadd 	bl	3a88 <__wrap_exit>
     4ce:	bf00      	nop
     4d0:	00080000 	.word	0x00080000
     4d4:	20030000 	.word	0x20030000
     4d8:	00000000 	.word	0x00000000
     4dc:	000042b9 	.word	0x000042b9
     4e0:	20000b80 	.word	0x20000b80
     4e4:	20003050 	.word	0x20003050
     4e8:	00003a9d 	.word	0x00003a9d
     4ec:	00000000 	.word	0x00000000

000004f0 <HardFault_Handler>:
     4f0:	f04f 0310 	mov.w	r3, #16
     4f4:	f000 b80c 	b.w	510 <Fault_Handler>

000004f8 <MemManage_Handler>:
     4f8:	f04f 0320 	mov.w	r3, #32
     4fc:	f000 b808 	b.w	510 <Fault_Handler>

00000500 <BusFault_Handler>:
     500:	f04f 0330 	mov.w	r3, #48	; 0x30
     504:	f000 b804 	b.w	510 <Fault_Handler>

00000508 <UsageFault_Handler>:
     508:	f04f 0340 	mov.w	r3, #64	; 0x40
     50c:	f000 b800 	b.w	510 <Fault_Handler>

00000510 <Fault_Handler>:
     510:	f3ef 8008 	mrs	r0, MSP
     514:	f04f 0104 	mov.w	r1, #4
     518:	4672      	mov	r2, lr
     51a:	420a      	tst	r2, r1
     51c:	d001      	beq.n	522 <Fault_Handler_Continue>
     51e:	f3ef 8009 	mrs	r0, PSP

00000522 <Fault_Handler_Continue>:
     522:	469c      	mov	ip, r3
     524:	4924      	ldr	r1, [pc, #144]	; (5b8 <Fault_Handler_Continue2+0x2e>)
     526:	6802      	ldr	r2, [r0, #0]
     528:	600a      	str	r2, [r1, #0]
     52a:	3104      	adds	r1, #4
     52c:	6842      	ldr	r2, [r0, #4]
     52e:	600a      	str	r2, [r1, #0]
     530:	3104      	adds	r1, #4
     532:	6882      	ldr	r2, [r0, #8]
     534:	600a      	str	r2, [r1, #0]
     536:	3104      	adds	r1, #4
     538:	68c2      	ldr	r2, [r0, #12]
     53a:	600a      	str	r2, [r1, #0]
     53c:	3104      	adds	r1, #4
     53e:	c1f0      	stmia	r1!, {r4, r5, r6, r7}
     540:	4647      	mov	r7, r8
     542:	600f      	str	r7, [r1, #0]
     544:	3104      	adds	r1, #4
     546:	464f      	mov	r7, r9
     548:	600f      	str	r7, [r1, #0]
     54a:	3104      	adds	r1, #4
     54c:	4657      	mov	r7, sl
     54e:	600f      	str	r7, [r1, #0]
     550:	3104      	adds	r1, #4
     552:	465f      	mov	r7, fp
     554:	600f      	str	r7, [r1, #0]
     556:	3104      	adds	r1, #4
     558:	6902      	ldr	r2, [r0, #16]
     55a:	600a      	str	r2, [r1, #0]
     55c:	3108      	adds	r1, #8
     55e:	6942      	ldr	r2, [r0, #20]
     560:	600a      	str	r2, [r1, #0]
     562:	3104      	adds	r1, #4
     564:	6982      	ldr	r2, [r0, #24]
     566:	600a      	str	r2, [r1, #0]
     568:	3104      	adds	r1, #4
     56a:	69c2      	ldr	r2, [r0, #28]
     56c:	600a      	str	r2, [r1, #0]
     56e:	3104      	adds	r1, #4
     570:	4603      	mov	r3, r0
     572:	3320      	adds	r3, #32
     574:	f44f 7600 	mov.w	r6, #512	; 0x200
     578:	4232      	tst	r2, r6
     57a:	d000      	beq.n	57e <Fault_Handler_Continue1>
     57c:	3304      	adds	r3, #4

0000057e <Fault_Handler_Continue1>:
     57e:	4675      	mov	r5, lr
     580:	f04f 0610 	mov.w	r6, #16
     584:	4235      	tst	r5, r6
     586:	d100      	bne.n	58a <Fault_Handler_Continue2>
     588:	3348      	adds	r3, #72	; 0x48

0000058a <Fault_Handler_Continue2>:
     58a:	460c      	mov	r4, r1
     58c:	3c10      	subs	r4, #16
     58e:	6023      	str	r3, [r4, #0]
     590:	f3ef 8209 	mrs	r2, PSP
     594:	600a      	str	r2, [r1, #0]
     596:	3104      	adds	r1, #4
     598:	f3ef 8208 	mrs	r2, MSP
     59c:	600a      	str	r2, [r1, #0]
     59e:	3104      	adds	r1, #4
     5a0:	4672      	mov	r2, lr
     5a2:	600a      	str	r2, [r1, #0]
     5a4:	3104      	adds	r1, #4
     5a6:	f3ef 8214 	mrs	r2, CONTROL
     5aa:	600a      	str	r2, [r1, #0]
     5ac:	4b03      	ldr	r3, [pc, #12]	; (5bc <Fault_Handler_Continue2+0x32>)
     5ae:	4660      	mov	r0, ip
     5b0:	4901      	ldr	r1, [pc, #4]	; (5b8 <Fault_Handler_Continue2+0x2e>)
     5b2:	4a03      	ldr	r2, [pc, #12]	; (5c0 <Fault_Handler_Continue2+0x36>)
     5b4:	4798      	blx	r3
     5b6:	e7fe      	b.n	5b6 <Fault_Handler_Continue2+0x2c>
     5b8:	20001e00 	.word	0x20001e00
     5bc:	00003ecd 	.word	0x00003ecd
     5c0:	20000110 	.word	0x20000110

000005c4 <SVC_Handler>:
     5c4:	f01e 0f04 	tst.w	lr, #4
     5c8:	bf0c      	ite	eq
     5ca:	f3ef 8008 	mrseq	r0, MSP
     5ce:	f3ef 8009 	mrsne	r0, PSP
     5d2:	6981      	ldr	r1, [r0, #24]
     5d4:	f811 1c02 	ldrb.w	r1, [r1, #-2]
     5d8:	bbb9      	cbnz	r1, 64a <SVC_User>
     5da:	b501      	push	{r0, lr}
     5dc:	e890 100f 	ldmia.w	r0, {r0, r1, r2, r3, ip}
     5e0:	47e0      	blx	ip
     5e2:	e8bd 5000 	ldmia.w	sp!, {ip, lr}
     5e6:	e88c 0003 	stmia.w	ip, {r0, r1}

000005ea <SVC_Context>:
     5ea:	4b27      	ldr	r3, [pc, #156]	; (688 <SysTick_Handler+0x12>)
     5ec:	e893 0006 	ldmia.w	r3, {r1, r2}
     5f0:	4291      	cmp	r1, r2
     5f2:	bf08      	it	eq
     5f4:	4770      	bxeq	lr
     5f6:	b941      	cbnz	r1, 60a <SVC_ContextSave>
     5f8:	f01e 0f10 	tst.w	lr, #16
     5fc:	d110      	bne.n	620 <SVC_ContextSwitch>
     5fe:	4923      	ldr	r1, [pc, #140]	; (68c <SysTick_Handler+0x16>)
     600:	6808      	ldr	r0, [r1, #0]
     602:	f020 0001 	bic.w	r0, r0, #1
     606:	6008      	str	r0, [r1, #0]
     608:	e00a      	b.n	620 <SVC_ContextSwitch>

0000060a <SVC_ContextSave>:
     60a:	e92c 0ff0 	stmdb	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
     60e:	f01e 0f10 	tst.w	lr, #16
     612:	bf08      	it	eq
     614:	ed2c 8a10 	vstmdbeq	ip!, {s16-s31}
     618:	f8c1 c038 	str.w	ip, [r1, #56]	; 0x38
     61c:	f881 e022 	strb.w	lr, [r1, #34]	; 0x22

00000620 <SVC_ContextSwitch>:
        /* The call to thread_switch_helper can clobber R2 and R3, but we don't
         * want to clobber R2 or R3. We can't save R2 and R3 to the stack (as
         * the stack we save them onto is likely to be inaccessible after the
         * call to thread_switch_helper). So, we just re-obtain the values from
         * osRtxInfo again. */
        BL       thread_switch_helper
     620:	f006 fd0a 	bl	7038 <thread_switch_helper>
        LDR      R3,=osRtxInfo+I_T_RUN_OFS // Load address of osRtxInfo.run
     624:	4b18      	ldr	r3, [pc, #96]	; (688 <SysTick_Handler+0x12>)
        LDM      R3,{R1,R2}             // Load osRtxInfo.thread.run: curr & next
     626:	e893 0006 	ldmia.w	r3, {r1, r2}

        STR      R2,[R3]                // osRtxInfo.thread.run: curr = next
     62a:	601a      	str	r2, [r3, #0]

0000062c <SVC_ContextRestore>:

SVC_ContextRestore:
        LDRB     R1,[R2,#TCB_SF_OFS]    // Load stack frame information
     62c:	f892 1022 	ldrb.w	r1, [r2, #34]	; 0x22
        LDR      R0,[R2,#TCB_SP_OFS]    // Load SP
     630:	6b90      	ldr	r0, [r2, #56]	; 0x38
        ORR      LR,R1,#0xFFFFFF00      // Set EXC_RETURN
     632:	f061 0eff 	orn	lr, r1, #255	; 0xff

#ifdef __FPU_PRESENT
        TST      LR,#0x10               // Check if extended stack frame
     636:	f01e 0f10 	tst.w	lr, #16
        IT       EQ
     63a:	bf08      	it	eq
        VLDMIAEQ R0!,{S16-S31}          //  Restore VFP S16..S31
     63c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
#endif
        LDMIA    R0!,{R4-R11}           // Restore R4..R11
     640:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
        MSR      PSP,R0                 // Set PSP
     644:	f380 8809 	msr	PSP, r0

00000648 <SVC_Exit>:
#ifdef FEATURE_UVISOR
        CPSIE I                         // The PSP has been set. Re-enable interrupts.
#endif

SVC_Exit:
        BX       LR                     // Exit from handler
     648:	4770      	bx	lr

0000064a <SVC_User>:

SVC_User:
        LDR      R2,=osRtxUserSVC       // Load address of SVC table
     64a:	4a11      	ldr	r2, [pc, #68]	; (690 <SysTick_Handler+0x1a>)
        LDR      R3,[R2]                // Load SVC maximum number
     64c:	6813      	ldr	r3, [r2, #0]
        CMP      R1,R3                  // Check SVC number range
     64e:	4299      	cmp	r1, r3
        BHI      SVC_Exit               // Branch if out of range
     650:	d8fa      	bhi.n	648 <SVC_Exit>

        PUSH     {R0,LR}                // Save SP and EXC_RETURN
     652:	b501      	push	{r0, lr}
        LDR      R12,[R2,R1,LSL #2]     // Load address of SVC function
     654:	f852 c021 	ldr.w	ip, [r2, r1, lsl #2]
        LDM      R0,{R0-R3}             // Load function parameters from stack
     658:	c80f      	ldmia	r0, {r0, r1, r2, r3}
        BLX      R12                    // Call service function
     65a:	47e0      	blx	ip
        POP      {R12,LR}               // Restore SP and EXC_RETURN
     65c:	e8bd 5000 	ldmia.w	sp!, {ip, lr}
        STR      R0,[R12]               // Store function return value
     660:	f8cc 0000 	str.w	r0, [ip]

        BX       LR                     // Return from handler
     664:	4770      	bx	lr

00000666 <PendSV_Handler>:
        .global  PendSV_Handler
        .fnstart
        .cantunwind
PendSV_Handler:

        PUSH     {R0,LR}                // Save EXC_RETURN
     666:	b501      	push	{r0, lr}
        BL       osRtxPendSV_Handler    // Call osRtxPendSV_Handler
     668:	f006 f920 	bl	68ac <osRtxPendSV_Handler>
        POP      {R0,LR}                // Restore EXC_RETURN
     66c:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
        MRS      R12,PSP
     670:	f3ef 8c09 	mrs	ip, PSP
        B        SVC_Context
     674:	e7b9      	b.n	5ea <SVC_Context>

00000676 <SysTick_Handler>:
        .global  SysTick_Handler
        .fnstart
        .cantunwind
SysTick_Handler:

        PUSH     {R0,LR}                // Save EXC_RETURN
     676:	b501      	push	{r0, lr}
        BL       osRtxTick_Handler      // Call osRtxTick_Handler
     678:	f006 f8b2 	bl	67e0 <osRtxTick_Handler>
        POP      {R0,LR}                // Restore EXC_RETURN
     67c:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
        MRS      R12,PSP
     680:	f3ef 8c09 	mrs	ip, PSP
        B        SVC_Context
     684:	e7b1      	b.n	5ea <SVC_Context>
     686:	0000      	.short	0x0000
     688:	20000124 	.word	0x20000124
     68c:	e000ef34 	.word	0xe000ef34
        LDR      R2,=osRtxUserSVC       // Load address of SVC table
     690:	000125ec 	.word	0x000125ec

00000694 <Reset_Handler>:
    .align 2
    .globl   Reset_Handler
    .weak    Reset_Handler
    .type    Reset_Handler, %function
Reset_Handler:
    cpsid   i               /* Mask interrupts */
     694:	b672      	cpsid	i
    .equ    VTOR, 0xE000ED08
    ldr     r0, =VTOR
     696:	4809      	ldr	r0, [pc, #36]	; (6bc <Reset_Handler+0x28>)
    ldr     r1, =__isr_vector
     698:	4909      	ldr	r1, [pc, #36]	; (6c0 <Reset_Handler+0x2c>)
    str     r1, [r0]
     69a:	6001      	str	r1, [r0, #0]
#ifndef __NO_SYSTEM_INIT
    ldr   r0,=SystemInit
     69c:	4809      	ldr	r0, [pc, #36]	; (6c4 <Reset_Handler+0x30>)
    blx   r0
     69e:	4780      	blx	r0
 *      linker script.
 *      __etext: End of code section, i.e., begin of data sections to copy from.
 *      __data_start__/__data_end__: RAM address range that data should be
 *      copied to. Both must be aligned to 4 bytes boundary.  */

    ldr    r1, =__etext
     6a0:	4909      	ldr	r1, [pc, #36]	; (6c8 <Reset_Handler+0x34>)
    ldr    r2, =__data_start__
     6a2:	4a0a      	ldr	r2, [pc, #40]	; (6cc <Reset_Handler+0x38>)
    ldr    r3, =__data_end__
     6a4:	4b0a      	ldr	r3, [pc, #40]	; (6d0 <Reset_Handler+0x3c>)
#if 1
/* Here are two copies of loop implemenations. First one favors code size
 * and the second one favors performance. Default uses the first one.
 * Change to "#if 0" to use the second one */
.LC0:
    cmp     r2, r3
     6a6:	429a      	cmp	r2, r3
    ittt    lt
     6a8:	bfbe      	ittt	lt
    ldrlt   r0, [r1], #4
     6aa:	f851 0b04 	ldrlt.w	r0, [r1], #4
    strlt   r0, [r2], #4
     6ae:	f842 0b04 	strlt.w	r0, [r2], #4
    blt    .LC0
     6b2:	e7f8      	blt.n	6a6 <Reset_Handler+0x12>
    itt    lt
    strlt   r0, [r1], #4
    blt    .LC2
#endif /* __STARTUP_CLEAR_BSS */

    cpsie   i               /* Unmask interrupts */
     6b4:	b662      	cpsie	i
#ifndef __START
#define __START _start
#endif
#ifndef __ATOLLIC__
    ldr   r0,=__START
     6b6:	4807      	ldr	r0, [pc, #28]	; (6d4 <Reset_Handler+0x40>)
    blx   r0
     6b8:	4780      	blx	r0
     6ba:	0000      	.short	0x0000
    ldr     r0, =VTOR
     6bc:	e000ed08 	.word	0xe000ed08
    ldr     r1, =__isr_vector
     6c0:	00000000 	.word	0x00000000
    ldr   r0,=SystemInit
     6c4:	00007fa9 	.word	0x00007fa9
    ldr    r1, =__etext
     6c8:	00012cd4 	.word	0x00012cd4
    ldr    r2, =__data_start__
     6cc:	20000000 	.word	0x20000000
    ldr    r3, =__data_end__
     6d0:	20000b70 	.word	0x20000b70
    ldr   r0,=__START
     6d4:	0000047d 	.word	0x0000047d

000006d8 <ADC0_IRQHandler>:
    .align  1
    .thumb_func
    .weak DefaultISR
    .type DefaultISR, %function
DefaultISR:
    b DefaultISR
     6d8:	f7ff bffe 	b.w	6d8 <ADC0_IRQHandler>
    .align 1
    .thumb_func
    .weak NMI_Handler
    .type NMI_Handler, %function
NMI_Handler:
    ldr   r0,=NMI_Handler
     6dc:	4835      	ldr	r0, [pc, #212]	; (7b4 <ENET_1588_Timer_IRQHandler+0x10>)
    bx    r0
     6de:	4700      	bx	r0
    .align 1
    .thumb_func
    .weak HardFault_Handler
    .type HardFault_Handler, %function
HardFault_Handler:
    ldr   r0,=HardFault_Handler
     6e0:	4835      	ldr	r0, [pc, #212]	; (7b8 <ENET_1588_Timer_IRQHandler+0x14>)
    bx    r0
     6e2:	4700      	bx	r0
    .align 1
    .thumb_func
    .weak SVC_Handler
    .type SVC_Handler, %function
SVC_Handler:
    ldr   r0,=SVC_Handler
     6e4:	4835      	ldr	r0, [pc, #212]	; (7bc <ENET_1588_Timer_IRQHandler+0x18>)
    bx    r0
     6e6:	4700      	bx	r0
    .align 1
    .thumb_func
    .weak PendSV_Handler
    .type PendSV_Handler, %function
PendSV_Handler:
    ldr   r0,=PendSV_Handler
     6e8:	4835      	ldr	r0, [pc, #212]	; (7c0 <ENET_1588_Timer_IRQHandler+0x1c>)
    bx    r0
     6ea:	4700      	bx	r0
    .align 1
    .thumb_func
    .weak SysTick_Handler
    .type SysTick_Handler, %function
SysTick_Handler:
    ldr   r0,=SysTick_Handler
     6ec:	4835      	ldr	r0, [pc, #212]	; (7c4 <ENET_1588_Timer_IRQHandler+0x20>)
    bx    r0
     6ee:	4700      	bx	r0

000006f0 <DMA0_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA0_IRQHandler
    .type DMA0_IRQHandler, %function
DMA0_IRQHandler:
    ldr   r0,=DMA0_DriverIRQHandler
     6f0:	4835      	ldr	r0, [pc, #212]	; (7c8 <ENET_1588_Timer_IRQHandler+0x24>)
    bx    r0
     6f2:	4700      	bx	r0

000006f4 <DMA1_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA1_IRQHandler
    .type DMA1_IRQHandler, %function
DMA1_IRQHandler:
    ldr   r0,=DMA1_DriverIRQHandler
     6f4:	4835      	ldr	r0, [pc, #212]	; (7cc <ENET_1588_Timer_IRQHandler+0x28>)
    bx    r0
     6f6:	4700      	bx	r0

000006f8 <DMA2_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA2_IRQHandler
    .type DMA2_IRQHandler, %function
DMA2_IRQHandler:
    ldr   r0,=DMA2_DriverIRQHandler
     6f8:	4835      	ldr	r0, [pc, #212]	; (7d0 <ENET_1588_Timer_IRQHandler+0x2c>)
    bx    r0
     6fa:	4700      	bx	r0

000006fc <DMA3_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA3_IRQHandler
    .type DMA3_IRQHandler, %function
DMA3_IRQHandler:
    ldr   r0,=DMA3_DriverIRQHandler
     6fc:	4835      	ldr	r0, [pc, #212]	; (7d4 <ENET_1588_Timer_IRQHandler+0x30>)
    bx    r0
     6fe:	4700      	bx	r0

00000700 <DMA4_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA4_IRQHandler
    .type DMA4_IRQHandler, %function
DMA4_IRQHandler:
    ldr   r0,=DMA4_DriverIRQHandler
     700:	4835      	ldr	r0, [pc, #212]	; (7d8 <ENET_1588_Timer_IRQHandler+0x34>)
    bx    r0
     702:	4700      	bx	r0

00000704 <DMA5_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA5_IRQHandler
    .type DMA5_IRQHandler, %function
DMA5_IRQHandler:
    ldr   r0,=DMA5_DriverIRQHandler
     704:	4835      	ldr	r0, [pc, #212]	; (7dc <ENET_1588_Timer_IRQHandler+0x38>)
    bx    r0
     706:	4700      	bx	r0

00000708 <DMA6_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA6_IRQHandler
    .type DMA6_IRQHandler, %function
DMA6_IRQHandler:
    ldr   r0,=DMA6_DriverIRQHandler
     708:	4835      	ldr	r0, [pc, #212]	; (7e0 <ENET_1588_Timer_IRQHandler+0x3c>)
    bx    r0
     70a:	4700      	bx	r0

0000070c <DMA7_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA7_IRQHandler
    .type DMA7_IRQHandler, %function
DMA7_IRQHandler:
    ldr   r0,=DMA7_DriverIRQHandler
     70c:	4835      	ldr	r0, [pc, #212]	; (7e4 <ENET_1588_Timer_IRQHandler+0x40>)
    bx    r0
     70e:	4700      	bx	r0

00000710 <DMA8_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA8_IRQHandler
    .type DMA8_IRQHandler, %function
DMA8_IRQHandler:
    ldr   r0,=DMA8_DriverIRQHandler
     710:	4835      	ldr	r0, [pc, #212]	; (7e8 <ENET_1588_Timer_IRQHandler+0x44>)
    bx    r0
     712:	4700      	bx	r0

00000714 <DMA9_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA9_IRQHandler
    .type DMA9_IRQHandler, %function
DMA9_IRQHandler:
    ldr   r0,=DMA9_DriverIRQHandler
     714:	4835      	ldr	r0, [pc, #212]	; (7ec <ENET_1588_Timer_IRQHandler+0x48>)
    bx    r0
     716:	4700      	bx	r0

00000718 <DMA10_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA10_IRQHandler
    .type DMA10_IRQHandler, %function
DMA10_IRQHandler:
    ldr   r0,=DMA10_DriverIRQHandler
     718:	4835      	ldr	r0, [pc, #212]	; (7f0 <ENET_1588_Timer_IRQHandler+0x4c>)
    bx    r0
     71a:	4700      	bx	r0

0000071c <DMA11_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA11_IRQHandler
    .type DMA11_IRQHandler, %function
DMA11_IRQHandler:
    ldr   r0,=DMA11_DriverIRQHandler
     71c:	4835      	ldr	r0, [pc, #212]	; (7f4 <ENET_1588_Timer_IRQHandler+0x50>)
    bx    r0
     71e:	4700      	bx	r0

00000720 <DMA12_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA12_IRQHandler
    .type DMA12_IRQHandler, %function
DMA12_IRQHandler:
    ldr   r0,=DMA12_DriverIRQHandler
     720:	4835      	ldr	r0, [pc, #212]	; (7f8 <ENET_1588_Timer_IRQHandler+0x54>)
    bx    r0
     722:	4700      	bx	r0

00000724 <DMA13_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA13_IRQHandler
    .type DMA13_IRQHandler, %function
DMA13_IRQHandler:
    ldr   r0,=DMA13_DriverIRQHandler
     724:	4835      	ldr	r0, [pc, #212]	; (7fc <ENET_1588_Timer_IRQHandler+0x58>)
    bx    r0
     726:	4700      	bx	r0

00000728 <DMA14_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA14_IRQHandler
    .type DMA14_IRQHandler, %function
DMA14_IRQHandler:
    ldr   r0,=DMA14_DriverIRQHandler
     728:	4835      	ldr	r0, [pc, #212]	; (800 <USB_RAM_GAP>)
    bx    r0
     72a:	4700      	bx	r0

0000072c <DMA15_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA15_IRQHandler
    .type DMA15_IRQHandler, %function
DMA15_IRQHandler:
    ldr   r0,=DMA15_DriverIRQHandler
     72c:	4835      	ldr	r0, [pc, #212]	; (804 <USB_RAM_GAP+0x4>)
    bx    r0
     72e:	4700      	bx	r0

00000730 <DMA_Error_IRQHandler>:
    .align 1
    .thumb_func
    .weak DMA_Error_IRQHandler
    .type DMA_Error_IRQHandler, %function
DMA_Error_IRQHandler:
    ldr   r0,=DMA_Error_DriverIRQHandler
     730:	4835      	ldr	r0, [pc, #212]	; (808 <USB_RAM_GAP+0x8>)
    bx    r0
     732:	4700      	bx	r0

00000734 <I2C0_IRQHandler>:
    .align 1
    .thumb_func
    .weak I2C0_IRQHandler
    .type I2C0_IRQHandler, %function
I2C0_IRQHandler:
    ldr   r0,=I2C0_DriverIRQHandler
     734:	4835      	ldr	r0, [pc, #212]	; (80c <USB_RAM_GAP+0xc>)
    bx    r0
     736:	4700      	bx	r0

00000738 <I2C1_IRQHandler>:
    .align 1
    .thumb_func
    .weak I2C1_IRQHandler
    .type I2C1_IRQHandler, %function
I2C1_IRQHandler:
    ldr   r0,=I2C1_DriverIRQHandler
     738:	4835      	ldr	r0, [pc, #212]	; (810 <USB_RAM_GAP+0x10>)
    bx    r0
     73a:	4700      	bx	r0

0000073c <SPI0_IRQHandler>:
    .align 1
    .thumb_func
    .weak SPI0_IRQHandler
    .type SPI0_IRQHandler, %function
SPI0_IRQHandler:
    ldr   r0,=SPI0_DriverIRQHandler
     73c:	4835      	ldr	r0, [pc, #212]	; (814 <USB_RAM_GAP+0x14>)
    bx    r0
     73e:	4700      	bx	r0

00000740 <SPI1_IRQHandler>:
    .align 1
    .thumb_func
    .weak SPI1_IRQHandler
    .type SPI1_IRQHandler, %function
SPI1_IRQHandler:
    ldr   r0,=SPI1_DriverIRQHandler
     740:	4835      	ldr	r0, [pc, #212]	; (818 <USB_RAM_GAP+0x18>)
    bx    r0
     742:	4700      	bx	r0

00000744 <I2S0_Tx_IRQHandler>:
    .align 1
    .thumb_func
    .weak I2S0_Tx_IRQHandler
    .type I2S0_Tx_IRQHandler, %function
I2S0_Tx_IRQHandler:
    ldr   r0,=I2S0_Tx_DriverIRQHandler
     744:	4835      	ldr	r0, [pc, #212]	; (81c <USB_RAM_GAP+0x1c>)
    bx    r0
     746:	4700      	bx	r0

00000748 <I2S0_Rx_IRQHandler>:
    .align 1
    .thumb_func
    .weak I2S0_Rx_IRQHandler
    .type I2S0_Rx_IRQHandler, %function
I2S0_Rx_IRQHandler:
    ldr   r0,=I2S0_Rx_DriverIRQHandler
     748:	4835      	ldr	r0, [pc, #212]	; (820 <USB_RAM_GAP+0x20>)
    bx    r0
     74a:	4700      	bx	r0

0000074c <UART0_LON_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART0_LON_IRQHandler
    .type UART0_LON_IRQHandler, %function
UART0_LON_IRQHandler:
    ldr   r0,=UART0_LON_DriverIRQHandler
     74c:	4835      	ldr	r0, [pc, #212]	; (824 <USB_RAM_GAP+0x24>)
    bx    r0
     74e:	4700      	bx	r0

00000750 <UART0_RX_TX_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART0_RX_TX_IRQHandler
    .type UART0_RX_TX_IRQHandler, %function
UART0_RX_TX_IRQHandler:
    ldr   r0,=UART0_RX_TX_DriverIRQHandler
     750:	4835      	ldr	r0, [pc, #212]	; (828 <USB_RAM_GAP+0x28>)
    bx    r0
     752:	4700      	bx	r0

00000754 <UART0_ERR_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART0_ERR_IRQHandler
    .type UART0_ERR_IRQHandler, %function
UART0_ERR_IRQHandler:
    ldr   r0,=UART0_ERR_DriverIRQHandler
     754:	4835      	ldr	r0, [pc, #212]	; (82c <USB_RAM_GAP+0x2c>)
    bx    r0
     756:	4700      	bx	r0

00000758 <UART1_RX_TX_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART1_RX_TX_IRQHandler
    .type UART1_RX_TX_IRQHandler, %function
UART1_RX_TX_IRQHandler:
    ldr   r0,=UART1_RX_TX_DriverIRQHandler
     758:	4835      	ldr	r0, [pc, #212]	; (830 <USB_RAM_GAP+0x30>)
    bx    r0
     75a:	4700      	bx	r0

0000075c <UART1_ERR_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART1_ERR_IRQHandler
    .type UART1_ERR_IRQHandler, %function
UART1_ERR_IRQHandler:
    ldr   r0,=UART1_ERR_DriverIRQHandler
     75c:	4835      	ldr	r0, [pc, #212]	; (834 <USB_RAM_GAP+0x34>)
    bx    r0
     75e:	4700      	bx	r0

00000760 <UART2_RX_TX_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART2_RX_TX_IRQHandler
    .type UART2_RX_TX_IRQHandler, %function
UART2_RX_TX_IRQHandler:
    ldr   r0,=UART2_RX_TX_DriverIRQHandler
     760:	4835      	ldr	r0, [pc, #212]	; (838 <USB_RAM_GAP+0x38>)
    bx    r0
     762:	4700      	bx	r0

00000764 <UART2_ERR_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART2_ERR_IRQHandler
    .type UART2_ERR_IRQHandler, %function
UART2_ERR_IRQHandler:
    ldr   r0,=UART2_ERR_DriverIRQHandler
     764:	4835      	ldr	r0, [pc, #212]	; (83c <USB_RAM_GAP+0x3c>)
    bx    r0
     766:	4700      	bx	r0

00000768 <UART3_RX_TX_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART3_RX_TX_IRQHandler
    .type UART3_RX_TX_IRQHandler, %function
UART3_RX_TX_IRQHandler:
    ldr   r0,=UART3_RX_TX_DriverIRQHandler
     768:	4835      	ldr	r0, [pc, #212]	; (840 <USB_RAM_GAP+0x40>)
    bx    r0
     76a:	4700      	bx	r0

0000076c <UART3_ERR_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART3_ERR_IRQHandler
    .type UART3_ERR_IRQHandler, %function
UART3_ERR_IRQHandler:
    ldr   r0,=UART3_ERR_DriverIRQHandler
     76c:	4835      	ldr	r0, [pc, #212]	; (844 <USB_RAM_GAP+0x44>)
    bx    r0
     76e:	4700      	bx	r0

00000770 <SPI2_IRQHandler>:
    .align 1
    .thumb_func
    .weak SPI2_IRQHandler
    .type SPI2_IRQHandler, %function
SPI2_IRQHandler:
    ldr   r0,=SPI2_DriverIRQHandler
     770:	4835      	ldr	r0, [pc, #212]	; (848 <USB_RAM_GAP+0x48>)
    bx    r0
     772:	4700      	bx	r0

00000774 <UART4_RX_TX_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART4_RX_TX_IRQHandler
    .type UART4_RX_TX_IRQHandler, %function
UART4_RX_TX_IRQHandler:
    ldr   r0,=UART4_RX_TX_DriverIRQHandler
     774:	4835      	ldr	r0, [pc, #212]	; (84c <USB_RAM_GAP+0x4c>)
    bx    r0
     776:	4700      	bx	r0

00000778 <UART4_ERR_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART4_ERR_IRQHandler
    .type UART4_ERR_IRQHandler, %function
UART4_ERR_IRQHandler:
    ldr   r0,=UART4_ERR_DriverIRQHandler
     778:	4835      	ldr	r0, [pc, #212]	; (850 <USB_RAM_GAP+0x50>)
    bx    r0
     77a:	4700      	bx	r0

0000077c <UART5_RX_TX_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART5_RX_TX_IRQHandler
    .type UART5_RX_TX_IRQHandler, %function
UART5_RX_TX_IRQHandler:
    ldr   r0,=UART5_RX_TX_DriverIRQHandler
     77c:	4835      	ldr	r0, [pc, #212]	; (854 <USB_RAM_GAP+0x54>)
    bx    r0
     77e:	4700      	bx	r0

00000780 <UART5_ERR_IRQHandler>:
    .align 1
    .thumb_func
    .weak UART5_ERR_IRQHandler
    .type UART5_ERR_IRQHandler, %function
UART5_ERR_IRQHandler:
    ldr   r0,=UART5_ERR_DriverIRQHandler
     780:	4835      	ldr	r0, [pc, #212]	; (858 <USB_RAM_GAP+0x58>)
    bx    r0
     782:	4700      	bx	r0

00000784 <I2C2_IRQHandler>:
    .align 1
    .thumb_func
    .weak I2C2_IRQHandler
    .type I2C2_IRQHandler, %function
I2C2_IRQHandler:
    ldr   r0,=I2C2_DriverIRQHandler
     784:	4835      	ldr	r0, [pc, #212]	; (85c <USB_RAM_GAP+0x5c>)
    bx    r0
     786:	4700      	bx	r0

00000788 <CAN0_ORed_Message_buffer_IRQHandler>:
    .align 1
    .thumb_func
    .weak CAN0_ORed_Message_buffer_IRQHandler
    .type CAN0_ORed_Message_buffer_IRQHandler, %function
CAN0_ORed_Message_buffer_IRQHandler:
    ldr   r0,=CAN0_DriverIRQHandler
     788:	4835      	ldr	r0, [pc, #212]	; (860 <USB_RAM_GAP+0x60>)
    bx    r0
     78a:	4700      	bx	r0

0000078c <CAN0_Bus_Off_IRQHandler>:
    .align 1
    .thumb_func
    .weak CAN0_Bus_Off_IRQHandler
    .type CAN0_Bus_Off_IRQHandler, %function
CAN0_Bus_Off_IRQHandler:
    ldr   r0,=CAN0_DriverIRQHandler
     78c:	4834      	ldr	r0, [pc, #208]	; (860 <USB_RAM_GAP+0x60>)
    bx    r0
     78e:	4700      	bx	r0

00000790 <CAN0_Error_IRQHandler>:
    .align 1
    .thumb_func
    .weak CAN0_Error_IRQHandler
    .type CAN0_Error_IRQHandler, %function
CAN0_Error_IRQHandler:
    ldr   r0,=CAN0_DriverIRQHandler
     790:	4833      	ldr	r0, [pc, #204]	; (860 <USB_RAM_GAP+0x60>)
    bx    r0
     792:	4700      	bx	r0

00000794 <CAN0_Tx_Warning_IRQHandler>:
    .align 1
    .thumb_func
    .weak CAN0_Tx_Warning_IRQHandler
    .type CAN0_Tx_Warning_IRQHandler, %function
CAN0_Tx_Warning_IRQHandler:
    ldr   r0,=CAN0_DriverIRQHandler
     794:	4832      	ldr	r0, [pc, #200]	; (860 <USB_RAM_GAP+0x60>)
    bx    r0
     796:	4700      	bx	r0

00000798 <CAN0_Rx_Warning_IRQHandler>:
    .align 1
    .thumb_func
    .weak CAN0_Rx_Warning_IRQHandler
    .type CAN0_Rx_Warning_IRQHandler, %function
CAN0_Rx_Warning_IRQHandler:
    ldr   r0,=CAN0_DriverIRQHandler
     798:	4831      	ldr	r0, [pc, #196]	; (860 <USB_RAM_GAP+0x60>)
    bx    r0
     79a:	4700      	bx	r0

0000079c <CAN0_Wake_Up_IRQHandler>:
    .align 1
    .thumb_func
    .weak CAN0_Wake_Up_IRQHandler
    .type CAN0_Wake_Up_IRQHandler, %function
CAN0_Wake_Up_IRQHandler:
    ldr   r0,=CAN0_DriverIRQHandler
     79c:	4830      	ldr	r0, [pc, #192]	; (860 <USB_RAM_GAP+0x60>)
    bx    r0
     79e:	4700      	bx	r0

000007a0 <SDHC_IRQHandler>:
    .align 1
    .thumb_func
    .weak SDHC_IRQHandler
    .type SDHC_IRQHandler, %function
SDHC_IRQHandler:
    ldr   r0,=SDHC_DriverIRQHandler
     7a0:	4830      	ldr	r0, [pc, #192]	; (864 <USB_RAM_GAP+0x64>)
    bx    r0
     7a2:	4700      	bx	r0

000007a4 <ENET_1588_Timer_IRQHandler>:
    .align 1
    .thumb_func
    .weak ENET_1588_Timer_IRQHandler
    .type ENET_1588_Timer_IRQHandler, %function
ENET_1588_Timer_IRQHandler:
    ldr   r0,=ENET_1588_Timer_DriverIRQHandler
     7a4:	4830      	ldr	r0, [pc, #192]	; (868 <USB_RAM_GAP+0x68>)
    bx    r0
     7a6:	4700      	bx	r0
    .align 1
    .thumb_func
    .weak ENET_Transmit_IRQHandler
    .type ENET_Transmit_IRQHandler, %function
ENET_Transmit_IRQHandler:
    ldr   r0,=ENET_Transmit_DriverIRQHandler
     7a8:	4830      	ldr	r0, [pc, #192]	; (86c <USB_RAM_GAP+0x6c>)
    bx    r0
     7aa:	4700      	bx	r0
    .align 1
    .thumb_func
    .weak ENET_Receive_IRQHandler
    .type ENET_Receive_IRQHandler, %function
ENET_Receive_IRQHandler:
    ldr   r0,=ENET_Receive_DriverIRQHandler
     7ac:	4830      	ldr	r0, [pc, #192]	; (870 <USB_RAM_GAP+0x70>)
    bx    r0
     7ae:	4700      	bx	r0
    .align 1
    .thumb_func
    .weak ENET_Error_IRQHandler
    .type ENET_Error_IRQHandler, %function
ENET_Error_IRQHandler:
    ldr   r0,=ENET_Error_DriverIRQHandler
     7b0:	4830      	ldr	r0, [pc, #192]	; (874 <USB_RAM_GAP+0x74>)
    bx    r0
     7b2:	4700      	bx	r0
    ldr   r0,=NMI_Handler
     7b4:	00007f93 	.word	0x00007f93
    ldr   r0,=HardFault_Handler
     7b8:	000004f1 	.word	0x000004f1
    ldr   r0,=SVC_Handler
     7bc:	000005c5 	.word	0x000005c5
    ldr   r0,=PendSV_Handler
     7c0:	00000667 	.word	0x00000667
    ldr   r0,=SysTick_Handler
     7c4:	00000677 	.word	0x00000677
    ldr   r0,=DMA0_DriverIRQHandler
     7c8:	00008d6d 	.word	0x00008d6d
    ldr   r0,=DMA1_DriverIRQHandler
     7cc:	00008d81 	.word	0x00008d81
    ldr   r0,=DMA2_DriverIRQHandler
     7d0:	00008d95 	.word	0x00008d95
    ldr   r0,=DMA3_DriverIRQHandler
     7d4:	00008da9 	.word	0x00008da9
    ldr   r0,=DMA4_DriverIRQHandler
     7d8:	00008dbd 	.word	0x00008dbd
    ldr   r0,=DMA5_DriverIRQHandler
     7dc:	00008dd1 	.word	0x00008dd1
    ldr   r0,=DMA6_DriverIRQHandler
     7e0:	00008de5 	.word	0x00008de5
    ldr   r0,=DMA7_DriverIRQHandler
     7e4:	00008df9 	.word	0x00008df9
    ldr   r0,=DMA8_DriverIRQHandler
     7e8:	00008e0d 	.word	0x00008e0d
    ldr   r0,=DMA9_DriverIRQHandler
     7ec:	00008e21 	.word	0x00008e21
    ldr   r0,=DMA10_DriverIRQHandler
     7f0:	00008e35 	.word	0x00008e35
    ldr   r0,=DMA11_DriverIRQHandler
     7f4:	00008e49 	.word	0x00008e49
    ldr   r0,=DMA12_DriverIRQHandler
     7f8:	00008e5d 	.word	0x00008e5d
    ldr   r0,=DMA13_DriverIRQHandler
     7fc:	00008e71 	.word	0x00008e71
    ldr   r0,=DMA14_DriverIRQHandler
     800:	00008e85 	.word	0x00008e85
    ldr   r0,=DMA15_DriverIRQHandler
     804:	00008e99 	.word	0x00008e99
    ldr   r0,=DMA_Error_DriverIRQHandler
     808:	000006d9 	.word	0x000006d9
    ldr   r0,=I2C0_DriverIRQHandler
     80c:	00008fa1 	.word	0x00008fa1
    ldr   r0,=I2C1_DriverIRQHandler
     810:	00008fbd 	.word	0x00008fbd
    ldr   r0,=SPI0_DriverIRQHandler
     814:	00008b59 	.word	0x00008b59
    ldr   r0,=SPI1_DriverIRQHandler
     818:	00008b95 	.word	0x00008b95
    ldr   r0,=I2S0_Tx_DriverIRQHandler
     81c:	000090e1 	.word	0x000090e1
    ldr   r0,=I2S0_Rx_DriverIRQHandler
     820:	00009125 	.word	0x00009125
    ldr   r0,=UART0_LON_DriverIRQHandler
     824:	000006d9 	.word	0x000006d9
    ldr   r0,=UART0_RX_TX_DriverIRQHandler
     828:	000097d9 	.word	0x000097d9
    ldr   r0,=UART0_ERR_DriverIRQHandler
     82c:	000006d9 	.word	0x000006d9
    ldr   r0,=UART1_RX_TX_DriverIRQHandler
     830:	00009805 	.word	0x00009805
    ldr   r0,=UART1_ERR_DriverIRQHandler
     834:	000006d9 	.word	0x000006d9
    ldr   r0,=UART2_RX_TX_DriverIRQHandler
     838:	00009831 	.word	0x00009831
    ldr   r0,=UART2_ERR_DriverIRQHandler
     83c:	000006d9 	.word	0x000006d9
    ldr   r0,=UART3_RX_TX_DriverIRQHandler
     840:	0000985d 	.word	0x0000985d
    ldr   r0,=UART3_ERR_DriverIRQHandler
     844:	000006d9 	.word	0x000006d9
    ldr   r0,=SPI2_DriverIRQHandler
     848:	00008bd1 	.word	0x00008bd1
    ldr   r0,=UART4_RX_TX_DriverIRQHandler
     84c:	00009889 	.word	0x00009889
    ldr   r0,=UART4_ERR_DriverIRQHandler
     850:	000006d9 	.word	0x000006d9
    ldr   r0,=UART5_RX_TX_DriverIRQHandler
     854:	000098b5 	.word	0x000098b5
    ldr   r0,=UART5_ERR_DriverIRQHandler
     858:	000006d9 	.word	0x000006d9
    ldr   r0,=I2C2_DriverIRQHandler
     85c:	00008fd9 	.word	0x00008fd9
    ldr   r0,=CAN0_DriverIRQHandler
     860:	00008f0d 	.word	0x00008f0d
    ldr   r0,=SDHC_DriverIRQHandler
     864:	00009169 	.word	0x00009169
    ldr   r0,=ENET_1588_Timer_DriverIRQHandler
     868:	000006d9 	.word	0x000006d9
    ldr   r0,=ENET_Transmit_DriverIRQHandler
     86c:	000006d9 	.word	0x000006d9
    ldr   r0,=ENET_Receive_DriverIRQHandler
     870:	000006d9 	.word	0x000006d9
    ldr   r0,=ENET_Error_DriverIRQHandler
     874:	000006d9 	.word	0x000006d9
	...

00000880 <memchr>:
     880:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     884:	2a10      	cmp	r2, #16
     886:	db2b      	blt.n	8e0 <memchr+0x60>
     888:	f010 0f07 	tst.w	r0, #7
     88c:	d008      	beq.n	8a0 <memchr+0x20>
     88e:	f810 3b01 	ldrb.w	r3, [r0], #1
     892:	3a01      	subs	r2, #1
     894:	428b      	cmp	r3, r1
     896:	d02d      	beq.n	8f4 <memchr+0x74>
     898:	f010 0f07 	tst.w	r0, #7
     89c:	b342      	cbz	r2, 8f0 <memchr+0x70>
     89e:	d1f6      	bne.n	88e <memchr+0xe>
     8a0:	b4f0      	push	{r4, r5, r6, r7}
     8a2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
     8a6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
     8aa:	f022 0407 	bic.w	r4, r2, #7
     8ae:	f07f 0700 	mvns.w	r7, #0
     8b2:	2300      	movs	r3, #0
     8b4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
     8b8:	3c08      	subs	r4, #8
     8ba:	ea85 0501 	eor.w	r5, r5, r1
     8be:	ea86 0601 	eor.w	r6, r6, r1
     8c2:	fa85 f547 	uadd8	r5, r5, r7
     8c6:	faa3 f587 	sel	r5, r3, r7
     8ca:	fa86 f647 	uadd8	r6, r6, r7
     8ce:	faa5 f687 	sel	r6, r5, r7
     8d2:	b98e      	cbnz	r6, 8f8 <memchr+0x78>
     8d4:	d1ee      	bne.n	8b4 <memchr+0x34>
     8d6:	bcf0      	pop	{r4, r5, r6, r7}
     8d8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
     8dc:	f002 0207 	and.w	r2, r2, #7
     8e0:	b132      	cbz	r2, 8f0 <memchr+0x70>
     8e2:	f810 3b01 	ldrb.w	r3, [r0], #1
     8e6:	3a01      	subs	r2, #1
     8e8:	ea83 0301 	eor.w	r3, r3, r1
     8ec:	b113      	cbz	r3, 8f4 <memchr+0x74>
     8ee:	d1f8      	bne.n	8e2 <memchr+0x62>
     8f0:	2000      	movs	r0, #0
     8f2:	4770      	bx	lr
     8f4:	3801      	subs	r0, #1
     8f6:	4770      	bx	lr
     8f8:	2d00      	cmp	r5, #0
     8fa:	bf06      	itte	eq
     8fc:	4635      	moveq	r5, r6
     8fe:	3803      	subeq	r0, #3
     900:	3807      	subne	r0, #7
     902:	f015 0f01 	tst.w	r5, #1
     906:	d107      	bne.n	918 <memchr+0x98>
     908:	3001      	adds	r0, #1
     90a:	f415 7f80 	tst.w	r5, #256	; 0x100
     90e:	bf02      	ittt	eq
     910:	3001      	addeq	r0, #1
     912:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
     916:	3001      	addeq	r0, #1
     918:	bcf0      	pop	{r4, r5, r6, r7}
     91a:	3801      	subs	r0, #1
     91c:	4770      	bx	lr
     91e:	bf00      	nop

00000920 <memcpy>:
     920:	4684      	mov	ip, r0
     922:	ea41 0300 	orr.w	r3, r1, r0
     926:	f013 0303 	ands.w	r3, r3, #3
     92a:	d16d      	bne.n	a08 <memcpy+0xe8>
     92c:	3a40      	subs	r2, #64	; 0x40
     92e:	d341      	bcc.n	9b4 <memcpy+0x94>
     930:	f851 3b04 	ldr.w	r3, [r1], #4
     934:	f840 3b04 	str.w	r3, [r0], #4
     938:	f851 3b04 	ldr.w	r3, [r1], #4
     93c:	f840 3b04 	str.w	r3, [r0], #4
     940:	f851 3b04 	ldr.w	r3, [r1], #4
     944:	f840 3b04 	str.w	r3, [r0], #4
     948:	f851 3b04 	ldr.w	r3, [r1], #4
     94c:	f840 3b04 	str.w	r3, [r0], #4
     950:	f851 3b04 	ldr.w	r3, [r1], #4
     954:	f840 3b04 	str.w	r3, [r0], #4
     958:	f851 3b04 	ldr.w	r3, [r1], #4
     95c:	f840 3b04 	str.w	r3, [r0], #4
     960:	f851 3b04 	ldr.w	r3, [r1], #4
     964:	f840 3b04 	str.w	r3, [r0], #4
     968:	f851 3b04 	ldr.w	r3, [r1], #4
     96c:	f840 3b04 	str.w	r3, [r0], #4
     970:	f851 3b04 	ldr.w	r3, [r1], #4
     974:	f840 3b04 	str.w	r3, [r0], #4
     978:	f851 3b04 	ldr.w	r3, [r1], #4
     97c:	f840 3b04 	str.w	r3, [r0], #4
     980:	f851 3b04 	ldr.w	r3, [r1], #4
     984:	f840 3b04 	str.w	r3, [r0], #4
     988:	f851 3b04 	ldr.w	r3, [r1], #4
     98c:	f840 3b04 	str.w	r3, [r0], #4
     990:	f851 3b04 	ldr.w	r3, [r1], #4
     994:	f840 3b04 	str.w	r3, [r0], #4
     998:	f851 3b04 	ldr.w	r3, [r1], #4
     99c:	f840 3b04 	str.w	r3, [r0], #4
     9a0:	f851 3b04 	ldr.w	r3, [r1], #4
     9a4:	f840 3b04 	str.w	r3, [r0], #4
     9a8:	f851 3b04 	ldr.w	r3, [r1], #4
     9ac:	f840 3b04 	str.w	r3, [r0], #4
     9b0:	3a40      	subs	r2, #64	; 0x40
     9b2:	d2bd      	bcs.n	930 <memcpy+0x10>
     9b4:	3230      	adds	r2, #48	; 0x30
     9b6:	d311      	bcc.n	9dc <memcpy+0xbc>
     9b8:	f851 3b04 	ldr.w	r3, [r1], #4
     9bc:	f840 3b04 	str.w	r3, [r0], #4
     9c0:	f851 3b04 	ldr.w	r3, [r1], #4
     9c4:	f840 3b04 	str.w	r3, [r0], #4
     9c8:	f851 3b04 	ldr.w	r3, [r1], #4
     9cc:	f840 3b04 	str.w	r3, [r0], #4
     9d0:	f851 3b04 	ldr.w	r3, [r1], #4
     9d4:	f840 3b04 	str.w	r3, [r0], #4
     9d8:	3a10      	subs	r2, #16
     9da:	d2ed      	bcs.n	9b8 <memcpy+0x98>
     9dc:	320c      	adds	r2, #12
     9de:	d305      	bcc.n	9ec <memcpy+0xcc>
     9e0:	f851 3b04 	ldr.w	r3, [r1], #4
     9e4:	f840 3b04 	str.w	r3, [r0], #4
     9e8:	3a04      	subs	r2, #4
     9ea:	d2f9      	bcs.n	9e0 <memcpy+0xc0>
     9ec:	3204      	adds	r2, #4
     9ee:	d008      	beq.n	a02 <memcpy+0xe2>
     9f0:	07d2      	lsls	r2, r2, #31
     9f2:	bf1c      	itt	ne
     9f4:	f811 3b01 	ldrbne.w	r3, [r1], #1
     9f8:	f800 3b01 	strbne.w	r3, [r0], #1
     9fc:	d301      	bcc.n	a02 <memcpy+0xe2>
     9fe:	880b      	ldrh	r3, [r1, #0]
     a00:	8003      	strh	r3, [r0, #0]
     a02:	4660      	mov	r0, ip
     a04:	4770      	bx	lr
     a06:	bf00      	nop
     a08:	2a08      	cmp	r2, #8
     a0a:	d313      	bcc.n	a34 <memcpy+0x114>
     a0c:	078b      	lsls	r3, r1, #30
     a0e:	d08d      	beq.n	92c <memcpy+0xc>
     a10:	f010 0303 	ands.w	r3, r0, #3
     a14:	d08a      	beq.n	92c <memcpy+0xc>
     a16:	f1c3 0304 	rsb	r3, r3, #4
     a1a:	1ad2      	subs	r2, r2, r3
     a1c:	07db      	lsls	r3, r3, #31
     a1e:	bf1c      	itt	ne
     a20:	f811 3b01 	ldrbne.w	r3, [r1], #1
     a24:	f800 3b01 	strbne.w	r3, [r0], #1
     a28:	d380      	bcc.n	92c <memcpy+0xc>
     a2a:	f831 3b02 	ldrh.w	r3, [r1], #2
     a2e:	f820 3b02 	strh.w	r3, [r0], #2
     a32:	e77b      	b.n	92c <memcpy+0xc>
     a34:	3a04      	subs	r2, #4
     a36:	d3d9      	bcc.n	9ec <memcpy+0xcc>
     a38:	3a01      	subs	r2, #1
     a3a:	f811 3b01 	ldrb.w	r3, [r1], #1
     a3e:	f800 3b01 	strb.w	r3, [r0], #1
     a42:	d2f9      	bcs.n	a38 <memcpy+0x118>
     a44:	780b      	ldrb	r3, [r1, #0]
     a46:	7003      	strb	r3, [r0, #0]
     a48:	784b      	ldrb	r3, [r1, #1]
     a4a:	7043      	strb	r3, [r0, #1]
     a4c:	788b      	ldrb	r3, [r1, #2]
     a4e:	7083      	strb	r3, [r0, #2]
     a50:	4660      	mov	r0, ip
     a52:	4770      	bx	lr
	...

00000a80 <strlen>:
     a80:	f890 f000 	pld	[r0]
     a84:	e96d 4502 	strd	r4, r5, [sp, #-8]!
     a88:	f020 0107 	bic.w	r1, r0, #7
     a8c:	f06f 0c00 	mvn.w	ip, #0
     a90:	f010 0407 	ands.w	r4, r0, #7
     a94:	f891 f020 	pld	[r1, #32]
     a98:	f040 8049 	bne.w	b2e <strlen+0xae>
     a9c:	f04f 0400 	mov.w	r4, #0
     aa0:	f06f 0007 	mvn.w	r0, #7
     aa4:	e9d1 2300 	ldrd	r2, r3, [r1]
     aa8:	f891 f040 	pld	[r1, #64]	; 0x40
     aac:	f100 0008 	add.w	r0, r0, #8
     ab0:	fa82 f24c 	uadd8	r2, r2, ip
     ab4:	faa4 f28c 	sel	r2, r4, ip
     ab8:	fa83 f34c 	uadd8	r3, r3, ip
     abc:	faa2 f38c 	sel	r3, r2, ip
     ac0:	bb4b      	cbnz	r3, b16 <strlen+0x96>
     ac2:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
     ac6:	fa82 f24c 	uadd8	r2, r2, ip
     aca:	f100 0008 	add.w	r0, r0, #8
     ace:	faa4 f28c 	sel	r2, r4, ip
     ad2:	fa83 f34c 	uadd8	r3, r3, ip
     ad6:	faa2 f38c 	sel	r3, r2, ip
     ada:	b9e3      	cbnz	r3, b16 <strlen+0x96>
     adc:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
     ae0:	fa82 f24c 	uadd8	r2, r2, ip
     ae4:	f100 0008 	add.w	r0, r0, #8
     ae8:	faa4 f28c 	sel	r2, r4, ip
     aec:	fa83 f34c 	uadd8	r3, r3, ip
     af0:	faa2 f38c 	sel	r3, r2, ip
     af4:	b97b      	cbnz	r3, b16 <strlen+0x96>
     af6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
     afa:	f101 0120 	add.w	r1, r1, #32
     afe:	fa82 f24c 	uadd8	r2, r2, ip
     b02:	f100 0008 	add.w	r0, r0, #8
     b06:	faa4 f28c 	sel	r2, r4, ip
     b0a:	fa83 f34c 	uadd8	r3, r3, ip
     b0e:	faa2 f38c 	sel	r3, r2, ip
     b12:	2b00      	cmp	r3, #0
     b14:	d0c6      	beq.n	aa4 <strlen+0x24>
     b16:	2a00      	cmp	r2, #0
     b18:	bf04      	itt	eq
     b1a:	3004      	addeq	r0, #4
     b1c:	461a      	moveq	r2, r3
     b1e:	ba12      	rev	r2, r2
     b20:	fab2 f282 	clz	r2, r2
     b24:	e8fd 4502 	ldrd	r4, r5, [sp], #8
     b28:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
     b2c:	4770      	bx	lr
     b2e:	e9d1 2300 	ldrd	r2, r3, [r1]
     b32:	f004 0503 	and.w	r5, r4, #3
     b36:	f1c4 0000 	rsb	r0, r4, #0
     b3a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
     b3e:	f014 0f04 	tst.w	r4, #4
     b42:	f891 f040 	pld	[r1, #64]	; 0x40
     b46:	fa0c f505 	lsl.w	r5, ip, r5
     b4a:	ea62 0205 	orn	r2, r2, r5
     b4e:	bf1c      	itt	ne
     b50:	ea63 0305 	ornne	r3, r3, r5
     b54:	4662      	movne	r2, ip
     b56:	f04f 0400 	mov.w	r4, #0
     b5a:	e7a9      	b.n	ab0 <strlen+0x30>

00000b5c <__aeabi_drsub>:
     b5c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
     b60:	e002      	b.n	b68 <__adddf3>
     b62:	bf00      	nop

00000b64 <__aeabi_dsub>:
     b64:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00000b68 <__adddf3>:
     b68:	b530      	push	{r4, r5, lr}
     b6a:	ea4f 0441 	mov.w	r4, r1, lsl #1
     b6e:	ea4f 0543 	mov.w	r5, r3, lsl #1
     b72:	ea94 0f05 	teq	r4, r5
     b76:	bf08      	it	eq
     b78:	ea90 0f02 	teqeq	r0, r2
     b7c:	bf1f      	itttt	ne
     b7e:	ea54 0c00 	orrsne.w	ip, r4, r0
     b82:	ea55 0c02 	orrsne.w	ip, r5, r2
     b86:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
     b8a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
     b8e:	f000 80e2 	beq.w	d56 <__adddf3+0x1ee>
     b92:	ea4f 5454 	mov.w	r4, r4, lsr #21
     b96:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
     b9a:	bfb8      	it	lt
     b9c:	426d      	neglt	r5, r5
     b9e:	dd0c      	ble.n	bba <__adddf3+0x52>
     ba0:	442c      	add	r4, r5
     ba2:	ea80 0202 	eor.w	r2, r0, r2
     ba6:	ea81 0303 	eor.w	r3, r1, r3
     baa:	ea82 0000 	eor.w	r0, r2, r0
     bae:	ea83 0101 	eor.w	r1, r3, r1
     bb2:	ea80 0202 	eor.w	r2, r0, r2
     bb6:	ea81 0303 	eor.w	r3, r1, r3
     bba:	2d36      	cmp	r5, #54	; 0x36
     bbc:	bf88      	it	hi
     bbe:	bd30      	pophi	{r4, r5, pc}
     bc0:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
     bc4:	ea4f 3101 	mov.w	r1, r1, lsl #12
     bc8:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
     bcc:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
     bd0:	d002      	beq.n	bd8 <__adddf3+0x70>
     bd2:	4240      	negs	r0, r0
     bd4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     bd8:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
     bdc:	ea4f 3303 	mov.w	r3, r3, lsl #12
     be0:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
     be4:	d002      	beq.n	bec <__adddf3+0x84>
     be6:	4252      	negs	r2, r2
     be8:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     bec:	ea94 0f05 	teq	r4, r5
     bf0:	f000 80a7 	beq.w	d42 <__adddf3+0x1da>
     bf4:	f1a4 0401 	sub.w	r4, r4, #1
     bf8:	f1d5 0e20 	rsbs	lr, r5, #32
     bfc:	db0d      	blt.n	c1a <__adddf3+0xb2>
     bfe:	fa02 fc0e 	lsl.w	ip, r2, lr
     c02:	fa22 f205 	lsr.w	r2, r2, r5
     c06:	1880      	adds	r0, r0, r2
     c08:	f141 0100 	adc.w	r1, r1, #0
     c0c:	fa03 f20e 	lsl.w	r2, r3, lr
     c10:	1880      	adds	r0, r0, r2
     c12:	fa43 f305 	asr.w	r3, r3, r5
     c16:	4159      	adcs	r1, r3
     c18:	e00e      	b.n	c38 <__adddf3+0xd0>
     c1a:	f1a5 0520 	sub.w	r5, r5, #32
     c1e:	f10e 0e20 	add.w	lr, lr, #32
     c22:	2a01      	cmp	r2, #1
     c24:	fa03 fc0e 	lsl.w	ip, r3, lr
     c28:	bf28      	it	cs
     c2a:	f04c 0c02 	orrcs.w	ip, ip, #2
     c2e:	fa43 f305 	asr.w	r3, r3, r5
     c32:	18c0      	adds	r0, r0, r3
     c34:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
     c38:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
     c3c:	d507      	bpl.n	c4e <__adddf3+0xe6>
     c3e:	f04f 0e00 	mov.w	lr, #0
     c42:	f1dc 0c00 	rsbs	ip, ip, #0
     c46:	eb7e 0000 	sbcs.w	r0, lr, r0
     c4a:	eb6e 0101 	sbc.w	r1, lr, r1
     c4e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
     c52:	d31b      	bcc.n	c8c <__adddf3+0x124>
     c54:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
     c58:	d30c      	bcc.n	c74 <__adddf3+0x10c>
     c5a:	0849      	lsrs	r1, r1, #1
     c5c:	ea5f 0030 	movs.w	r0, r0, rrx
     c60:	ea4f 0c3c 	mov.w	ip, ip, rrx
     c64:	f104 0401 	add.w	r4, r4, #1
     c68:	ea4f 5244 	mov.w	r2, r4, lsl #21
     c6c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
     c70:	f080 809a 	bcs.w	da8 <__adddf3+0x240>
     c74:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
     c78:	bf08      	it	eq
     c7a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
     c7e:	f150 0000 	adcs.w	r0, r0, #0
     c82:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
     c86:	ea41 0105 	orr.w	r1, r1, r5
     c8a:	bd30      	pop	{r4, r5, pc}
     c8c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
     c90:	4140      	adcs	r0, r0
     c92:	eb41 0101 	adc.w	r1, r1, r1
     c96:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
     c9a:	f1a4 0401 	sub.w	r4, r4, #1
     c9e:	d1e9      	bne.n	c74 <__adddf3+0x10c>
     ca0:	f091 0f00 	teq	r1, #0
     ca4:	bf04      	itt	eq
     ca6:	4601      	moveq	r1, r0
     ca8:	2000      	moveq	r0, #0
     caa:	fab1 f381 	clz	r3, r1
     cae:	bf08      	it	eq
     cb0:	3320      	addeq	r3, #32
     cb2:	f1a3 030b 	sub.w	r3, r3, #11
     cb6:	f1b3 0220 	subs.w	r2, r3, #32
     cba:	da0c      	bge.n	cd6 <__adddf3+0x16e>
     cbc:	320c      	adds	r2, #12
     cbe:	dd08      	ble.n	cd2 <__adddf3+0x16a>
     cc0:	f102 0c14 	add.w	ip, r2, #20
     cc4:	f1c2 020c 	rsb	r2, r2, #12
     cc8:	fa01 f00c 	lsl.w	r0, r1, ip
     ccc:	fa21 f102 	lsr.w	r1, r1, r2
     cd0:	e00c      	b.n	cec <__adddf3+0x184>
     cd2:	f102 0214 	add.w	r2, r2, #20
     cd6:	bfd8      	it	le
     cd8:	f1c2 0c20 	rsble	ip, r2, #32
     cdc:	fa01 f102 	lsl.w	r1, r1, r2
     ce0:	fa20 fc0c 	lsr.w	ip, r0, ip
     ce4:	bfdc      	itt	le
     ce6:	ea41 010c 	orrle.w	r1, r1, ip
     cea:	4090      	lslle	r0, r2
     cec:	1ae4      	subs	r4, r4, r3
     cee:	bfa2      	ittt	ge
     cf0:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
     cf4:	4329      	orrge	r1, r5
     cf6:	bd30      	popge	{r4, r5, pc}
     cf8:	ea6f 0404 	mvn.w	r4, r4
     cfc:	3c1f      	subs	r4, #31
     cfe:	da1c      	bge.n	d3a <__adddf3+0x1d2>
     d00:	340c      	adds	r4, #12
     d02:	dc0e      	bgt.n	d22 <__adddf3+0x1ba>
     d04:	f104 0414 	add.w	r4, r4, #20
     d08:	f1c4 0220 	rsb	r2, r4, #32
     d0c:	fa20 f004 	lsr.w	r0, r0, r4
     d10:	fa01 f302 	lsl.w	r3, r1, r2
     d14:	ea40 0003 	orr.w	r0, r0, r3
     d18:	fa21 f304 	lsr.w	r3, r1, r4
     d1c:	ea45 0103 	orr.w	r1, r5, r3
     d20:	bd30      	pop	{r4, r5, pc}
     d22:	f1c4 040c 	rsb	r4, r4, #12
     d26:	f1c4 0220 	rsb	r2, r4, #32
     d2a:	fa20 f002 	lsr.w	r0, r0, r2
     d2e:	fa01 f304 	lsl.w	r3, r1, r4
     d32:	ea40 0003 	orr.w	r0, r0, r3
     d36:	4629      	mov	r1, r5
     d38:	bd30      	pop	{r4, r5, pc}
     d3a:	fa21 f004 	lsr.w	r0, r1, r4
     d3e:	4629      	mov	r1, r5
     d40:	bd30      	pop	{r4, r5, pc}
     d42:	f094 0f00 	teq	r4, #0
     d46:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
     d4a:	bf06      	itte	eq
     d4c:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
     d50:	3401      	addeq	r4, #1
     d52:	3d01      	subne	r5, #1
     d54:	e74e      	b.n	bf4 <__adddf3+0x8c>
     d56:	ea7f 5c64 	mvns.w	ip, r4, asr #21
     d5a:	bf18      	it	ne
     d5c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
     d60:	d029      	beq.n	db6 <__adddf3+0x24e>
     d62:	ea94 0f05 	teq	r4, r5
     d66:	bf08      	it	eq
     d68:	ea90 0f02 	teqeq	r0, r2
     d6c:	d005      	beq.n	d7a <__adddf3+0x212>
     d6e:	ea54 0c00 	orrs.w	ip, r4, r0
     d72:	bf04      	itt	eq
     d74:	4619      	moveq	r1, r3
     d76:	4610      	moveq	r0, r2
     d78:	bd30      	pop	{r4, r5, pc}
     d7a:	ea91 0f03 	teq	r1, r3
     d7e:	bf1e      	ittt	ne
     d80:	2100      	movne	r1, #0
     d82:	2000      	movne	r0, #0
     d84:	bd30      	popne	{r4, r5, pc}
     d86:	ea5f 5c54 	movs.w	ip, r4, lsr #21
     d8a:	d105      	bne.n	d98 <__adddf3+0x230>
     d8c:	0040      	lsls	r0, r0, #1
     d8e:	4149      	adcs	r1, r1
     d90:	bf28      	it	cs
     d92:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
     d96:	bd30      	pop	{r4, r5, pc}
     d98:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
     d9c:	bf3c      	itt	cc
     d9e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
     da2:	bd30      	popcc	{r4, r5, pc}
     da4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
     da8:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
     dac:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
     db0:	f04f 0000 	mov.w	r0, #0
     db4:	bd30      	pop	{r4, r5, pc}
     db6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
     dba:	bf1a      	itte	ne
     dbc:	4619      	movne	r1, r3
     dbe:	4610      	movne	r0, r2
     dc0:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
     dc4:	bf1c      	itt	ne
     dc6:	460b      	movne	r3, r1
     dc8:	4602      	movne	r2, r0
     dca:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
     dce:	bf06      	itte	eq
     dd0:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
     dd4:	ea91 0f03 	teqeq	r1, r3
     dd8:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
     ddc:	bd30      	pop	{r4, r5, pc}
     dde:	bf00      	nop

00000de0 <__aeabi_ui2d>:
     de0:	f090 0f00 	teq	r0, #0
     de4:	bf04      	itt	eq
     de6:	2100      	moveq	r1, #0
     de8:	4770      	bxeq	lr
     dea:	b530      	push	{r4, r5, lr}
     dec:	f44f 6480 	mov.w	r4, #1024	; 0x400
     df0:	f104 0432 	add.w	r4, r4, #50	; 0x32
     df4:	f04f 0500 	mov.w	r5, #0
     df8:	f04f 0100 	mov.w	r1, #0
     dfc:	e750      	b.n	ca0 <__adddf3+0x138>
     dfe:	bf00      	nop

00000e00 <__aeabi_i2d>:
     e00:	f090 0f00 	teq	r0, #0
     e04:	bf04      	itt	eq
     e06:	2100      	moveq	r1, #0
     e08:	4770      	bxeq	lr
     e0a:	b530      	push	{r4, r5, lr}
     e0c:	f44f 6480 	mov.w	r4, #1024	; 0x400
     e10:	f104 0432 	add.w	r4, r4, #50	; 0x32
     e14:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
     e18:	bf48      	it	mi
     e1a:	4240      	negmi	r0, r0
     e1c:	f04f 0100 	mov.w	r1, #0
     e20:	e73e      	b.n	ca0 <__adddf3+0x138>
     e22:	bf00      	nop

00000e24 <__aeabi_f2d>:
     e24:	0042      	lsls	r2, r0, #1
     e26:	ea4f 01e2 	mov.w	r1, r2, asr #3
     e2a:	ea4f 0131 	mov.w	r1, r1, rrx
     e2e:	ea4f 7002 	mov.w	r0, r2, lsl #28
     e32:	bf1f      	itttt	ne
     e34:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
     e38:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
     e3c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
     e40:	4770      	bxne	lr
     e42:	f092 0f00 	teq	r2, #0
     e46:	bf14      	ite	ne
     e48:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
     e4c:	4770      	bxeq	lr
     e4e:	b530      	push	{r4, r5, lr}
     e50:	f44f 7460 	mov.w	r4, #896	; 0x380
     e54:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
     e58:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
     e5c:	e720      	b.n	ca0 <__adddf3+0x138>
     e5e:	bf00      	nop

00000e60 <__aeabi_ul2d>:
     e60:	ea50 0201 	orrs.w	r2, r0, r1
     e64:	bf08      	it	eq
     e66:	4770      	bxeq	lr
     e68:	b530      	push	{r4, r5, lr}
     e6a:	f04f 0500 	mov.w	r5, #0
     e6e:	e00a      	b.n	e86 <__aeabi_l2d+0x16>

00000e70 <__aeabi_l2d>:
     e70:	ea50 0201 	orrs.w	r2, r0, r1
     e74:	bf08      	it	eq
     e76:	4770      	bxeq	lr
     e78:	b530      	push	{r4, r5, lr}
     e7a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
     e7e:	d502      	bpl.n	e86 <__aeabi_l2d+0x16>
     e80:	4240      	negs	r0, r0
     e82:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     e86:	f44f 6480 	mov.w	r4, #1024	; 0x400
     e8a:	f104 0432 	add.w	r4, r4, #50	; 0x32
     e8e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
     e92:	f43f aedc 	beq.w	c4e <__adddf3+0xe6>
     e96:	f04f 0203 	mov.w	r2, #3
     e9a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
     e9e:	bf18      	it	ne
     ea0:	3203      	addne	r2, #3
     ea2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
     ea6:	bf18      	it	ne
     ea8:	3203      	addne	r2, #3
     eaa:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
     eae:	f1c2 0320 	rsb	r3, r2, #32
     eb2:	fa00 fc03 	lsl.w	ip, r0, r3
     eb6:	fa20 f002 	lsr.w	r0, r0, r2
     eba:	fa01 fe03 	lsl.w	lr, r1, r3
     ebe:	ea40 000e 	orr.w	r0, r0, lr
     ec2:	fa21 f102 	lsr.w	r1, r1, r2
     ec6:	4414      	add	r4, r2
     ec8:	e6c1      	b.n	c4e <__adddf3+0xe6>
     eca:	bf00      	nop

00000ecc <__aeabi_dmul>:
     ecc:	b570      	push	{r4, r5, r6, lr}
     ece:	f04f 0cff 	mov.w	ip, #255	; 0xff
     ed2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
     ed6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
     eda:	bf1d      	ittte	ne
     edc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
     ee0:	ea94 0f0c 	teqne	r4, ip
     ee4:	ea95 0f0c 	teqne	r5, ip
     ee8:	f000 f8de 	bleq	10a8 <__aeabi_dmul+0x1dc>
     eec:	442c      	add	r4, r5
     eee:	ea81 0603 	eor.w	r6, r1, r3
     ef2:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
     ef6:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
     efa:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
     efe:	bf18      	it	ne
     f00:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
     f04:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     f08:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
     f0c:	d038      	beq.n	f80 <__aeabi_dmul+0xb4>
     f0e:	fba0 ce02 	umull	ip, lr, r0, r2
     f12:	f04f 0500 	mov.w	r5, #0
     f16:	fbe1 e502 	umlal	lr, r5, r1, r2
     f1a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
     f1e:	fbe0 e503 	umlal	lr, r5, r0, r3
     f22:	f04f 0600 	mov.w	r6, #0
     f26:	fbe1 5603 	umlal	r5, r6, r1, r3
     f2a:	f09c 0f00 	teq	ip, #0
     f2e:	bf18      	it	ne
     f30:	f04e 0e01 	orrne.w	lr, lr, #1
     f34:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
     f38:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
     f3c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
     f40:	d204      	bcs.n	f4c <__aeabi_dmul+0x80>
     f42:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
     f46:	416d      	adcs	r5, r5
     f48:	eb46 0606 	adc.w	r6, r6, r6
     f4c:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
     f50:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
     f54:	ea4f 20c5 	mov.w	r0, r5, lsl #11
     f58:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
     f5c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
     f60:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
     f64:	bf88      	it	hi
     f66:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
     f6a:	d81e      	bhi.n	faa <__aeabi_dmul+0xde>
     f6c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
     f70:	bf08      	it	eq
     f72:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
     f76:	f150 0000 	adcs.w	r0, r0, #0
     f7a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
     f7e:	bd70      	pop	{r4, r5, r6, pc}
     f80:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
     f84:	ea46 0101 	orr.w	r1, r6, r1
     f88:	ea40 0002 	orr.w	r0, r0, r2
     f8c:	ea81 0103 	eor.w	r1, r1, r3
     f90:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
     f94:	bfc2      	ittt	gt
     f96:	ebd4 050c 	rsbsgt	r5, r4, ip
     f9a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
     f9e:	bd70      	popgt	{r4, r5, r6, pc}
     fa0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
     fa4:	f04f 0e00 	mov.w	lr, #0
     fa8:	3c01      	subs	r4, #1
     faa:	f300 80ab 	bgt.w	1104 <__aeabi_dmul+0x238>
     fae:	f114 0f36 	cmn.w	r4, #54	; 0x36
     fb2:	bfde      	ittt	le
     fb4:	2000      	movle	r0, #0
     fb6:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
     fba:	bd70      	pople	{r4, r5, r6, pc}
     fbc:	f1c4 0400 	rsb	r4, r4, #0
     fc0:	3c20      	subs	r4, #32
     fc2:	da35      	bge.n	1030 <__aeabi_dmul+0x164>
     fc4:	340c      	adds	r4, #12
     fc6:	dc1b      	bgt.n	1000 <__aeabi_dmul+0x134>
     fc8:	f104 0414 	add.w	r4, r4, #20
     fcc:	f1c4 0520 	rsb	r5, r4, #32
     fd0:	fa00 f305 	lsl.w	r3, r0, r5
     fd4:	fa20 f004 	lsr.w	r0, r0, r4
     fd8:	fa01 f205 	lsl.w	r2, r1, r5
     fdc:	ea40 0002 	orr.w	r0, r0, r2
     fe0:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
     fe4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
     fe8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
     fec:	fa21 f604 	lsr.w	r6, r1, r4
     ff0:	eb42 0106 	adc.w	r1, r2, r6
     ff4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
     ff8:	bf08      	it	eq
     ffa:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
     ffe:	bd70      	pop	{r4, r5, r6, pc}
    1000:	f1c4 040c 	rsb	r4, r4, #12
    1004:	f1c4 0520 	rsb	r5, r4, #32
    1008:	fa00 f304 	lsl.w	r3, r0, r4
    100c:	fa20 f005 	lsr.w	r0, r0, r5
    1010:	fa01 f204 	lsl.w	r2, r1, r4
    1014:	ea40 0002 	orr.w	r0, r0, r2
    1018:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    101c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    1020:	f141 0100 	adc.w	r1, r1, #0
    1024:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    1028:	bf08      	it	eq
    102a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    102e:	bd70      	pop	{r4, r5, r6, pc}
    1030:	f1c4 0520 	rsb	r5, r4, #32
    1034:	fa00 f205 	lsl.w	r2, r0, r5
    1038:	ea4e 0e02 	orr.w	lr, lr, r2
    103c:	fa20 f304 	lsr.w	r3, r0, r4
    1040:	fa01 f205 	lsl.w	r2, r1, r5
    1044:	ea43 0302 	orr.w	r3, r3, r2
    1048:	fa21 f004 	lsr.w	r0, r1, r4
    104c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    1050:	fa21 f204 	lsr.w	r2, r1, r4
    1054:	ea20 0002 	bic.w	r0, r0, r2
    1058:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    105c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    1060:	bf08      	it	eq
    1062:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    1066:	bd70      	pop	{r4, r5, r6, pc}
    1068:	f094 0f00 	teq	r4, #0
    106c:	d10f      	bne.n	108e <__aeabi_dmul+0x1c2>
    106e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    1072:	0040      	lsls	r0, r0, #1
    1074:	eb41 0101 	adc.w	r1, r1, r1
    1078:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    107c:	bf08      	it	eq
    107e:	3c01      	subeq	r4, #1
    1080:	d0f7      	beq.n	1072 <__aeabi_dmul+0x1a6>
    1082:	ea41 0106 	orr.w	r1, r1, r6
    1086:	f095 0f00 	teq	r5, #0
    108a:	bf18      	it	ne
    108c:	4770      	bxne	lr
    108e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    1092:	0052      	lsls	r2, r2, #1
    1094:	eb43 0303 	adc.w	r3, r3, r3
    1098:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    109c:	bf08      	it	eq
    109e:	3d01      	subeq	r5, #1
    10a0:	d0f7      	beq.n	1092 <__aeabi_dmul+0x1c6>
    10a2:	ea43 0306 	orr.w	r3, r3, r6
    10a6:	4770      	bx	lr
    10a8:	ea94 0f0c 	teq	r4, ip
    10ac:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    10b0:	bf18      	it	ne
    10b2:	ea95 0f0c 	teqne	r5, ip
    10b6:	d00c      	beq.n	10d2 <__aeabi_dmul+0x206>
    10b8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    10bc:	bf18      	it	ne
    10be:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    10c2:	d1d1      	bne.n	1068 <__aeabi_dmul+0x19c>
    10c4:	ea81 0103 	eor.w	r1, r1, r3
    10c8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    10cc:	f04f 0000 	mov.w	r0, #0
    10d0:	bd70      	pop	{r4, r5, r6, pc}
    10d2:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    10d6:	bf06      	itte	eq
    10d8:	4610      	moveq	r0, r2
    10da:	4619      	moveq	r1, r3
    10dc:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    10e0:	d019      	beq.n	1116 <__aeabi_dmul+0x24a>
    10e2:	ea94 0f0c 	teq	r4, ip
    10e6:	d102      	bne.n	10ee <__aeabi_dmul+0x222>
    10e8:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    10ec:	d113      	bne.n	1116 <__aeabi_dmul+0x24a>
    10ee:	ea95 0f0c 	teq	r5, ip
    10f2:	d105      	bne.n	1100 <__aeabi_dmul+0x234>
    10f4:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    10f8:	bf1c      	itt	ne
    10fa:	4610      	movne	r0, r2
    10fc:	4619      	movne	r1, r3
    10fe:	d10a      	bne.n	1116 <__aeabi_dmul+0x24a>
    1100:	ea81 0103 	eor.w	r1, r1, r3
    1104:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    1108:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    110c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    1110:	f04f 0000 	mov.w	r0, #0
    1114:	bd70      	pop	{r4, r5, r6, pc}
    1116:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    111a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    111e:	bd70      	pop	{r4, r5, r6, pc}

00001120 <__aeabi_ddiv>:
    1120:	b570      	push	{r4, r5, r6, lr}
    1122:	f04f 0cff 	mov.w	ip, #255	; 0xff
    1126:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    112a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    112e:	bf1d      	ittte	ne
    1130:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    1134:	ea94 0f0c 	teqne	r4, ip
    1138:	ea95 0f0c 	teqne	r5, ip
    113c:	f000 f8a7 	bleq	128e <__aeabi_ddiv+0x16e>
    1140:	eba4 0405 	sub.w	r4, r4, r5
    1144:	ea81 0e03 	eor.w	lr, r1, r3
    1148:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    114c:	ea4f 3101 	mov.w	r1, r1, lsl #12
    1150:	f000 8088 	beq.w	1264 <__aeabi_ddiv+0x144>
    1154:	ea4f 3303 	mov.w	r3, r3, lsl #12
    1158:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    115c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    1160:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    1164:	ea4f 2202 	mov.w	r2, r2, lsl #8
    1168:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    116c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    1170:	ea4f 2600 	mov.w	r6, r0, lsl #8
    1174:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    1178:	429d      	cmp	r5, r3
    117a:	bf08      	it	eq
    117c:	4296      	cmpeq	r6, r2
    117e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    1182:	f504 7440 	add.w	r4, r4, #768	; 0x300
    1186:	d202      	bcs.n	118e <__aeabi_ddiv+0x6e>
    1188:	085b      	lsrs	r3, r3, #1
    118a:	ea4f 0232 	mov.w	r2, r2, rrx
    118e:	1ab6      	subs	r6, r6, r2
    1190:	eb65 0503 	sbc.w	r5, r5, r3
    1194:	085b      	lsrs	r3, r3, #1
    1196:	ea4f 0232 	mov.w	r2, r2, rrx
    119a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    119e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    11a2:	ebb6 0e02 	subs.w	lr, r6, r2
    11a6:	eb75 0e03 	sbcs.w	lr, r5, r3
    11aa:	bf22      	ittt	cs
    11ac:	1ab6      	subcs	r6, r6, r2
    11ae:	4675      	movcs	r5, lr
    11b0:	ea40 000c 	orrcs.w	r0, r0, ip
    11b4:	085b      	lsrs	r3, r3, #1
    11b6:	ea4f 0232 	mov.w	r2, r2, rrx
    11ba:	ebb6 0e02 	subs.w	lr, r6, r2
    11be:	eb75 0e03 	sbcs.w	lr, r5, r3
    11c2:	bf22      	ittt	cs
    11c4:	1ab6      	subcs	r6, r6, r2
    11c6:	4675      	movcs	r5, lr
    11c8:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    11cc:	085b      	lsrs	r3, r3, #1
    11ce:	ea4f 0232 	mov.w	r2, r2, rrx
    11d2:	ebb6 0e02 	subs.w	lr, r6, r2
    11d6:	eb75 0e03 	sbcs.w	lr, r5, r3
    11da:	bf22      	ittt	cs
    11dc:	1ab6      	subcs	r6, r6, r2
    11de:	4675      	movcs	r5, lr
    11e0:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    11e4:	085b      	lsrs	r3, r3, #1
    11e6:	ea4f 0232 	mov.w	r2, r2, rrx
    11ea:	ebb6 0e02 	subs.w	lr, r6, r2
    11ee:	eb75 0e03 	sbcs.w	lr, r5, r3
    11f2:	bf22      	ittt	cs
    11f4:	1ab6      	subcs	r6, r6, r2
    11f6:	4675      	movcs	r5, lr
    11f8:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    11fc:	ea55 0e06 	orrs.w	lr, r5, r6
    1200:	d018      	beq.n	1234 <__aeabi_ddiv+0x114>
    1202:	ea4f 1505 	mov.w	r5, r5, lsl #4
    1206:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    120a:	ea4f 1606 	mov.w	r6, r6, lsl #4
    120e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1212:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    1216:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    121a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    121e:	d1c0      	bne.n	11a2 <__aeabi_ddiv+0x82>
    1220:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    1224:	d10b      	bne.n	123e <__aeabi_ddiv+0x11e>
    1226:	ea41 0100 	orr.w	r1, r1, r0
    122a:	f04f 0000 	mov.w	r0, #0
    122e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    1232:	e7b6      	b.n	11a2 <__aeabi_ddiv+0x82>
    1234:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    1238:	bf04      	itt	eq
    123a:	4301      	orreq	r1, r0
    123c:	2000      	moveq	r0, #0
    123e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    1242:	bf88      	it	hi
    1244:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    1248:	f63f aeaf 	bhi.w	faa <__aeabi_dmul+0xde>
    124c:	ebb5 0c03 	subs.w	ip, r5, r3
    1250:	bf04      	itt	eq
    1252:	ebb6 0c02 	subseq.w	ip, r6, r2
    1256:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    125a:	f150 0000 	adcs.w	r0, r0, #0
    125e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    1262:	bd70      	pop	{r4, r5, r6, pc}
    1264:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    1268:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    126c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    1270:	bfc2      	ittt	gt
    1272:	ebd4 050c 	rsbsgt	r5, r4, ip
    1276:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    127a:	bd70      	popgt	{r4, r5, r6, pc}
    127c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    1280:	f04f 0e00 	mov.w	lr, #0
    1284:	3c01      	subs	r4, #1
    1286:	e690      	b.n	faa <__aeabi_dmul+0xde>
    1288:	ea45 0e06 	orr.w	lr, r5, r6
    128c:	e68d      	b.n	faa <__aeabi_dmul+0xde>
    128e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    1292:	ea94 0f0c 	teq	r4, ip
    1296:	bf08      	it	eq
    1298:	ea95 0f0c 	teqeq	r5, ip
    129c:	f43f af3b 	beq.w	1116 <__aeabi_dmul+0x24a>
    12a0:	ea94 0f0c 	teq	r4, ip
    12a4:	d10a      	bne.n	12bc <__aeabi_ddiv+0x19c>
    12a6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    12aa:	f47f af34 	bne.w	1116 <__aeabi_dmul+0x24a>
    12ae:	ea95 0f0c 	teq	r5, ip
    12b2:	f47f af25 	bne.w	1100 <__aeabi_dmul+0x234>
    12b6:	4610      	mov	r0, r2
    12b8:	4619      	mov	r1, r3
    12ba:	e72c      	b.n	1116 <__aeabi_dmul+0x24a>
    12bc:	ea95 0f0c 	teq	r5, ip
    12c0:	d106      	bne.n	12d0 <__aeabi_ddiv+0x1b0>
    12c2:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    12c6:	f43f aefd 	beq.w	10c4 <__aeabi_dmul+0x1f8>
    12ca:	4610      	mov	r0, r2
    12cc:	4619      	mov	r1, r3
    12ce:	e722      	b.n	1116 <__aeabi_dmul+0x24a>
    12d0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    12d4:	bf18      	it	ne
    12d6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    12da:	f47f aec5 	bne.w	1068 <__aeabi_dmul+0x19c>
    12de:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    12e2:	f47f af0d 	bne.w	1100 <__aeabi_dmul+0x234>
    12e6:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    12ea:	f47f aeeb 	bne.w	10c4 <__aeabi_dmul+0x1f8>
    12ee:	e712      	b.n	1116 <__aeabi_dmul+0x24a>

000012f0 <__gedf2>:
    12f0:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
    12f4:	e006      	b.n	1304 <__cmpdf2+0x4>
    12f6:	bf00      	nop

000012f8 <__ledf2>:
    12f8:	f04f 0c01 	mov.w	ip, #1
    12fc:	e002      	b.n	1304 <__cmpdf2+0x4>
    12fe:	bf00      	nop

00001300 <__cmpdf2>:
    1300:	f04f 0c01 	mov.w	ip, #1
    1304:	f84d cd04 	str.w	ip, [sp, #-4]!
    1308:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    130c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    1310:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    1314:	bf18      	it	ne
    1316:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
    131a:	d01b      	beq.n	1354 <__cmpdf2+0x54>
    131c:	b001      	add	sp, #4
    131e:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
    1322:	bf0c      	ite	eq
    1324:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
    1328:	ea91 0f03 	teqne	r1, r3
    132c:	bf02      	ittt	eq
    132e:	ea90 0f02 	teqeq	r0, r2
    1332:	2000      	moveq	r0, #0
    1334:	4770      	bxeq	lr
    1336:	f110 0f00 	cmn.w	r0, #0
    133a:	ea91 0f03 	teq	r1, r3
    133e:	bf58      	it	pl
    1340:	4299      	cmppl	r1, r3
    1342:	bf08      	it	eq
    1344:	4290      	cmpeq	r0, r2
    1346:	bf2c      	ite	cs
    1348:	17d8      	asrcs	r0, r3, #31
    134a:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
    134e:	f040 0001 	orr.w	r0, r0, #1
    1352:	4770      	bx	lr
    1354:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    1358:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    135c:	d102      	bne.n	1364 <__cmpdf2+0x64>
    135e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    1362:	d107      	bne.n	1374 <__cmpdf2+0x74>
    1364:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    1368:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    136c:	d1d6      	bne.n	131c <__cmpdf2+0x1c>
    136e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    1372:	d0d3      	beq.n	131c <__cmpdf2+0x1c>
    1374:	f85d 0b04 	ldr.w	r0, [sp], #4
    1378:	4770      	bx	lr
    137a:	bf00      	nop

0000137c <__aeabi_cdrcmple>:
    137c:	4684      	mov	ip, r0
    137e:	4610      	mov	r0, r2
    1380:	4662      	mov	r2, ip
    1382:	468c      	mov	ip, r1
    1384:	4619      	mov	r1, r3
    1386:	4663      	mov	r3, ip
    1388:	e000      	b.n	138c <__aeabi_cdcmpeq>
    138a:	bf00      	nop

0000138c <__aeabi_cdcmpeq>:
    138c:	b501      	push	{r0, lr}
    138e:	f7ff ffb7 	bl	1300 <__cmpdf2>
    1392:	2800      	cmp	r0, #0
    1394:	bf48      	it	mi
    1396:	f110 0f00 	cmnmi.w	r0, #0
    139a:	bd01      	pop	{r0, pc}

0000139c <__aeabi_dcmpeq>:
    139c:	f84d ed08 	str.w	lr, [sp, #-8]!
    13a0:	f7ff fff4 	bl	138c <__aeabi_cdcmpeq>
    13a4:	bf0c      	ite	eq
    13a6:	2001      	moveq	r0, #1
    13a8:	2000      	movne	r0, #0
    13aa:	f85d fb08 	ldr.w	pc, [sp], #8
    13ae:	bf00      	nop

000013b0 <__aeabi_dcmplt>:
    13b0:	f84d ed08 	str.w	lr, [sp, #-8]!
    13b4:	f7ff ffea 	bl	138c <__aeabi_cdcmpeq>
    13b8:	bf34      	ite	cc
    13ba:	2001      	movcc	r0, #1
    13bc:	2000      	movcs	r0, #0
    13be:	f85d fb08 	ldr.w	pc, [sp], #8
    13c2:	bf00      	nop

000013c4 <__aeabi_dcmple>:
    13c4:	f84d ed08 	str.w	lr, [sp, #-8]!
    13c8:	f7ff ffe0 	bl	138c <__aeabi_cdcmpeq>
    13cc:	bf94      	ite	ls
    13ce:	2001      	movls	r0, #1
    13d0:	2000      	movhi	r0, #0
    13d2:	f85d fb08 	ldr.w	pc, [sp], #8
    13d6:	bf00      	nop

000013d8 <__aeabi_dcmpge>:
    13d8:	f84d ed08 	str.w	lr, [sp, #-8]!
    13dc:	f7ff ffce 	bl	137c <__aeabi_cdrcmple>
    13e0:	bf94      	ite	ls
    13e2:	2001      	movls	r0, #1
    13e4:	2000      	movhi	r0, #0
    13e6:	f85d fb08 	ldr.w	pc, [sp], #8
    13ea:	bf00      	nop

000013ec <__aeabi_dcmpgt>:
    13ec:	f84d ed08 	str.w	lr, [sp, #-8]!
    13f0:	f7ff ffc4 	bl	137c <__aeabi_cdrcmple>
    13f4:	bf34      	ite	cc
    13f6:	2001      	movcc	r0, #1
    13f8:	2000      	movcs	r0, #0
    13fa:	f85d fb08 	ldr.w	pc, [sp], #8
    13fe:	bf00      	nop

00001400 <__aeabi_dcmpun>:
    1400:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    1404:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    1408:	d102      	bne.n	1410 <__aeabi_dcmpun+0x10>
    140a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    140e:	d10a      	bne.n	1426 <__aeabi_dcmpun+0x26>
    1410:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    1414:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    1418:	d102      	bne.n	1420 <__aeabi_dcmpun+0x20>
    141a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    141e:	d102      	bne.n	1426 <__aeabi_dcmpun+0x26>
    1420:	f04f 0000 	mov.w	r0, #0
    1424:	4770      	bx	lr
    1426:	f04f 0001 	mov.w	r0, #1
    142a:	4770      	bx	lr

0000142c <__aeabi_d2iz>:
    142c:	ea4f 0241 	mov.w	r2, r1, lsl #1
    1430:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    1434:	d215      	bcs.n	1462 <__aeabi_d2iz+0x36>
    1436:	d511      	bpl.n	145c <__aeabi_d2iz+0x30>
    1438:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    143c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    1440:	d912      	bls.n	1468 <__aeabi_d2iz+0x3c>
    1442:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    1446:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    144a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    144e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    1452:	fa23 f002 	lsr.w	r0, r3, r2
    1456:	bf18      	it	ne
    1458:	4240      	negne	r0, r0
    145a:	4770      	bx	lr
    145c:	f04f 0000 	mov.w	r0, #0
    1460:	4770      	bx	lr
    1462:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    1466:	d105      	bne.n	1474 <__aeabi_d2iz+0x48>
    1468:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
    146c:	bf08      	it	eq
    146e:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
    1472:	4770      	bx	lr
    1474:	f04f 0000 	mov.w	r0, #0
    1478:	4770      	bx	lr
    147a:	bf00      	nop

0000147c <__aeabi_uldivmod>:
    147c:	b953      	cbnz	r3, 1494 <__aeabi_uldivmod+0x18>
    147e:	b94a      	cbnz	r2, 1494 <__aeabi_uldivmod+0x18>
    1480:	2900      	cmp	r1, #0
    1482:	bf08      	it	eq
    1484:	2800      	cmpeq	r0, #0
    1486:	bf1c      	itt	ne
    1488:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    148c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    1490:	f000 b97a 	b.w	1788 <__aeabi_idiv0>
    1494:	f1ad 0c08 	sub.w	ip, sp, #8
    1498:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    149c:	f000 f806 	bl	14ac <__udivmoddi4>
    14a0:	f8dd e004 	ldr.w	lr, [sp, #4]
    14a4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    14a8:	b004      	add	sp, #16
    14aa:	4770      	bx	lr

000014ac <__udivmoddi4>:
    14ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    14b0:	468c      	mov	ip, r1
    14b2:	460d      	mov	r5, r1
    14b4:	4604      	mov	r4, r0
    14b6:	9e08      	ldr	r6, [sp, #32]
    14b8:	2b00      	cmp	r3, #0
    14ba:	d151      	bne.n	1560 <__udivmoddi4+0xb4>
    14bc:	428a      	cmp	r2, r1
    14be:	4617      	mov	r7, r2
    14c0:	d96d      	bls.n	159e <__udivmoddi4+0xf2>
    14c2:	fab2 fe82 	clz	lr, r2
    14c6:	f1be 0f00 	cmp.w	lr, #0
    14ca:	d00b      	beq.n	14e4 <__udivmoddi4+0x38>
    14cc:	f1ce 0c20 	rsb	ip, lr, #32
    14d0:	fa01 f50e 	lsl.w	r5, r1, lr
    14d4:	fa20 fc0c 	lsr.w	ip, r0, ip
    14d8:	fa02 f70e 	lsl.w	r7, r2, lr
    14dc:	ea4c 0c05 	orr.w	ip, ip, r5
    14e0:	fa00 f40e 	lsl.w	r4, r0, lr
    14e4:	ea4f 4a17 	mov.w	sl, r7, lsr #16
    14e8:	0c25      	lsrs	r5, r4, #16
    14ea:	fbbc f8fa 	udiv	r8, ip, sl
    14ee:	fa1f f987 	uxth.w	r9, r7
    14f2:	fb0a cc18 	mls	ip, sl, r8, ip
    14f6:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
    14fa:	fb08 f309 	mul.w	r3, r8, r9
    14fe:	42ab      	cmp	r3, r5
    1500:	d90a      	bls.n	1518 <__udivmoddi4+0x6c>
    1502:	19ed      	adds	r5, r5, r7
    1504:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
    1508:	f080 8123 	bcs.w	1752 <__udivmoddi4+0x2a6>
    150c:	42ab      	cmp	r3, r5
    150e:	f240 8120 	bls.w	1752 <__udivmoddi4+0x2a6>
    1512:	f1a8 0802 	sub.w	r8, r8, #2
    1516:	443d      	add	r5, r7
    1518:	1aed      	subs	r5, r5, r3
    151a:	b2a4      	uxth	r4, r4
    151c:	fbb5 f0fa 	udiv	r0, r5, sl
    1520:	fb0a 5510 	mls	r5, sl, r0, r5
    1524:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
    1528:	fb00 f909 	mul.w	r9, r0, r9
    152c:	45a1      	cmp	r9, r4
    152e:	d909      	bls.n	1544 <__udivmoddi4+0x98>
    1530:	19e4      	adds	r4, r4, r7
    1532:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
    1536:	f080 810a 	bcs.w	174e <__udivmoddi4+0x2a2>
    153a:	45a1      	cmp	r9, r4
    153c:	f240 8107 	bls.w	174e <__udivmoddi4+0x2a2>
    1540:	3802      	subs	r0, #2
    1542:	443c      	add	r4, r7
    1544:	eba4 0409 	sub.w	r4, r4, r9
    1548:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
    154c:	2100      	movs	r1, #0
    154e:	2e00      	cmp	r6, #0
    1550:	d061      	beq.n	1616 <__udivmoddi4+0x16a>
    1552:	fa24 f40e 	lsr.w	r4, r4, lr
    1556:	2300      	movs	r3, #0
    1558:	6034      	str	r4, [r6, #0]
    155a:	6073      	str	r3, [r6, #4]
    155c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1560:	428b      	cmp	r3, r1
    1562:	d907      	bls.n	1574 <__udivmoddi4+0xc8>
    1564:	2e00      	cmp	r6, #0
    1566:	d054      	beq.n	1612 <__udivmoddi4+0x166>
    1568:	2100      	movs	r1, #0
    156a:	e886 0021 	stmia.w	r6, {r0, r5}
    156e:	4608      	mov	r0, r1
    1570:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1574:	fab3 f183 	clz	r1, r3
    1578:	2900      	cmp	r1, #0
    157a:	f040 808e 	bne.w	169a <__udivmoddi4+0x1ee>
    157e:	42ab      	cmp	r3, r5
    1580:	d302      	bcc.n	1588 <__udivmoddi4+0xdc>
    1582:	4282      	cmp	r2, r0
    1584:	f200 80fa 	bhi.w	177c <__udivmoddi4+0x2d0>
    1588:	1a84      	subs	r4, r0, r2
    158a:	eb65 0503 	sbc.w	r5, r5, r3
    158e:	2001      	movs	r0, #1
    1590:	46ac      	mov	ip, r5
    1592:	2e00      	cmp	r6, #0
    1594:	d03f      	beq.n	1616 <__udivmoddi4+0x16a>
    1596:	e886 1010 	stmia.w	r6, {r4, ip}
    159a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    159e:	b912      	cbnz	r2, 15a6 <__udivmoddi4+0xfa>
    15a0:	2701      	movs	r7, #1
    15a2:	fbb7 f7f2 	udiv	r7, r7, r2
    15a6:	fab7 fe87 	clz	lr, r7
    15aa:	f1be 0f00 	cmp.w	lr, #0
    15ae:	d134      	bne.n	161a <__udivmoddi4+0x16e>
    15b0:	1beb      	subs	r3, r5, r7
    15b2:	0c3a      	lsrs	r2, r7, #16
    15b4:	fa1f fc87 	uxth.w	ip, r7
    15b8:	2101      	movs	r1, #1
    15ba:	fbb3 f8f2 	udiv	r8, r3, r2
    15be:	0c25      	lsrs	r5, r4, #16
    15c0:	fb02 3318 	mls	r3, r2, r8, r3
    15c4:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
    15c8:	fb0c f308 	mul.w	r3, ip, r8
    15cc:	42ab      	cmp	r3, r5
    15ce:	d907      	bls.n	15e0 <__udivmoddi4+0x134>
    15d0:	19ed      	adds	r5, r5, r7
    15d2:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
    15d6:	d202      	bcs.n	15de <__udivmoddi4+0x132>
    15d8:	42ab      	cmp	r3, r5
    15da:	f200 80d1 	bhi.w	1780 <__udivmoddi4+0x2d4>
    15de:	4680      	mov	r8, r0
    15e0:	1aed      	subs	r5, r5, r3
    15e2:	b2a3      	uxth	r3, r4
    15e4:	fbb5 f0f2 	udiv	r0, r5, r2
    15e8:	fb02 5510 	mls	r5, r2, r0, r5
    15ec:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
    15f0:	fb0c fc00 	mul.w	ip, ip, r0
    15f4:	45a4      	cmp	ip, r4
    15f6:	d907      	bls.n	1608 <__udivmoddi4+0x15c>
    15f8:	19e4      	adds	r4, r4, r7
    15fa:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
    15fe:	d202      	bcs.n	1606 <__udivmoddi4+0x15a>
    1600:	45a4      	cmp	ip, r4
    1602:	f200 80b8 	bhi.w	1776 <__udivmoddi4+0x2ca>
    1606:	4618      	mov	r0, r3
    1608:	eba4 040c 	sub.w	r4, r4, ip
    160c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
    1610:	e79d      	b.n	154e <__udivmoddi4+0xa2>
    1612:	4631      	mov	r1, r6
    1614:	4630      	mov	r0, r6
    1616:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    161a:	f1ce 0420 	rsb	r4, lr, #32
    161e:	fa05 f30e 	lsl.w	r3, r5, lr
    1622:	fa07 f70e 	lsl.w	r7, r7, lr
    1626:	fa20 f804 	lsr.w	r8, r0, r4
    162a:	0c3a      	lsrs	r2, r7, #16
    162c:	fa25 f404 	lsr.w	r4, r5, r4
    1630:	ea48 0803 	orr.w	r8, r8, r3
    1634:	fbb4 f1f2 	udiv	r1, r4, r2
    1638:	ea4f 4518 	mov.w	r5, r8, lsr #16
    163c:	fb02 4411 	mls	r4, r2, r1, r4
    1640:	fa1f fc87 	uxth.w	ip, r7
    1644:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
    1648:	fb01 f30c 	mul.w	r3, r1, ip
    164c:	42ab      	cmp	r3, r5
    164e:	fa00 f40e 	lsl.w	r4, r0, lr
    1652:	d909      	bls.n	1668 <__udivmoddi4+0x1bc>
    1654:	19ed      	adds	r5, r5, r7
    1656:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
    165a:	f080 808a 	bcs.w	1772 <__udivmoddi4+0x2c6>
    165e:	42ab      	cmp	r3, r5
    1660:	f240 8087 	bls.w	1772 <__udivmoddi4+0x2c6>
    1664:	3902      	subs	r1, #2
    1666:	443d      	add	r5, r7
    1668:	1aeb      	subs	r3, r5, r3
    166a:	fa1f f588 	uxth.w	r5, r8
    166e:	fbb3 f0f2 	udiv	r0, r3, r2
    1672:	fb02 3310 	mls	r3, r2, r0, r3
    1676:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
    167a:	fb00 f30c 	mul.w	r3, r0, ip
    167e:	42ab      	cmp	r3, r5
    1680:	d907      	bls.n	1692 <__udivmoddi4+0x1e6>
    1682:	19ed      	adds	r5, r5, r7
    1684:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
    1688:	d26f      	bcs.n	176a <__udivmoddi4+0x2be>
    168a:	42ab      	cmp	r3, r5
    168c:	d96d      	bls.n	176a <__udivmoddi4+0x2be>
    168e:	3802      	subs	r0, #2
    1690:	443d      	add	r5, r7
    1692:	1aeb      	subs	r3, r5, r3
    1694:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
    1698:	e78f      	b.n	15ba <__udivmoddi4+0x10e>
    169a:	f1c1 0720 	rsb	r7, r1, #32
    169e:	fa22 f807 	lsr.w	r8, r2, r7
    16a2:	408b      	lsls	r3, r1
    16a4:	fa05 f401 	lsl.w	r4, r5, r1
    16a8:	ea48 0303 	orr.w	r3, r8, r3
    16ac:	fa20 fe07 	lsr.w	lr, r0, r7
    16b0:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    16b4:	40fd      	lsrs	r5, r7
    16b6:	ea4e 0e04 	orr.w	lr, lr, r4
    16ba:	fbb5 f9fc 	udiv	r9, r5, ip
    16be:	ea4f 441e 	mov.w	r4, lr, lsr #16
    16c2:	fb0c 5519 	mls	r5, ip, r9, r5
    16c6:	fa1f f883 	uxth.w	r8, r3
    16ca:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
    16ce:	fb09 f408 	mul.w	r4, r9, r8
    16d2:	42ac      	cmp	r4, r5
    16d4:	fa02 f201 	lsl.w	r2, r2, r1
    16d8:	fa00 fa01 	lsl.w	sl, r0, r1
    16dc:	d908      	bls.n	16f0 <__udivmoddi4+0x244>
    16de:	18ed      	adds	r5, r5, r3
    16e0:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    16e4:	d243      	bcs.n	176e <__udivmoddi4+0x2c2>
    16e6:	42ac      	cmp	r4, r5
    16e8:	d941      	bls.n	176e <__udivmoddi4+0x2c2>
    16ea:	f1a9 0902 	sub.w	r9, r9, #2
    16ee:	441d      	add	r5, r3
    16f0:	1b2d      	subs	r5, r5, r4
    16f2:	fa1f fe8e 	uxth.w	lr, lr
    16f6:	fbb5 f0fc 	udiv	r0, r5, ip
    16fa:	fb0c 5510 	mls	r5, ip, r0, r5
    16fe:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
    1702:	fb00 f808 	mul.w	r8, r0, r8
    1706:	45a0      	cmp	r8, r4
    1708:	d907      	bls.n	171a <__udivmoddi4+0x26e>
    170a:	18e4      	adds	r4, r4, r3
    170c:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
    1710:	d229      	bcs.n	1766 <__udivmoddi4+0x2ba>
    1712:	45a0      	cmp	r8, r4
    1714:	d927      	bls.n	1766 <__udivmoddi4+0x2ba>
    1716:	3802      	subs	r0, #2
    1718:	441c      	add	r4, r3
    171a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
    171e:	eba4 0408 	sub.w	r4, r4, r8
    1722:	fba0 8902 	umull	r8, r9, r0, r2
    1726:	454c      	cmp	r4, r9
    1728:	46c6      	mov	lr, r8
    172a:	464d      	mov	r5, r9
    172c:	d315      	bcc.n	175a <__udivmoddi4+0x2ae>
    172e:	d012      	beq.n	1756 <__udivmoddi4+0x2aa>
    1730:	b156      	cbz	r6, 1748 <__udivmoddi4+0x29c>
    1732:	ebba 030e 	subs.w	r3, sl, lr
    1736:	eb64 0405 	sbc.w	r4, r4, r5
    173a:	fa04 f707 	lsl.w	r7, r4, r7
    173e:	40cb      	lsrs	r3, r1
    1740:	431f      	orrs	r7, r3
    1742:	40cc      	lsrs	r4, r1
    1744:	6037      	str	r7, [r6, #0]
    1746:	6074      	str	r4, [r6, #4]
    1748:	2100      	movs	r1, #0
    174a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    174e:	4618      	mov	r0, r3
    1750:	e6f8      	b.n	1544 <__udivmoddi4+0x98>
    1752:	4690      	mov	r8, r2
    1754:	e6e0      	b.n	1518 <__udivmoddi4+0x6c>
    1756:	45c2      	cmp	sl, r8
    1758:	d2ea      	bcs.n	1730 <__udivmoddi4+0x284>
    175a:	ebb8 0e02 	subs.w	lr, r8, r2
    175e:	eb69 0503 	sbc.w	r5, r9, r3
    1762:	3801      	subs	r0, #1
    1764:	e7e4      	b.n	1730 <__udivmoddi4+0x284>
    1766:	4628      	mov	r0, r5
    1768:	e7d7      	b.n	171a <__udivmoddi4+0x26e>
    176a:	4640      	mov	r0, r8
    176c:	e791      	b.n	1692 <__udivmoddi4+0x1e6>
    176e:	4681      	mov	r9, r0
    1770:	e7be      	b.n	16f0 <__udivmoddi4+0x244>
    1772:	4601      	mov	r1, r0
    1774:	e778      	b.n	1668 <__udivmoddi4+0x1bc>
    1776:	3802      	subs	r0, #2
    1778:	443c      	add	r4, r7
    177a:	e745      	b.n	1608 <__udivmoddi4+0x15c>
    177c:	4608      	mov	r0, r1
    177e:	e708      	b.n	1592 <__udivmoddi4+0xe6>
    1780:	f1a8 0802 	sub.w	r8, r8, #2
    1784:	443d      	add	r5, r7
    1786:	e72b      	b.n	15e0 <__udivmoddi4+0x134>

00001788 <__aeabi_idiv0>:
    1788:	4770      	bx	lr
    178a:	bf00      	nop

0000178c <_ZN4mbed10DigitalOutC1E7PinName>:
public:
    /** Create a DigitalOut connected to the specified pin
     *
     *  @param pin DigitalOut pin to connect to
     */
    DigitalOut(PinName pin) : gpio()
    178c:	b500      	push	{lr}
    178e:	b083      	sub	sp, #12
    1790:	9001      	str	r0, [sp, #4]
    1792:	9100      	str	r1, [sp, #0]
    1794:	9b01      	ldr	r3, [sp, #4]
    1796:	2200      	movs	r2, #0
    1798:	601a      	str	r2, [r3, #0]
    {
        // No lock needed in the constructor
        gpio_init_out(&gpio, pin);
    179a:	9b01      	ldr	r3, [sp, #4]
    179c:	9900      	ldr	r1, [sp, #0]
    179e:	4618      	mov	r0, r3
    17a0:	f000 fa9c 	bl	1cdc <gpio_init_out>
    }
    17a4:	9b01      	ldr	r3, [sp, #4]
    17a6:	4618      	mov	r0, r3
    17a8:	b003      	add	sp, #12
    17aa:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000017b0 <_Z17print_memory_infov>:
#include "mbed.h"
#include "mbed_mem_trace.h"

DigitalOut led1(LED1);

void print_memory_info() {
    17b0:	b500      	push	{lr}
    17b2:	b08b      	sub	sp, #44	; 0x2c
    // allocate enough room for every thread's stack statistics
    int cnt = osThreadGetCount();
    17b4:	f006 fa18 	bl	7be8 <osThreadGetCount>
    17b8:	4603      	mov	r3, r0
    17ba:	9308      	str	r3, [sp, #32]
    mbed_stats_stack_t *stats = (mbed_stats_stack_t*) malloc(cnt * sizeof(mbed_stats_stack_t));
    17bc:	9b08      	ldr	r3, [sp, #32]
    17be:	011b      	lsls	r3, r3, #4
    17c0:	4618      	mov	r0, r3
    17c2:	f009 fb25 	bl	ae10 <malloc>
    17c6:	9007      	str	r0, [sp, #28]

    cnt = mbed_stats_stack_get_each(stats, cnt);
    17c8:	9b08      	ldr	r3, [sp, #32]
    17ca:	4619      	mov	r1, r3
    17cc:	9807      	ldr	r0, [sp, #28]
    17ce:	f002 fa2f 	bl	3c30 <mbed_stats_stack_get_each>
    17d2:	4603      	mov	r3, r0
    17d4:	9308      	str	r3, [sp, #32]
    for (int i = 0; i < cnt; i++) {
    17d6:	2300      	movs	r3, #0
    17d8:	9309      	str	r3, [sp, #36]	; 0x24
    17da:	9a09      	ldr	r2, [sp, #36]	; 0x24
    17dc:	9b08      	ldr	r3, [sp, #32]
    17de:	429a      	cmp	r2, r3
    17e0:	da16      	bge.n	1810 <_Z17print_memory_infov+0x60>
        printf("Thread: 0x%lX, Stack size: %lu / %lu\r\n", stats[i].thread_id, stats[i].max_size, stats[i].reserved_size);
    17e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    17e4:	011b      	lsls	r3, r3, #4
    17e6:	9a07      	ldr	r2, [sp, #28]
    17e8:	4413      	add	r3, r2
    17ea:	6819      	ldr	r1, [r3, #0]
    17ec:	9b09      	ldr	r3, [sp, #36]	; 0x24
    17ee:	011b      	lsls	r3, r3, #4
    17f0:	9a07      	ldr	r2, [sp, #28]
    17f2:	4413      	add	r3, r2
    17f4:	6858      	ldr	r0, [r3, #4]
    17f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    17f8:	011b      	lsls	r3, r3, #4
    17fa:	9a07      	ldr	r2, [sp, #28]
    17fc:	4413      	add	r3, r2
    17fe:	689b      	ldr	r3, [r3, #8]
    1800:	4602      	mov	r2, r0
    1802:	480c      	ldr	r0, [pc, #48]	; (1834 <_Z17print_memory_infov+0x84>)
    1804:	f009 fe8c 	bl	b520 <printf>
    for (int i = 0; i < cnt; i++) {
    1808:	9b09      	ldr	r3, [sp, #36]	; 0x24
    180a:	3301      	adds	r3, #1
    180c:	9309      	str	r3, [sp, #36]	; 0x24
    180e:	e7e4      	b.n	17da <_Z17print_memory_infov+0x2a>
    }
    free(stats);
    1810:	9807      	ldr	r0, [sp, #28]
    1812:	f009 fb05 	bl	ae20 <free>

    // Grab the heap statistics
    mbed_stats_heap_t heap_stats;
    mbed_stats_heap_get(&heap_stats);
    1816:	ab01      	add	r3, sp, #4
    1818:	4618      	mov	r0, r3
    181a:	f000 ffab 	bl	2774 <mbed_stats_heap_get>
    printf("Heap size: %lu / %lu bytes\r\n", heap_stats.current_size, heap_stats.reserved_size);
    181e:	9b01      	ldr	r3, [sp, #4]
    1820:	9a04      	ldr	r2, [sp, #16]
    1822:	4619      	mov	r1, r3
    1824:	4804      	ldr	r0, [pc, #16]	; (1838 <_Z17print_memory_infov+0x88>)
    1826:	f009 fe7b 	bl	b520 <printf>
}
    182a:	bf00      	nop
    182c:	b00b      	add	sp, #44	; 0x2c
    182e:	f85d fb04 	ldr.w	pc, [sp], #4
    1832:	bf00      	nop
    1834:	000109d4 	.word	0x000109d4
    1838:	000109fc 	.word	0x000109fc

0000183c <main>:

int main() {
    183c:	b510      	push	{r4, lr}
    183e:	b08a      	sub	sp, #40	; 0x28
    print_memory_info();
    1840:	f7ff ffb6 	bl	17b0 <_Z17print_memory_infov>
    mbed_mem_trace_set_callback(mbed_mem_trace_default_callback);
    1844:	4816      	ldr	r0, [pc, #88]	; (18a0 <main+0x64>)
    1846:	f001 fb8b 	bl	2f60 <mbed_mem_trace_set_callback>

    while (true) {
        wait(2.0);
    184a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
    184e:	f002 fa61 	bl	3d14 <wait>

        void *ptr1 = malloc(512);
    1852:	f44f 7000 	mov.w	r0, #512	; 0x200
    1856:	f009 fadb 	bl	ae10 <malloc>
    185a:	9009      	str	r0, [sp, #36]	; 0x24
        void *ptr2 = calloc(768, 1);
    185c:	2101      	movs	r1, #1
    185e:	f44f 7040 	mov.w	r0, #768	; 0x300
    1862:	f008 fd6d 	bl	a340 <calloc>
    1866:	9008      	str	r0, [sp, #32]
        void *ptr3 = (void*)new DigitalOut(LED1);
    1868:	2004      	movs	r0, #4
    186a:	f002 f98f 	bl	3b8c <_Znwj>
    186e:	4603      	mov	r3, r0
    1870:	461c      	mov	r4, r3
    1872:	f241 0116 	movw	r1, #4118	; 0x1016
    1876:	4620      	mov	r0, r4
    1878:	f7ff ff88 	bl	178c <_ZN4mbed10DigitalOutC1E7PinName>
    187c:	9407      	str	r4, [sp, #28]

        // Grab the heap statistics
        mbed_stats_heap_t heap_stats;
        mbed_stats_heap_get(&heap_stats);
    187e:	ab01      	add	r3, sp, #4
    1880:	4618      	mov	r0, r3
    1882:	f000 ff77 	bl	2774 <mbed_stats_heap_get>
        printf("Heap size: %lu / %lu bytes\r\n", heap_stats.current_size, heap_stats.reserved_size);
    1886:	9b01      	ldr	r3, [sp, #4]
    1888:	9a04      	ldr	r2, [sp, #16]
    188a:	4619      	mov	r1, r3
    188c:	4805      	ldr	r0, [pc, #20]	; (18a4 <main+0x68>)
    188e:	f009 fe47 	bl	b520 <printf>

        // Forget to free a pointer
        free(ptr1);
    1892:	9809      	ldr	r0, [sp, #36]	; 0x24
    1894:	f009 fac4 	bl	ae20 <free>
        free(ptr3);
    1898:	9807      	ldr	r0, [sp, #28]
    189a:	f009 fac1 	bl	ae20 <free>
    }
    189e:	e7d4      	b.n	184a <main+0xe>
    18a0:	000030b5 	.word	0x000030b5
    18a4:	000109fc 	.word	0x000109fc

000018a8 <_Z41__static_initialization_and_destruction_0ii>:
}
    18a8:	b500      	push	{lr}
    18aa:	b083      	sub	sp, #12
    18ac:	9001      	str	r0, [sp, #4]
    18ae:	9100      	str	r1, [sp, #0]
    18b0:	9b01      	ldr	r3, [sp, #4]
    18b2:	2b01      	cmp	r3, #1
    18b4:	d109      	bne.n	18ca <_Z41__static_initialization_and_destruction_0ii+0x22>
    18b6:	9b00      	ldr	r3, [sp, #0]
    18b8:	f64f 72ff 	movw	r2, #65535	; 0xffff
    18bc:	4293      	cmp	r3, r2
    18be:	d104      	bne.n	18ca <_Z41__static_initialization_and_destruction_0ii+0x22>
DigitalOut led1(LED1);
    18c0:	f241 0116 	movw	r1, #4118	; 0x1016
    18c4:	4803      	ldr	r0, [pc, #12]	; (18d4 <_Z41__static_initialization_and_destruction_0ii+0x2c>)
    18c6:	f7ff ff61 	bl	178c <_ZN4mbed10DigitalOutC1E7PinName>
}
    18ca:	bf00      	nop
    18cc:	b003      	add	sp, #12
    18ce:	f85d fb04 	ldr.w	pc, [sp], #4
    18d2:	bf00      	nop
    18d4:	20000b9c 	.word	0x20000b9c

000018d8 <_GLOBAL__sub_I_led1>:
    18d8:	b508      	push	{r3, lr}
    18da:	f64f 71ff 	movw	r1, #65535	; 0xffff
    18de:	2001      	movs	r0, #1
    18e0:	f7ff ffe2 	bl	18a8 <_Z41__static_initialization_and_destruction_0ii>
    18e4:	bd08      	pop	{r3, pc}

000018e6 <_ZnwjPv>:
  __attribute__((__externally_visible__));
#endif

// Default placement versions of operator new.
inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
{ return __p; }
    18e6:	b082      	sub	sp, #8
    18e8:	9001      	str	r0, [sp, #4]
    18ea:	9100      	str	r1, [sp, #0]
    18ec:	9b00      	ldr	r3, [sp, #0]
    18ee:	4618      	mov	r0, r3
    18f0:	b002      	add	sp, #8
    18f2:	4770      	bx	lr

000018f4 <_ZL14singleton_lockv>:
 * This function is typically used to provide
 * exclusive access when initializing a
 * global object.
 */
inline static void singleton_lock(void)
{
    18f4:	b508      	push	{r3, lr}
#ifdef MBED_CONF_RTOS_PRESENT
    osMutexAcquire(singleton_mutex_id, osWaitForever);
    18f6:	4b04      	ldr	r3, [pc, #16]	; (1908 <_ZL14singleton_lockv+0x14>)
    18f8:	681b      	ldr	r3, [r3, #0]
    18fa:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    18fe:	4618      	mov	r0, r3
    1900:	f004 fe36 	bl	6570 <osMutexAcquire>
#endif
}
    1904:	bf00      	nop
    1906:	bd08      	pop	{r3, pc}
    1908:	20001ed0 	.word	0x20001ed0

0000190c <_ZL16singleton_unlockv>:
 * This function is typically used to provide
 * exclusive access when initializing a
 * global object.
 */
inline static void singleton_unlock(void)
{
    190c:	b508      	push	{r3, lr}
#ifdef MBED_CONF_RTOS_PRESENT
    osMutexRelease(singleton_mutex_id);
    190e:	4b03      	ldr	r3, [pc, #12]	; (191c <_ZL16singleton_unlockv+0x10>)
    1910:	681b      	ldr	r3, [r3, #0]
    1912:	4618      	mov	r0, r3
    1914:	f004 fe5a 	bl	65cc <osMutexRelease>
#endif
}
    1918:	bf00      	nop
    191a:	bd08      	pop	{r3, pc}
    191c:	20001ed0 	.word	0x20001ed0

00001920 <_ZN12SingletonPtrIN4rtos5MutexEEptEv>:
    /** Get a pointer to the underlying singleton
     *
     * @returns
     *   A pointer to the singleton
     */
    T *operator->()
    1920:	b500      	push	{lr}
    1922:	b083      	sub	sp, #12
    1924:	9001      	str	r0, [sp, #4]
    {
        return get();
    1926:	9801      	ldr	r0, [sp, #4]
    1928:	f000 f806 	bl	1938 <_ZN12SingletonPtrIN4rtos5MutexEE3getEv>
    192c:	4603      	mov	r3, r0
    }
    192e:	4618      	mov	r0, r3
    1930:	b003      	add	sp, #12
    1932:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00001938 <_ZN12SingletonPtrIN4rtos5MutexEE3getEv>:
    T *get()
    1938:	b510      	push	{r4, lr}
    193a:	b082      	sub	sp, #8
    193c:	9001      	str	r0, [sp, #4]
        if (NULL == _ptr) {
    193e:	9b01      	ldr	r3, [sp, #4]
    1940:	681b      	ldr	r3, [r3, #0]
    1942:	2b00      	cmp	r3, #0
    1944:	d118      	bne.n	1978 <_ZN12SingletonPtrIN4rtos5MutexEE3getEv+0x40>
            singleton_lock();
    1946:	f7ff ffd5 	bl	18f4 <_ZL14singleton_lockv>
            if (NULL == _ptr) {
    194a:	9b01      	ldr	r3, [sp, #4]
    194c:	681b      	ldr	r3, [r3, #0]
    194e:	2b00      	cmp	r3, #0
    1950:	d110      	bne.n	1974 <_ZN12SingletonPtrIN4rtos5MutexEE3getEv+0x3c>
                _ptr = new (_data) T();
    1952:	9b01      	ldr	r3, [sp, #4]
    1954:	3304      	adds	r3, #4
    1956:	4619      	mov	r1, r3
    1958:	2024      	movs	r0, #36	; 0x24
    195a:	f7ff ffc4 	bl	18e6 <_ZnwjPv>
    195e:	4604      	mov	r4, r0
    1960:	2c00      	cmp	r4, #0
    1962:	d004      	beq.n	196e <_ZN12SingletonPtrIN4rtos5MutexEE3getEv+0x36>
    1964:	4620      	mov	r0, r4
    1966:	f002 fa35 	bl	3dd4 <_ZN4rtos5MutexC1Ev>
    196a:	4622      	mov	r2, r4
    196c:	e000      	b.n	1970 <_ZN12SingletonPtrIN4rtos5MutexEE3getEv+0x38>
    196e:	4622      	mov	r2, r4
    1970:	9b01      	ldr	r3, [sp, #4]
    1972:	601a      	str	r2, [r3, #0]
            singleton_unlock();
    1974:	f7ff ffca 	bl	190c <_ZL16singleton_unlockv>
        MBED_ASSERT(_ptr == (T *)&_data);
    1978:	9b01      	ldr	r3, [sp, #4]
    197a:	681a      	ldr	r2, [r3, #0]
    197c:	9b01      	ldr	r3, [sp, #4]
    197e:	3304      	adds	r3, #4
    1980:	429a      	cmp	r2, r3
    1982:	d004      	beq.n	198e <_ZN12SingletonPtrIN4rtos5MutexEE3getEv+0x56>
    1984:	225e      	movs	r2, #94	; 0x5e
    1986:	4904      	ldr	r1, [pc, #16]	; (1998 <_ZN12SingletonPtrIN4rtos5MutexEE3getEv+0x60>)
    1988:	4804      	ldr	r0, [pc, #16]	; (199c <_ZN12SingletonPtrIN4rtos5MutexEE3getEv+0x64>)
    198a:	f001 f835 	bl	29f8 <mbed_assert_internal>
        return _ptr;
    198e:	9b01      	ldr	r3, [sp, #4]
    1990:	681b      	ldr	r3, [r3, #0]
    }
    1992:	4618      	mov	r0, r3
    1994:	b002      	add	sp, #8
    1996:	bd10      	pop	{r4, pc}
    1998:	00010a1c 	.word	0x00010a1c
    199c:	00010a40 	.word	0x00010a40

000019a0 <_ZN4mbed10FileHandle5lseekEli>:
     *    -1 on failure or unsupported
     *  @deprecated Replaced by `off_t FileHandle::seek(off_t offset, int whence = SEEK_SET)'
     *
     */
    MBED_DEPRECATED_SINCE("mbed-os-5.4", "Replaced by FileHandle::seek")
    virtual off_t lseek(off_t offset, int whence)
    19a0:	b500      	push	{lr}
    19a2:	b085      	sub	sp, #20
    19a4:	9003      	str	r0, [sp, #12]
    19a6:	9102      	str	r1, [sp, #8]
    19a8:	9201      	str	r2, [sp, #4]
    {
        return seek(offset, whence);
    19aa:	9b03      	ldr	r3, [sp, #12]
    19ac:	681b      	ldr	r3, [r3, #0]
    19ae:	3310      	adds	r3, #16
    19b0:	681b      	ldr	r3, [r3, #0]
    19b2:	9a01      	ldr	r2, [sp, #4]
    19b4:	9902      	ldr	r1, [sp, #8]
    19b6:	9803      	ldr	r0, [sp, #12]
    19b8:	4798      	blx	r3
    19ba:	4603      	mov	r3, r0
    }
    19bc:	4618      	mov	r0, r3
    19be:	b005      	add	sp, #20
    19c0:	f85d fb04 	ldr.w	pc, [sp], #4

000019c4 <_ZN4mbed10FileHandle5fsyncEv>:
     *    0 on success or un-needed,
     *   -1 on error
     *  @deprecated Replaced by `int FileHandle::sync()'
     */
    MBED_DEPRECATED_SINCE("mbed-os-5.4", "Replaced by FileHandle::sync")
    virtual int fsync()
    19c4:	b500      	push	{lr}
    19c6:	b083      	sub	sp, #12
    19c8:	9001      	str	r0, [sp, #4]
    {
        return sync();
    19ca:	9b01      	ldr	r3, [sp, #4]
    19cc:	681b      	ldr	r3, [r3, #0]
    19ce:	3318      	adds	r3, #24
    19d0:	681b      	ldr	r3, [r3, #0]
    19d2:	9801      	ldr	r0, [sp, #4]
    19d4:	4798      	blx	r3
    19d6:	4603      	mov	r3, r0
    }
    19d8:	4618      	mov	r0, r3
    19da:	b003      	add	sp, #12
    19dc:	f85d fb04 	ldr.w	pc, [sp], #4

000019e0 <_ZN4mbed10FileHandle4flenEv>:
     *  @returns
     *   Length of the file
     *  @deprecated Replaced by `off_t FileHandle::size()'
     */
    MBED_DEPRECATED_SINCE("mbed-os-5.4", "Replaced by FileHandle::size")
    virtual off_t flen()
    19e0:	b500      	push	{lr}
    19e2:	b083      	sub	sp, #12
    19e4:	9001      	str	r0, [sp, #4]
    {
        return size();
    19e6:	9b01      	ldr	r3, [sp, #4]
    19e8:	681b      	ldr	r3, [r3, #0]
    19ea:	3328      	adds	r3, #40	; 0x28
    19ec:	681b      	ldr	r3, [r3, #0]
    19ee:	9801      	ldr	r0, [sp, #4]
    19f0:	4798      	blx	r3
    19f2:	4603      	mov	r3, r0
    }
    19f4:	4618      	mov	r0, r3
    19f6:	b003      	add	sp, #12
    19f8:	f85d fb04 	ldr.w	pc, [sp], #4

000019fc <_ZN4mbed10FileHandle12set_blockingEb>:
     *  @param blocking     true for blocking mode, false for non-blocking mode.
     *
     *  @return             0 on success
     *  @return             Negative error code on failure
     */
    virtual int set_blocking(bool blocking)
    19fc:	b082      	sub	sp, #8
    19fe:	9001      	str	r0, [sp, #4]
    1a00:	460b      	mov	r3, r1
    1a02:	f88d 3003 	strb.w	r3, [sp, #3]
    {
        return blocking ? 0 : -ENOTTY;
    1a06:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1a0a:	2b00      	cmp	r3, #0
    1a0c:	d001      	beq.n	1a12 <_ZN4mbed10FileHandle12set_blockingEb+0x16>
    1a0e:	2300      	movs	r3, #0
    1a10:	e001      	b.n	1a16 <_ZN4mbed10FileHandle12set_blockingEb+0x1a>
    1a12:	f06f 0318 	mvn.w	r3, #24
    }
    1a16:	4618      	mov	r0, r3
    1a18:	b002      	add	sp, #8
    1a1a:	4770      	bx	lr

00001a1c <_ZNK4mbed10FileHandle11is_blockingEv>:

    /** Check current blocking or non-blocking mode for file operations.
     *
     *  @return             true for blocking mode, false for non-blocking mode.
     */
    virtual bool is_blocking() const
    1a1c:	b082      	sub	sp, #8
    1a1e:	9001      	str	r0, [sp, #4]
    {
        return true;
    1a20:	2301      	movs	r3, #1
    }
    1a22:	4618      	mov	r0, r3
    1a24:	b002      	add	sp, #8
    1a26:	4770      	bx	lr

00001a28 <_ZNK4mbed10FileHandle4pollEs>:
     *
     * @param events        bitmask of poll events we're interested in - POLLIN/POLLOUT etc.
     *
     * @returns             bitmask of poll events that have occurred.
     */
    virtual short poll(short events) const
    1a28:	b082      	sub	sp, #8
    1a2a:	9001      	str	r0, [sp, #4]
    1a2c:	460b      	mov	r3, r1
    1a2e:	f8ad 3002 	strh.w	r3, [sp, #2]
    {
        // Possible default for real files
        return POLLIN | POLLOUT;
    1a32:	2311      	movs	r3, #17
    }
    1a34:	4618      	mov	r0, r3
    1a36:	b002      	add	sp, #8
    1a38:	4770      	bx	lr

00001a3a <_ZN4mbed10FileHandle5sigioENS_8CallbackIFvvEEE>:
     *  is called is not guaranteed and susceptible to change. It should be used
     *  as a cue to make read/write/poll calls to find the current state.
     *
     *  @param func     Function to call on state change
     */
    virtual void sigio(Callback<void()> func)
    1a3a:	b082      	sub	sp, #8
    1a3c:	9001      	str	r0, [sp, #4]
    1a3e:	9100      	str	r1, [sp, #0]
    {
        //Default for real files. Do nothing for real files.
    }
    1a40:	bf00      	nop
    1a42:	b002      	add	sp, #8
    1a44:	4770      	bx	lr
	...

00001a48 <_ZN4mbed10FileHandleD1Ev>:
    virtual ~FileHandle() {}
    1a48:	b500      	push	{lr}
    1a4a:	b083      	sub	sp, #12
    1a4c:	9001      	str	r0, [sp, #4]
    1a4e:	4a05      	ldr	r2, [pc, #20]	; (1a64 <_ZN4mbed10FileHandleD1Ev+0x1c>)
    1a50:	9b01      	ldr	r3, [sp, #4]
    1a52:	601a      	str	r2, [r3, #0]
    1a54:	9801      	ldr	r0, [sp, #4]
    1a56:	f000 f845 	bl	1ae4 <_ZN4mbed11NonCopyableINS_10FileHandleEED1Ev>
    1a5a:	9b01      	ldr	r3, [sp, #4]
    1a5c:	4618      	mov	r0, r3
    1a5e:	b003      	add	sp, #12
    1a60:	f85d fb04 	ldr.w	pc, [sp], #4
    1a64:	000124f4 	.word	0x000124f4

00001a68 <_ZN4mbed10FileHandleD0Ev>:
    1a68:	b500      	push	{lr}
    1a6a:	b083      	sub	sp, #12
    1a6c:	9001      	str	r0, [sp, #4]
    1a6e:	9801      	ldr	r0, [sp, #4]
    1a70:	f7ff ffea 	bl	1a48 <_ZN4mbed10FileHandleD1Ev>
    1a74:	9801      	ldr	r0, [sp, #4]
    1a76:	f002 f8ab 	bl	3bd0 <_ZdlPv>
    1a7a:	9b01      	ldr	r3, [sp, #4]
    1a7c:	4618      	mov	r0, r3
    1a7e:	b003      	add	sp, #12
    1a80:	f85d fb04 	ldr.w	pc, [sp], #4

00001a84 <_ZN4mbed10FileHandle4tellEv>:
    virtual off_t tell()
    1a84:	b500      	push	{lr}
    1a86:	b083      	sub	sp, #12
    1a88:	9001      	str	r0, [sp, #4]
        return seek(0, SEEK_CUR);
    1a8a:	9b01      	ldr	r3, [sp, #4]
    1a8c:	681b      	ldr	r3, [r3, #0]
    1a8e:	3310      	adds	r3, #16
    1a90:	681b      	ldr	r3, [r3, #0]
    1a92:	2201      	movs	r2, #1
    1a94:	2100      	movs	r1, #0
    1a96:	9801      	ldr	r0, [sp, #4]
    1a98:	4798      	blx	r3
    1a9a:	4603      	mov	r3, r0
    }
    1a9c:	4618      	mov	r0, r3
    1a9e:	b003      	add	sp, #12
    1aa0:	f85d fb04 	ldr.w	pc, [sp], #4

00001aa4 <_ZN4mbed10FileHandle6rewindEv>:
    virtual void rewind()
    1aa4:	b500      	push	{lr}
    1aa6:	b083      	sub	sp, #12
    1aa8:	9001      	str	r0, [sp, #4]
        seek(0, SEEK_SET);
    1aaa:	9b01      	ldr	r3, [sp, #4]
    1aac:	681b      	ldr	r3, [r3, #0]
    1aae:	3310      	adds	r3, #16
    1ab0:	681b      	ldr	r3, [r3, #0]
    1ab2:	2200      	movs	r2, #0
    1ab4:	2100      	movs	r1, #0
    1ab6:	9801      	ldr	r0, [sp, #4]
    1ab8:	4798      	blx	r3
    }
    1aba:	bf00      	nop
    1abc:	b003      	add	sp, #12
    1abe:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00001ac4 <_ZN4mbed10FileHandleC1Ev>:
class FileHandle : private NonCopyable<FileHandle> {
    1ac4:	b500      	push	{lr}
    1ac6:	b083      	sub	sp, #12
    1ac8:	9001      	str	r0, [sp, #4]
    1aca:	9801      	ldr	r0, [sp, #4]
    1acc:	f000 f810 	bl	1af0 <_ZN4mbed11NonCopyableINS_10FileHandleEEC1Ev>
    1ad0:	4a03      	ldr	r2, [pc, #12]	; (1ae0 <_ZN4mbed10FileHandleC1Ev+0x1c>)
    1ad2:	9b01      	ldr	r3, [sp, #4]
    1ad4:	601a      	str	r2, [r3, #0]
    1ad6:	9b01      	ldr	r3, [sp, #4]
    1ad8:	4618      	mov	r0, r3
    1ada:	b003      	add	sp, #12
    1adc:	f85d fb04 	ldr.w	pc, [sp], #4
    1ae0:	000124f4 	.word	0x000124f4

00001ae4 <_ZN4mbed11NonCopyableINS_10FileHandleEED1Ev>:
     */
    NonCopyable() { }
    /**
     * Disallow destruction of NonCopyable objects from outside of its hierarchy.
     */
    ~NonCopyable() { }
    1ae4:	b082      	sub	sp, #8
    1ae6:	9001      	str	r0, [sp, #4]
    1ae8:	9b01      	ldr	r3, [sp, #4]
    1aea:	4618      	mov	r0, r3
    1aec:	b002      	add	sp, #8
    1aee:	4770      	bx	lr

00001af0 <_ZN4mbed11NonCopyableINS_10FileHandleEEC1Ev>:
    NonCopyable() { }
    1af0:	b082      	sub	sp, #8
    1af2:	9001      	str	r0, [sp, #4]
    1af4:	9b01      	ldr	r3, [sp, #4]
    1af6:	4618      	mov	r0, r3
    1af8:	b002      	add	sp, #8
    1afa:	4770      	bx	lr

00001afc <_ZN13StorageVolumeC1Ev>:

class StorageVolume {
public:
    MBED_DEPRECATED_SINCE("mbed-os-5.5", "StorageVolume is deprecated. "
                          "Use MBRBlockDevice for volumes instead")
    StorageVolume() : allocated(false) { /* empty */ }
    1afc:	b082      	sub	sp, #8
    1afe:	9001      	str	r0, [sp, #4]
    1b00:	9b01      	ldr	r3, [sp, #4]
    1b02:	2200      	movs	r2, #0
    1b04:	701a      	strb	r2, [r3, #0]
    1b06:	9b01      	ldr	r3, [sp, #4]
    1b08:	4618      	mov	r0, r3
    1b0a:	b002      	add	sp, #8
    1b0c:	4770      	bx	lr

00001b0e <_ZN20StorageVolumeManagerC1Ev>:

class StorageVolumeManager {
public:
    MBED_DEPRECATED_SINCE("mbed-os-5.5", "StorageVolumeManager is deprecated. "
                          "Use MBRBlockDevice to manage volumes instead")
    StorageVolumeManager()  { /* empty */ }
    1b0e:	b530      	push	{r4, r5, lr}
    1b10:	b083      	sub	sp, #12
    1b12:	9001      	str	r0, [sp, #4]
    1b14:	9b01      	ldr	r3, [sp, #4]
    1b16:	3338      	adds	r3, #56	; 0x38
    1b18:	2403      	movs	r4, #3
    1b1a:	461d      	mov	r5, r3
    1b1c:	2c00      	cmp	r4, #0
    1b1e:	db05      	blt.n	1b2c <_ZN20StorageVolumeManagerC1Ev+0x1e>
    1b20:	4628      	mov	r0, r5
    1b22:	f7ff ffeb 	bl	1afc <_ZN13StorageVolumeC1Ev>
    1b26:	3520      	adds	r5, #32
    1b28:	3c01      	subs	r4, #1
    1b2a:	e7f7      	b.n	1b1c <_ZN20StorageVolumeManagerC1Ev+0xe>
    1b2c:	9b01      	ldr	r3, [sp, #4]
    1b2e:	4618      	mov	r0, r3
    1b30:	b003      	add	sp, #12
    1b32:	bd30      	pop	{r4, r5, pc}

00001b34 <_ZN20StorageVolumeManagerD1Ev>:
    ~StorageVolumeManager() { /* empty */ }
    1b34:	b082      	sub	sp, #8
    1b36:	9001      	str	r0, [sp, #4]
    1b38:	9b01      	ldr	r3, [sp, #4]
    1b3a:	4618      	mov	r0, r3
    1b3c:	b002      	add	sp, #8
    1b3e:	4770      	bx	lr

00001b40 <_Z41__static_initialization_and_destruction_0ii>:
    if(ret < ARM_DRIVER_OK) {
        CFSTORE_ERRLOG("%s:debug: storage_mtd->initialize() failed for storage_mtd=%p (ret=%d)", __func__, storage_mtd, (int) ret);
        return ret;
    }
    return ret;
}
    1b40:	b500      	push	{lr}
    1b42:	b083      	sub	sp, #12
    1b44:	9001      	str	r0, [sp, #4]
    1b46:	9100      	str	r1, [sp, #0]
    1b48:	9b01      	ldr	r3, [sp, #4]
    1b4a:	2b01      	cmp	r3, #1
    1b4c:	d10c      	bne.n	1b68 <_Z41__static_initialization_and_destruction_0ii+0x28>
    1b4e:	9b00      	ldr	r3, [sp, #0]
    1b50:	f64f 72ff 	movw	r2, #65535	; 0xffff
    1b54:	4293      	cmp	r3, r2
    1b56:	d107      	bne.n	1b68 <_Z41__static_initialization_and_destruction_0ii+0x28>
StorageVolumeManager volumeManager;
    1b58:	4805      	ldr	r0, [pc, #20]	; (1b70 <_Z41__static_initialization_and_destruction_0ii+0x30>)
    1b5a:	f7ff ffd8 	bl	1b0e <_ZN20StorageVolumeManagerC1Ev>
    1b5e:	4a05      	ldr	r2, [pc, #20]	; (1b74 <_Z41__static_initialization_and_destruction_0ii+0x34>)
    1b60:	4905      	ldr	r1, [pc, #20]	; (1b78 <_Z41__static_initialization_and_destruction_0ii+0x38>)
    1b62:	4803      	ldr	r0, [pc, #12]	; (1b70 <_Z41__static_initialization_and_destruction_0ii+0x30>)
    1b64:	f001 ff88 	bl	3a78 <__aeabi_atexit>
}
    1b68:	bf00      	nop
    1b6a:	b003      	add	sp, #12
    1b6c:	f85d fb04 	ldr.w	pc, [sp], #4
    1b70:	20000ba0 	.word	0x20000ba0
    1b74:	20000000 	.word	0x20000000
    1b78:	00001b35 	.word	0x00001b35

00001b7c <_GLOBAL__sub_I_volumeManager>:
    1b7c:	b508      	push	{r3, lr}
    1b7e:	f64f 71ff 	movw	r1, #65535	; 0xffff
    1b82:	2001      	movs	r0, #1
    1b84:	f7ff ffdc 	bl	1b40 <_Z41__static_initialization_and_destruction_0ii>
    1b88:	bd08      	pop	{r3, pc}

00001b8a <are_interrupts_enabled>:

static volatile bool critical_interrupts_enabled = false;
static volatile bool state_saved = false;

static bool are_interrupts_enabled(void)
{
    1b8a:	b082      	sub	sp, #8
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    1b8c:	f3ef 8310 	mrs	r3, PRIMASK
    1b90:	9301      	str	r3, [sp, #4]
  return(result);
    1b92:	9b01      	ldr	r3, [sp, #4]
#if defined(__CORTEX_A9)
    return ((__get_CPSR() & 0x80) == 0);
#else
    return ((__get_PRIMASK() & 0x1) == 0);
    1b94:	f003 0301 	and.w	r3, r3, #1
    1b98:	2b00      	cmp	r3, #0
    1b9a:	bf0c      	ite	eq
    1b9c:	2301      	moveq	r3, #1
    1b9e:	2300      	movne	r3, #0
    1ba0:	b2db      	uxtb	r3, r3
#endif
}
    1ba2:	4618      	mov	r0, r3
    1ba4:	b002      	add	sp, #8
    1ba6:	4770      	bx	lr

00001ba8 <hal_critical_section_enter>:


MBED_WEAK void hal_critical_section_enter(void)
{
    1ba8:	b500      	push	{lr}
    1baa:	b083      	sub	sp, #12
    const bool interrupt_state = are_interrupts_enabled();
    1bac:	f7ff ffed 	bl	1b8a <are_interrupts_enabled>
    1bb0:	4603      	mov	r3, r0
    1bb2:	f88d 3007 	strb.w	r3, [sp, #7]
  __ASM volatile ("cpsid i" : : : "memory");
    1bb6:	b672      	cpsid	i

    __disable_irq();

    if (state_saved == true) {
    1bb8:	4b08      	ldr	r3, [pc, #32]	; (1bdc <hal_critical_section_enter+0x34>)
    1bba:	781b      	ldrb	r3, [r3, #0]
    1bbc:	b2db      	uxtb	r3, r3
    1bbe:	2b00      	cmp	r3, #0
    1bc0:	d107      	bne.n	1bd2 <hal_critical_section_enter+0x2a>
        return;
    }

    critical_interrupts_enabled = interrupt_state;
    1bc2:	4a07      	ldr	r2, [pc, #28]	; (1be0 <hal_critical_section_enter+0x38>)
    1bc4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1bc8:	7013      	strb	r3, [r2, #0]
    state_saved = true;
    1bca:	4b04      	ldr	r3, [pc, #16]	; (1bdc <hal_critical_section_enter+0x34>)
    1bcc:	2201      	movs	r2, #1
    1bce:	701a      	strb	r2, [r3, #0]
    1bd0:	e000      	b.n	1bd4 <hal_critical_section_enter+0x2c>
        return;
    1bd2:	bf00      	nop
}
    1bd4:	b003      	add	sp, #12
    1bd6:	f85d fb04 	ldr.w	pc, [sp], #4
    1bda:	bf00      	nop
    1bdc:	20000c59 	.word	0x20000c59
    1be0:	20000c58 	.word	0x20000c58

00001be4 <hal_critical_section_exit>:

MBED_WEAK void hal_critical_section_exit(void)
{
    1be4:	b508      	push	{r3, lr}
#ifndef FEATURE_UVISOR
    // Interrupts must be disabled on invoking an exit from a critical section
    MBED_ASSERT(!are_interrupts_enabled());
    1be6:	f7ff ffd0 	bl	1b8a <are_interrupts_enabled>
    1bea:	4603      	mov	r3, r0
    1bec:	2b00      	cmp	r3, #0
    1bee:	d004      	beq.n	1bfa <hal_critical_section_exit+0x16>
    1bf0:	2236      	movs	r2, #54	; 0x36
    1bf2:	4907      	ldr	r1, [pc, #28]	; (1c10 <hal_critical_section_exit+0x2c>)
    1bf4:	4807      	ldr	r0, [pc, #28]	; (1c14 <hal_critical_section_exit+0x30>)
    1bf6:	f000 feff 	bl	29f8 <mbed_assert_internal>
#endif
    state_saved = false;
    1bfa:	4b07      	ldr	r3, [pc, #28]	; (1c18 <hal_critical_section_exit+0x34>)
    1bfc:	2200      	movs	r2, #0
    1bfe:	701a      	strb	r2, [r3, #0]

    // Restore the IRQs to their state prior to entering the critical section
    if (critical_interrupts_enabled == true) {
    1c00:	4b06      	ldr	r3, [pc, #24]	; (1c1c <hal_critical_section_exit+0x38>)
    1c02:	781b      	ldrb	r3, [r3, #0]
    1c04:	b2db      	uxtb	r3, r3
    1c06:	2b00      	cmp	r3, #0
    1c08:	d000      	beq.n	1c0c <hal_critical_section_exit+0x28>
  __ASM volatile ("cpsie i" : : : "memory");
    1c0a:	b662      	cpsie	i
        __enable_irq();
    }
}
    1c0c:	bf00      	nop
    1c0e:	bd08      	pop	{r3, pc}
    1c10:	00010a54 	.word	0x00010a54
    1c14:	00010a80 	.word	0x00010a80
    1c18:	20000c59 	.word	0x20000c59
    1c1c:	20000c58 	.word	0x20000c58

00001c20 <_gpio_init_in>:
 * limitations under the License.
 */
#include "hal/gpio_api.h"

static inline void _gpio_init_in(gpio_t *gpio, PinName pin, PinMode mode)
{
    1c20:	b500      	push	{lr}
    1c22:	b085      	sub	sp, #20
    1c24:	9003      	str	r0, [sp, #12]
    1c26:	9102      	str	r1, [sp, #8]
    1c28:	4613      	mov	r3, r2
    1c2a:	f88d 3007 	strb.w	r3, [sp, #7]
    gpio_init(gpio, pin);
    1c2e:	9902      	ldr	r1, [sp, #8]
    1c30:	9803      	ldr	r0, [sp, #12]
    1c32:	f008 fa03 	bl	a03c <gpio_init>
    if (pin != NC) {
    1c36:	9b02      	ldr	r3, [sp, #8]
    1c38:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1c3c:	d009      	beq.n	1c52 <_gpio_init_in+0x32>
        gpio_dir(gpio, PIN_INPUT);
    1c3e:	2100      	movs	r1, #0
    1c40:	9803      	ldr	r0, [sp, #12]
    1c42:	f008 fa21 	bl	a088 <gpio_dir>
        gpio_mode(gpio, mode);
    1c46:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1c4a:	4619      	mov	r1, r3
    1c4c:	9803      	ldr	r0, [sp, #12]
    1c4e:	f008 fa09 	bl	a064 <gpio_mode>
    }
}
    1c52:	bf00      	nop
    1c54:	b005      	add	sp, #20
    1c56:	f85d fb04 	ldr.w	pc, [sp], #4

00001c5a <_gpio_init_out>:

static inline void _gpio_init_out(gpio_t *gpio, PinName pin, PinMode mode, int value)
{
    1c5a:	b500      	push	{lr}
    1c5c:	b085      	sub	sp, #20
    1c5e:	9003      	str	r0, [sp, #12]
    1c60:	9102      	str	r1, [sp, #8]
    1c62:	9300      	str	r3, [sp, #0]
    1c64:	4613      	mov	r3, r2
    1c66:	f88d 3007 	strb.w	r3, [sp, #7]
    gpio_init(gpio, pin);
    1c6a:	9902      	ldr	r1, [sp, #8]
    1c6c:	9803      	ldr	r0, [sp, #12]
    1c6e:	f008 f9e5 	bl	a03c <gpio_init>
    if (pin != NC) {
    1c72:	9b02      	ldr	r3, [sp, #8]
    1c74:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1c78:	d00d      	beq.n	1c96 <_gpio_init_out+0x3c>
        gpio_write(gpio, value);
    1c7a:	9900      	ldr	r1, [sp, #0]
    1c7c:	9803      	ldr	r0, [sp, #12]
    1c7e:	f008 fa47 	bl	a110 <gpio_write>
        gpio_dir(gpio, PIN_OUTPUT);
    1c82:	2101      	movs	r1, #1
    1c84:	9803      	ldr	r0, [sp, #12]
    1c86:	f008 f9ff 	bl	a088 <gpio_dir>
        gpio_mode(gpio, mode);
    1c8a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1c8e:	4619      	mov	r1, r3
    1c90:	9803      	ldr	r0, [sp, #12]
    1c92:	f008 f9e7 	bl	a064 <gpio_mode>
    }
}
    1c96:	bf00      	nop
    1c98:	b005      	add	sp, #20
    1c9a:	f85d fb04 	ldr.w	pc, [sp], #4

00001c9e <gpio_init_in>:

void gpio_init_in(gpio_t *gpio, PinName pin)
{
    1c9e:	b500      	push	{lr}
    1ca0:	b083      	sub	sp, #12
    1ca2:	9001      	str	r0, [sp, #4]
    1ca4:	9100      	str	r1, [sp, #0]
    gpio_init_in_ex(gpio, pin, PullDefault);
    1ca6:	2202      	movs	r2, #2
    1ca8:	9900      	ldr	r1, [sp, #0]
    1caa:	9801      	ldr	r0, [sp, #4]
    1cac:	f000 f804 	bl	1cb8 <gpio_init_in_ex>
}
    1cb0:	bf00      	nop
    1cb2:	b003      	add	sp, #12
    1cb4:	f85d fb04 	ldr.w	pc, [sp], #4

00001cb8 <gpio_init_in_ex>:

void gpio_init_in_ex(gpio_t *gpio, PinName pin, PinMode mode)
{
    1cb8:	b500      	push	{lr}
    1cba:	b085      	sub	sp, #20
    1cbc:	9003      	str	r0, [sp, #12]
    1cbe:	9102      	str	r1, [sp, #8]
    1cc0:	4613      	mov	r3, r2
    1cc2:	f88d 3007 	strb.w	r3, [sp, #7]
    _gpio_init_in(gpio, pin, mode);
    1cc6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    1cca:	461a      	mov	r2, r3
    1ccc:	9902      	ldr	r1, [sp, #8]
    1cce:	9803      	ldr	r0, [sp, #12]
    1cd0:	f7ff ffa6 	bl	1c20 <_gpio_init_in>
}
    1cd4:	bf00      	nop
    1cd6:	b005      	add	sp, #20
    1cd8:	f85d fb04 	ldr.w	pc, [sp], #4

00001cdc <gpio_init_out>:

void gpio_init_out(gpio_t *gpio, PinName pin)
{
    1cdc:	b500      	push	{lr}
    1cde:	b083      	sub	sp, #12
    1ce0:	9001      	str	r0, [sp, #4]
    1ce2:	9100      	str	r1, [sp, #0]
    gpio_init_out_ex(gpio, pin, 0);
    1ce4:	2200      	movs	r2, #0
    1ce6:	9900      	ldr	r1, [sp, #0]
    1ce8:	9801      	ldr	r0, [sp, #4]
    1cea:	f000 f804 	bl	1cf6 <gpio_init_out_ex>
}
    1cee:	bf00      	nop
    1cf0:	b003      	add	sp, #12
    1cf2:	f85d fb04 	ldr.w	pc, [sp], #4

00001cf6 <gpio_init_out_ex>:

void gpio_init_out_ex(gpio_t *gpio, PinName pin, int value)
{
    1cf6:	b500      	push	{lr}
    1cf8:	b085      	sub	sp, #20
    1cfa:	9003      	str	r0, [sp, #12]
    1cfc:	9102      	str	r1, [sp, #8]
    1cfe:	9201      	str	r2, [sp, #4]
    _gpio_init_out(gpio, pin, PullNone, value);
    1d00:	9b01      	ldr	r3, [sp, #4]
    1d02:	2200      	movs	r2, #0
    1d04:	9902      	ldr	r1, [sp, #8]
    1d06:	9803      	ldr	r0, [sp, #12]
    1d08:	f7ff ffa7 	bl	1c5a <_gpio_init_out>
}
    1d0c:	bf00      	nop
    1d0e:	b005      	add	sp, #20
    1d10:	f85d fb04 	ldr.w	pc, [sp], #4

00001d14 <pinmap_pinout>:
 */
#include "hal/pinmap.h"
#include "platform/mbed_error.h"

void pinmap_pinout(PinName pin, const PinMap *map)
{
    1d14:	b500      	push	{lr}
    1d16:	b085      	sub	sp, #20
    1d18:	9003      	str	r0, [sp, #12]
    1d1a:	9102      	str	r1, [sp, #8]
    if (pin == NC) {
    1d1c:	9b03      	ldr	r3, [sp, #12]
    1d1e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1d22:	d021      	beq.n	1d68 <pinmap_pinout+0x54>
        return;
    }

    while (map->pin != NC) {
    1d24:	e012      	b.n	1d4c <pinmap_pinout+0x38>
        if (map->pin == pin) {
    1d26:	9b02      	ldr	r3, [sp, #8]
    1d28:	681a      	ldr	r2, [r3, #0]
    1d2a:	9b03      	ldr	r3, [sp, #12]
    1d2c:	429a      	cmp	r2, r3
    1d2e:	d10a      	bne.n	1d46 <pinmap_pinout+0x32>
            pin_function(pin, map->function);
    1d30:	9b02      	ldr	r3, [sp, #8]
    1d32:	689b      	ldr	r3, [r3, #8]
    1d34:	4619      	mov	r1, r3
    1d36:	9803      	ldr	r0, [sp, #12]
    1d38:	f008 fa44 	bl	a1c4 <pin_function>

            pin_mode(pin, PullNone);
    1d3c:	2100      	movs	r1, #0
    1d3e:	9803      	ldr	r0, [sp, #12]
    1d40:	f008 fa76 	bl	a230 <pin_mode>
            return;
    1d44:	e011      	b.n	1d6a <pinmap_pinout+0x56>
        }
        map++;
    1d46:	9b02      	ldr	r3, [sp, #8]
    1d48:	330c      	adds	r3, #12
    1d4a:	9302      	str	r3, [sp, #8]
    while (map->pin != NC) {
    1d4c:	9b02      	ldr	r3, [sp, #8]
    1d4e:	681b      	ldr	r3, [r3, #0]
    1d50:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1d54:	d1e7      	bne.n	1d26 <pinmap_pinout+0x12>
    }
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_PINMAP_INVALID), "could not pinout", pin);
    1d56:	9a03      	ldr	r2, [sp, #12]
    1d58:	2300      	movs	r3, #0
    1d5a:	9300      	str	r3, [sp, #0]
    1d5c:	2300      	movs	r3, #0
    1d5e:	4904      	ldr	r1, [pc, #16]	; (1d70 <pinmap_pinout+0x5c>)
    1d60:	4804      	ldr	r0, [pc, #16]	; (1d74 <pinmap_pinout+0x60>)
    1d62:	f001 f829 	bl	2db8 <mbed_error>
    1d66:	e000      	b.n	1d6a <pinmap_pinout+0x56>
        return;
    1d68:	bf00      	nop
}
    1d6a:	b005      	add	sp, #20
    1d6c:	f85d fb04 	ldr.w	pc, [sp], #4
    1d70:	00010a9c 	.word	0x00010a9c
    1d74:	80010130 	.word	0x80010130

00001d78 <pinmap_merge>:

uint32_t pinmap_merge(uint32_t a, uint32_t b)
{
    1d78:	b500      	push	{lr}
    1d7a:	b085      	sub	sp, #20
    1d7c:	9003      	str	r0, [sp, #12]
    1d7e:	9102      	str	r1, [sp, #8]
    // both are the same (inc both NC)
    if (a == b) {
    1d80:	9a03      	ldr	r2, [sp, #12]
    1d82:	9b02      	ldr	r3, [sp, #8]
    1d84:	429a      	cmp	r2, r3
    1d86:	d101      	bne.n	1d8c <pinmap_merge+0x14>
        return a;
    1d88:	9b03      	ldr	r3, [sp, #12]
    1d8a:	e015      	b.n	1db8 <pinmap_merge+0x40>
    }

    // one (or both) is not connected
    if (a == (uint32_t)NC) {
    1d8c:	9b03      	ldr	r3, [sp, #12]
    1d8e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1d92:	d101      	bne.n	1d98 <pinmap_merge+0x20>
        return b;
    1d94:	9b02      	ldr	r3, [sp, #8]
    1d96:	e00f      	b.n	1db8 <pinmap_merge+0x40>
    }
    if (b == (uint32_t)NC) {
    1d98:	9b02      	ldr	r3, [sp, #8]
    1d9a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1d9e:	d101      	bne.n	1da4 <pinmap_merge+0x2c>
        return a;
    1da0:	9b03      	ldr	r3, [sp, #12]
    1da2:	e009      	b.n	1db8 <pinmap_merge+0x40>
    }

    // mis-match error case
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_PINMAP_INVALID), "pinmap mis-match", a);
    1da4:	2300      	movs	r3, #0
    1da6:	9300      	str	r3, [sp, #0]
    1da8:	2300      	movs	r3, #0
    1daa:	9a03      	ldr	r2, [sp, #12]
    1dac:	4904      	ldr	r1, [pc, #16]	; (1dc0 <pinmap_merge+0x48>)
    1dae:	4805      	ldr	r0, [pc, #20]	; (1dc4 <pinmap_merge+0x4c>)
    1db0:	f001 f802 	bl	2db8 <mbed_error>
    return (uint32_t)NC;
    1db4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
    1db8:	4618      	mov	r0, r3
    1dba:	b005      	add	sp, #20
    1dbc:	f85d fb04 	ldr.w	pc, [sp], #4
    1dc0:	00010ab0 	.word	0x00010ab0
    1dc4:	80010130 	.word	0x80010130

00001dc8 <pinmap_find_peripheral>:

uint32_t pinmap_find_peripheral(PinName pin, const PinMap *map)
{
    1dc8:	b082      	sub	sp, #8
    1dca:	9001      	str	r0, [sp, #4]
    1dcc:	9100      	str	r1, [sp, #0]
    while (map->pin != NC) {
    1dce:	e00a      	b.n	1de6 <pinmap_find_peripheral+0x1e>
        if (map->pin == pin) {
    1dd0:	9b00      	ldr	r3, [sp, #0]
    1dd2:	681a      	ldr	r2, [r3, #0]
    1dd4:	9b01      	ldr	r3, [sp, #4]
    1dd6:	429a      	cmp	r2, r3
    1dd8:	d102      	bne.n	1de0 <pinmap_find_peripheral+0x18>
            return map->peripheral;
    1dda:	9b00      	ldr	r3, [sp, #0]
    1ddc:	685b      	ldr	r3, [r3, #4]
    1dde:	e009      	b.n	1df4 <pinmap_find_peripheral+0x2c>
        }
        map++;
    1de0:	9b00      	ldr	r3, [sp, #0]
    1de2:	330c      	adds	r3, #12
    1de4:	9300      	str	r3, [sp, #0]
    while (map->pin != NC) {
    1de6:	9b00      	ldr	r3, [sp, #0]
    1de8:	681b      	ldr	r3, [r3, #0]
    1dea:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1dee:	d1ef      	bne.n	1dd0 <pinmap_find_peripheral+0x8>
    }
    return (uint32_t)NC;
    1df0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
    1df4:	4618      	mov	r0, r3
    1df6:	b002      	add	sp, #8
    1df8:	4770      	bx	lr
	...

00001dfc <pinmap_peripheral>:

uint32_t pinmap_peripheral(PinName pin, const PinMap *map)
{
    1dfc:	b500      	push	{lr}
    1dfe:	b087      	sub	sp, #28
    1e00:	9003      	str	r0, [sp, #12]
    1e02:	9102      	str	r1, [sp, #8]
    uint32_t peripheral = (uint32_t)NC;
    1e04:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1e08:	9305      	str	r3, [sp, #20]

    if (pin == (PinName)NC) {
    1e0a:	9b03      	ldr	r3, [sp, #12]
    1e0c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1e10:	d102      	bne.n	1e18 <pinmap_peripheral+0x1c>
        return (uint32_t)NC;
    1e12:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1e16:	e011      	b.n	1e3c <pinmap_peripheral+0x40>
    }
    peripheral = pinmap_find_peripheral(pin, map);
    1e18:	9902      	ldr	r1, [sp, #8]
    1e1a:	9803      	ldr	r0, [sp, #12]
    1e1c:	f7ff ffd4 	bl	1dc8 <pinmap_find_peripheral>
    1e20:	9005      	str	r0, [sp, #20]
    if ((uint32_t)NC == peripheral) { // no mapping available
    1e22:	9b05      	ldr	r3, [sp, #20]
    1e24:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    1e28:	d107      	bne.n	1e3a <pinmap_peripheral+0x3e>
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_PINMAP_INVALID), "pinmap not found for peripheral", peripheral);
    1e2a:	2300      	movs	r3, #0
    1e2c:	9300      	str	r3, [sp, #0]
    1e2e:	2300      	movs	r3, #0
    1e30:	9a05      	ldr	r2, [sp, #20]
    1e32:	4904      	ldr	r1, [pc, #16]	; (1e44 <pinmap_peripheral+0x48>)
    1e34:	4804      	ldr	r0, [pc, #16]	; (1e48 <pinmap_peripheral+0x4c>)
    1e36:	f000 ffbf 	bl	2db8 <mbed_error>
    }
    return peripheral;
    1e3a:	9b05      	ldr	r3, [sp, #20]
}
    1e3c:	4618      	mov	r0, r3
    1e3e:	b007      	add	sp, #28
    1e40:	f85d fb04 	ldr.w	pc, [sp], #4
    1e44:	00010ac4 	.word	0x00010ac4
    1e48:	80010130 	.word	0x80010130

00001e4c <read_us>:
#if defined(MBED_CPU_STATS_ENABLED) && defined(DEVICE_LPTICKER)
static ticker_data_t *sleep_ticker = NULL;
#endif

static inline us_timestamp_t read_us(void)
{
    1e4c:	b410      	push	{r4}
    if (NULL == sleep_ticker) {
        sleep_ticker = (ticker_data_t *)get_lp_ticker_data();
    }
    return ticker_read_us(sleep_ticker);
#else
    return 0;
    1e4e:	f04f 0300 	mov.w	r3, #0
    1e52:	f04f 0400 	mov.w	r4, #0
#endif
}
    1e56:	4618      	mov	r0, r3
    1e58:	4621      	mov	r1, r4
    1e5a:	f85d 4b04 	ldr.w	r4, [sp], #4
    1e5e:	4770      	bx	lr

00001e60 <sleep_manager_lock_deep_sleep_internal>:
}

#endif // MBED_SLEEP_TRACING_ENABLED

void sleep_manager_lock_deep_sleep_internal(void)
{
    1e60:	b500      	push	{lr}
    1e62:	b083      	sub	sp, #12
    core_util_critical_section_enter();
    1e64:	f000 fe96 	bl	2b94 <core_util_critical_section_enter>
    if (deep_sleep_lock == USHRT_MAX) {
    1e68:	4b0d      	ldr	r3, [pc, #52]	; (1ea0 <sleep_manager_lock_deep_sleep_internal+0x40>)
    1e6a:	881b      	ldrh	r3, [r3, #0]
    1e6c:	f64f 72ff 	movw	r2, #65535	; 0xffff
    1e70:	4293      	cmp	r3, r2
    1e72:	d10b      	bne.n	1e8c <sleep_manager_lock_deep_sleep_internal+0x2c>
        core_util_critical_section_exit();
    1e74:	f000 fea8 	bl	2bc8 <core_util_critical_section_exit>
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_HAL, MBED_ERROR_CODE_OVERFLOW), "DeepSleepLock overflow (> USHRT_MAX)", deep_sleep_lock);
    1e78:	4b09      	ldr	r3, [pc, #36]	; (1ea0 <sleep_manager_lock_deep_sleep_internal+0x40>)
    1e7a:	881b      	ldrh	r3, [r3, #0]
    1e7c:	461a      	mov	r2, r3
    1e7e:	2300      	movs	r3, #0
    1e80:	9300      	str	r3, [sp, #0]
    1e82:	2300      	movs	r3, #0
    1e84:	4907      	ldr	r1, [pc, #28]	; (1ea4 <sleep_manager_lock_deep_sleep_internal+0x44>)
    1e86:	4808      	ldr	r0, [pc, #32]	; (1ea8 <sleep_manager_lock_deep_sleep_internal+0x48>)
    1e88:	f000 ff96 	bl	2db8 <mbed_error>
    }
    core_util_atomic_incr_u16(&deep_sleep_lock, 1);
    1e8c:	2101      	movs	r1, #1
    1e8e:	4804      	ldr	r0, [pc, #16]	; (1ea0 <sleep_manager_lock_deep_sleep_internal+0x40>)
    1e90:	f000 feb0 	bl	2bf4 <core_util_atomic_incr_u16>
    core_util_critical_section_exit();
    1e94:	f000 fe98 	bl	2bc8 <core_util_critical_section_exit>
}
    1e98:	bf00      	nop
    1e9a:	b003      	add	sp, #12
    1e9c:	f85d fb04 	ldr.w	pc, [sp], #4
    1ea0:	20000c5a 	.word	0x20000c5a
    1ea4:	00010b04 	.word	0x00010b04
    1ea8:	80040123 	.word	0x80040123

00001eac <sleep_manager_unlock_deep_sleep_internal>:

void sleep_manager_unlock_deep_sleep_internal(void)
{
    1eac:	b500      	push	{lr}
    1eae:	b083      	sub	sp, #12
    core_util_critical_section_enter();
    1eb0:	f000 fe70 	bl	2b94 <core_util_critical_section_enter>
    if (deep_sleep_lock == 0) {
    1eb4:	4b0c      	ldr	r3, [pc, #48]	; (1ee8 <sleep_manager_unlock_deep_sleep_internal+0x3c>)
    1eb6:	881b      	ldrh	r3, [r3, #0]
    1eb8:	2b00      	cmp	r3, #0
    1eba:	d10b      	bne.n	1ed4 <sleep_manager_unlock_deep_sleep_internal+0x28>
        core_util_critical_section_exit();
    1ebc:	f000 fe84 	bl	2bc8 <core_util_critical_section_exit>
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_HAL, MBED_ERROR_CODE_UNDERFLOW), "DeepSleepLock underflow (< 0)", deep_sleep_lock);
    1ec0:	4b09      	ldr	r3, [pc, #36]	; (1ee8 <sleep_manager_unlock_deep_sleep_internal+0x3c>)
    1ec2:	881b      	ldrh	r3, [r3, #0]
    1ec4:	461a      	mov	r2, r3
    1ec6:	2300      	movs	r3, #0
    1ec8:	9300      	str	r3, [sp, #0]
    1eca:	2300      	movs	r3, #0
    1ecc:	4907      	ldr	r1, [pc, #28]	; (1eec <sleep_manager_unlock_deep_sleep_internal+0x40>)
    1ece:	4808      	ldr	r0, [pc, #32]	; (1ef0 <sleep_manager_unlock_deep_sleep_internal+0x44>)
    1ed0:	f000 ff72 	bl	2db8 <mbed_error>
    }
    core_util_atomic_decr_u16(&deep_sleep_lock, 1);
    1ed4:	2101      	movs	r1, #1
    1ed6:	4804      	ldr	r0, [pc, #16]	; (1ee8 <sleep_manager_unlock_deep_sleep_internal+0x3c>)
    1ed8:	f000 feb2 	bl	2c40 <core_util_atomic_decr_u16>
    core_util_critical_section_exit();
    1edc:	f000 fe74 	bl	2bc8 <core_util_critical_section_exit>
}
    1ee0:	bf00      	nop
    1ee2:	b003      	add	sp, #12
    1ee4:	f85d fb04 	ldr.w	pc, [sp], #4
    1ee8:	20000c5a 	.word	0x20000c5a
    1eec:	00010b2c 	.word	0x00010b2c
    1ef0:	80040124 	.word	0x80040124

00001ef4 <sleep_manager_sleep_auto>:
{
    return deep_sleep_lock == 0 ? true : false;
}

void sleep_manager_sleep_auto(void)
{
    1ef4:	b510      	push	{r4, lr}
    1ef6:	b086      	sub	sp, #24
#ifdef MBED_SLEEP_TRACING_ENABLED
    sleep_tracker_print_stats();
#endif
    core_util_critical_section_enter();
    1ef8:	f000 fe4c 	bl	2b94 <core_util_critical_section_enter>
    us_timestamp_t start = read_us();
    1efc:	f7ff ffa6 	bl	1e4c <read_us>
    1f00:	e9cd 0104 	strd	r0, r1, [sp, #16]
    bool deep = false;
    1f04:	2300      	movs	r3, #0
    1f06:	f88d 300f 	strb.w	r3, [sp, #15]

// debug profile should keep debuggers attached, no deep sleep allowed
#ifdef MBED_DEBUG
    hal_sleep();
    1f0a:	f008 f9ef 	bl	a2ec <hal_sleep>
    } else {
        hal_sleep();
    }
#endif

    us_timestamp_t end = read_us();
    1f0e:	f7ff ff9d 	bl	1e4c <read_us>
    1f12:	e9cd 0100 	strd	r0, r1, [sp]
    if (true == deep) {
    1f16:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1f1a:	2b00      	cmp	r3, #0
    1f1c:	d010      	beq.n	1f40 <sleep_manager_sleep_auto+0x4c>
        deep_sleep_time += end - start;
    1f1e:	e9dd 1200 	ldrd	r1, r2, [sp]
    1f22:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
    1f26:	1ac9      	subs	r1, r1, r3
    1f28:	eb62 0204 	sbc.w	r2, r2, r4
    1f2c:	4b0f      	ldr	r3, [pc, #60]	; (1f6c <sleep_manager_sleep_auto+0x78>)
    1f2e:	e9d3 3400 	ldrd	r3, r4, [r3]
    1f32:	185b      	adds	r3, r3, r1
    1f34:	eb44 0402 	adc.w	r4, r4, r2
    1f38:	4a0c      	ldr	r2, [pc, #48]	; (1f6c <sleep_manager_sleep_auto+0x78>)
    1f3a:	e9c2 3400 	strd	r3, r4, [r2]
    1f3e:	e00f      	b.n	1f60 <sleep_manager_sleep_auto+0x6c>
    } else {
        sleep_time += end - start;
    1f40:	e9dd 1200 	ldrd	r1, r2, [sp]
    1f44:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
    1f48:	1ac9      	subs	r1, r1, r3
    1f4a:	eb62 0204 	sbc.w	r2, r2, r4
    1f4e:	4b08      	ldr	r3, [pc, #32]	; (1f70 <sleep_manager_sleep_auto+0x7c>)
    1f50:	e9d3 3400 	ldrd	r3, r4, [r3]
    1f54:	185b      	adds	r3, r3, r1
    1f56:	eb44 0402 	adc.w	r4, r4, r2
    1f5a:	4a05      	ldr	r2, [pc, #20]	; (1f70 <sleep_manager_sleep_auto+0x7c>)
    1f5c:	e9c2 3400 	strd	r3, r4, [r2]
    }
    core_util_critical_section_exit();
    1f60:	f000 fe32 	bl	2bc8 <core_util_critical_section_exit>
}
    1f64:	bf00      	nop
    1f66:	b006      	add	sp, #24
    1f68:	bd10      	pop	{r4, pc}
    1f6a:	bf00      	nop
    1f6c:	20000c68 	.word	0x20000c68
    1f70:	20000c60 	.word	0x20000c60

00001f74 <initialize>:

/*
 * Initialize a ticker instance.
 */
static void initialize(const ticker_data_t *ticker)
{
    1f74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1f78:	b08c      	sub	sp, #48	; 0x30
    1f7a:	9003      	str	r0, [sp, #12]
    // return if the queue has already been initialized, in that case the
    // interface used by the queue is already initialized.
    if (ticker->queue->initialized) {
    1f7c:	9b03      	ldr	r3, [sp, #12]
    1f7e:	685b      	ldr	r3, [r3, #4]
    1f80:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
    1f84:	2b00      	cmp	r3, #0
    1f86:	f040 80e4 	bne.w	2152 <initialize+0x1de>
        return;
    }

    ticker->interface->init();
    1f8a:	9b03      	ldr	r3, [sp, #12]
    1f8c:	681b      	ldr	r3, [r3, #0]
    1f8e:	681b      	ldr	r3, [r3, #0]
    1f90:	4798      	blx	r3

    const ticker_info_t *info = ticker->interface->get_info();
    1f92:	9b03      	ldr	r3, [sp, #12]
    1f94:	681b      	ldr	r3, [r3, #0]
    1f96:	699b      	ldr	r3, [r3, #24]
    1f98:	4798      	blx	r3
    1f9a:	9008      	str	r0, [sp, #32]
    uint32_t frequency = info->frequency;
    1f9c:	9b08      	ldr	r3, [sp, #32]
    1f9e:	681b      	ldr	r3, [r3, #0]
    1fa0:	930b      	str	r3, [sp, #44]	; 0x2c
    if (info->frequency == 0) {
    1fa2:	9b08      	ldr	r3, [sp, #32]
    1fa4:	681b      	ldr	r3, [r3, #0]
    1fa6:	2b00      	cmp	r3, #0
    1fa8:	d106      	bne.n	1fb8 <initialize+0x44>
        MBED_ASSERT(0);
    1faa:	2229      	movs	r2, #41	; 0x29
    1fac:	496b      	ldr	r1, [pc, #428]	; (215c <initialize+0x1e8>)
    1fae:	486c      	ldr	r0, [pc, #432]	; (2160 <initialize+0x1ec>)
    1fb0:	f000 fd22 	bl	29f8 <mbed_assert_internal>
        frequency = 1000000;
    1fb4:	4b6b      	ldr	r3, [pc, #428]	; (2164 <initialize+0x1f0>)
    1fb6:	930b      	str	r3, [sp, #44]	; 0x2c
    }

    uint8_t frequency_shifts = 0;
    1fb8:	2300      	movs	r3, #0
    1fba:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
    for (uint8_t i = 31; i > 0; --i) {
    1fbe:	231f      	movs	r3, #31
    1fc0:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    1fc4:	e012      	b.n	1fec <initialize+0x78>
        if ((1 << i) == frequency) {
    1fc6:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
    1fca:	2201      	movs	r2, #1
    1fcc:	fa02 f303 	lsl.w	r3, r2, r3
    1fd0:	461a      	mov	r2, r3
    1fd2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1fd4:	429a      	cmp	r2, r3
    1fd6:	d104      	bne.n	1fe2 <initialize+0x6e>
            frequency_shifts = i;
    1fd8:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
    1fdc:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
            break;
    1fe0:	e008      	b.n	1ff4 <initialize+0x80>
    for (uint8_t i = 31; i > 0; --i) {
    1fe2:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
    1fe6:	3b01      	subs	r3, #1
    1fe8:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    1fec:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
    1ff0:	2b00      	cmp	r3, #0
    1ff2:	d1e8      	bne.n	1fc6 <initialize+0x52>
        }
    }

    uint32_t bits = info->bits;
    1ff4:	9b08      	ldr	r3, [sp, #32]
    1ff6:	685b      	ldr	r3, [r3, #4]
    1ff8:	9309      	str	r3, [sp, #36]	; 0x24
    if ((info->bits > 32) || (info->bits < 4)) {
    1ffa:	9b08      	ldr	r3, [sp, #32]
    1ffc:	685b      	ldr	r3, [r3, #4]
    1ffe:	2b20      	cmp	r3, #32
    2000:	d803      	bhi.n	200a <initialize+0x96>
    2002:	9b08      	ldr	r3, [sp, #32]
    2004:	685b      	ldr	r3, [r3, #4]
    2006:	2b03      	cmp	r3, #3
    2008:	d806      	bhi.n	2018 <initialize+0xa4>
        MBED_ASSERT(0);
    200a:	2237      	movs	r2, #55	; 0x37
    200c:	4953      	ldr	r1, [pc, #332]	; (215c <initialize+0x1e8>)
    200e:	4854      	ldr	r0, [pc, #336]	; (2160 <initialize+0x1ec>)
    2010:	f000 fcf2 	bl	29f8 <mbed_assert_internal>
        bits = 32;
    2014:	2320      	movs	r3, #32
    2016:	9309      	str	r3, [sp, #36]	; 0x24
    }
    uint32_t max_delta = 0x7 << (bits - 4); // 7/16th
    2018:	9b09      	ldr	r3, [sp, #36]	; 0x24
    201a:	3b04      	subs	r3, #4
    201c:	2207      	movs	r2, #7
    201e:	fa02 f303 	lsl.w	r3, r2, r3
    2022:	9307      	str	r3, [sp, #28]
    uint64_t max_delta_us =
        ((uint64_t)max_delta * 1000000 + frequency - 1) / frequency;
    2024:	9b07      	ldr	r3, [sp, #28]
    2026:	4619      	mov	r1, r3
    2028:	f04f 0200 	mov.w	r2, #0
    202c:	460b      	mov	r3, r1
    202e:	4614      	mov	r4, r2
    2030:	0160      	lsls	r0, r4, #5
    2032:	9001      	str	r0, [sp, #4]
    2034:	9801      	ldr	r0, [sp, #4]
    2036:	ea40 60d3 	orr.w	r0, r0, r3, lsr #27
    203a:	9001      	str	r0, [sp, #4]
    203c:	015b      	lsls	r3, r3, #5
    203e:	9300      	str	r3, [sp, #0]
    2040:	e9dd 3400 	ldrd	r3, r4, [sp]
    2044:	1a5b      	subs	r3, r3, r1
    2046:	eb64 0402 	sbc.w	r4, r4, r2
    204a:	ea4f 2a44 	mov.w	sl, r4, lsl #9
    204e:	ea4a 5ad3 	orr.w	sl, sl, r3, lsr #23
    2052:	ea4f 2943 	mov.w	r9, r3, lsl #9
    2056:	464b      	mov	r3, r9
    2058:	4654      	mov	r4, sl
    205a:	185b      	adds	r3, r3, r1
    205c:	eb44 0402 	adc.w	r4, r4, r2
    2060:	01a6      	lsls	r6, r4, #6
    2062:	ea46 6693 	orr.w	r6, r6, r3, lsr #26
    2066:	019d      	lsls	r5, r3, #6
    2068:	1aed      	subs	r5, r5, r3
    206a:	eb66 0604 	sbc.w	r6, r6, r4
    206e:	1949      	adds	r1, r1, r5
    2070:	eb42 0206 	adc.w	r2, r2, r6
    2074:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2076:	f04f 0400 	mov.w	r4, #0
    207a:	185b      	adds	r3, r3, r1
    207c:	eb44 0402 	adc.w	r4, r4, r2
    2080:	f113 30ff 	adds.w	r0, r3, #4294967295	; 0xffffffff
    2084:	f144 31ff 	adc.w	r1, r4, #4294967295	; 0xffffffff
    2088:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    208a:	f04f 0400 	mov.w	r4, #0
    uint64_t max_delta_us =
    208e:	461a      	mov	r2, r3
    2090:	4623      	mov	r3, r4
    2092:	f7ff f9f3 	bl	147c <__aeabi_uldivmod>
    2096:	4603      	mov	r3, r0
    2098:	460c      	mov	r4, r1
    209a:	e9cd 3404 	strd	r3, r4, [sp, #16]

    ticker->queue->event_handler = NULL;
    209e:	9b03      	ldr	r3, [sp, #12]
    20a0:	685b      	ldr	r3, [r3, #4]
    20a2:	2200      	movs	r2, #0
    20a4:	601a      	str	r2, [r3, #0]
    ticker->queue->head = NULL;
    20a6:	9b03      	ldr	r3, [sp, #12]
    20a8:	685b      	ldr	r3, [r3, #4]
    20aa:	2200      	movs	r2, #0
    20ac:	605a      	str	r2, [r3, #4]
    ticker->queue->tick_last_read = ticker->interface->read();
    20ae:	9b03      	ldr	r3, [sp, #12]
    20b0:	685c      	ldr	r4, [r3, #4]
    20b2:	9b03      	ldr	r3, [sp, #12]
    20b4:	681b      	ldr	r3, [r3, #0]
    20b6:	685b      	ldr	r3, [r3, #4]
    20b8:	4798      	blx	r3
    20ba:	4603      	mov	r3, r0
    20bc:	6223      	str	r3, [r4, #32]
    ticker->queue->tick_remainder = 0;
    20be:	9b03      	ldr	r3, [sp, #12]
    20c0:	685a      	ldr	r2, [r3, #4]
    20c2:	f04f 0300 	mov.w	r3, #0
    20c6:	f04f 0400 	mov.w	r4, #0
    20ca:	e9c2 340a 	strd	r3, r4, [r2, #40]	; 0x28
    ticker->queue->frequency = frequency;
    20ce:	9b03      	ldr	r3, [sp, #12]
    20d0:	685b      	ldr	r3, [r3, #4]
    20d2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    20d4:	609a      	str	r2, [r3, #8]
    ticker->queue->frequency_shifts = frequency_shifts;
    20d6:	9b03      	ldr	r3, [sp, #12]
    20d8:	685b      	ldr	r3, [r3, #4]
    20da:	f89d 202b 	ldrb.w	r2, [sp, #43]	; 0x2b
    20de:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    ticker->queue->bitmask = ((uint64_t)1 << bits) - 1;
    20e2:	9b03      	ldr	r3, [sp, #12]
    20e4:	685d      	ldr	r5, [r3, #4]
    20e6:	f04f 0301 	mov.w	r3, #1
    20ea:	f04f 0400 	mov.w	r4, #0
    20ee:	9a09      	ldr	r2, [sp, #36]	; 0x24
    20f0:	f1a2 0020 	sub.w	r0, r2, #32
    20f4:	f1c2 0120 	rsb	r1, r2, #32
    20f8:	fa04 f802 	lsl.w	r8, r4, r2
    20fc:	fa03 f000 	lsl.w	r0, r3, r0
    2100:	ea48 0800 	orr.w	r8, r8, r0
    2104:	fa23 f101 	lsr.w	r1, r3, r1
    2108:	ea48 0801 	orr.w	r8, r8, r1
    210c:	fa03 f702 	lsl.w	r7, r3, r2
    2110:	463b      	mov	r3, r7
    2112:	3b01      	subs	r3, #1
    2114:	60eb      	str	r3, [r5, #12]
    ticker->queue->max_delta = max_delta;
    2116:	9b03      	ldr	r3, [sp, #12]
    2118:	685b      	ldr	r3, [r3, #4]
    211a:	9a07      	ldr	r2, [sp, #28]
    211c:	611a      	str	r2, [r3, #16]
    ticker->queue->max_delta_us = max_delta_us;
    211e:	9b03      	ldr	r3, [sp, #12]
    2120:	685a      	ldr	r2, [r3, #4]
    2122:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
    2126:	e9c2 3406 	strd	r3, r4, [r2, #24]
    ticker->queue->present_time = 0;
    212a:	9b03      	ldr	r3, [sp, #12]
    212c:	685a      	ldr	r2, [r3, #4]
    212e:	f04f 0300 	mov.w	r3, #0
    2132:	f04f 0400 	mov.w	r4, #0
    2136:	e9c2 340c 	strd	r3, r4, [r2, #48]	; 0x30
    ticker->queue->initialized = true;
    213a:	9b03      	ldr	r3, [sp, #12]
    213c:	685b      	ldr	r3, [r3, #4]
    213e:	2201      	movs	r2, #1
    2140:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    update_present_time(ticker);
    2144:	9803      	ldr	r0, [sp, #12]
    2146:	f000 f80f 	bl	2168 <update_present_time>
    schedule_interrupt(ticker);
    214a:	9803      	ldr	r0, [sp, #12]
    214c:	f000 fa06 	bl	255c <schedule_interrupt>
    2150:	e000      	b.n	2154 <initialize+0x1e0>
        return;
    2152:	bf00      	nop
}
    2154:	b00c      	add	sp, #48	; 0x30
    2156:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    215a:	bf00      	nop
    215c:	00010b4c 	.word	0x00010b4c
    2160:	00010b6c 	.word	0x00010b6c
    2164:	000f4240 	.word	0x000f4240

00002168 <update_present_time>:

/**
 * Update the present timestamp value of a ticker.
 */
static void update_present_time(const ticker_data_t *const ticker)
{
    2168:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    216c:	b096      	sub	sp, #88	; 0x58
    216e:	900b      	str	r0, [sp, #44]	; 0x2c
    ticker_event_queue_t *queue = ticker->queue;
    2170:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2172:	685b      	ldr	r3, [r3, #4]
    2174:	9313      	str	r3, [sp, #76]	; 0x4c
    uint32_t ticker_time = ticker->interface->read();
    2176:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2178:	681b      	ldr	r3, [r3, #0]
    217a:	685b      	ldr	r3, [r3, #4]
    217c:	4798      	blx	r3
    217e:	9012      	str	r0, [sp, #72]	; 0x48
    if (ticker_time == ticker->queue->tick_last_read) {
    2180:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2182:	685b      	ldr	r3, [r3, #4]
    2184:	6a1a      	ldr	r2, [r3, #32]
    2186:	9b12      	ldr	r3, [sp, #72]	; 0x48
    2188:	429a      	cmp	r2, r3
    218a:	f000 812e 	beq.w	23ea <update_present_time+0x282>
        // No work to do
        return;
    }

    uint64_t elapsed_ticks = (ticker_time - queue->tick_last_read) & queue->bitmask;
    218e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2190:	6a1a      	ldr	r2, [r3, #32]
    2192:	9b12      	ldr	r3, [sp, #72]	; 0x48
    2194:	1a9a      	subs	r2, r3, r2
    2196:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2198:	68db      	ldr	r3, [r3, #12]
    219a:	4013      	ands	r3, r2
    219c:	f04f 0400 	mov.w	r4, #0
    21a0:	e9cd 3410 	strd	r3, r4, [sp, #64]	; 0x40
    queue->tick_last_read = ticker_time;
    21a4:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    21a6:	9b12      	ldr	r3, [sp, #72]	; 0x48
    21a8:	6213      	str	r3, [r2, #32]

    uint64_t elapsed_us;
    if (1000000 == queue->frequency) {
    21aa:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    21ac:	689a      	ldr	r2, [r3, #8]
    21ae:	4b91      	ldr	r3, [pc, #580]	; (23f4 <update_present_time+0x28c>)
    21b0:	429a      	cmp	r2, r3
    21b2:	d104      	bne.n	21be <update_present_time+0x56>
        // Optimized for 1MHz

        elapsed_us = elapsed_ticks;
    21b4:	e9dd 3410 	ldrd	r3, r4, [sp, #64]	; 0x40
    21b8:	e9cd 3414 	strd	r3, r4, [sp, #80]	; 0x50
    21bc:	e109      	b.n	23d2 <update_present_time+0x26a>
    } else if (0 != queue->frequency_shifts) {
    21be:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    21c0:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
    21c4:	2b00      	cmp	r3, #0
    21c6:	f000 808f 	beq.w	22e8 <update_present_time+0x180>
        // Optimized for frequencies divisible by 2
        uint64_t us_x_ticks = elapsed_ticks * 1000000;
    21ca:	e9dd 1210 	ldrd	r1, r2, [sp, #64]	; 0x40
    21ce:	460b      	mov	r3, r1
    21d0:	4614      	mov	r4, r2
    21d2:	0160      	lsls	r0, r4, #5
    21d4:	9001      	str	r0, [sp, #4]
    21d6:	9801      	ldr	r0, [sp, #4]
    21d8:	ea40 60d3 	orr.w	r0, r0, r3, lsr #27
    21dc:	9001      	str	r0, [sp, #4]
    21de:	015b      	lsls	r3, r3, #5
    21e0:	9300      	str	r3, [sp, #0]
    21e2:	e9dd 3400 	ldrd	r3, r4, [sp]
    21e6:	1a5b      	subs	r3, r3, r1
    21e8:	eb64 0402 	sbc.w	r4, r4, r2
    21ec:	0260      	lsls	r0, r4, #9
    21ee:	9003      	str	r0, [sp, #12]
    21f0:	9803      	ldr	r0, [sp, #12]
    21f2:	ea40 50d3 	orr.w	r0, r0, r3, lsr #23
    21f6:	9003      	str	r0, [sp, #12]
    21f8:	025b      	lsls	r3, r3, #9
    21fa:	9302      	str	r3, [sp, #8]
    21fc:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
    2200:	185b      	adds	r3, r3, r1
    2202:	eb44 0402 	adc.w	r4, r4, r2
    2206:	01a0      	lsls	r0, r4, #6
    2208:	9005      	str	r0, [sp, #20]
    220a:	9805      	ldr	r0, [sp, #20]
    220c:	ea40 6093 	orr.w	r0, r0, r3, lsr #26
    2210:	9005      	str	r0, [sp, #20]
    2212:	0198      	lsls	r0, r3, #6
    2214:	9004      	str	r0, [sp, #16]
    2216:	e9dd 5604 	ldrd	r5, r6, [sp, #16]
    221a:	1aed      	subs	r5, r5, r3
    221c:	eb66 0604 	sbc.w	r6, r6, r4
    2220:	462b      	mov	r3, r5
    2222:	4634      	mov	r4, r6
    2224:	185b      	adds	r3, r3, r1
    2226:	eb44 0402 	adc.w	r4, r4, r2
    222a:	e9cd 340e 	strd	r3, r4, [sp, #56]	; 0x38
        elapsed_us = us_x_ticks >> queue->frequency_shifts;
    222e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2230:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
    2234:	461a      	mov	r2, r3
    2236:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
    223a:	f1c2 0020 	rsb	r0, r2, #32
    223e:	f1a2 0120 	sub.w	r1, r2, #32
    2242:	fa23 f902 	lsr.w	r9, r3, r2
    2246:	fa04 f000 	lsl.w	r0, r4, r0
    224a:	ea49 0900 	orr.w	r9, r9, r0
    224e:	fa24 f101 	lsr.w	r1, r4, r1
    2252:	ea49 0901 	orr.w	r9, r9, r1
    2256:	fa24 fa02 	lsr.w	sl, r4, r2
    225a:	e9cd 9a14 	strd	r9, sl, [sp, #80]	; 0x50

        // Update remainder
        queue->tick_remainder += us_x_ticks - (elapsed_us << queue->frequency_shifts);
    225e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2260:	e9d3 560a 	ldrd	r5, r6, [r3, #40]	; 0x28
    2264:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2266:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
    226a:	461a      	mov	r2, r3
    226c:	e9dd 3414 	ldrd	r3, r4, [sp, #80]	; 0x50
    2270:	f1a2 0020 	sub.w	r0, r2, #32
    2274:	f1c2 0120 	rsb	r1, r2, #32
    2278:	fa04 f802 	lsl.w	r8, r4, r2
    227c:	fa03 f000 	lsl.w	r0, r3, r0
    2280:	ea48 0800 	orr.w	r8, r8, r0
    2284:	fa23 f101 	lsr.w	r1, r3, r1
    2288:	ea48 0801 	orr.w	r8, r8, r1
    228c:	fa03 f702 	lsl.w	r7, r3, r2
    2290:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
    2294:	1bdb      	subs	r3, r3, r7
    2296:	eb64 0408 	sbc.w	r4, r4, r8
    229a:	195b      	adds	r3, r3, r5
    229c:	eb44 0406 	adc.w	r4, r4, r6
    22a0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    22a2:	e9c2 340a 	strd	r3, r4, [r2, #40]	; 0x28
        if (queue->tick_remainder >= queue->frequency) {
    22a6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    22a8:	e9d3 120a 	ldrd	r1, r2, [r3, #40]	; 0x28
    22ac:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    22ae:	689b      	ldr	r3, [r3, #8]
    22b0:	f04f 0400 	mov.w	r4, #0
    22b4:	42a2      	cmp	r2, r4
    22b6:	bf08      	it	eq
    22b8:	4299      	cmpeq	r1, r3
    22ba:	f0c0 808a 	bcc.w	23d2 <update_present_time+0x26a>
            elapsed_us += 1;
    22be:	e9dd 3414 	ldrd	r3, r4, [sp, #80]	; 0x50
    22c2:	3301      	adds	r3, #1
    22c4:	f144 0400 	adc.w	r4, r4, #0
    22c8:	e9cd 3414 	strd	r3, r4, [sp, #80]	; 0x50
            queue->tick_remainder -= queue->frequency;
    22cc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    22ce:	e9d3 120a 	ldrd	r1, r2, [r3, #40]	; 0x28
    22d2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    22d4:	689b      	ldr	r3, [r3, #8]
    22d6:	f04f 0400 	mov.w	r4, #0
    22da:	1acb      	subs	r3, r1, r3
    22dc:	eb62 0404 	sbc.w	r4, r2, r4
    22e0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    22e2:	e9c2 340a 	strd	r3, r4, [r2, #40]	; 0x28
    22e6:	e074      	b.n	23d2 <update_present_time+0x26a>
        }
    } else {
        // General case

        uint64_t us_x_ticks = elapsed_ticks * 1000000;
    22e8:	e9dd 1210 	ldrd	r1, r2, [sp, #64]	; 0x40
    22ec:	460b      	mov	r3, r1
    22ee:	4614      	mov	r4, r2
    22f0:	0160      	lsls	r0, r4, #5
    22f2:	9007      	str	r0, [sp, #28]
    22f4:	9807      	ldr	r0, [sp, #28]
    22f6:	ea40 60d3 	orr.w	r0, r0, r3, lsr #27
    22fa:	9007      	str	r0, [sp, #28]
    22fc:	015b      	lsls	r3, r3, #5
    22fe:	9306      	str	r3, [sp, #24]
    2300:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
    2304:	1a5b      	subs	r3, r3, r1
    2306:	eb64 0402 	sbc.w	r4, r4, r2
    230a:	0260      	lsls	r0, r4, #9
    230c:	9009      	str	r0, [sp, #36]	; 0x24
    230e:	9809      	ldr	r0, [sp, #36]	; 0x24
    2310:	ea40 50d3 	orr.w	r0, r0, r3, lsr #23
    2314:	9009      	str	r0, [sp, #36]	; 0x24
    2316:	025b      	lsls	r3, r3, #9
    2318:	9308      	str	r3, [sp, #32]
    231a:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
    231e:	185b      	adds	r3, r3, r1
    2320:	eb44 0402 	adc.w	r4, r4, r2
    2324:	01a6      	lsls	r6, r4, #6
    2326:	ea46 6693 	orr.w	r6, r6, r3, lsr #26
    232a:	019d      	lsls	r5, r3, #6
    232c:	1aed      	subs	r5, r5, r3
    232e:	eb66 0604 	sbc.w	r6, r6, r4
    2332:	186b      	adds	r3, r5, r1
    2334:	eb46 0402 	adc.w	r4, r6, r2
    2338:	e9cd 340c 	strd	r3, r4, [sp, #48]	; 0x30
        elapsed_us = us_x_ticks / queue->frequency;
    233c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    233e:	689b      	ldr	r3, [r3, #8]
    2340:	f04f 0400 	mov.w	r4, #0
    2344:	461a      	mov	r2, r3
    2346:	4623      	mov	r3, r4
    2348:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    234c:	f7ff f896 	bl	147c <__aeabi_uldivmod>
    2350:	4603      	mov	r3, r0
    2352:	460c      	mov	r4, r1
    2354:	e9cd 3414 	strd	r3, r4, [sp, #80]	; 0x50

        // Update remainder
        queue->tick_remainder += us_x_ticks - elapsed_us * queue->frequency;
    2358:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    235a:	e9d3 120a 	ldrd	r1, r2, [r3, #40]	; 0x28
    235e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2360:	689b      	ldr	r3, [r3, #8]
    2362:	f04f 0400 	mov.w	r4, #0
    2366:	9814      	ldr	r0, [sp, #80]	; 0x50
    2368:	fb04 f500 	mul.w	r5, r4, r0
    236c:	9815      	ldr	r0, [sp, #84]	; 0x54
    236e:	fb03 f000 	mul.w	r0, r3, r0
    2372:	4428      	add	r0, r5
    2374:	9d14      	ldr	r5, [sp, #80]	; 0x50
    2376:	fba5 3403 	umull	r3, r4, r5, r3
    237a:	4420      	add	r0, r4
    237c:	4604      	mov	r4, r0
    237e:	e9dd 560c 	ldrd	r5, r6, [sp, #48]	; 0x30
    2382:	1aeb      	subs	r3, r5, r3
    2384:	eb66 0404 	sbc.w	r4, r6, r4
    2388:	185b      	adds	r3, r3, r1
    238a:	eb44 0402 	adc.w	r4, r4, r2
    238e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    2390:	e9c2 340a 	strd	r3, r4, [r2, #40]	; 0x28
        if (queue->tick_remainder >= queue->frequency) {
    2394:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2396:	e9d3 120a 	ldrd	r1, r2, [r3, #40]	; 0x28
    239a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    239c:	689b      	ldr	r3, [r3, #8]
    239e:	f04f 0400 	mov.w	r4, #0
    23a2:	42a2      	cmp	r2, r4
    23a4:	bf08      	it	eq
    23a6:	4299      	cmpeq	r1, r3
    23a8:	d313      	bcc.n	23d2 <update_present_time+0x26a>
            elapsed_us += 1;
    23aa:	e9dd 3414 	ldrd	r3, r4, [sp, #80]	; 0x50
    23ae:	3301      	adds	r3, #1
    23b0:	f144 0400 	adc.w	r4, r4, #0
    23b4:	e9cd 3414 	strd	r3, r4, [sp, #80]	; 0x50
            queue->tick_remainder -= queue->frequency;
    23b8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    23ba:	e9d3 120a 	ldrd	r1, r2, [r3, #40]	; 0x28
    23be:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    23c0:	689b      	ldr	r3, [r3, #8]
    23c2:	f04f 0400 	mov.w	r4, #0
    23c6:	1acb      	subs	r3, r1, r3
    23c8:	eb62 0404 	sbc.w	r4, r2, r4
    23cc:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    23ce:	e9c2 340a 	strd	r3, r4, [r2, #40]	; 0x28
        }
    }

    // Update current time
    queue->present_time += elapsed_us;
    23d2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    23d4:	e9d3 120c 	ldrd	r1, r2, [r3, #48]	; 0x30
    23d8:	e9dd 3414 	ldrd	r3, r4, [sp, #80]	; 0x50
    23dc:	185b      	adds	r3, r3, r1
    23de:	eb44 0402 	adc.w	r4, r4, r2
    23e2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    23e4:	e9c2 340c 	strd	r3, r4, [r2, #48]	; 0x30
    23e8:	e000      	b.n	23ec <update_present_time+0x284>
        return;
    23ea:	bf00      	nop
}
    23ec:	b016      	add	sp, #88	; 0x58
    23ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    23f2:	bf00      	nop
    23f4:	000f4240 	.word	0x000f4240

000023f8 <compute_tick>:

/**
 * Given the absolute timestamp compute the hal tick timestamp.
 */
static timestamp_t compute_tick(const ticker_data_t *const ticker, us_timestamp_t timestamp)
{
    23f8:	b570      	push	{r4, r5, r6, lr}
    23fa:	b088      	sub	sp, #32
    23fc:	9003      	str	r0, [sp, #12]
    23fe:	e9cd 2300 	strd	r2, r3, [sp]
    ticker_event_queue_t *queue = ticker->queue;
    2402:	9b03      	ldr	r3, [sp, #12]
    2404:	685b      	ldr	r3, [r3, #4]
    2406:	9306      	str	r3, [sp, #24]
    us_timestamp_t delta_us = timestamp - queue->present_time;
    2408:	9b06      	ldr	r3, [sp, #24]
    240a:	e9d3 230c 	ldrd	r2, r3, [r3, #48]	; 0x30
    240e:	e9dd 0100 	ldrd	r0, r1, [sp]
    2412:	1a82      	subs	r2, r0, r2
    2414:	eb61 0303 	sbc.w	r3, r1, r3
    2418:	e9cd 2304 	strd	r2, r3, [sp, #16]

    timestamp_t delta = ticker->queue->max_delta;
    241c:	9b03      	ldr	r3, [sp, #12]
    241e:	685b      	ldr	r3, [r3, #4]
    2420:	691b      	ldr	r3, [r3, #16]
    2422:	9307      	str	r3, [sp, #28]
    if (delta_us <=  ticker->queue->max_delta_us) {
    2424:	9b03      	ldr	r3, [sp, #12]
    2426:	685b      	ldr	r3, [r3, #4]
    2428:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
    242c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    2430:	4299      	cmp	r1, r3
    2432:	bf08      	it	eq
    2434:	4290      	cmpeq	r0, r2
    2436:	d362      	bcc.n	24fe <compute_tick+0x106>
        // Checking max_delta_us ensures the operation will not overflow

        if (1000000 == queue->frequency) {
    2438:	9b06      	ldr	r3, [sp, #24]
    243a:	689b      	ldr	r3, [r3, #8]
    243c:	4a35      	ldr	r2, [pc, #212]	; (2514 <compute_tick+0x11c>)
    243e:	4293      	cmp	r3, r2
    2440:	d10c      	bne.n	245c <compute_tick+0x64>
            // Optimized for 1MHz

            delta = delta_us;
    2442:	9b04      	ldr	r3, [sp, #16]
    2444:	9307      	str	r3, [sp, #28]
            if (delta > ticker->queue->max_delta) {
    2446:	9b03      	ldr	r3, [sp, #12]
    2448:	685b      	ldr	r3, [r3, #4]
    244a:	691a      	ldr	r2, [r3, #16]
    244c:	9b07      	ldr	r3, [sp, #28]
    244e:	429a      	cmp	r2, r3
    2450:	d255      	bcs.n	24fe <compute_tick+0x106>
                delta = ticker->queue->max_delta;
    2452:	9b03      	ldr	r3, [sp, #12]
    2454:	685b      	ldr	r3, [r3, #4]
    2456:	691b      	ldr	r3, [r3, #16]
    2458:	9307      	str	r3, [sp, #28]
    245a:	e050      	b.n	24fe <compute_tick+0x106>
            }
        } else if (0 != queue->frequency_shifts) {
    245c:	9b06      	ldr	r3, [sp, #24]
    245e:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
    2462:	2b00      	cmp	r3, #0
    2464:	d029      	beq.n	24ba <compute_tick+0xc2>
            // Optimized frequencies divisible by 2

            delta = (delta_us << ticker->queue->frequency_shifts) / 1000000;
    2466:	9b03      	ldr	r3, [sp, #12]
    2468:	685b      	ldr	r3, [r3, #4]
    246a:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
    246e:	4619      	mov	r1, r3
    2470:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    2474:	f1a1 0620 	sub.w	r6, r1, #32
    2478:	f1c1 0020 	rsb	r0, r1, #32
    247c:	fa03 f501 	lsl.w	r5, r3, r1
    2480:	fa02 f606 	lsl.w	r6, r2, r6
    2484:	4335      	orrs	r5, r6
    2486:	fa22 f000 	lsr.w	r0, r2, r0
    248a:	4305      	orrs	r5, r0
    248c:	fa02 f401 	lsl.w	r4, r2, r1
    2490:	4a20      	ldr	r2, [pc, #128]	; (2514 <compute_tick+0x11c>)
    2492:	f04f 0300 	mov.w	r3, #0
    2496:	4620      	mov	r0, r4
    2498:	4629      	mov	r1, r5
    249a:	f7fe ffef 	bl	147c <__aeabi_uldivmod>
    249e:	4603      	mov	r3, r0
    24a0:	460c      	mov	r4, r1
    24a2:	9307      	str	r3, [sp, #28]
            if (delta > ticker->queue->max_delta) {
    24a4:	9b03      	ldr	r3, [sp, #12]
    24a6:	685b      	ldr	r3, [r3, #4]
    24a8:	691a      	ldr	r2, [r3, #16]
    24aa:	9b07      	ldr	r3, [sp, #28]
    24ac:	429a      	cmp	r2, r3
    24ae:	d226      	bcs.n	24fe <compute_tick+0x106>
                delta = ticker->queue->max_delta;
    24b0:	9b03      	ldr	r3, [sp, #12]
    24b2:	685b      	ldr	r3, [r3, #4]
    24b4:	691b      	ldr	r3, [r3, #16]
    24b6:	9307      	str	r3, [sp, #28]
    24b8:	e021      	b.n	24fe <compute_tick+0x106>
            }
        } else {
            // General case

            delta = delta_us * queue->frequency / 1000000;
    24ba:	9b06      	ldr	r3, [sp, #24]
    24bc:	689b      	ldr	r3, [r3, #8]
    24be:	f04f 0400 	mov.w	r4, #0
    24c2:	9a04      	ldr	r2, [sp, #16]
    24c4:	fb04 f102 	mul.w	r1, r4, r2
    24c8:	9a05      	ldr	r2, [sp, #20]
    24ca:	fb03 f202 	mul.w	r2, r3, r2
    24ce:	440a      	add	r2, r1
    24d0:	9904      	ldr	r1, [sp, #16]
    24d2:	fba1 0103 	umull	r0, r1, r1, r3
    24d6:	1853      	adds	r3, r2, r1
    24d8:	4619      	mov	r1, r3
    24da:	4a0e      	ldr	r2, [pc, #56]	; (2514 <compute_tick+0x11c>)
    24dc:	f04f 0300 	mov.w	r3, #0
    24e0:	f7fe ffcc 	bl	147c <__aeabi_uldivmod>
    24e4:	4603      	mov	r3, r0
    24e6:	460c      	mov	r4, r1
    24e8:	9307      	str	r3, [sp, #28]
            if (delta > ticker->queue->max_delta) {
    24ea:	9b03      	ldr	r3, [sp, #12]
    24ec:	685b      	ldr	r3, [r3, #4]
    24ee:	691a      	ldr	r2, [r3, #16]
    24f0:	9b07      	ldr	r3, [sp, #28]
    24f2:	429a      	cmp	r2, r3
    24f4:	d203      	bcs.n	24fe <compute_tick+0x106>
                delta = ticker->queue->max_delta;
    24f6:	9b03      	ldr	r3, [sp, #12]
    24f8:	685b      	ldr	r3, [r3, #4]
    24fa:	691b      	ldr	r3, [r3, #16]
    24fc:	9307      	str	r3, [sp, #28]
            }
        }
    }
    return (queue->tick_last_read + delta) & queue->bitmask;
    24fe:	9b06      	ldr	r3, [sp, #24]
    2500:	6a1a      	ldr	r2, [r3, #32]
    2502:	9b07      	ldr	r3, [sp, #28]
    2504:	441a      	add	r2, r3
    2506:	9b06      	ldr	r3, [sp, #24]
    2508:	68db      	ldr	r3, [r3, #12]
    250a:	4013      	ands	r3, r2
}
    250c:	4618      	mov	r0, r3
    250e:	b008      	add	sp, #32
    2510:	bd70      	pop	{r4, r5, r6, pc}
    2512:	bf00      	nop
    2514:	000f4240 	.word	0x000f4240

00002518 <_ticker_match_interval_passed>:

/**
 * Return 1 if the tick has incremented to or past match_tick, otherwise 0.
 */
int _ticker_match_interval_passed(timestamp_t prev_tick, timestamp_t cur_tick, timestamp_t match_tick)
{
    2518:	b084      	sub	sp, #16
    251a:	9003      	str	r0, [sp, #12]
    251c:	9102      	str	r1, [sp, #8]
    251e:	9201      	str	r2, [sp, #4]
    if (match_tick > prev_tick) {
    2520:	9a01      	ldr	r2, [sp, #4]
    2522:	9b03      	ldr	r3, [sp, #12]
    2524:	429a      	cmp	r2, r3
    2526:	d90b      	bls.n	2540 <_ticker_match_interval_passed+0x28>
        return (cur_tick >= match_tick) || (cur_tick < prev_tick);
    2528:	9a02      	ldr	r2, [sp, #8]
    252a:	9b01      	ldr	r3, [sp, #4]
    252c:	429a      	cmp	r2, r3
    252e:	d203      	bcs.n	2538 <_ticker_match_interval_passed+0x20>
    2530:	9a02      	ldr	r2, [sp, #8]
    2532:	9b03      	ldr	r3, [sp, #12]
    2534:	429a      	cmp	r2, r3
    2536:	d201      	bcs.n	253c <_ticker_match_interval_passed+0x24>
    2538:	2301      	movs	r3, #1
    253a:	e00c      	b.n	2556 <_ticker_match_interval_passed+0x3e>
    253c:	2300      	movs	r3, #0
    253e:	e00a      	b.n	2556 <_ticker_match_interval_passed+0x3e>
    } else {
        return (cur_tick < prev_tick) && (cur_tick >= match_tick);
    2540:	9a02      	ldr	r2, [sp, #8]
    2542:	9b03      	ldr	r3, [sp, #12]
    2544:	429a      	cmp	r2, r3
    2546:	d205      	bcs.n	2554 <_ticker_match_interval_passed+0x3c>
    2548:	9a02      	ldr	r2, [sp, #8]
    254a:	9b01      	ldr	r3, [sp, #4]
    254c:	429a      	cmp	r2, r3
    254e:	d301      	bcc.n	2554 <_ticker_match_interval_passed+0x3c>
    2550:	2301      	movs	r3, #1
    2552:	e000      	b.n	2556 <_ticker_match_interval_passed+0x3e>
    2554:	2300      	movs	r3, #0
    }
}
    2556:	4618      	mov	r0, r3
    2558:	b004      	add	sp, #16
    255a:	4770      	bx	lr

0000255c <schedule_interrupt>:
 * @note If there is no event in the queue then the interrupt is scheduled to
 * in ticker.queue.max_delta. This is necessary to keep track
 * of the timer overflow.
 */
static void schedule_interrupt(const ticker_data_t *const ticker)
{
    255c:	b510      	push	{r4, lr}
    255e:	b08c      	sub	sp, #48	; 0x30
    2560:	9001      	str	r0, [sp, #4]
    ticker_event_queue_t *queue = ticker->queue;
    2562:	9b01      	ldr	r3, [sp, #4]
    2564:	685b      	ldr	r3, [r3, #4]
    2566:	930b      	str	r3, [sp, #44]	; 0x2c
    update_present_time(ticker);
    2568:	9801      	ldr	r0, [sp, #4]
    256a:	f7ff fdfd 	bl	2168 <update_present_time>

    if (ticker->queue->head) {
    256e:	9b01      	ldr	r3, [sp, #4]
    2570:	685b      	ldr	r3, [r3, #4]
    2572:	685b      	ldr	r3, [r3, #4]
    2574:	2b00      	cmp	r3, #0
    2576:	d042      	beq.n	25fe <schedule_interrupt+0xa2>
        us_timestamp_t present = ticker->queue->present_time;
    2578:	9b01      	ldr	r3, [sp, #4]
    257a:	685b      	ldr	r3, [r3, #4]
    257c:	e9d3 340c 	ldrd	r3, r4, [r3, #48]	; 0x30
    2580:	e9cd 3408 	strd	r3, r4, [sp, #32]
        us_timestamp_t match_time = ticker->queue->head->timestamp;
    2584:	9b01      	ldr	r3, [sp, #4]
    2586:	685b      	ldr	r3, [r3, #4]
    2588:	685b      	ldr	r3, [r3, #4]
    258a:	e9d3 3400 	ldrd	r3, r4, [r3]
    258e:	e9cd 3406 	strd	r3, r4, [sp, #24]

        // if the event at the head of the queue is in the past then schedule
        // it immediately.
        if (match_time <= present) {
    2592:	e9dd 3406 	ldrd	r3, r4, [sp, #24]
    2596:	e9dd 1208 	ldrd	r1, r2, [sp, #32]
    259a:	42a2      	cmp	r2, r4
    259c:	bf08      	it	eq
    259e:	4299      	cmpeq	r1, r3
    25a0:	d304      	bcc.n	25ac <schedule_interrupt+0x50>
            ticker->interface->fire_interrupt();
    25a2:	9b01      	ldr	r3, [sp, #4]
    25a4:	681b      	ldr	r3, [r3, #0]
    25a6:	695b      	ldr	r3, [r3, #20]
    25a8:	4798      	blx	r3
            return;
    25aa:	e036      	b.n	261a <schedule_interrupt+0xbe>
        }

        timestamp_t match_tick = compute_tick(ticker, match_time);
    25ac:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    25b0:	9801      	ldr	r0, [sp, #4]
    25b2:	f7ff ff21 	bl	23f8 <compute_tick>
    25b6:	9005      	str	r0, [sp, #20]
        // The time has been checked to be future, but it could still round
        // to the last tick as a result of us to ticks conversion
        if (match_tick == queue->tick_last_read) {
    25b8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    25ba:	6a1a      	ldr	r2, [r3, #32]
    25bc:	9b05      	ldr	r3, [sp, #20]
    25be:	429a      	cmp	r2, r3
    25c0:	d104      	bne.n	25cc <schedule_interrupt+0x70>
            // Match time has already expired so fire immediately
            ticker->interface->fire_interrupt();
    25c2:	9b01      	ldr	r3, [sp, #4]
    25c4:	681b      	ldr	r3, [r3, #0]
    25c6:	695b      	ldr	r3, [r3, #20]
    25c8:	4798      	blx	r3
            return;
    25ca:	e026      	b.n	261a <schedule_interrupt+0xbe>
        }

        ticker->interface->set_interrupt(match_tick);
    25cc:	9b01      	ldr	r3, [sp, #4]
    25ce:	681b      	ldr	r3, [r3, #0]
    25d0:	691b      	ldr	r3, [r3, #16]
    25d2:	9805      	ldr	r0, [sp, #20]
    25d4:	4798      	blx	r3
        timestamp_t cur_tick = ticker->interface->read();
    25d6:	9b01      	ldr	r3, [sp, #4]
    25d8:	681b      	ldr	r3, [r3, #0]
    25da:	685b      	ldr	r3, [r3, #4]
    25dc:	4798      	blx	r3
    25de:	9004      	str	r0, [sp, #16]

        if (_ticker_match_interval_passed(queue->tick_last_read, cur_tick, match_tick)) {
    25e0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    25e2:	6a1b      	ldr	r3, [r3, #32]
    25e4:	9a05      	ldr	r2, [sp, #20]
    25e6:	9904      	ldr	r1, [sp, #16]
    25e8:	4618      	mov	r0, r3
    25ea:	f7ff ff95 	bl	2518 <_ticker_match_interval_passed>
    25ee:	4603      	mov	r3, r0
    25f0:	2b00      	cmp	r3, #0
    25f2:	d012      	beq.n	261a <schedule_interrupt+0xbe>
            ticker->interface->fire_interrupt();
    25f4:	9b01      	ldr	r3, [sp, #4]
    25f6:	681b      	ldr	r3, [r3, #0]
    25f8:	695b      	ldr	r3, [r3, #20]
    25fa:	4798      	blx	r3
    25fc:	e00d      	b.n	261a <schedule_interrupt+0xbe>
        }
    } else {
        uint32_t match_tick =
            (queue->tick_last_read + queue->max_delta) & queue->bitmask;
    25fe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2600:	6a1a      	ldr	r2, [r3, #32]
    2602:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    2604:	691b      	ldr	r3, [r3, #16]
    2606:	441a      	add	r2, r3
    2608:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    260a:	68db      	ldr	r3, [r3, #12]
        uint32_t match_tick =
    260c:	4013      	ands	r3, r2
    260e:	9303      	str	r3, [sp, #12]
        ticker->interface->set_interrupt(match_tick);
    2610:	9b01      	ldr	r3, [sp, #4]
    2612:	681b      	ldr	r3, [r3, #0]
    2614:	691b      	ldr	r3, [r3, #16]
    2616:	9803      	ldr	r0, [sp, #12]
    2618:	4798      	blx	r3
    }
}
    261a:	b00c      	add	sp, #48	; 0x30
    261c:	bd10      	pop	{r4, pc}

0000261e <ticker_irq_handler>:
    set_handler(ticker, handler);
    core_util_critical_section_exit();
}

void ticker_irq_handler(const ticker_data_t *const ticker)
{
    261e:	b510      	push	{r4, lr}
    2620:	b084      	sub	sp, #16
    2622:	9001      	str	r0, [sp, #4]
    core_util_critical_section_enter();
    2624:	f000 fab6 	bl	2b94 <core_util_critical_section_enter>

    ticker->interface->clear_interrupt();
    2628:	9b01      	ldr	r3, [sp, #4]
    262a:	681b      	ldr	r3, [r3, #0]
    262c:	68db      	ldr	r3, [r3, #12]
    262e:	4798      	blx	r3

    /* Go through all the pending TimerEvents */
    while (1) {
        if (ticker->queue->head == NULL) {
    2630:	9b01      	ldr	r3, [sp, #4]
    2632:	685b      	ldr	r3, [r3, #4]
    2634:	685b      	ldr	r3, [r3, #4]
    2636:	2b00      	cmp	r3, #0
    2638:	d027      	beq.n	268a <ticker_irq_handler+0x6c>
            break;
        }

        // update the current timestamp used by the queue
        update_present_time(ticker);
    263a:	9801      	ldr	r0, [sp, #4]
    263c:	f7ff fd94 	bl	2168 <update_present_time>

        if (ticker->queue->head->timestamp <= ticker->queue->present_time) {
    2640:	9b01      	ldr	r3, [sp, #4]
    2642:	685b      	ldr	r3, [r3, #4]
    2644:	685b      	ldr	r3, [r3, #4]
    2646:	e9d3 3400 	ldrd	r3, r4, [r3]
    264a:	9a01      	ldr	r2, [sp, #4]
    264c:	6852      	ldr	r2, [r2, #4]
    264e:	e9d2 120c 	ldrd	r1, r2, [r2, #48]	; 0x30
    2652:	42a2      	cmp	r2, r4
    2654:	bf08      	it	eq
    2656:	4299      	cmpeq	r1, r3
    2658:	d319      	bcc.n	268e <ticker_irq_handler+0x70>
            // This event was in the past:
            //      point to the following one and execute its handler
            ticker_event_t *p = ticker->queue->head;
    265a:	9b01      	ldr	r3, [sp, #4]
    265c:	685b      	ldr	r3, [r3, #4]
    265e:	685b      	ldr	r3, [r3, #4]
    2660:	9303      	str	r3, [sp, #12]
            ticker->queue->head = ticker->queue->head->next;
    2662:	9b01      	ldr	r3, [sp, #4]
    2664:	685b      	ldr	r3, [r3, #4]
    2666:	9a01      	ldr	r2, [sp, #4]
    2668:	6852      	ldr	r2, [r2, #4]
    266a:	6852      	ldr	r2, [r2, #4]
    266c:	68d2      	ldr	r2, [r2, #12]
    266e:	605a      	str	r2, [r3, #4]
            if (ticker->queue->event_handler != NULL) {
    2670:	9b01      	ldr	r3, [sp, #4]
    2672:	685b      	ldr	r3, [r3, #4]
    2674:	681b      	ldr	r3, [r3, #0]
    2676:	2b00      	cmp	r3, #0
    2678:	d0da      	beq.n	2630 <ticker_irq_handler+0x12>
                (*ticker->queue->event_handler)(p->id); // NOTE: the handler can set new events
    267a:	9b01      	ldr	r3, [sp, #4]
    267c:	685b      	ldr	r3, [r3, #4]
    267e:	681b      	ldr	r3, [r3, #0]
    2680:	9a03      	ldr	r2, [sp, #12]
    2682:	6892      	ldr	r2, [r2, #8]
    2684:	4610      	mov	r0, r2
    2686:	4798      	blx	r3
        if (ticker->queue->head == NULL) {
    2688:	e7d2      	b.n	2630 <ticker_irq_handler+0x12>
            break;
    268a:	bf00      	nop
    268c:	e000      	b.n	2690 <ticker_irq_handler+0x72>
            }
            /* Note: We continue back to examining the head because calling the
             * event handler may have altered the chain of pending events. */
        } else {
            break;
    268e:	bf00      	nop
        }
    }

    schedule_interrupt(ticker);
    2690:	9801      	ldr	r0, [sp, #4]
    2692:	f7ff ff63 	bl	255c <schedule_interrupt>

    core_util_critical_section_exit();
    2696:	f000 fa97 	bl	2bc8 <core_util_critical_section_exit>
}
    269a:	bf00      	nop
    269c:	b004      	add	sp, #16
    269e:	bd10      	pop	{r4, pc}

000026a0 <ticker_read>:

    core_util_critical_section_exit();
}

timestamp_t ticker_read(const ticker_data_t *const ticker)
{
    26a0:	b510      	push	{r4, lr}
    26a2:	b082      	sub	sp, #8
    26a4:	9001      	str	r0, [sp, #4]
    return ticker_read_us(ticker);
    26a6:	9801      	ldr	r0, [sp, #4]
    26a8:	f000 f805 	bl	26b6 <ticker_read_us>
    26ac:	4603      	mov	r3, r0
    26ae:	460c      	mov	r4, r1
}
    26b0:	4618      	mov	r0, r3
    26b2:	b002      	add	sp, #8
    26b4:	bd10      	pop	{r4, pc}

000026b6 <ticker_read_us>:

us_timestamp_t ticker_read_us(const ticker_data_t *const ticker)
{
    26b6:	b510      	push	{r4, lr}
    26b8:	b082      	sub	sp, #8
    26ba:	9001      	str	r0, [sp, #4]
    initialize(ticker);
    26bc:	9801      	ldr	r0, [sp, #4]
    26be:	f7ff fc59 	bl	1f74 <initialize>

    core_util_critical_section_enter();
    26c2:	f000 fa67 	bl	2b94 <core_util_critical_section_enter>
    update_present_time(ticker);
    26c6:	9801      	ldr	r0, [sp, #4]
    26c8:	f7ff fd4e 	bl	2168 <update_present_time>
    core_util_critical_section_exit();
    26cc:	f000 fa7c 	bl	2bc8 <core_util_critical_section_exit>

    return ticker->queue->present_time;
    26d0:	9b01      	ldr	r3, [sp, #4]
    26d2:	685b      	ldr	r3, [r3, #4]
    26d4:	e9d3 340c 	ldrd	r3, r4, [r3, #48]	; 0x30
}
    26d8:	4618      	mov	r0, r3
    26da:	4621      	mov	r1, r4
    26dc:	b002      	add	sp, #8
    26de:	bd10      	pop	{r4, pc}

000026e0 <get_us_ticker_data>:
    .queue = &events
};

const ticker_data_t *get_us_ticker_data(void)
{
    return &us_data;
    26e0:	4b01      	ldr	r3, [pc, #4]	; (26e8 <get_us_ticker_data+0x8>)
}
    26e2:	4618      	mov	r0, r3
    26e4:	4770      	bx	lr
    26e6:	bf00      	nop
    26e8:	000124e4 	.word	0x000124e4

000026ec <us_ticker_irq_handler>:

    return prev_irq_handler;
}

void us_ticker_irq_handler(void)
{
    26ec:	b508      	push	{r3, lr}
    if (irq_handler) {
    26ee:	4b05      	ldr	r3, [pc, #20]	; (2704 <us_ticker_irq_handler+0x18>)
    26f0:	681b      	ldr	r3, [r3, #0]
    26f2:	2b00      	cmp	r3, #0
    26f4:	d003      	beq.n	26fe <us_ticker_irq_handler+0x12>
        irq_handler(&us_data);
    26f6:	4b03      	ldr	r3, [pc, #12]	; (2704 <us_ticker_irq_handler+0x18>)
    26f8:	681b      	ldr	r3, [r3, #0]
    26fa:	4803      	ldr	r0, [pc, #12]	; (2708 <us_ticker_irq_handler+0x1c>)
    26fc:	4798      	blx	r3
    }
}
    26fe:	bf00      	nop
    2700:	bd08      	pop	{r3, pc}
    2702:	bf00      	nop
    2704:	20000004 	.word	0x20000004
    2708:	000124e4 	.word	0x000124e4

0000270c <_ZN4mbed10FileHandle4syncEv>:
    virtual int sync()
    270c:	b082      	sub	sp, #8
    270e:	9001      	str	r0, [sp, #4]
        return 0;
    2710:	2300      	movs	r3, #0
    }
    2712:	4618      	mov	r0, r3
    2714:	b002      	add	sp, #8
    2716:	4770      	bx	lr

00002718 <_ZN4mbed10FileHandle6isattyEv>:
    virtual int isatty()
    2718:	b082      	sub	sp, #8
    271a:	9001      	str	r0, [sp, #4]
        return false;
    271c:	2300      	movs	r3, #0
    }
    271e:	4618      	mov	r0, r3
    2720:	b002      	add	sp, #8
    2722:	4770      	bx	lr

00002724 <_ZN4mbed10FileHandle4sizeEv>:
#include "platform/mbed_critical.h"

namespace mbed {

off_t FileHandle::size()
{
    2724:	b500      	push	{lr}
    2726:	b085      	sub	sp, #20
    2728:	9001      	str	r0, [sp, #4]
    /* remember our current position */
    off_t off = seek(0, SEEK_CUR);
    272a:	9b01      	ldr	r3, [sp, #4]
    272c:	681b      	ldr	r3, [r3, #0]
    272e:	3310      	adds	r3, #16
    2730:	681b      	ldr	r3, [r3, #0]
    2732:	2201      	movs	r2, #1
    2734:	2100      	movs	r1, #0
    2736:	9801      	ldr	r0, [sp, #4]
    2738:	4798      	blx	r3
    273a:	9003      	str	r0, [sp, #12]
    if (off < 0) {
    273c:	9b03      	ldr	r3, [sp, #12]
    273e:	2b00      	cmp	r3, #0
    2740:	da01      	bge.n	2746 <_ZN4mbed10FileHandle4sizeEv+0x22>
        return off;
    2742:	9b03      	ldr	r3, [sp, #12]
    2744:	e011      	b.n	276a <_ZN4mbed10FileHandle4sizeEv+0x46>
    }
    /* seek to the end to get the file length */
    off_t size = seek(0, SEEK_END);
    2746:	9b01      	ldr	r3, [sp, #4]
    2748:	681b      	ldr	r3, [r3, #0]
    274a:	3310      	adds	r3, #16
    274c:	681b      	ldr	r3, [r3, #0]
    274e:	2202      	movs	r2, #2
    2750:	2100      	movs	r1, #0
    2752:	9801      	ldr	r0, [sp, #4]
    2754:	4798      	blx	r3
    2756:	9002      	str	r0, [sp, #8]
    /* return to our old position */
    seek(off, SEEK_SET);
    2758:	9b01      	ldr	r3, [sp, #4]
    275a:	681b      	ldr	r3, [r3, #0]
    275c:	3310      	adds	r3, #16
    275e:	681b      	ldr	r3, [r3, #0]
    2760:	2200      	movs	r2, #0
    2762:	9903      	ldr	r1, [sp, #12]
    2764:	9801      	ldr	r0, [sp, #4]
    2766:	4798      	blx	r3
    return size;
    2768:	9b02      	ldr	r3, [sp, #8]
}
    276a:	4618      	mov	r0, r3
    276c:	b005      	add	sp, #20
    276e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00002774 <mbed_stats_heap_get>:
static SingletonPtr<PlatformMutex> malloc_stats_mutex;
static mbed_stats_heap_t heap_stats = {0, 0, 0, 0, 0};
#endif

void mbed_stats_heap_get(mbed_stats_heap_t *stats)
{
    2774:	b500      	push	{lr}
    2776:	b083      	sub	sp, #12
    2778:	9001      	str	r0, [sp, #4]
#ifdef MBED_HEAP_STATS_ENABLED
    extern uint32_t mbed_heap_size;
    heap_stats.reserved_size = mbed_heap_size;
    277a:	4b0e      	ldr	r3, [pc, #56]	; (27b4 <mbed_stats_heap_get+0x40>)
    277c:	681b      	ldr	r3, [r3, #0]
    277e:	4a0e      	ldr	r2, [pc, #56]	; (27b8 <mbed_stats_heap_get+0x44>)
    2780:	60d3      	str	r3, [r2, #12]

    malloc_stats_mutex->lock();
    2782:	480e      	ldr	r0, [pc, #56]	; (27bc <mbed_stats_heap_get+0x48>)
    2784:	f7ff f8cc 	bl	1920 <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    2788:	4603      	mov	r3, r0
    278a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    278e:	4618      	mov	r0, r3
    2790:	f001 fb6c 	bl	3e6c <_ZN4rtos5Mutex4lockEm>
    memcpy(stats, &heap_stats, sizeof(mbed_stats_heap_t));
    2794:	2218      	movs	r2, #24
    2796:	4908      	ldr	r1, [pc, #32]	; (27b8 <mbed_stats_heap_get+0x44>)
    2798:	9801      	ldr	r0, [sp, #4]
    279a:	f7fe f8c1 	bl	920 <memcpy>
    malloc_stats_mutex->unlock();
    279e:	4807      	ldr	r0, [pc, #28]	; (27bc <mbed_stats_heap_get+0x48>)
    27a0:	f7ff f8be 	bl	1920 <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    27a4:	4603      	mov	r3, r0
    27a6:	4618      	mov	r0, r3
    27a8:	f001 fb78 	bl	3e9c <_ZN4rtos5Mutex6unlockEv>
#else
    memset(stats, 0, sizeof(mbed_stats_heap_t));
#endif
}
    27ac:	bf00      	nop
    27ae:	b003      	add	sp, #12
    27b0:	f85d fb04 	ldr.w	pc, [sp], #4
    27b4:	20000d9c 	.word	0x20000d9c
    27b8:	20000cd8 	.word	0x20000cd8
    27bc:	20000cb0 	.word	0x20000cb0

000027c0 <__wrap__malloc_r>:

// TODO: memory tracing doesn't work with uVisor enabled.
#if !defined(FEATURE_UVISOR)

extern "C" void *__wrap__malloc_r(struct _reent *r, size_t size)
{
    27c0:	b500      	push	{lr}
    27c2:	b083      	sub	sp, #12
    27c4:	4673      	mov	r3, lr
    27c6:	9001      	str	r0, [sp, #4]
    27c8:	9100      	str	r1, [sp, #0]
    return malloc_wrapper(r, size, MBED_CALLER_ADDR());
    27ca:	461a      	mov	r2, r3
    27cc:	9900      	ldr	r1, [sp, #0]
    27ce:	9801      	ldr	r0, [sp, #4]
    27d0:	f000 f806 	bl	27e0 <malloc_wrapper>
    27d4:	4603      	mov	r3, r0
}
    27d6:	4618      	mov	r0, r3
    27d8:	b003      	add	sp, #12
    27da:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000027e0 <malloc_wrapper>:

extern "C" void *malloc_wrapper(struct _reent *r, size_t size, void *caller)
{
    27e0:	b500      	push	{lr}
    27e2:	b087      	sub	sp, #28
    27e4:	9003      	str	r0, [sp, #12]
    27e6:	9102      	str	r1, [sp, #8]
    27e8:	9201      	str	r2, [sp, #4]
    void *ptr = NULL;
    27ea:	2300      	movs	r3, #0
    27ec:	9305      	str	r3, [sp, #20]
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_lock();
    27ee:	f000 fbc1 	bl	2f74 <mbed_mem_trace_lock>
#endif
#ifdef MBED_HEAP_STATS_ENABLED
    malloc_stats_mutex->lock();
    27f2:	4826      	ldr	r0, [pc, #152]	; (288c <malloc_wrapper+0xac>)
    27f4:	f7ff f894 	bl	1920 <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    27f8:	4603      	mov	r3, r0
    27fa:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    27fe:	4618      	mov	r0, r3
    2800:	f001 fb34 	bl	3e6c <_ZN4rtos5Mutex4lockEm>
    alloc_info_t *alloc_info = (alloc_info_t *)__real__malloc_r(r, size + sizeof(alloc_info_t));
    2804:	9b02      	ldr	r3, [sp, #8]
    2806:	3308      	adds	r3, #8
    2808:	4619      	mov	r1, r3
    280a:	9803      	ldr	r0, [sp, #12]
    280c:	f008 fb10 	bl	ae30 <_malloc_r>
    2810:	9004      	str	r0, [sp, #16]
    if (alloc_info != NULL) {
    2812:	9b04      	ldr	r3, [sp, #16]
    2814:	2b00      	cmp	r3, #0
    2816:	d021      	beq.n	285c <malloc_wrapper+0x7c>
        alloc_info->size = size;
    2818:	9b04      	ldr	r3, [sp, #16]
    281a:	9a02      	ldr	r2, [sp, #8]
    281c:	601a      	str	r2, [r3, #0]
        ptr = (void *)(alloc_info + 1);
    281e:	9b04      	ldr	r3, [sp, #16]
    2820:	3308      	adds	r3, #8
    2822:	9305      	str	r3, [sp, #20]
        heap_stats.current_size += size;
    2824:	4b1a      	ldr	r3, [pc, #104]	; (2890 <malloc_wrapper+0xb0>)
    2826:	681a      	ldr	r2, [r3, #0]
    2828:	9b02      	ldr	r3, [sp, #8]
    282a:	4413      	add	r3, r2
    282c:	4a18      	ldr	r2, [pc, #96]	; (2890 <malloc_wrapper+0xb0>)
    282e:	6013      	str	r3, [r2, #0]
        heap_stats.total_size += size;
    2830:	4b17      	ldr	r3, [pc, #92]	; (2890 <malloc_wrapper+0xb0>)
    2832:	689a      	ldr	r2, [r3, #8]
    2834:	9b02      	ldr	r3, [sp, #8]
    2836:	4413      	add	r3, r2
    2838:	4a15      	ldr	r2, [pc, #84]	; (2890 <malloc_wrapper+0xb0>)
    283a:	6093      	str	r3, [r2, #8]
        heap_stats.alloc_cnt += 1;
    283c:	4b14      	ldr	r3, [pc, #80]	; (2890 <malloc_wrapper+0xb0>)
    283e:	691b      	ldr	r3, [r3, #16]
    2840:	3301      	adds	r3, #1
    2842:	4a13      	ldr	r2, [pc, #76]	; (2890 <malloc_wrapper+0xb0>)
    2844:	6113      	str	r3, [r2, #16]
        if (heap_stats.current_size > heap_stats.max_size) {
    2846:	4b12      	ldr	r3, [pc, #72]	; (2890 <malloc_wrapper+0xb0>)
    2848:	681a      	ldr	r2, [r3, #0]
    284a:	4b11      	ldr	r3, [pc, #68]	; (2890 <malloc_wrapper+0xb0>)
    284c:	685b      	ldr	r3, [r3, #4]
    284e:	429a      	cmp	r2, r3
    2850:	d909      	bls.n	2866 <malloc_wrapper+0x86>
            heap_stats.max_size = heap_stats.current_size;
    2852:	4b0f      	ldr	r3, [pc, #60]	; (2890 <malloc_wrapper+0xb0>)
    2854:	681b      	ldr	r3, [r3, #0]
    2856:	4a0e      	ldr	r2, [pc, #56]	; (2890 <malloc_wrapper+0xb0>)
    2858:	6053      	str	r3, [r2, #4]
    285a:	e004      	b.n	2866 <malloc_wrapper+0x86>
        }
    } else {
        heap_stats.alloc_fail_cnt += 1;
    285c:	4b0c      	ldr	r3, [pc, #48]	; (2890 <malloc_wrapper+0xb0>)
    285e:	695b      	ldr	r3, [r3, #20]
    2860:	3301      	adds	r3, #1
    2862:	4a0b      	ldr	r2, [pc, #44]	; (2890 <malloc_wrapper+0xb0>)
    2864:	6153      	str	r3, [r2, #20]
    }
    malloc_stats_mutex->unlock();
    2866:	4809      	ldr	r0, [pc, #36]	; (288c <malloc_wrapper+0xac>)
    2868:	f7ff f85a 	bl	1920 <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    286c:	4603      	mov	r3, r0
    286e:	4618      	mov	r0, r3
    2870:	f001 fb14 	bl	3e9c <_ZN4rtos5Mutex6unlockEv>
#else // #ifdef MBED_HEAP_STATS_ENABLED
    ptr = __real__malloc_r(r, size);
#endif // #ifdef MBED_HEAP_STATS_ENABLED
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_malloc(ptr, size, caller);
    2874:	9a01      	ldr	r2, [sp, #4]
    2876:	9902      	ldr	r1, [sp, #8]
    2878:	9805      	ldr	r0, [sp, #20]
    287a:	f000 fba5 	bl	2fc8 <mbed_mem_trace_malloc>
    mbed_mem_trace_unlock();
    287e:	f000 fb8f 	bl	2fa0 <mbed_mem_trace_unlock>
#endif // #ifdef MBED_MEM_TRACING_ENABLED
    return ptr;
    2882:	9b05      	ldr	r3, [sp, #20]
}
    2884:	4618      	mov	r0, r3
    2886:	b007      	add	sp, #28
    2888:	f85d fb04 	ldr.w	pc, [sp], #4
    288c:	20000cb0 	.word	0x20000cb0
    2890:	20000cd8 	.word	0x20000cd8

00002894 <__wrap__realloc_r>:

extern "C" void *__wrap__realloc_r(struct _reent *r, void *ptr, size_t size)
{
    2894:	b510      	push	{r4, lr}
    2896:	b088      	sub	sp, #32
    2898:	4674      	mov	r4, lr
    289a:	9003      	str	r0, [sp, #12]
    289c:	9102      	str	r1, [sp, #8]
    289e:	9201      	str	r2, [sp, #4]
    void *new_ptr = NULL;
    28a0:	2300      	movs	r3, #0
    28a2:	9307      	str	r3, [sp, #28]
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_lock();
    28a4:	f000 fb66 	bl	2f74 <mbed_mem_trace_lock>
    // resize memory directly (returns ptr + 0).

    // Note - no lock needed since malloc and free are thread safe

    // Get old size
    uint32_t old_size = 0;
    28a8:	2300      	movs	r3, #0
    28aa:	9306      	str	r3, [sp, #24]
    if (ptr != NULL) {
    28ac:	9b02      	ldr	r3, [sp, #8]
    28ae:	2b00      	cmp	r3, #0
    28b0:	d005      	beq.n	28be <__wrap__realloc_r+0x2a>
        alloc_info_t *alloc_info = ((alloc_info_t *)ptr) - 1;
    28b2:	9b02      	ldr	r3, [sp, #8]
    28b4:	3b08      	subs	r3, #8
    28b6:	9305      	str	r3, [sp, #20]
        old_size = alloc_info->size;
    28b8:	9b05      	ldr	r3, [sp, #20]
    28ba:	681b      	ldr	r3, [r3, #0]
    28bc:	9306      	str	r3, [sp, #24]
    }

    // Allocate space
    if (size != 0) {
    28be:	9b01      	ldr	r3, [sp, #4]
    28c0:	2b00      	cmp	r3, #0
    28c2:	d003      	beq.n	28cc <__wrap__realloc_r+0x38>
        new_ptr = malloc(size);
    28c4:	9801      	ldr	r0, [sp, #4]
    28c6:	f008 faa3 	bl	ae10 <malloc>
    28ca:	9007      	str	r0, [sp, #28]
    }

    // If the new buffer has been allocated copy the data to it
    // and free the old buffer
    if (new_ptr != NULL) {
    28cc:	9b07      	ldr	r3, [sp, #28]
    28ce:	2b00      	cmp	r3, #0
    28d0:	d00f      	beq.n	28f2 <__wrap__realloc_r+0x5e>
        uint32_t copy_size = (old_size < size) ? old_size : size;
    28d2:	9a06      	ldr	r2, [sp, #24]
    28d4:	9b01      	ldr	r3, [sp, #4]
    28d6:	429a      	cmp	r2, r3
    28d8:	d201      	bcs.n	28de <__wrap__realloc_r+0x4a>
    28da:	9b06      	ldr	r3, [sp, #24]
    28dc:	e000      	b.n	28e0 <__wrap__realloc_r+0x4c>
    28de:	9b01      	ldr	r3, [sp, #4]
    28e0:	9304      	str	r3, [sp, #16]
        memcpy(new_ptr, (void *)ptr, copy_size);
    28e2:	9a04      	ldr	r2, [sp, #16]
    28e4:	9902      	ldr	r1, [sp, #8]
    28e6:	9807      	ldr	r0, [sp, #28]
    28e8:	f7fe f81a 	bl	920 <memcpy>
        free(ptr);
    28ec:	9802      	ldr	r0, [sp, #8]
    28ee:	f008 fa97 	bl	ae20 <free>
    }
#else // #ifdef MBED_HEAP_STATS_ENABLED
    new_ptr = __real__realloc_r(r, ptr, size);
#endif // #ifdef MBED_HEAP_STATS_ENABLED
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_realloc(new_ptr, ptr, size, MBED_CALLER_ADDR());
    28f2:	4623      	mov	r3, r4
    28f4:	9a01      	ldr	r2, [sp, #4]
    28f6:	9902      	ldr	r1, [sp, #8]
    28f8:	9807      	ldr	r0, [sp, #28]
    28fa:	f000 fb81 	bl	3000 <mbed_mem_trace_realloc>
    mbed_mem_trace_unlock();
    28fe:	f000 fb4f 	bl	2fa0 <mbed_mem_trace_unlock>
#endif // #ifdef MBED_MEM_TRACING_ENABLED
    return new_ptr;
    2902:	9b07      	ldr	r3, [sp, #28]
}
    2904:	4618      	mov	r0, r3
    2906:	b008      	add	sp, #32
    2908:	bd10      	pop	{r4, pc}

0000290a <__wrap__free_r>:

extern "C" void __wrap__free_r(struct _reent *r, void *ptr)
{
    290a:	b500      	push	{lr}
    290c:	b083      	sub	sp, #12
    290e:	4673      	mov	r3, lr
    2910:	9001      	str	r0, [sp, #4]
    2912:	9100      	str	r1, [sp, #0]
    free_wrapper(r, ptr, MBED_CALLER_ADDR());
    2914:	461a      	mov	r2, r3
    2916:	9900      	ldr	r1, [sp, #0]
    2918:	9801      	ldr	r0, [sp, #4]
    291a:	f000 f805 	bl	2928 <free_wrapper>
}
    291e:	bf00      	nop
    2920:	b003      	add	sp, #12
    2922:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00002928 <free_wrapper>:

extern "C" void free_wrapper(struct _reent *r, void *ptr, void *caller)
{
    2928:	b500      	push	{lr}
    292a:	b087      	sub	sp, #28
    292c:	9003      	str	r0, [sp, #12]
    292e:	9102      	str	r1, [sp, #8]
    2930:	9201      	str	r2, [sp, #4]
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_lock();
    2932:	f000 fb1f 	bl	2f74 <mbed_mem_trace_lock>
#endif
#ifdef MBED_HEAP_STATS_ENABLED
    malloc_stats_mutex->lock();
    2936:	4819      	ldr	r0, [pc, #100]	; (299c <free_wrapper+0x74>)
    2938:	f7fe fff2 	bl	1920 <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    293c:	4603      	mov	r3, r0
    293e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2942:	4618      	mov	r0, r3
    2944:	f001 fa92 	bl	3e6c <_ZN4rtos5Mutex4lockEm>
    alloc_info_t *alloc_info = NULL;
    2948:	2300      	movs	r3, #0
    294a:	9305      	str	r3, [sp, #20]
    if (ptr != NULL) {
    294c:	9b02      	ldr	r3, [sp, #8]
    294e:	2b00      	cmp	r3, #0
    2950:	d00e      	beq.n	2970 <free_wrapper+0x48>
        alloc_info = ((alloc_info_t *)ptr) - 1;
    2952:	9b02      	ldr	r3, [sp, #8]
    2954:	3b08      	subs	r3, #8
    2956:	9305      	str	r3, [sp, #20]
        heap_stats.current_size -= alloc_info->size;
    2958:	4b11      	ldr	r3, [pc, #68]	; (29a0 <free_wrapper+0x78>)
    295a:	681a      	ldr	r2, [r3, #0]
    295c:	9b05      	ldr	r3, [sp, #20]
    295e:	681b      	ldr	r3, [r3, #0]
    2960:	1ad3      	subs	r3, r2, r3
    2962:	4a0f      	ldr	r2, [pc, #60]	; (29a0 <free_wrapper+0x78>)
    2964:	6013      	str	r3, [r2, #0]
        heap_stats.alloc_cnt -= 1;
    2966:	4b0e      	ldr	r3, [pc, #56]	; (29a0 <free_wrapper+0x78>)
    2968:	691b      	ldr	r3, [r3, #16]
    296a:	3b01      	subs	r3, #1
    296c:	4a0c      	ldr	r2, [pc, #48]	; (29a0 <free_wrapper+0x78>)
    296e:	6113      	str	r3, [r2, #16]
    }
    __real__free_r(r, (void *)alloc_info);
    2970:	9905      	ldr	r1, [sp, #20]
    2972:	9803      	ldr	r0, [sp, #12]
    2974:	f007 fefa 	bl	a76c <_free_r>
    malloc_stats_mutex->unlock();
    2978:	4808      	ldr	r0, [pc, #32]	; (299c <free_wrapper+0x74>)
    297a:	f7fe ffd1 	bl	1920 <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    297e:	4603      	mov	r3, r0
    2980:	4618      	mov	r0, r3
    2982:	f001 fa8b 	bl	3e9c <_ZN4rtos5Mutex6unlockEv>
#else // #ifdef MBED_HEAP_STATS_ENABLED
    __real__free_r(r, ptr);
#endif // #ifdef MBED_HEAP_STATS_ENABLED
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_free(ptr, caller);
    2986:	9901      	ldr	r1, [sp, #4]
    2988:	9802      	ldr	r0, [sp, #8]
    298a:	f000 fb79 	bl	3080 <mbed_mem_trace_free>
    mbed_mem_trace_unlock();
    298e:	f000 fb07 	bl	2fa0 <mbed_mem_trace_unlock>
#endif // #ifdef MBED_MEM_TRACING_ENABLED
}
    2992:	bf00      	nop
    2994:	b007      	add	sp, #28
    2996:	f85d fb04 	ldr.w	pc, [sp], #4
    299a:	bf00      	nop
    299c:	20000cb0 	.word	0x20000cb0
    29a0:	20000cd8 	.word	0x20000cd8

000029a4 <__wrap__calloc_r>:

extern "C" void *__wrap__calloc_r(struct _reent *r, size_t nmemb, size_t size)
{
    29a4:	b510      	push	{r4, lr}
    29a6:	b086      	sub	sp, #24
    29a8:	4674      	mov	r4, lr
    29aa:	9003      	str	r0, [sp, #12]
    29ac:	9102      	str	r1, [sp, #8]
    29ae:	9201      	str	r2, [sp, #4]
    void *ptr = NULL;
    29b0:	2300      	movs	r3, #0
    29b2:	9305      	str	r3, [sp, #20]
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_lock();
    29b4:	f000 fade 	bl	2f74 <mbed_mem_trace_lock>
#endif
#ifdef MBED_HEAP_STATS_ENABLED
    // Note - no lock needed since malloc is thread safe

    ptr = malloc(nmemb * size);
    29b8:	9b02      	ldr	r3, [sp, #8]
    29ba:	9a01      	ldr	r2, [sp, #4]
    29bc:	fb02 f303 	mul.w	r3, r2, r3
    29c0:	4618      	mov	r0, r3
    29c2:	f008 fa25 	bl	ae10 <malloc>
    29c6:	9005      	str	r0, [sp, #20]
    if (ptr != NULL) {
    29c8:	9b05      	ldr	r3, [sp, #20]
    29ca:	2b00      	cmp	r3, #0
    29cc:	d008      	beq.n	29e0 <__wrap__calloc_r+0x3c>
        memset(ptr, 0, nmemb * size);
    29ce:	9b02      	ldr	r3, [sp, #8]
    29d0:	9a01      	ldr	r2, [sp, #4]
    29d2:	fb02 f303 	mul.w	r3, r2, r3
    29d6:	461a      	mov	r2, r3
    29d8:	2100      	movs	r1, #0
    29da:	9805      	ldr	r0, [sp, #20]
    29dc:	f008 fd52 	bl	b484 <memset>
    }
#else // #ifdef MBED_HEAP_STATS_ENABLED
    ptr = __real__calloc_r(r, nmemb, size);
#endif // #ifdef MBED_HEAP_STATS_ENABLED
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_calloc(ptr, nmemb, size, MBED_CALLER_ADDR());
    29e0:	4623      	mov	r3, r4
    29e2:	9a01      	ldr	r2, [sp, #4]
    29e4:	9902      	ldr	r1, [sp, #8]
    29e6:	9805      	ldr	r0, [sp, #20]
    29e8:	f000 fb2a 	bl	3040 <mbed_mem_trace_calloc>
    mbed_mem_trace_unlock();
    29ec:	f000 fad8 	bl	2fa0 <mbed_mem_trace_unlock>
#endif // #ifdef MBED_MEM_TRACING_ENABLED
    return ptr;
    29f0:	9b05      	ldr	r3, [sp, #20]
}
    29f2:	4618      	mov	r0, r3
    29f4:	b006      	add	sp, #24
    29f6:	bd10      	pop	{r4, pc}

000029f8 <mbed_assert_internal>:

#include "platform/mbed_interface.h"
#include "platform/mbed_critical.h"

void mbed_assert_internal(const char *expr, const char *file, int line)
{
    29f8:	b500      	push	{lr}
    29fa:	b085      	sub	sp, #20
    29fc:	9003      	str	r0, [sp, #12]
    29fe:	9102      	str	r1, [sp, #8]
    2a00:	9201      	str	r2, [sp, #4]
    core_util_critical_section_enter();
    2a02:	f000 f8c7 	bl	2b94 <core_util_critical_section_enter>
    mbed_error_printf("mbed assertation failed: %s, file: %s, line %d \n", expr, file, line);
    2a06:	9b01      	ldr	r3, [sp, #4]
    2a08:	9a02      	ldr	r2, [sp, #8]
    2a0a:	9903      	ldr	r1, [sp, #12]
    2a0c:	4804      	ldr	r0, [pc, #16]	; (2a20 <mbed_assert_internal+0x28>)
    2a0e:	f000 f848 	bl	2aa2 <mbed_error_printf>
    mbed_die();
    2a12:	f000 f807 	bl	2a24 <mbed_die>
}
    2a16:	bf00      	nop
    2a18:	b005      	add	sp, #20
    2a1a:	f85d fb04 	ldr.w	pc, [sp], #4
    2a1e:	bf00      	nop
    2a20:	00010b70 	.word	0x00010b70

00002a24 <mbed_die>:
extern int stdio_uart_inited;
extern serial_t stdio_uart;
#endif

WEAK void mbed_die(void)
{
    2a24:	b500      	push	{lr}
    2a26:	b085      	sub	sp, #20
#if !defined (NRF51_H) && !defined(TARGET_EFM32)
    core_util_critical_section_enter();
    2a28:	f000 f8b4 	bl	2b94 <core_util_critical_section_enter>
#endif
    gpio_t led_err;
    gpio_init_out(&led_err, LED1);
    2a2c:	ab01      	add	r3, sp, #4
    2a2e:	f241 0116 	movw	r1, #4118	; 0x1016
    2a32:	4618      	mov	r0, r3
    2a34:	f7ff f952 	bl	1cdc <gpio_init_out>

    while (1) {
        for (int i = 0; i < 4; ++i) {
    2a38:	2300      	movs	r3, #0
    2a3a:	9303      	str	r3, [sp, #12]
    2a3c:	e012      	b.n	2a64 <mbed_die+0x40>
            gpio_write(&led_err, 1);
    2a3e:	ab01      	add	r3, sp, #4
    2a40:	2101      	movs	r1, #1
    2a42:	4618      	mov	r0, r3
    2a44:	f007 fb64 	bl	a110 <gpio_write>
            wait_ms(150);
    2a48:	2096      	movs	r0, #150	; 0x96
    2a4a:	f001 f979 	bl	3d40 <wait_ms>
            gpio_write(&led_err, 0);
    2a4e:	ab01      	add	r3, sp, #4
    2a50:	2100      	movs	r1, #0
    2a52:	4618      	mov	r0, r3
    2a54:	f007 fb5c 	bl	a110 <gpio_write>
            wait_ms(150);
    2a58:	2096      	movs	r0, #150	; 0x96
    2a5a:	f001 f971 	bl	3d40 <wait_ms>
        for (int i = 0; i < 4; ++i) {
    2a5e:	9b03      	ldr	r3, [sp, #12]
    2a60:	3301      	adds	r3, #1
    2a62:	9303      	str	r3, [sp, #12]
    2a64:	9b03      	ldr	r3, [sp, #12]
    2a66:	2b03      	cmp	r3, #3
    2a68:	dde9      	ble.n	2a3e <mbed_die+0x1a>
        }

        for (int i = 0; i < 4; ++i) {
    2a6a:	2300      	movs	r3, #0
    2a6c:	9302      	str	r3, [sp, #8]
    2a6e:	e014      	b.n	2a9a <mbed_die+0x76>
            gpio_write(&led_err, 1);
    2a70:	ab01      	add	r3, sp, #4
    2a72:	2101      	movs	r1, #1
    2a74:	4618      	mov	r0, r3
    2a76:	f007 fb4b 	bl	a110 <gpio_write>
            wait_ms(400);
    2a7a:	f44f 70c8 	mov.w	r0, #400	; 0x190
    2a7e:	f001 f95f 	bl	3d40 <wait_ms>
            gpio_write(&led_err, 0);
    2a82:	ab01      	add	r3, sp, #4
    2a84:	2100      	movs	r1, #0
    2a86:	4618      	mov	r0, r3
    2a88:	f007 fb42 	bl	a110 <gpio_write>
            wait_ms(400);
    2a8c:	f44f 70c8 	mov.w	r0, #400	; 0x190
    2a90:	f001 f956 	bl	3d40 <wait_ms>
        for (int i = 0; i < 4; ++i) {
    2a94:	9b02      	ldr	r3, [sp, #8]
    2a96:	3301      	adds	r3, #1
    2a98:	9302      	str	r3, [sp, #8]
    2a9a:	9b02      	ldr	r3, [sp, #8]
    2a9c:	2b03      	cmp	r3, #3
    2a9e:	dde7      	ble.n	2a70 <mbed_die+0x4c>
        for (int i = 0; i < 4; ++i) {
    2aa0:	e7ca      	b.n	2a38 <mbed_die+0x14>

00002aa2 <mbed_error_printf>:
        }
    }
}

void mbed_error_printf(const char *format, ...)
{
    2aa2:	b40f      	push	{r0, r1, r2, r3}
    2aa4:	b500      	push	{lr}
    2aa6:	b083      	sub	sp, #12
    va_list arg;
    va_start(arg, format);
    2aa8:	ab05      	add	r3, sp, #20
    2aaa:	9301      	str	r3, [sp, #4]
    mbed_error_vfprintf(format, arg);
    2aac:	9901      	ldr	r1, [sp, #4]
    2aae:	9804      	ldr	r0, [sp, #16]
    2ab0:	f000 f806 	bl	2ac0 <mbed_error_vfprintf>
    va_end(arg);
}
    2ab4:	bf00      	nop
    2ab6:	b003      	add	sp, #12
    2ab8:	f85d eb04 	ldr.w	lr, [sp], #4
    2abc:	b004      	add	sp, #16
    2abe:	4770      	bx	lr

00002ac0 <mbed_error_vfprintf>:

void mbed_error_vfprintf(const char *format, va_list arg)
{
    2ac0:	b500      	push	{lr}
    2ac2:	b0a7      	sub	sp, #156	; 0x9c
    2ac4:	9001      	str	r0, [sp, #4]
    2ac6:	9100      	str	r1, [sp, #0]
#if DEVICE_SERIAL
#define ERROR_BUF_SIZE      (128)
    core_util_critical_section_enter();
    2ac8:	f000 f864 	bl	2b94 <core_util_critical_section_enter>
    char buffer[ERROR_BUF_SIZE];
    int size = vsnprintf(buffer, ERROR_BUF_SIZE, format, arg);
    2acc:	a803      	add	r0, sp, #12
    2ace:	9b00      	ldr	r3, [sp, #0]
    2ad0:	9a01      	ldr	r2, [sp, #4]
    2ad2:	2180      	movs	r1, #128	; 0x80
    2ad4:	f00c f9f6 	bl	eec4 <vsnprintf>
    2ad8:	9023      	str	r0, [sp, #140]	; 0x8c
    if (size > 0) {
    2ada:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    2adc:	2b00      	cmp	r3, #0
    2ade:	dd33      	ble.n	2b48 <mbed_error_vfprintf+0x88>
        if (!stdio_uart_inited) {
    2ae0:	4b1c      	ldr	r3, [pc, #112]	; (2b54 <mbed_error_vfprintf+0x94>)
    2ae2:	681b      	ldr	r3, [r3, #0]
    2ae4:	2b00      	cmp	r3, #0
    2ae6:	d106      	bne.n	2af6 <mbed_error_vfprintf+0x36>
            serial_init(&stdio_uart, STDIO_UART_TX, STDIO_UART_RX);
    2ae8:	f241 0210 	movw	r2, #4112	; 0x1010
    2aec:	f241 0111 	movw	r1, #4113	; 0x1011
    2af0:	4819      	ldr	r0, [pc, #100]	; (2b58 <mbed_error_vfprintf+0x98>)
    2af2:	f006 ff33 	bl	995c <serial_init>
        }
#if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES
        char stdio_out_prev = '\0';
    2af6:	2300      	movs	r3, #0
    2af8:	f88d 3097 	strb.w	r3, [sp, #151]	; 0x97
        for (int i = 0; i < size; i++) {
    2afc:	2300      	movs	r3, #0
    2afe:	9324      	str	r3, [sp, #144]	; 0x90
    2b00:	e01e      	b.n	2b40 <mbed_error_vfprintf+0x80>
            if (buffer[i] == '\n' && stdio_out_prev != '\r') {
    2b02:	aa03      	add	r2, sp, #12
    2b04:	9b24      	ldr	r3, [sp, #144]	; 0x90
    2b06:	4413      	add	r3, r2
    2b08:	781b      	ldrb	r3, [r3, #0]
    2b0a:	2b0a      	cmp	r3, #10
    2b0c:	d107      	bne.n	2b1e <mbed_error_vfprintf+0x5e>
    2b0e:	f89d 3097 	ldrb.w	r3, [sp, #151]	; 0x97
    2b12:	2b0d      	cmp	r3, #13
    2b14:	d003      	beq.n	2b1e <mbed_error_vfprintf+0x5e>
                serial_putc(&stdio_uart, '\r');
    2b16:	210d      	movs	r1, #13
    2b18:	480f      	ldr	r0, [pc, #60]	; (2b58 <mbed_error_vfprintf+0x98>)
    2b1a:	f006 fff5 	bl	9b08 <serial_putc>
            }
            serial_putc(&stdio_uart, buffer[i]);
    2b1e:	aa03      	add	r2, sp, #12
    2b20:	9b24      	ldr	r3, [sp, #144]	; 0x90
    2b22:	4413      	add	r3, r2
    2b24:	781b      	ldrb	r3, [r3, #0]
    2b26:	4619      	mov	r1, r3
    2b28:	480b      	ldr	r0, [pc, #44]	; (2b58 <mbed_error_vfprintf+0x98>)
    2b2a:	f006 ffed 	bl	9b08 <serial_putc>
            stdio_out_prev = buffer[i];
    2b2e:	aa03      	add	r2, sp, #12
    2b30:	9b24      	ldr	r3, [sp, #144]	; 0x90
    2b32:	4413      	add	r3, r2
    2b34:	781b      	ldrb	r3, [r3, #0]
    2b36:	f88d 3097 	strb.w	r3, [sp, #151]	; 0x97
        for (int i = 0; i < size; i++) {
    2b3a:	9b24      	ldr	r3, [sp, #144]	; 0x90
    2b3c:	3301      	adds	r3, #1
    2b3e:	9324      	str	r3, [sp, #144]	; 0x90
    2b40:	9a24      	ldr	r2, [sp, #144]	; 0x90
    2b42:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    2b44:	429a      	cmp	r2, r3
    2b46:	dbdc      	blt.n	2b02 <mbed_error_vfprintf+0x42>
        for (int i = 0; i < size; i++) {
            serial_putc(&stdio_uart, buffer[i]);
        }
#endif
    }
    core_util_critical_section_exit();
    2b48:	f000 f83e 	bl	2bc8 <core_util_critical_section_exit>
#endif
}
    2b4c:	bf00      	nop
    2b4e:	b027      	add	sp, #156	; 0x9c
    2b50:	f85d fb04 	ldr.w	pc, [sp], #4
    2b54:	20001538 	.word	0x20001538
    2b58:	20002f6c 	.word	0x20002f6c

00002b5c <core_util_are_interrupts_enabled>:
#endif

static volatile uint32_t critical_section_reentrancy_counter = 0;

bool core_util_are_interrupts_enabled(void)
{
    2b5c:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    2b5e:	f3ef 8310 	mrs	r3, PRIMASK
    2b62:	9301      	str	r3, [sp, #4]
  return(result);
    2b64:	9b01      	ldr	r3, [sp, #4]
#if defined(__CORTEX_A9)
    return ((__get_CPSR() & 0x80) == 0);
#else
    return ((__get_PRIMASK() & 0x1) == 0);
    2b66:	f003 0301 	and.w	r3, r3, #1
    2b6a:	2b00      	cmp	r3, #0
    2b6c:	bf0c      	ite	eq
    2b6e:	2301      	moveq	r3, #1
    2b70:	2300      	movne	r3, #0
    2b72:	b2db      	uxtb	r3, r3
#endif
}
    2b74:	4618      	mov	r0, r3
    2b76:	b002      	add	sp, #8
    2b78:	4770      	bx	lr

00002b7a <core_util_is_isr_active>:

bool core_util_is_isr_active(void)
{
    2b7a:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    2b7c:	f3ef 8305 	mrs	r3, IPSR
    2b80:	9301      	str	r3, [sp, #4]
  return(result);
    2b82:	9b01      	ldr	r3, [sp, #4]
        case CPSR_M_SVC:
        default:
            return true;
    }
#else
    return (__get_IPSR() != 0U);
    2b84:	2b00      	cmp	r3, #0
    2b86:	bf14      	ite	ne
    2b88:	2301      	movne	r3, #1
    2b8a:	2300      	moveq	r3, #0
    2b8c:	b2db      	uxtb	r3, r3
#endif
}
    2b8e:	4618      	mov	r0, r3
    2b90:	b002      	add	sp, #8
    2b92:	4770      	bx	lr

00002b94 <core_util_critical_section_enter>:
{
    return hal_in_critical_section();
}

void core_util_critical_section_enter(void)
{
    2b94:	b508      	push	{r3, lr}
// FIXME
#ifdef FEATURE_UVISOR
#warning "core_util_critical_section_enter needs fixing to work from unprivileged code"
#else
    // If the reentrancy counter overflows something has gone badly wrong.
    MBED_ASSERT(critical_section_reentrancy_counter < UINT32_MAX);
    2b96:	4b09      	ldr	r3, [pc, #36]	; (2bbc <core_util_critical_section_enter+0x28>)
    2b98:	681b      	ldr	r3, [r3, #0]
    2b9a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    2b9e:	d104      	bne.n	2baa <core_util_critical_section_enter+0x16>
    2ba0:	2255      	movs	r2, #85	; 0x55
    2ba2:	4907      	ldr	r1, [pc, #28]	; (2bc0 <core_util_critical_section_enter+0x2c>)
    2ba4:	4807      	ldr	r0, [pc, #28]	; (2bc4 <core_util_critical_section_enter+0x30>)
    2ba6:	f7ff ff27 	bl	29f8 <mbed_assert_internal>
#endif /* FEATURE_UVISOR */

    hal_critical_section_enter();
    2baa:	f7fe fffd 	bl	1ba8 <hal_critical_section_enter>

    ++critical_section_reentrancy_counter;
    2bae:	4b03      	ldr	r3, [pc, #12]	; (2bbc <core_util_critical_section_enter+0x28>)
    2bb0:	681b      	ldr	r3, [r3, #0]
    2bb2:	3301      	adds	r3, #1
    2bb4:	4a01      	ldr	r2, [pc, #4]	; (2bbc <core_util_critical_section_enter+0x28>)
    2bb6:	6013      	str	r3, [r2, #0]
}
    2bb8:	bf00      	nop
    2bba:	bd08      	pop	{r3, pc}
    2bbc:	20000cf0 	.word	0x20000cf0
    2bc0:	00010ba4 	.word	0x00010ba4
    2bc4:	00010bc8 	.word	0x00010bc8

00002bc8 <core_util_critical_section_exit>:

void core_util_critical_section_exit(void)
{
    2bc8:	b508      	push	{r3, lr}
#ifdef FEATURE_UVISOR
#warning "core_util_critical_section_exit needs fixing to work from unprivileged code"
#endif /* FEATURE_UVISOR */

    // If critical_section_enter has not previously been called, do nothing
    if (critical_section_reentrancy_counter == 0) {
    2bca:	4b09      	ldr	r3, [pc, #36]	; (2bf0 <core_util_critical_section_exit+0x28>)
    2bcc:	681b      	ldr	r3, [r3, #0]
    2bce:	2b00      	cmp	r3, #0
    2bd0:	d00b      	beq.n	2bea <core_util_critical_section_exit+0x22>
        return;
    }

    --critical_section_reentrancy_counter;
    2bd2:	4b07      	ldr	r3, [pc, #28]	; (2bf0 <core_util_critical_section_exit+0x28>)
    2bd4:	681b      	ldr	r3, [r3, #0]
    2bd6:	3b01      	subs	r3, #1
    2bd8:	4a05      	ldr	r2, [pc, #20]	; (2bf0 <core_util_critical_section_exit+0x28>)
    2bda:	6013      	str	r3, [r2, #0]

    if (critical_section_reentrancy_counter == 0) {
    2bdc:	4b04      	ldr	r3, [pc, #16]	; (2bf0 <core_util_critical_section_exit+0x28>)
    2bde:	681b      	ldr	r3, [r3, #0]
    2be0:	2b00      	cmp	r3, #0
    2be2:	d103      	bne.n	2bec <core_util_critical_section_exit+0x24>
        hal_critical_section_exit();
    2be4:	f7fe fffe 	bl	1be4 <hal_critical_section_exit>
    2be8:	e000      	b.n	2bec <core_util_critical_section_exit+0x24>
        return;
    2bea:	bf00      	nop
    }
}
    2bec:	bd08      	pop	{r3, pc}
    2bee:	bf00      	nop
    2bf0:	20000cf0 	.word	0x20000cf0

00002bf4 <core_util_atomic_incr_u16>:
    } while (__STREXB(newValue, valuePtr));
    return newValue;
}

uint16_t core_util_atomic_incr_u16(volatile uint16_t *valuePtr, uint16_t delta)
{
    2bf4:	b088      	sub	sp, #32
    2bf6:	9001      	str	r0, [sp, #4]
    2bf8:	460b      	mov	r3, r1
    2bfa:	f8ad 3002 	strh.w	r3, [sp, #2]
    2bfe:	9b01      	ldr	r3, [sp, #4]
    2c00:	9304      	str	r3, [sp, #16]
__STATIC_FORCEINLINE uint16_t __LDREXH(volatile uint16_t *addr)
{
    uint32_t result;

#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
    2c02:	9b04      	ldr	r3, [sp, #16]
    2c04:	e8d3 3f5f 	ldrexh	r3, [r3]
    2c08:	9303      	str	r3, [sp, #12]
    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
       accepted by assembler. So has to use following less efficient pattern.
    */
   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
#endif
   return ((uint16_t) result);    /* Add explicit type cast here */
    2c0a:	9b03      	ldr	r3, [sp, #12]
    2c0c:	b29a      	uxth	r2, r3
    uint16_t newValue;
    do {
        newValue = __LDREXH(valuePtr) + delta;
    2c0e:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    2c12:	4413      	add	r3, r2
    2c14:	f8ad 301e 	strh.w	r3, [sp, #30]
    2c18:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    2c1c:	f8ad 301c 	strh.w	r3, [sp, #28]
    2c20:	9b01      	ldr	r3, [sp, #4]
    2c22:	9306      	str	r3, [sp, #24]
 */
__STATIC_FORCEINLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
{
   uint32_t result;

   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
    2c24:	f8bd 201c 	ldrh.w	r2, [sp, #28]
    2c28:	9906      	ldr	r1, [sp, #24]
    2c2a:	e8c1 2f53 	strexh	r3, r2, [r1]
    2c2e:	9305      	str	r3, [sp, #20]
   return(result);
    2c30:	9b05      	ldr	r3, [sp, #20]
    } while (__STREXH(newValue, valuePtr));
    2c32:	2b00      	cmp	r3, #0
    2c34:	d1e3      	bne.n	2bfe <core_util_atomic_incr_u16+0xa>
    return newValue;
    2c36:	f8bd 301e 	ldrh.w	r3, [sp, #30]
}
    2c3a:	4618      	mov	r0, r3
    2c3c:	b008      	add	sp, #32
    2c3e:	4770      	bx	lr

00002c40 <core_util_atomic_decr_u16>:
    } while (__STREXB(newValue, valuePtr));
    return newValue;
}

uint16_t core_util_atomic_decr_u16(volatile uint16_t *valuePtr, uint16_t delta)
{
    2c40:	b088      	sub	sp, #32
    2c42:	9001      	str	r0, [sp, #4]
    2c44:	460b      	mov	r3, r1
    2c46:	f8ad 3002 	strh.w	r3, [sp, #2]
    2c4a:	9b01      	ldr	r3, [sp, #4]
    2c4c:	9304      	str	r3, [sp, #16]
   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
    2c4e:	9b04      	ldr	r3, [sp, #16]
    2c50:	e8d3 3f5f 	ldrexh	r3, [r3]
    2c54:	9303      	str	r3, [sp, #12]
   return ((uint16_t) result);    /* Add explicit type cast here */
    2c56:	9b03      	ldr	r3, [sp, #12]
    2c58:	b29a      	uxth	r2, r3
    uint16_t newValue;
    do {
        newValue = __LDREXH(valuePtr) - delta;
    2c5a:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    2c5e:	1ad3      	subs	r3, r2, r3
    2c60:	f8ad 301e 	strh.w	r3, [sp, #30]
    2c64:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    2c68:	f8ad 301c 	strh.w	r3, [sp, #28]
    2c6c:	9b01      	ldr	r3, [sp, #4]
    2c6e:	9306      	str	r3, [sp, #24]
   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
    2c70:	f8bd 201c 	ldrh.w	r2, [sp, #28]
    2c74:	9906      	ldr	r1, [sp, #24]
    2c76:	e8c1 2f53 	strexh	r3, r2, [r1]
    2c7a:	9305      	str	r3, [sp, #20]
   return(result);
    2c7c:	9b05      	ldr	r3, [sp, #20]
    } while (__STREXH(newValue, valuePtr));
    2c7e:	2b00      	cmp	r3, #0
    2c80:	d1e3      	bne.n	2c4a <core_util_atomic_decr_u16+0xa>
    return newValue;
    2c82:	f8bd 301e 	ldrh.w	r3, [sp, #30]
}
    2c86:	4618      	mov	r0, r3
    2c88:	b008      	add	sp, #32
    2c8a:	4770      	bx	lr

00002c8c <mbed_halt_system>:
static void print_error_report(mbed_error_ctx *ctx, const char *);
static mbed_error_status_t handle_error(mbed_error_status_t error_status, unsigned int error_value, const char *filename, int line_number, void *caller);

//Helper function to halt the system
static void mbed_halt_system(void)
{
    2c8c:	b508      	push	{r3, lr}
    //If not in ISR context exit, otherwise spin on WFI
    if (core_util_is_isr_active() || !core_util_are_interrupts_enabled()) {
    2c8e:	f7ff ff74 	bl	2b7a <core_util_is_isr_active>
    2c92:	4603      	mov	r3, r0
    2c94:	2b00      	cmp	r3, #0
    2c96:	d107      	bne.n	2ca8 <mbed_halt_system+0x1c>
    2c98:	f7ff ff60 	bl	2b5c <core_util_are_interrupts_enabled>
    2c9c:	4603      	mov	r3, r0
    2c9e:	f083 0301 	eor.w	r3, r3, #1
    2ca2:	b2db      	uxtb	r3, r3
    2ca4:	2b00      	cmp	r3, #0
    2ca6:	d001      	beq.n	2cac <mbed_halt_system+0x20>
        for (;;) {
            __WFI();
    2ca8:	bf30      	wfi
    2caa:	e7fd      	b.n	2ca8 <mbed_halt_system+0x1c>
        }
    } else {
        //exit eventually calls mbed_die
        exit(1);
    2cac:	2001      	movs	r0, #1
    2cae:	f000 feeb 	bl	3a88 <__wrap_exit>
	...

00002cb4 <handle_error>:
    exit(1);
}

//Set an error status with the error handling system
static mbed_error_status_t handle_error(mbed_error_status_t error_status, unsigned int error_value, const char *filename, int line_number, void *caller)
{
    2cb4:	b510      	push	{r4, lr}
    2cb6:	b094      	sub	sp, #80	; 0x50
    2cb8:	9003      	str	r0, [sp, #12]
    2cba:	9102      	str	r1, [sp, #8]
    2cbc:	9201      	str	r2, [sp, #4]
    2cbe:	9300      	str	r3, [sp, #0]
    mbed_error_ctx current_error_ctx;

    //Error status should always be < 0
    if (error_status >= 0) {
    2cc0:	9b03      	ldr	r3, [sp, #12]
    2cc2:	2b00      	cmp	r3, #0
    2cc4:	db01      	blt.n	2cca <handle_error+0x16>
        //This is a weird situation, someone called mbed_error with invalid error code.
        //We will still handle the situation but change the error code to ERROR_INVALID_ARGUMENT, atleast the context will have info on who called it
        error_status = MBED_ERROR_INVALID_ARGUMENT;
    2cc6:	4b35      	ldr	r3, [pc, #212]	; (2d9c <handle_error+0xe8>)
    2cc8:	9303      	str	r3, [sp, #12]
    }

    //Prevent corruption by holding out other callers
    //and we also need this until we remove the "error" call completely
    while (error_in_progress == 1);
    2cca:	bf00      	nop
    2ccc:	4b34      	ldr	r3, [pc, #208]	; (2da0 <handle_error+0xec>)
    2cce:	781b      	ldrb	r3, [r3, #0]
    2cd0:	2b01      	cmp	r3, #1
    2cd2:	d0fb      	beq.n	2ccc <handle_error+0x18>

    //Use critsect here, as we don't want inadvertant modification of this global variable
    core_util_critical_section_enter();
    2cd4:	f7ff ff5e 	bl	2b94 <core_util_critical_section_enter>
    error_in_progress = 1;
    2cd8:	4b31      	ldr	r3, [pc, #196]	; (2da0 <handle_error+0xec>)
    2cda:	2201      	movs	r2, #1
    2cdc:	701a      	strb	r2, [r3, #0]
    core_util_critical_section_exit();
    2cde:	f7ff ff73 	bl	2bc8 <core_util_critical_section_exit>

    //Increment error count
    error_count++;
    2ce2:	4b30      	ldr	r3, [pc, #192]	; (2da4 <handle_error+0xf0>)
    2ce4:	681b      	ldr	r3, [r3, #0]
    2ce6:	3301      	adds	r3, #1
    2ce8:	4a2e      	ldr	r2, [pc, #184]	; (2da4 <handle_error+0xf0>)
    2cea:	6013      	str	r3, [r2, #0]

    //Clear the context capturing buffer
    memset(&current_error_ctx, sizeof(mbed_error_ctx), 0);
    2cec:	ab04      	add	r3, sp, #16
    2cee:	2200      	movs	r2, #0
    2cf0:	2134      	movs	r1, #52	; 0x34
    2cf2:	4618      	mov	r0, r3
    2cf4:	f008 fbc6 	bl	b484 <memset>
    //Capture error information
    current_error_ctx.error_status = error_status;
    2cf8:	9b03      	ldr	r3, [sp, #12]
    2cfa:	9304      	str	r3, [sp, #16]
    current_error_ctx.error_address = (uint32_t)caller;
    2cfc:	9b16      	ldr	r3, [sp, #88]	; 0x58
    2cfe:	9305      	str	r3, [sp, #20]
    current_error_ctx.error_value = error_value;
    2d00:	9b02      	ldr	r3, [sp, #8]
    2d02:	9306      	str	r3, [sp, #24]
#ifdef MBED_CONF_RTOS_PRESENT
    //Capture thread info
    osRtxThread_t *current_thread = osRtxInfo.thread.run.curr;
    2d04:	4b28      	ldr	r3, [pc, #160]	; (2da8 <handle_error+0xf4>)
    2d06:	695b      	ldr	r3, [r3, #20]
    2d08:	9313      	str	r3, [sp, #76]	; 0x4c
    current_error_ctx.thread_id = (uint32_t)current_thread;
    2d0a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2d0c:	9307      	str	r3, [sp, #28]
    current_error_ctx.thread_entry_address = (uint32_t)current_thread->thread_addr;
    2d0e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2d10:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    2d12:	9308      	str	r3, [sp, #32]
    current_error_ctx.thread_stack_size = current_thread->stack_size;
    2d14:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2d16:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    2d18:	9309      	str	r3, [sp, #36]	; 0x24
    current_error_ctx.thread_stack_mem = (uint32_t)current_thread->stack_mem;
    2d1a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    2d1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    2d1e:	930a      	str	r3, [sp, #40]	; 0x28
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    2d20:	f3ef 8305 	mrs	r3, IPSR
    2d24:	9312      	str	r3, [sp, #72]	; 0x48
  return(result);
    2d26:	9b12      	ldr	r3, [sp, #72]	; 0x48
#ifdef TARGET_CORTEX_M
    GET_CURRENT_SP(current_error_ctx.thread_current_sp);
    2d28:	2b00      	cmp	r3, #0
    2d2a:	d005      	beq.n	2d38 <handle_error+0x84>
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
    2d2c:	f3ef 8308 	mrs	r3, MSP
    2d30:	461c      	mov	r4, r3
  return(result);
    2d32:	4623      	mov	r3, r4
    2d34:	930b      	str	r3, [sp, #44]	; 0x2c
    2d36:	e012      	b.n	2d5e <handle_error+0xaa>
  __ASM volatile ("MRS %0, control" : "=r" (result) );
    2d38:	f3ef 8314 	mrs	r3, CONTROL
    2d3c:	9311      	str	r3, [sp, #68]	; 0x44
  return(result);
    2d3e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    2d40:	f003 0302 	and.w	r3, r3, #2
    2d44:	2b00      	cmp	r3, #0
    2d46:	d105      	bne.n	2d54 <handle_error+0xa0>
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
    2d48:	f3ef 8308 	mrs	r3, MSP
    2d4c:	461c      	mov	r4, r3
  return(result);
    2d4e:	4623      	mov	r3, r4
    2d50:	930b      	str	r3, [sp, #44]	; 0x2c
    2d52:	e004      	b.n	2d5e <handle_error+0xaa>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
    2d54:	f3ef 8309 	mrs	r3, PSP
    2d58:	461c      	mov	r4, r3
  return(result);
    2d5a:	4623      	mov	r3, r4
    2d5c:	930b      	str	r3, [sp, #44]	; 0x2c
    strncpy(current_error_ctx.error_filename, filename, MBED_CONF_PLATFORM_MAX_ERROR_FILENAME_LEN);
    current_error_ctx.error_line_number = line_number;
#endif

    //Capture the fist system error and store it
    if (error_count == 1) { //first error
    2d5e:	4b11      	ldr	r3, [pc, #68]	; (2da4 <handle_error+0xf0>)
    2d60:	681b      	ldr	r3, [r3, #0]
    2d62:	2b01      	cmp	r3, #1
    2d64:	d105      	bne.n	2d72 <handle_error+0xbe>
        memcpy(&first_error_ctx, &current_error_ctx, sizeof(mbed_error_ctx));
    2d66:	ab04      	add	r3, sp, #16
    2d68:	2234      	movs	r2, #52	; 0x34
    2d6a:	4619      	mov	r1, r3
    2d6c:	480f      	ldr	r0, [pc, #60]	; (2dac <handle_error+0xf8>)
    2d6e:	f7fd fdd7 	bl	920 <memcpy>
    }

    //copy this error to last error
    memcpy(&last_error_ctx, &current_error_ctx, sizeof(mbed_error_ctx));
    2d72:	ab04      	add	r3, sp, #16
    2d74:	2234      	movs	r2, #52	; 0x34
    2d76:	4619      	mov	r1, r3
    2d78:	480d      	ldr	r0, [pc, #52]	; (2db0 <handle_error+0xfc>)
    2d7a:	f7fd fdd1 	bl	920 <memcpy>
    //Log the error with error log
    mbed_error_hist_put(&current_error_ctx);
#endif

    //Call the error hook if available
    if (error_hook != NULL) {
    2d7e:	4b0d      	ldr	r3, [pc, #52]	; (2db4 <handle_error+0x100>)
    2d80:	681b      	ldr	r3, [r3, #0]
    2d82:	2b00      	cmp	r3, #0
    2d84:	d003      	beq.n	2d8e <handle_error+0xda>
        error_hook(&last_error_ctx);
    2d86:	4b0b      	ldr	r3, [pc, #44]	; (2db4 <handle_error+0x100>)
    2d88:	681b      	ldr	r3, [r3, #0]
    2d8a:	4809      	ldr	r0, [pc, #36]	; (2db0 <handle_error+0xfc>)
    2d8c:	4798      	blx	r3
    }

    error_in_progress = 0;
    2d8e:	4b04      	ldr	r3, [pc, #16]	; (2da0 <handle_error+0xec>)
    2d90:	2200      	movs	r2, #0
    2d92:	701a      	strb	r2, [r3, #0]

    return MBED_SUCCESS;
    2d94:	2300      	movs	r3, #0
}
    2d96:	4618      	mov	r0, r3
    2d98:	b014      	add	sp, #80	; 0x50
    2d9a:	bd10      	pop	{r4, pc}
    2d9c:	80ff0101 	.word	0x80ff0101
    2da0:	20000cf4 	.word	0x20000cf4
    2da4:	20000cf8 	.word	0x20000cf8
    2da8:	20000110 	.word	0x20000110
    2dac:	20000cfc 	.word	0x20000cfc
    2db0:	20000d30 	.word	0x20000d30
    2db4:	20000d64 	.word	0x20000d64

00002db8 <mbed_error>:
    return handle_error(error_status, error_value, filename, line_number, MBED_CALLER_ADDR());
}

//Sets a fatal error, this function is marked WEAK to be able to override this for some tests
WEAK mbed_error_status_t mbed_error(mbed_error_status_t error_status, const char *error_msg, unsigned int error_value, const char *filename, int line_number)
{
    2db8:	b510      	push	{r4, lr}
    2dba:	b086      	sub	sp, #24
    2dbc:	4674      	mov	r4, lr
    2dbe:	9005      	str	r0, [sp, #20]
    2dc0:	9104      	str	r1, [sp, #16]
    2dc2:	9203      	str	r2, [sp, #12]
    2dc4:	9302      	str	r3, [sp, #8]
    //set the error reported and then halt the system
    if (MBED_SUCCESS != handle_error(error_status, error_value, filename, line_number, MBED_CALLER_ADDR())) {
    2dc6:	4623      	mov	r3, r4
    2dc8:	9300      	str	r3, [sp, #0]
    2dca:	9b08      	ldr	r3, [sp, #32]
    2dcc:	9a02      	ldr	r2, [sp, #8]
    2dce:	9903      	ldr	r1, [sp, #12]
    2dd0:	9805      	ldr	r0, [sp, #20]
    2dd2:	f7ff ff6f 	bl	2cb4 <handle_error>
    2dd6:	4603      	mov	r3, r0
    2dd8:	2b00      	cmp	r3, #0
    2dda:	d001      	beq.n	2de0 <mbed_error+0x28>
        return MBED_ERROR_FAILED_OPERATION;
    2ddc:	4b05      	ldr	r3, [pc, #20]	; (2df4 <mbed_error+0x3c>)
    2dde:	e006      	b.n	2dee <mbed_error+0x36>
    }

    //On fatal errors print the error context/report
    ERROR_REPORT(&last_error_ctx, error_msg);
    2de0:	9904      	ldr	r1, [sp, #16]
    2de2:	4805      	ldr	r0, [pc, #20]	; (2df8 <mbed_error+0x40>)
    2de4:	f000 f80a 	bl	2dfc <print_error_report>
    mbed_halt_system();
    2de8:	f7ff ff50 	bl	2c8c <mbed_halt_system>

    return MBED_ERROR_FAILED_OPERATION;
    2dec:	4b01      	ldr	r3, [pc, #4]	; (2df4 <mbed_error+0x3c>)
}
    2dee:	4618      	mov	r0, r3
    2df0:	b006      	add	sp, #24
    2df2:	bd10      	pop	{r4, pc}
    2df4:	80ff010f 	.word	0x80ff010f
    2df8:	20000d30 	.word	0x20000d30

00002dfc <print_error_report>:
}
#endif

#ifndef NDEBUG
static void print_error_report(mbed_error_ctx *ctx, const char *error_msg)
{
    2dfc:	b510      	push	{r4, lr}
    2dfe:	b086      	sub	sp, #24
    2e00:	9003      	str	r0, [sp, #12]
    2e02:	9102      	str	r1, [sp, #8]
    uint32_t error_code = MBED_GET_ERROR_CODE(ctx->error_status);
    2e04:	9b03      	ldr	r3, [sp, #12]
    2e06:	681b      	ldr	r3, [r3, #0]
    2e08:	175b      	asrs	r3, r3, #29
    2e0a:	f003 0303 	and.w	r3, r3, #3
    2e0e:	2b03      	cmp	r3, #3
    2e10:	d103      	bne.n	2e1a <print_error_report+0x1e>
    2e12:	9b03      	ldr	r3, [sp, #12]
    2e14:	681b      	ldr	r3, [r3, #0]
    2e16:	425b      	negs	r3, r3
    2e18:	e002      	b.n	2e20 <print_error_report+0x24>
    2e1a:	9b03      	ldr	r3, [sp, #12]
    2e1c:	681b      	ldr	r3, [r3, #0]
    2e1e:	b29b      	uxth	r3, r3
    2e20:	9305      	str	r3, [sp, #20]
    uint32_t error_module = MBED_GET_ERROR_MODULE(ctx->error_status);
    2e22:	9b03      	ldr	r3, [sp, #12]
    2e24:	681b      	ldr	r3, [r3, #0]
    2e26:	141b      	asrs	r3, r3, #16
    2e28:	b2db      	uxtb	r3, r3
    2e2a:	9304      	str	r3, [sp, #16]

    mbed_error_printf("\n\n++ MbedOS Error Info ++\nError Status: 0x%X Code: %d Module: %d\nError Message: ", ctx->error_status, error_code, error_module);
    2e2c:	9b03      	ldr	r3, [sp, #12]
    2e2e:	6819      	ldr	r1, [r3, #0]
    2e30:	9b04      	ldr	r3, [sp, #16]
    2e32:	9a05      	ldr	r2, [sp, #20]
    2e34:	483d      	ldr	r0, [pc, #244]	; (2f2c <print_error_report+0x130>)
    2e36:	f7ff fe34 	bl	2aa2 <mbed_error_printf>

    switch (error_code) {
    2e3a:	9b05      	ldr	r3, [sp, #20]
    2e3c:	f2a3 1331 	subw	r3, r3, #305	; 0x131
    2e40:	2b07      	cmp	r3, #7
    2e42:	d84b      	bhi.n	2edc <print_error_report+0xe0>
    2e44:	a201      	add	r2, pc, #4	; (adr r2, 2e4c <print_error_report+0x50>)
    2e46:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    2e4a:	bf00      	nop
    2e4c:	00002e6d 	.word	0x00002e6d
    2e50:	00002e7b 	.word	0x00002e7b
    2e54:	00002e89 	.word	0x00002e89
    2e58:	00002e97 	.word	0x00002e97
    2e5c:	00002ea5 	.word	0x00002ea5
    2e60:	00002ec1 	.word	0x00002ec1
    2e64:	00002eb3 	.word	0x00002eb3
    2e68:	00002ecf 	.word	0x00002ecf
        //These are errors reported by kernel handled from mbed_rtx_handlers
        case MBED_ERROR_CODE_RTOS_EVENT:
            mbed_error_printf("Kernel Error: 0x%X, ", ctx->error_value);
    2e6c:	9b03      	ldr	r3, [sp, #12]
    2e6e:	689b      	ldr	r3, [r3, #8]
    2e70:	4619      	mov	r1, r3
    2e72:	482f      	ldr	r0, [pc, #188]	; (2f30 <print_error_report+0x134>)
    2e74:	f7ff fe15 	bl	2aa2 <mbed_error_printf>
            break;
    2e78:	e031      	b.n	2ede <print_error_report+0xe2>

        case MBED_ERROR_CODE_RTOS_THREAD_EVENT:
            mbed_error_printf("Thread: 0x%X, ", ctx->error_value);
    2e7a:	9b03      	ldr	r3, [sp, #12]
    2e7c:	689b      	ldr	r3, [r3, #8]
    2e7e:	4619      	mov	r1, r3
    2e80:	482c      	ldr	r0, [pc, #176]	; (2f34 <print_error_report+0x138>)
    2e82:	f7ff fe0e 	bl	2aa2 <mbed_error_printf>
            break;
    2e86:	e02a      	b.n	2ede <print_error_report+0xe2>

        case MBED_ERROR_CODE_RTOS_MUTEX_EVENT:
            mbed_error_printf("Mutex: 0x%X, ", ctx->error_value);
    2e88:	9b03      	ldr	r3, [sp, #12]
    2e8a:	689b      	ldr	r3, [r3, #8]
    2e8c:	4619      	mov	r1, r3
    2e8e:	482a      	ldr	r0, [pc, #168]	; (2f38 <print_error_report+0x13c>)
    2e90:	f7ff fe07 	bl	2aa2 <mbed_error_printf>
            break;
    2e94:	e023      	b.n	2ede <print_error_report+0xe2>

        case MBED_ERROR_CODE_RTOS_SEMAPHORE_EVENT:
            mbed_error_printf("Semaphore: 0x%X, ", ctx->error_value);
    2e96:	9b03      	ldr	r3, [sp, #12]
    2e98:	689b      	ldr	r3, [r3, #8]
    2e9a:	4619      	mov	r1, r3
    2e9c:	4827      	ldr	r0, [pc, #156]	; (2f3c <print_error_report+0x140>)
    2e9e:	f7ff fe00 	bl	2aa2 <mbed_error_printf>
            break;
    2ea2:	e01c      	b.n	2ede <print_error_report+0xe2>

        case MBED_ERROR_CODE_RTOS_MEMORY_POOL_EVENT:
            mbed_error_printf("MemoryPool: 0x%X, ", ctx->error_value);
    2ea4:	9b03      	ldr	r3, [sp, #12]
    2ea6:	689b      	ldr	r3, [r3, #8]
    2ea8:	4619      	mov	r1, r3
    2eaa:	4825      	ldr	r0, [pc, #148]	; (2f40 <print_error_report+0x144>)
    2eac:	f7ff fdf9 	bl	2aa2 <mbed_error_printf>
            break;
    2eb0:	e015      	b.n	2ede <print_error_report+0xe2>

        case MBED_ERROR_CODE_RTOS_EVENT_FLAGS_EVENT:
            mbed_error_printf("EventFlags: 0x%X, ", ctx->error_value);
    2eb2:	9b03      	ldr	r3, [sp, #12]
    2eb4:	689b      	ldr	r3, [r3, #8]
    2eb6:	4619      	mov	r1, r3
    2eb8:	4822      	ldr	r0, [pc, #136]	; (2f44 <print_error_report+0x148>)
    2eba:	f7ff fdf2 	bl	2aa2 <mbed_error_printf>
            break;
    2ebe:	e00e      	b.n	2ede <print_error_report+0xe2>

        case MBED_ERROR_CODE_RTOS_TIMER_EVENT:
            mbed_error_printf("Timer: 0x%X, ", ctx->error_value);
    2ec0:	9b03      	ldr	r3, [sp, #12]
    2ec2:	689b      	ldr	r3, [r3, #8]
    2ec4:	4619      	mov	r1, r3
    2ec6:	4820      	ldr	r0, [pc, #128]	; (2f48 <print_error_report+0x14c>)
    2ec8:	f7ff fdeb 	bl	2aa2 <mbed_error_printf>
            break;
    2ecc:	e007      	b.n	2ede <print_error_report+0xe2>

        case MBED_ERROR_CODE_RTOS_MESSAGE_QUEUE_EVENT:
            mbed_error_printf("MessageQueue: 0x%X, ", ctx->error_value);
    2ece:	9b03      	ldr	r3, [sp, #12]
    2ed0:	689b      	ldr	r3, [r3, #8]
    2ed2:	4619      	mov	r1, r3
    2ed4:	481d      	ldr	r0, [pc, #116]	; (2f4c <print_error_report+0x150>)
    2ed6:	f7ff fde4 	bl	2aa2 <mbed_error_printf>
            break;
    2eda:	e000      	b.n	2ede <print_error_report+0xe2>

        default:
            //Nothing to do here, just print the error info down
            break;
    2edc:	bf00      	nop
    }
    mbed_error_printf(error_msg);
    2ede:	9802      	ldr	r0, [sp, #8]
    2ee0:	f7ff fddf 	bl	2aa2 <mbed_error_printf>
    mbed_error_printf("\nLocation: 0x%X", ctx->error_address);
    2ee4:	9b03      	ldr	r3, [sp, #12]
    2ee6:	685b      	ldr	r3, [r3, #4]
    2ee8:	4619      	mov	r1, r3
    2eea:	4819      	ldr	r0, [pc, #100]	; (2f50 <print_error_report+0x154>)
    2eec:	f7ff fdd9 	bl	2aa2 <mbed_error_printf>
        //for string, we must pass address of a ptr which has the address of the string
        mbed_error_printf("\nFile:%s+%d", ctx->error_filename, ctx->error_line_number);
    }
#endif

    mbed_error_printf("\nError Value: 0x%X", ctx->error_value);
    2ef0:	9b03      	ldr	r3, [sp, #12]
    2ef2:	689b      	ldr	r3, [r3, #8]
    2ef4:	4619      	mov	r1, r3
    2ef6:	4817      	ldr	r0, [pc, #92]	; (2f54 <print_error_report+0x158>)
    2ef8:	f7ff fdd3 	bl	2aa2 <mbed_error_printf>
#ifdef TARGET_CORTEX_M
    mbed_error_printf("\nCurrent Thread: Id: 0x%X Entry: 0x%X StackSize: 0x%X StackMem: 0x%X SP: 0x%X ",
    2efc:	9b03      	ldr	r3, [sp, #12]
    2efe:	68d9      	ldr	r1, [r3, #12]
    2f00:	9b03      	ldr	r3, [sp, #12]
    2f02:	6918      	ldr	r0, [r3, #16]
    2f04:	9b03      	ldr	r3, [sp, #12]
    2f06:	695c      	ldr	r4, [r3, #20]
    2f08:	9b03      	ldr	r3, [sp, #12]
    2f0a:	699b      	ldr	r3, [r3, #24]
    2f0c:	9a03      	ldr	r2, [sp, #12]
    2f0e:	69d2      	ldr	r2, [r2, #28]
    2f10:	9201      	str	r2, [sp, #4]
    2f12:	9300      	str	r3, [sp, #0]
    2f14:	4623      	mov	r3, r4
    2f16:	4602      	mov	r2, r0
    2f18:	480f      	ldr	r0, [pc, #60]	; (2f58 <print_error_report+0x15c>)
    2f1a:	f7ff fdc2 	bl	2aa2 <mbed_error_printf>
    mbed_error_printf("\nIdle:");
    threads = (osRtxThread_t *)&osRtxInfo.thread.idle;
    print_threads_info(threads);
#endif

    mbed_error_printf("\n-- MbedOS Error Info --\n");
    2f1e:	480f      	ldr	r0, [pc, #60]	; (2f5c <print_error_report+0x160>)
    2f20:	f7ff fdbf 	bl	2aa2 <mbed_error_printf>
}
    2f24:	bf00      	nop
    2f26:	b006      	add	sp, #24
    2f28:	bd10      	pop	{r4, pc}
    2f2a:	bf00      	nop
    2f2c:	00010c14 	.word	0x00010c14
    2f30:	00010c68 	.word	0x00010c68
    2f34:	00010c80 	.word	0x00010c80
    2f38:	00010c90 	.word	0x00010c90
    2f3c:	00010ca0 	.word	0x00010ca0
    2f40:	00010cb4 	.word	0x00010cb4
    2f44:	00010cc8 	.word	0x00010cc8
    2f48:	00010cdc 	.word	0x00010cdc
    2f4c:	00010cec 	.word	0x00010cec
    2f50:	00010d04 	.word	0x00010d04
    2f54:	00010d14 	.word	0x00010d14
    2f58:	00010d28 	.word	0x00010d28
    2f5c:	00010d78 	.word	0x00010d78

00002f60 <mbed_mem_trace_set_callback>:
/******************************************************************************
 * Public interface
 *****************************************************************************/

void mbed_mem_trace_set_callback(mbed_mem_trace_cb_t cb)
{
    2f60:	b082      	sub	sp, #8
    2f62:	9001      	str	r0, [sp, #4]
    mem_trace_cb = cb;
    2f64:	4a02      	ldr	r2, [pc, #8]	; (2f70 <mbed_mem_trace_set_callback+0x10>)
    2f66:	9b01      	ldr	r3, [sp, #4]
    2f68:	6013      	str	r3, [r2, #0]
}
    2f6a:	bf00      	nop
    2f6c:	b002      	add	sp, #8
    2f6e:	4770      	bx	lr
    2f70:	20000d68 	.word	0x20000d68

00002f74 <mbed_mem_trace_lock>:

void mbed_mem_trace_lock()
{
    2f74:	b508      	push	{r3, lr}
    mem_trace_mutex->lock();
    2f76:	4808      	ldr	r0, [pc, #32]	; (2f98 <mbed_mem_trace_lock+0x24>)
    2f78:	f7fe fcd2 	bl	1920 <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    2f7c:	4603      	mov	r3, r0
    2f7e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2f82:	4618      	mov	r0, r3
    2f84:	f000 ff72 	bl	3e6c <_ZN4rtos5Mutex4lockEm>
    trace_lock_count++;
    2f88:	4b04      	ldr	r3, [pc, #16]	; (2f9c <mbed_mem_trace_lock+0x28>)
    2f8a:	781b      	ldrb	r3, [r3, #0]
    2f8c:	3301      	adds	r3, #1
    2f8e:	b2da      	uxtb	r2, r3
    2f90:	4b02      	ldr	r3, [pc, #8]	; (2f9c <mbed_mem_trace_lock+0x28>)
    2f92:	701a      	strb	r2, [r3, #0]
}
    2f94:	bf00      	nop
    2f96:	bd08      	pop	{r3, pc}
    2f98:	20000d70 	.word	0x20000d70
    2f9c:	20000d6c 	.word	0x20000d6c

00002fa0 <mbed_mem_trace_unlock>:

void mbed_mem_trace_unlock()
{
    2fa0:	b508      	push	{r3, lr}
    trace_lock_count--;
    2fa2:	4b07      	ldr	r3, [pc, #28]	; (2fc0 <mbed_mem_trace_unlock+0x20>)
    2fa4:	781b      	ldrb	r3, [r3, #0]
    2fa6:	3b01      	subs	r3, #1
    2fa8:	b2da      	uxtb	r2, r3
    2faa:	4b05      	ldr	r3, [pc, #20]	; (2fc0 <mbed_mem_trace_unlock+0x20>)
    2fac:	701a      	strb	r2, [r3, #0]
    mem_trace_mutex->unlock();
    2fae:	4805      	ldr	r0, [pc, #20]	; (2fc4 <mbed_mem_trace_unlock+0x24>)
    2fb0:	f7fe fcb6 	bl	1920 <_ZN12SingletonPtrIN4rtos5MutexEEptEv>
    2fb4:	4603      	mov	r3, r0
    2fb6:	4618      	mov	r0, r3
    2fb8:	f000 ff70 	bl	3e9c <_ZN4rtos5Mutex6unlockEv>
}
    2fbc:	bf00      	nop
    2fbe:	bd08      	pop	{r3, pc}
    2fc0:	20000d6c 	.word	0x20000d6c
    2fc4:	20000d70 	.word	0x20000d70

00002fc8 <mbed_mem_trace_malloc>:

void *mbed_mem_trace_malloc(void *res, size_t size, void *caller)
{
    2fc8:	b510      	push	{r4, lr}
    2fca:	b084      	sub	sp, #16
    2fcc:	9003      	str	r0, [sp, #12]
    2fce:	9102      	str	r1, [sp, #8]
    2fd0:	9201      	str	r2, [sp, #4]
    if (mem_trace_cb) {
    2fd2:	4b09      	ldr	r3, [pc, #36]	; (2ff8 <mbed_mem_trace_malloc+0x30>)
    2fd4:	681b      	ldr	r3, [r3, #0]
    2fd6:	2b00      	cmp	r3, #0
    2fd8:	d00a      	beq.n	2ff0 <mbed_mem_trace_malloc+0x28>
        if (TRACE_FIRST_LOCK()) {
    2fda:	4b08      	ldr	r3, [pc, #32]	; (2ffc <mbed_mem_trace_malloc+0x34>)
    2fdc:	781b      	ldrb	r3, [r3, #0]
    2fde:	2b01      	cmp	r3, #1
    2fe0:	dc06      	bgt.n	2ff0 <mbed_mem_trace_malloc+0x28>
            mem_trace_cb(MBED_MEM_TRACE_MALLOC, res, caller, size);
    2fe2:	4b05      	ldr	r3, [pc, #20]	; (2ff8 <mbed_mem_trace_malloc+0x30>)
    2fe4:	681c      	ldr	r4, [r3, #0]
    2fe6:	9b02      	ldr	r3, [sp, #8]
    2fe8:	9a01      	ldr	r2, [sp, #4]
    2fea:	9903      	ldr	r1, [sp, #12]
    2fec:	2000      	movs	r0, #0
    2fee:	47a0      	blx	r4
        }
    }
    return res;
    2ff0:	9b03      	ldr	r3, [sp, #12]
}
    2ff2:	4618      	mov	r0, r3
    2ff4:	b004      	add	sp, #16
    2ff6:	bd10      	pop	{r4, pc}
    2ff8:	20000d68 	.word	0x20000d68
    2ffc:	20000d6c 	.word	0x20000d6c

00003000 <mbed_mem_trace_realloc>:

void *mbed_mem_trace_realloc(void *res, void *ptr, size_t size, void *caller)
{
    3000:	b510      	push	{r4, lr}
    3002:	b086      	sub	sp, #24
    3004:	9005      	str	r0, [sp, #20]
    3006:	9104      	str	r1, [sp, #16]
    3008:	9203      	str	r2, [sp, #12]
    300a:	9302      	str	r3, [sp, #8]
    if (mem_trace_cb) {
    300c:	4b0a      	ldr	r3, [pc, #40]	; (3038 <mbed_mem_trace_realloc+0x38>)
    300e:	681b      	ldr	r3, [r3, #0]
    3010:	2b00      	cmp	r3, #0
    3012:	d00c      	beq.n	302e <mbed_mem_trace_realloc+0x2e>
        if (TRACE_FIRST_LOCK()) {
    3014:	4b09      	ldr	r3, [pc, #36]	; (303c <mbed_mem_trace_realloc+0x3c>)
    3016:	781b      	ldrb	r3, [r3, #0]
    3018:	2b01      	cmp	r3, #1
    301a:	dc08      	bgt.n	302e <mbed_mem_trace_realloc+0x2e>
            mem_trace_cb(MBED_MEM_TRACE_REALLOC, res, caller, ptr, size);
    301c:	4b06      	ldr	r3, [pc, #24]	; (3038 <mbed_mem_trace_realloc+0x38>)
    301e:	681c      	ldr	r4, [r3, #0]
    3020:	9b03      	ldr	r3, [sp, #12]
    3022:	9300      	str	r3, [sp, #0]
    3024:	9b04      	ldr	r3, [sp, #16]
    3026:	9a02      	ldr	r2, [sp, #8]
    3028:	9905      	ldr	r1, [sp, #20]
    302a:	2001      	movs	r0, #1
    302c:	47a0      	blx	r4
        }
    }
    return res;
    302e:	9b05      	ldr	r3, [sp, #20]
}
    3030:	4618      	mov	r0, r3
    3032:	b006      	add	sp, #24
    3034:	bd10      	pop	{r4, pc}
    3036:	bf00      	nop
    3038:	20000d68 	.word	0x20000d68
    303c:	20000d6c 	.word	0x20000d6c

00003040 <mbed_mem_trace_calloc>:

void *mbed_mem_trace_calloc(void *res, size_t num, size_t size, void *caller)
{
    3040:	b510      	push	{r4, lr}
    3042:	b086      	sub	sp, #24
    3044:	9005      	str	r0, [sp, #20]
    3046:	9104      	str	r1, [sp, #16]
    3048:	9203      	str	r2, [sp, #12]
    304a:	9302      	str	r3, [sp, #8]
    if (mem_trace_cb) {
    304c:	4b0a      	ldr	r3, [pc, #40]	; (3078 <mbed_mem_trace_calloc+0x38>)
    304e:	681b      	ldr	r3, [r3, #0]
    3050:	2b00      	cmp	r3, #0
    3052:	d00c      	beq.n	306e <mbed_mem_trace_calloc+0x2e>
        if (TRACE_FIRST_LOCK()) {
    3054:	4b09      	ldr	r3, [pc, #36]	; (307c <mbed_mem_trace_calloc+0x3c>)
    3056:	781b      	ldrb	r3, [r3, #0]
    3058:	2b01      	cmp	r3, #1
    305a:	dc08      	bgt.n	306e <mbed_mem_trace_calloc+0x2e>
            mem_trace_cb(MBED_MEM_TRACE_CALLOC, res, caller, num, size);
    305c:	4b06      	ldr	r3, [pc, #24]	; (3078 <mbed_mem_trace_calloc+0x38>)
    305e:	681c      	ldr	r4, [r3, #0]
    3060:	9b03      	ldr	r3, [sp, #12]
    3062:	9300      	str	r3, [sp, #0]
    3064:	9b04      	ldr	r3, [sp, #16]
    3066:	9a02      	ldr	r2, [sp, #8]
    3068:	9905      	ldr	r1, [sp, #20]
    306a:	2002      	movs	r0, #2
    306c:	47a0      	blx	r4
        }
    }
    return res;
    306e:	9b05      	ldr	r3, [sp, #20]
}
    3070:	4618      	mov	r0, r3
    3072:	b006      	add	sp, #24
    3074:	bd10      	pop	{r4, pc}
    3076:	bf00      	nop
    3078:	20000d68 	.word	0x20000d68
    307c:	20000d6c 	.word	0x20000d6c

00003080 <mbed_mem_trace_free>:

void mbed_mem_trace_free(void *ptr, void *caller)
{
    3080:	b510      	push	{r4, lr}
    3082:	b082      	sub	sp, #8
    3084:	9001      	str	r0, [sp, #4]
    3086:	9100      	str	r1, [sp, #0]
    if (mem_trace_cb) {
    3088:	4b08      	ldr	r3, [pc, #32]	; (30ac <mbed_mem_trace_free+0x2c>)
    308a:	681b      	ldr	r3, [r3, #0]
    308c:	2b00      	cmp	r3, #0
    308e:	d00a      	beq.n	30a6 <mbed_mem_trace_free+0x26>
        if (TRACE_FIRST_LOCK()) {
    3090:	4b07      	ldr	r3, [pc, #28]	; (30b0 <mbed_mem_trace_free+0x30>)
    3092:	781b      	ldrb	r3, [r3, #0]
    3094:	2b01      	cmp	r3, #1
    3096:	dc06      	bgt.n	30a6 <mbed_mem_trace_free+0x26>
            mem_trace_cb(MBED_MEM_TRACE_FREE, NULL, caller, ptr);
    3098:	4b04      	ldr	r3, [pc, #16]	; (30ac <mbed_mem_trace_free+0x2c>)
    309a:	681c      	ldr	r4, [r3, #0]
    309c:	9b01      	ldr	r3, [sp, #4]
    309e:	9a00      	ldr	r2, [sp, #0]
    30a0:	2100      	movs	r1, #0
    30a2:	2003      	movs	r0, #3
    30a4:	47a0      	blx	r4
        }
    }
}
    30a6:	bf00      	nop
    30a8:	b002      	add	sp, #8
    30aa:	bd10      	pop	{r4, pc}
    30ac:	20000d68 	.word	0x20000d68
    30b0:	20000d6c 	.word	0x20000d6c

000030b4 <mbed_mem_trace_default_callback>:

void mbed_mem_trace_default_callback(uint8_t op, void *res, void *caller, ...)
{
    30b4:	b40c      	push	{r2, r3}
    30b6:	b500      	push	{lr}
    30b8:	b089      	sub	sp, #36	; 0x24
    30ba:	4603      	mov	r3, r0
    30bc:	9102      	str	r1, [sp, #8]
    30be:	f88d 300f 	strb.w	r3, [sp, #15]
    va_list va;
    size_t temp_s1, temp_s2;
    void *temp_ptr;

    va_start(va, caller);
    30c2:	ab0b      	add	r3, sp, #44	; 0x2c
    30c4:	9304      	str	r3, [sp, #16]
    switch (op) {
    30c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    30ca:	2b03      	cmp	r3, #3
    30cc:	d848      	bhi.n	3160 <mbed_mem_trace_default_callback+0xac>
    30ce:	a201      	add	r2, pc, #4	; (adr r2, 30d4 <mbed_mem_trace_default_callback+0x20>)
    30d0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    30d4:	000030e5 	.word	0x000030e5
    30d8:	000030fd 	.word	0x000030fd
    30dc:	00003123 	.word	0x00003123
    30e0:	00003149 	.word	0x00003149
        case MBED_MEM_TRACE_MALLOC:
            temp_s1 = va_arg(va, size_t);
    30e4:	9b04      	ldr	r3, [sp, #16]
    30e6:	1d1a      	adds	r2, r3, #4
    30e8:	9204      	str	r2, [sp, #16]
    30ea:	681b      	ldr	r3, [r3, #0]
    30ec:	9307      	str	r3, [sp, #28]
            printf(MBED_MEM_DEFAULT_TRACER_PREFIX "m:%p;%p-%u\n", res, caller, temp_s1);
    30ee:	9b07      	ldr	r3, [sp, #28]
    30f0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    30f2:	9902      	ldr	r1, [sp, #8]
    30f4:	481f      	ldr	r0, [pc, #124]	; (3174 <mbed_mem_trace_default_callback+0xc0>)
    30f6:	f008 fa13 	bl	b520 <printf>
            break;
    30fa:	e034      	b.n	3166 <mbed_mem_trace_default_callback+0xb2>

        case MBED_MEM_TRACE_REALLOC:
            temp_ptr = va_arg(va, void *);
    30fc:	9b04      	ldr	r3, [sp, #16]
    30fe:	1d1a      	adds	r2, r3, #4
    3100:	9204      	str	r2, [sp, #16]
    3102:	681b      	ldr	r3, [r3, #0]
    3104:	9306      	str	r3, [sp, #24]
            temp_s1 = va_arg(va, size_t);
    3106:	9b04      	ldr	r3, [sp, #16]
    3108:	1d1a      	adds	r2, r3, #4
    310a:	9204      	str	r2, [sp, #16]
    310c:	681b      	ldr	r3, [r3, #0]
    310e:	9307      	str	r3, [sp, #28]
            printf(MBED_MEM_DEFAULT_TRACER_PREFIX "r:%p;%p-%p;%u\n", res, caller, temp_ptr, temp_s1);
    3110:	9b07      	ldr	r3, [sp, #28]
    3112:	9300      	str	r3, [sp, #0]
    3114:	9b06      	ldr	r3, [sp, #24]
    3116:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    3118:	9902      	ldr	r1, [sp, #8]
    311a:	4817      	ldr	r0, [pc, #92]	; (3178 <mbed_mem_trace_default_callback+0xc4>)
    311c:	f008 fa00 	bl	b520 <printf>
            break;
    3120:	e021      	b.n	3166 <mbed_mem_trace_default_callback+0xb2>

        case MBED_MEM_TRACE_CALLOC:
            temp_s1 = va_arg(va, size_t);
    3122:	9b04      	ldr	r3, [sp, #16]
    3124:	1d1a      	adds	r2, r3, #4
    3126:	9204      	str	r2, [sp, #16]
    3128:	681b      	ldr	r3, [r3, #0]
    312a:	9307      	str	r3, [sp, #28]
            temp_s2 = va_arg(va, size_t);
    312c:	9b04      	ldr	r3, [sp, #16]
    312e:	1d1a      	adds	r2, r3, #4
    3130:	9204      	str	r2, [sp, #16]
    3132:	681b      	ldr	r3, [r3, #0]
    3134:	9305      	str	r3, [sp, #20]
            printf(MBED_MEM_DEFAULT_TRACER_PREFIX "c:%p;%p-%u;%u\n", res, caller, temp_s1, temp_s2);
    3136:	9b05      	ldr	r3, [sp, #20]
    3138:	9300      	str	r3, [sp, #0]
    313a:	9b07      	ldr	r3, [sp, #28]
    313c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    313e:	9902      	ldr	r1, [sp, #8]
    3140:	480e      	ldr	r0, [pc, #56]	; (317c <mbed_mem_trace_default_callback+0xc8>)
    3142:	f008 f9ed 	bl	b520 <printf>
            break;
    3146:	e00e      	b.n	3166 <mbed_mem_trace_default_callback+0xb2>

        case MBED_MEM_TRACE_FREE:
            temp_ptr = va_arg(va, void *);
    3148:	9b04      	ldr	r3, [sp, #16]
    314a:	1d1a      	adds	r2, r3, #4
    314c:	9204      	str	r2, [sp, #16]
    314e:	681b      	ldr	r3, [r3, #0]
    3150:	9306      	str	r3, [sp, #24]
            printf(MBED_MEM_DEFAULT_TRACER_PREFIX "f:%p;%p-%p\n", res, caller, temp_ptr);
    3152:	9b06      	ldr	r3, [sp, #24]
    3154:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    3156:	9902      	ldr	r1, [sp, #8]
    3158:	4809      	ldr	r0, [pc, #36]	; (3180 <mbed_mem_trace_default_callback+0xcc>)
    315a:	f008 f9e1 	bl	b520 <printf>
            break;
    315e:	e002      	b.n	3166 <mbed_mem_trace_default_callback+0xb2>

        default:
            printf("?\n");
    3160:	4808      	ldr	r0, [pc, #32]	; (3184 <mbed_mem_trace_default_callback+0xd0>)
    3162:	f008 f9dd 	bl	b520 <printf>
    }
    va_end(va);
}
    3166:	bf00      	nop
    3168:	b009      	add	sp, #36	; 0x24
    316a:	f85d eb04 	ldr.w	lr, [sp], #4
    316e:	b002      	add	sp, #8
    3170:	4770      	bx	lr
    3172:	bf00      	nop
    3174:	00010d94 	.word	0x00010d94
    3178:	00010da4 	.word	0x00010da4
    317c:	00010db4 	.word	0x00010db4
    3180:	00010dc4 	.word	0x00010dc4
    3184:	00010dd4 	.word	0x00010dd4

00003188 <_ZL14singleton_lockv>:
{
    3188:	b508      	push	{r3, lr}
    osMutexAcquire(singleton_mutex_id, osWaitForever);
    318a:	4b04      	ldr	r3, [pc, #16]	; (319c <_ZL14singleton_lockv+0x14>)
    318c:	681b      	ldr	r3, [r3, #0]
    318e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    3192:	4618      	mov	r0, r3
    3194:	f003 f9ec 	bl	6570 <osMutexAcquire>
}
    3198:	bf00      	nop
    319a:	bd08      	pop	{r3, pc}
    319c:	20001ed0 	.word	0x20001ed0

000031a0 <_ZL16singleton_unlockv>:
{
    31a0:	b508      	push	{r3, lr}
    osMutexRelease(singleton_mutex_id);
    31a2:	4b03      	ldr	r3, [pc, #12]	; (31b0 <_ZL16singleton_unlockv+0x10>)
    31a4:	681b      	ldr	r3, [r3, #0]
    31a6:	4618      	mov	r0, r3
    31a8:	f003 fa10 	bl	65cc <osMutexRelease>
}
    31ac:	bf00      	nop
    31ae:	bd08      	pop	{r3, pc}
    31b0:	20001ed0 	.word	0x20001ed0

000031b4 <_ZN12DirectSerial4seekEli>:
class DirectSerial : public FileHandle {
public:
    DirectSerial(PinName tx, PinName rx, int baud);
    virtual ssize_t write(const void *buffer, size_t size);
    virtual ssize_t read(void *buffer, size_t size);
    virtual off_t seek(off_t offset, int whence = SEEK_SET)
    31b4:	b084      	sub	sp, #16
    31b6:	9003      	str	r0, [sp, #12]
    31b8:	9102      	str	r1, [sp, #8]
    31ba:	9201      	str	r2, [sp, #4]
    {
        return -ESPIPE;
    31bc:	f06f 031c 	mvn.w	r3, #28
    }
    31c0:	4618      	mov	r0, r3
    31c2:	b004      	add	sp, #16
    31c4:	4770      	bx	lr

000031c6 <_ZN12DirectSerial4sizeEv>:
    virtual off_t size()
    31c6:	b082      	sub	sp, #8
    31c8:	9001      	str	r0, [sp, #4]
    {
        return -EINVAL;
    31ca:	f06f 0315 	mvn.w	r3, #21
    }
    31ce:	4618      	mov	r0, r3
    31d0:	b002      	add	sp, #8
    31d2:	4770      	bx	lr

000031d4 <_ZN12DirectSerial6isattyEv>:
    virtual int isatty()
    31d4:	b082      	sub	sp, #8
    31d6:	9001      	str	r0, [sp, #4]
    {
        return true;
    31d8:	2301      	movs	r3, #1
    }
    31da:	4618      	mov	r0, r3
    31dc:	b002      	add	sp, #8
    31de:	4770      	bx	lr

000031e0 <_ZN12DirectSerial5closeEv>:
    virtual int close()
    31e0:	b082      	sub	sp, #8
    31e2:	9001      	str	r0, [sp, #4]
    {
        return 0;
    31e4:	2300      	movs	r3, #0
    }
    31e6:	4618      	mov	r0, r3
    31e8:	b002      	add	sp, #8
    31ea:	4770      	bx	lr

000031ec <_ZN12DirectSerialC1E7PinNameS0_i>:
    virtual short poll(short events) const;
};

DirectSerial::DirectSerial(PinName tx, PinName rx, int baud)
    31ec:	b500      	push	{lr}
    31ee:	b085      	sub	sp, #20
    31f0:	9003      	str	r0, [sp, #12]
    31f2:	9102      	str	r1, [sp, #8]
    31f4:	9201      	str	r2, [sp, #4]
    31f6:	9300      	str	r3, [sp, #0]
    31f8:	9b03      	ldr	r3, [sp, #12]
    31fa:	4618      	mov	r0, r3
    31fc:	f7fe fc62 	bl	1ac4 <_ZN4mbed10FileHandleC1Ev>
    3200:	4a0b      	ldr	r2, [pc, #44]	; (3230 <_ZN12DirectSerialC1E7PinNameS0_i+0x44>)
    3202:	9b03      	ldr	r3, [sp, #12]
    3204:	601a      	str	r2, [r3, #0]
{
    if (stdio_uart_inited) {
    3206:	4b0b      	ldr	r3, [pc, #44]	; (3234 <_ZN12DirectSerialC1E7PinNameS0_i+0x48>)
    3208:	681b      	ldr	r3, [r3, #0]
    320a:	2b00      	cmp	r3, #0
    320c:	d109      	bne.n	3222 <_ZN12DirectSerialC1E7PinNameS0_i+0x36>
        return;
    }
    serial_init(&stdio_uart, tx, rx);
    320e:	9a01      	ldr	r2, [sp, #4]
    3210:	9902      	ldr	r1, [sp, #8]
    3212:	4809      	ldr	r0, [pc, #36]	; (3238 <_ZN12DirectSerialC1E7PinNameS0_i+0x4c>)
    3214:	f006 fba2 	bl	995c <serial_init>
    serial_baud(&stdio_uart, baud);
    3218:	9900      	ldr	r1, [sp, #0]
    321a:	4807      	ldr	r0, [pc, #28]	; (3238 <_ZN12DirectSerialC1E7PinNameS0_i+0x4c>)
    321c:	f006 fc38 	bl	9a90 <serial_baud>
    3220:	e000      	b.n	3224 <_ZN12DirectSerialC1E7PinNameS0_i+0x38>
        return;
    3222:	bf00      	nop
#elif CONSOLE_FLOWCONTROL == CONSOLE_FLOWCONTROL_CTS
    serial_set_flow_control(&stdio_uart, FlowControlCTS, NC, STDIO_UART_CTS);
#elif CONSOLE_FLOWCONTROL == CONSOLE_FLOWCONTROL_RTSCTS
    serial_set_flow_control(&stdio_uart, FlowControlRTSCTS, STDIO_UART_RTS, STDIO_UART_CTS);
#endif
}
    3224:	9b03      	ldr	r3, [sp, #12]
    3226:	4618      	mov	r0, r3
    3228:	b005      	add	sp, #20
    322a:	f85d fb04 	ldr.w	pc, [sp], #4
    322e:	bf00      	nop
    3230:	00012544 	.word	0x00012544
    3234:	20001538 	.word	0x20001538
    3238:	20002f6c 	.word	0x20002f6c

0000323c <_ZN12DirectSerial5writeEPKvj>:

ssize_t DirectSerial::write(const void *buffer, size_t size)
{
    323c:	b500      	push	{lr}
    323e:	b087      	sub	sp, #28
    3240:	9003      	str	r0, [sp, #12]
    3242:	9102      	str	r1, [sp, #8]
    3244:	9201      	str	r2, [sp, #4]
    const unsigned char *buf = static_cast<const unsigned char *>(buffer);
    3246:	9b02      	ldr	r3, [sp, #8]
    3248:	9304      	str	r3, [sp, #16]
    for (size_t i = 0; i < size; i++) {
    324a:	2300      	movs	r3, #0
    324c:	9305      	str	r3, [sp, #20]
    324e:	9a05      	ldr	r2, [sp, #20]
    3250:	9b01      	ldr	r3, [sp, #4]
    3252:	429a      	cmp	r2, r3
    3254:	d20b      	bcs.n	326e <_ZN12DirectSerial5writeEPKvj+0x32>
        serial_putc(&stdio_uart, buf[i]);
    3256:	9a04      	ldr	r2, [sp, #16]
    3258:	9b05      	ldr	r3, [sp, #20]
    325a:	4413      	add	r3, r2
    325c:	781b      	ldrb	r3, [r3, #0]
    325e:	4619      	mov	r1, r3
    3260:	4805      	ldr	r0, [pc, #20]	; (3278 <_ZN12DirectSerial5writeEPKvj+0x3c>)
    3262:	f006 fc51 	bl	9b08 <serial_putc>
    for (size_t i = 0; i < size; i++) {
    3266:	9b05      	ldr	r3, [sp, #20]
    3268:	3301      	adds	r3, #1
    326a:	9305      	str	r3, [sp, #20]
    326c:	e7ef      	b.n	324e <_ZN12DirectSerial5writeEPKvj+0x12>
    }
    return size;
    326e:	9b01      	ldr	r3, [sp, #4]
}
    3270:	4618      	mov	r0, r3
    3272:	b007      	add	sp, #28
    3274:	f85d fb04 	ldr.w	pc, [sp], #4
    3278:	20002f6c 	.word	0x20002f6c

0000327c <_ZN12DirectSerial4readEPvj>:

ssize_t DirectSerial::read(void *buffer, size_t size)
{
    327c:	b500      	push	{lr}
    327e:	b087      	sub	sp, #28
    3280:	9003      	str	r0, [sp, #12]
    3282:	9102      	str	r1, [sp, #8]
    3284:	9201      	str	r2, [sp, #4]
    unsigned char *buf = static_cast<unsigned char *>(buffer);
    3286:	9b02      	ldr	r3, [sp, #8]
    3288:	9305      	str	r3, [sp, #20]
    if (size == 0) {
    328a:	9b01      	ldr	r3, [sp, #4]
    328c:	2b00      	cmp	r3, #0
    328e:	d101      	bne.n	3294 <_ZN12DirectSerial4readEPvj+0x18>
        return 0;
    3290:	2300      	movs	r3, #0
    3292:	e007      	b.n	32a4 <_ZN12DirectSerial4readEPvj+0x28>
    }
    buf[0] = serial_getc(&stdio_uart);
    3294:	4805      	ldr	r0, [pc, #20]	; (32ac <_ZN12DirectSerial4readEPvj+0x30>)
    3296:	f006 fc19 	bl	9acc <serial_getc>
    329a:	4603      	mov	r3, r0
    329c:	b2da      	uxtb	r2, r3
    329e:	9b05      	ldr	r3, [sp, #20]
    32a0:	701a      	strb	r2, [r3, #0]
    return 1;
    32a2:	2301      	movs	r3, #1
}
    32a4:	4618      	mov	r0, r3
    32a6:	b007      	add	sp, #28
    32a8:	f85d fb04 	ldr.w	pc, [sp], #4
    32ac:	20002f6c 	.word	0x20002f6c

000032b0 <_ZNK12DirectSerial4pollEs>:

short DirectSerial::poll(short events) const
{
    32b0:	b500      	push	{lr}
    32b2:	b085      	sub	sp, #20
    32b4:	9001      	str	r0, [sp, #4]
    32b6:	460b      	mov	r3, r1
    32b8:	f8ad 3002 	strh.w	r3, [sp, #2]
    short revents = 0;
    32bc:	2300      	movs	r3, #0
    32be:	f8ad 300e 	strh.w	r3, [sp, #14]
    if ((events & POLLIN) && serial_readable(&stdio_uart)) {
    32c2:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    32c6:	f003 0301 	and.w	r3, r3, #1
    32ca:	2b00      	cmp	r3, #0
    32cc:	d007      	beq.n	32de <_ZNK12DirectSerial4pollEs+0x2e>
    32ce:	4817      	ldr	r0, [pc, #92]	; (332c <_ZNK12DirectSerial4pollEs+0x7c>)
    32d0:	f006 fc36 	bl	9b40 <serial_readable>
    32d4:	4603      	mov	r3, r0
    32d6:	2b00      	cmp	r3, #0
    32d8:	d001      	beq.n	32de <_ZNK12DirectSerial4pollEs+0x2e>
    32da:	2301      	movs	r3, #1
    32dc:	e000      	b.n	32e0 <_ZNK12DirectSerial4pollEs+0x30>
    32de:	2300      	movs	r3, #0
    32e0:	2b00      	cmp	r3, #0
    32e2:	d005      	beq.n	32f0 <_ZNK12DirectSerial4pollEs+0x40>
        revents |= POLLIN;
    32e4:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    32e8:	f043 0301 	orr.w	r3, r3, #1
    32ec:	f8ad 300e 	strh.w	r3, [sp, #14]
    }
    if ((events & POLLOUT) && serial_writable(&stdio_uart)) {
    32f0:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    32f4:	f003 0310 	and.w	r3, r3, #16
    32f8:	2b00      	cmp	r3, #0
    32fa:	d007      	beq.n	330c <_ZNK12DirectSerial4pollEs+0x5c>
    32fc:	480b      	ldr	r0, [pc, #44]	; (332c <_ZNK12DirectSerial4pollEs+0x7c>)
    32fe:	f006 fc43 	bl	9b88 <serial_writable>
    3302:	4603      	mov	r3, r0
    3304:	2b00      	cmp	r3, #0
    3306:	d001      	beq.n	330c <_ZNK12DirectSerial4pollEs+0x5c>
    3308:	2301      	movs	r3, #1
    330a:	e000      	b.n	330e <_ZNK12DirectSerial4pollEs+0x5e>
    330c:	2300      	movs	r3, #0
    330e:	2b00      	cmp	r3, #0
    3310:	d005      	beq.n	331e <_ZNK12DirectSerial4pollEs+0x6e>
        revents |= POLLOUT;
    3312:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    3316:	f043 0310 	orr.w	r3, r3, #16
    331a:	f8ad 300e 	strh.w	r3, [sp, #14]
    }
    return revents;
    331e:	f9bd 300e 	ldrsh.w	r3, [sp, #14]
}
    3322:	4618      	mov	r0, r3
    3324:	b005      	add	sp, #20
    3326:	f85d fb04 	ldr.w	pc, [sp], #4
    332a:	bf00      	nop
    332c:	20002f6c 	.word	0x20002f6c

00003330 <_ZN4mbed28mbed_target_override_consoleEi>:
    return 1;
}


MBED_WEAK FileHandle *mbed::mbed_target_override_console(int fd)
{
    3330:	b082      	sub	sp, #8
    3332:	9001      	str	r0, [sp, #4]
    return NULL;
    3334:	2300      	movs	r3, #0
}
    3336:	4618      	mov	r0, r3
    3338:	b002      	add	sp, #8
    333a:	4770      	bx	lr

0000333c <_ZN4mbed21mbed_override_consoleEi>:

MBED_WEAK FileHandle *mbed::mbed_override_console(int fd)
{
    333c:	b082      	sub	sp, #8
    333e:	9001      	str	r0, [sp, #4]
    return NULL;
    3340:	2300      	movs	r3, #0
}
    3342:	4618      	mov	r0, r3
    3344:	b002      	add	sp, #8
    3346:	4770      	bx	lr

00003348 <_ZL15default_consolev>:

static FileHandle *default_console()
{
    3348:	b508      	push	{r3, lr}
    console.set_flow_control(SerialBase::CTS, NC, STDIO_UART_CTS);
#   elif CONSOLE_FLOWCONTROL == CONSOLE_FLOWCONTROL_RTSCTS
    console.set_flow_control(SerialBase::RTSCTS, STDIO_UART_RTS, STDIO_UART_CTS);
#   endif
#  else
    static DirectSerial console(STDIO_UART_TX, STDIO_UART_RX, MBED_CONF_PLATFORM_STDIO_BAUD_RATE);
    334a:	4b16      	ldr	r3, [pc, #88]	; (33a4 <_ZL15default_consolev+0x5c>)
    334c:	781b      	ldrb	r3, [r3, #0]
    334e:	f3bf 8f5b 	dmb	ish
    3352:	b2db      	uxtb	r3, r3
    3354:	f003 0301 	and.w	r3, r3, #1
    3358:	2b00      	cmp	r3, #0
    335a:	bf0c      	ite	eq
    335c:	2301      	moveq	r3, #1
    335e:	2300      	movne	r3, #0
    3360:	b2db      	uxtb	r3, r3
    3362:	2b00      	cmp	r3, #0
    3364:	d01b      	beq.n	339e <_ZL15default_consolev+0x56>
    3366:	480f      	ldr	r0, [pc, #60]	; (33a4 <_ZL15default_consolev+0x5c>)
    3368:	f000 fbb2 	bl	3ad0 <__cxa_guard_acquire>
    336c:	4603      	mov	r3, r0
    336e:	2b00      	cmp	r3, #0
    3370:	bf14      	ite	ne
    3372:	2301      	movne	r3, #1
    3374:	2300      	moveq	r3, #0
    3376:	b2db      	uxtb	r3, r3
    3378:	2b00      	cmp	r3, #0
    337a:	d010      	beq.n	339e <_ZL15default_consolev+0x56>
    337c:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
    3380:	f241 0210 	movw	r2, #4112	; 0x1010
    3384:	f241 0111 	movw	r1, #4113	; 0x1011
    3388:	4807      	ldr	r0, [pc, #28]	; (33a8 <_ZL15default_consolev+0x60>)
    338a:	f7ff ff2f 	bl	31ec <_ZN12DirectSerialC1E7PinNameS0_i>
    338e:	4805      	ldr	r0, [pc, #20]	; (33a4 <_ZL15default_consolev+0x5c>)
    3390:	f000 fbd4 	bl	3b3c <__cxa_guard_release>
    3394:	4a05      	ldr	r2, [pc, #20]	; (33ac <_ZL15default_consolev+0x64>)
    3396:	4906      	ldr	r1, [pc, #24]	; (33b0 <_ZL15default_consolev+0x68>)
    3398:	4803      	ldr	r0, [pc, #12]	; (33a8 <_ZL15default_consolev+0x60>)
    339a:	f000 fb6d 	bl	3a78 <__aeabi_atexit>
#  endif
#else // DEVICE_SERIAL
    static Sink console;
#endif
    return &console;
    339e:	4b02      	ldr	r3, [pc, #8]	; (33a8 <_ZL15default_consolev+0x60>)
}
    33a0:	4618      	mov	r0, r3
    33a2:	bd08      	pop	{r3, pc}
    33a4:	20000e24 	.word	0x20000e24
    33a8:	20000e20 	.word	0x20000e20
    33ac:	20000000 	.word	0x20000000
    33b0:	00003bf1 	.word	0x00003bf1

000033b4 <_ZL11get_consolei>:

/* Locate the default console for stdout, stdin, stderr */
static FileHandle *get_console(int fd)
{
    33b4:	b500      	push	{lr}
    33b6:	b085      	sub	sp, #20
    33b8:	9001      	str	r0, [sp, #4]
    FileHandle *fh = mbed_override_console(fd);
    33ba:	9801      	ldr	r0, [sp, #4]
    33bc:	f7ff ffbe 	bl	333c <_ZN4mbed21mbed_override_consoleEi>
    33c0:	9003      	str	r0, [sp, #12]
    if (fh) {
    33c2:	9b03      	ldr	r3, [sp, #12]
    33c4:	2b00      	cmp	r3, #0
    33c6:	d001      	beq.n	33cc <_ZL11get_consolei+0x18>
        return fh;
    33c8:	9b03      	ldr	r3, [sp, #12]
    33ca:	e00b      	b.n	33e4 <_ZL11get_consolei+0x30>
    }
    fh = mbed_target_override_console(fd);
    33cc:	9801      	ldr	r0, [sp, #4]
    33ce:	f7ff ffaf 	bl	3330 <_ZN4mbed28mbed_target_override_consoleEi>
    33d2:	9003      	str	r0, [sp, #12]
    if (fh) {
    33d4:	9b03      	ldr	r3, [sp, #12]
    33d6:	2b00      	cmp	r3, #0
    33d8:	d001      	beq.n	33de <_ZL11get_consolei+0x2a>
        return fh;
    33da:	9b03      	ldr	r3, [sp, #12]
    33dc:	e002      	b.n	33e4 <_ZL11get_consolei+0x30>
    }
    return default_console();
    33de:	f7ff ffb3 	bl	3348 <_ZL15default_consolev>
    33e2:	4603      	mov	r3, r0
}
    33e4:	4618      	mov	r0, r3
    33e6:	b005      	add	sp, #20
    33e8:	f85d fb04 	ldr.w	pc, [sp], #4

000033ec <_ZL7get_fhci>:

/* Deal with the fact C library may not _open descriptors 0, 1, 2 - auto bind */
static FileHandle *get_fhc(int fd)
{
    33ec:	b500      	push	{lr}
    33ee:	b085      	sub	sp, #20
    33f0:	9001      	str	r0, [sp, #4]
    if (fd >= OPEN_MAX) {
    33f2:	9b01      	ldr	r3, [sp, #4]
    33f4:	2b3f      	cmp	r3, #63	; 0x3f
    33f6:	dd01      	ble.n	33fc <_ZL7get_fhci+0x10>
        return NULL;
    33f8:	2300      	movs	r3, #0
    33fa:	e015      	b.n	3428 <_ZL7get_fhci+0x3c>
    }
    FileHandle *fh = filehandles[fd];
    33fc:	4a0c      	ldr	r2, [pc, #48]	; (3430 <_ZL7get_fhci+0x44>)
    33fe:	9b01      	ldr	r3, [sp, #4]
    3400:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3404:	9303      	str	r3, [sp, #12]
    if (fh == FILE_HANDLE_RESERVED && fd < 3) {
    3406:	9b03      	ldr	r3, [sp, #12]
    3408:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    340c:	d10b      	bne.n	3426 <_ZL7get_fhci+0x3a>
    340e:	9b01      	ldr	r3, [sp, #4]
    3410:	2b02      	cmp	r3, #2
    3412:	dc08      	bgt.n	3426 <_ZL7get_fhci+0x3a>
        filehandles[fd] = fh = get_console(fd);
    3414:	9801      	ldr	r0, [sp, #4]
    3416:	f7ff ffcd 	bl	33b4 <_ZL11get_consolei>
    341a:	9003      	str	r0, [sp, #12]
    341c:	4904      	ldr	r1, [pc, #16]	; (3430 <_ZL7get_fhci+0x44>)
    341e:	9b01      	ldr	r3, [sp, #4]
    3420:	9a03      	ldr	r2, [sp, #12]
    3422:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    return fh;
    3426:	9b03      	ldr	r3, [sp, #12]
}
    3428:	4618      	mov	r0, r3
    342a:	b005      	add	sp, #20
    342c:	f85d fb04 	ldr.w	pc, [sp], #4
    3430:	20000008 	.word	0x20000008

00003434 <_close>:

    return fildes;
}

extern "C" int PREFIX(_close)(FILEHANDLE fh)
{
    3434:	b500      	push	{lr}
    3436:	b083      	sub	sp, #12
    3438:	9001      	str	r0, [sp, #4]
    return close(fh);
    343a:	9801      	ldr	r0, [sp, #4]
    343c:	f000 f806 	bl	344c <close>
    3440:	4603      	mov	r3, r0
}
    3442:	4618      	mov	r0, r3
    3444:	b003      	add	sp, #12
    3446:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0000344c <close>:

extern "C" int close(int fildes)
{
    344c:	b500      	push	{lr}
    344e:	b085      	sub	sp, #20
    3450:	9001      	str	r0, [sp, #4]
    FileHandle *fhc = get_fhc(fildes);
    3452:	9801      	ldr	r0, [sp, #4]
    3454:	f7ff ffca 	bl	33ec <_ZL7get_fhci>
    3458:	9003      	str	r0, [sp, #12]
    filehandles[fildes] = NULL;
    345a:	4a14      	ldr	r2, [pc, #80]	; (34ac <close+0x60>)
    345c:	9b01      	ldr	r3, [sp, #4]
    345e:	2100      	movs	r1, #0
    3460:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    if (fhc == NULL) {
    3464:	9b03      	ldr	r3, [sp, #12]
    3466:	2b00      	cmp	r3, #0
    3468:	d107      	bne.n	347a <close+0x2e>
        errno = EBADF;
    346a:	f006 ff71 	bl	a350 <__errno>
    346e:	4602      	mov	r2, r0
    3470:	2309      	movs	r3, #9
    3472:	6013      	str	r3, [r2, #0]
        return -1;
    3474:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3478:	e013      	b.n	34a2 <close+0x56>
    }

    int err = fhc->close();
    347a:	9b03      	ldr	r3, [sp, #12]
    347c:	681b      	ldr	r3, [r3, #0]
    347e:	3314      	adds	r3, #20
    3480:	681b      	ldr	r3, [r3, #0]
    3482:	9803      	ldr	r0, [sp, #12]
    3484:	4798      	blx	r3
    3486:	9002      	str	r0, [sp, #8]
    if (err < 0) {
    3488:	9b02      	ldr	r3, [sp, #8]
    348a:	2b00      	cmp	r3, #0
    348c:	da08      	bge.n	34a0 <close+0x54>
        errno = -err;
    348e:	f006 ff5f 	bl	a350 <__errno>
    3492:	4602      	mov	r2, r0
    3494:	9b02      	ldr	r3, [sp, #8]
    3496:	425b      	negs	r3, r3
    3498:	6013      	str	r3, [r2, #0]
        return -1;
    349a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    349e:	e000      	b.n	34a2 <close+0x56>
    } else {
        return 0;
    34a0:	2300      	movs	r3, #0
    }
}
    34a2:	4618      	mov	r0, r3
    34a4:	b005      	add	sp, #20
    34a6:	f85d fb04 	ldr.w	pc, [sp], #4
    34aa:	bf00      	nop
    34ac:	20000008 	.word	0x20000008

000034b0 <_ZL12convert_crlfi>:

static bool convert_crlf(int fd)
{
    34b0:	b500      	push	{lr}
    34b2:	b083      	sub	sp, #12
    34b4:	9001      	str	r0, [sp, #4]
#if MBED_CONF_PLATFORM_STDIO_CONVERT_TTY_NEWLINES
    return isatty(fd);
#elif MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES
    return fd < 3 && isatty(fd);
    34b6:	9b01      	ldr	r3, [sp, #4]
    34b8:	2b02      	cmp	r3, #2
    34ba:	dc07      	bgt.n	34cc <_ZL12convert_crlfi+0x1c>
    34bc:	9801      	ldr	r0, [sp, #4]
    34be:	f000 f9d8 	bl	3872 <isatty>
    34c2:	4603      	mov	r3, r0
    34c4:	2b00      	cmp	r3, #0
    34c6:	d001      	beq.n	34cc <_ZL12convert_crlfi+0x1c>
    34c8:	2301      	movs	r3, #1
    34ca:	e000      	b.n	34ce <_ZL12convert_crlfi+0x1e>
    34cc:	2300      	movs	r3, #0
#else
    return false;
#endif
}
    34ce:	4618      	mov	r0, r3
    34d0:	b003      	add	sp, #12
    34d2:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000034d8 <_write>:
#if defined(__ICCARM__)
extern "C" size_t    __write(int        fh, const unsigned char *buffer, size_t length)
{
#else
extern "C" int PREFIX(_write)(FILEHANDLE fh, const unsigned char *buffer, unsigned int length, int mode)
{
    34d8:	b500      	push	{lr}
    34da:	b08d      	sub	sp, #52	; 0x34
    34dc:	9005      	str	r0, [sp, #20]
    34de:	9104      	str	r1, [sp, #16]
    34e0:	9203      	str	r2, [sp, #12]
    34e2:	9302      	str	r3, [sp, #8]
#endif

#if defined(MBED_TRAP_ERRORS_ENABLED) && MBED_TRAP_ERRORS_ENABLED && defined(MBED_CONF_RTOS_PRESENT)
    if (core_util_is_isr_active() || !core_util_are_interrupts_enabled()) {
    34e4:	f7ff fb49 	bl	2b7a <core_util_is_isr_active>
    34e8:	4603      	mov	r3, r0
    34ea:	2b00      	cmp	r3, #0
    34ec:	d107      	bne.n	34fe <_write+0x26>
    34ee:	f7ff fb35 	bl	2b5c <core_util_are_interrupts_enabled>
    34f2:	4603      	mov	r3, r0
    34f4:	f083 0301 	eor.w	r3, r3, #1
    34f8:	b2db      	uxtb	r3, r3
    34fa:	2b00      	cmp	r3, #0
    34fc:	d001      	beq.n	3502 <_write+0x2a>
    34fe:	2301      	movs	r3, #1
    3500:	e000      	b.n	3504 <_write+0x2c>
    3502:	2300      	movs	r3, #0
    3504:	2b00      	cmp	r3, #0
    3506:	d007      	beq.n	3518 <_write+0x40>
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_PROHIBITED_IN_ISR_CONTEXT), "Error - writing to a file in an ISR or critical section\r\n", fh);
    3508:	9a05      	ldr	r2, [sp, #20]
    350a:	2300      	movs	r3, #0
    350c:	9300      	str	r3, [sp, #0]
    350e:	2300      	movs	r3, #0
    3510:	494f      	ldr	r1, [pc, #316]	; (3650 <_write+0x178>)
    3512:	4850      	ldr	r0, [pc, #320]	; (3654 <_write+0x17c>)
    3514:	f7ff fc50 	bl	2db8 <mbed_error>
    }
#endif

    if (length > SSIZE_MAX) {
    3518:	9b03      	ldr	r3, [sp, #12]
    351a:	2b00      	cmp	r3, #0
    351c:	da07      	bge.n	352e <_write+0x56>
        errno = EINVAL;
    351e:	f006 ff17 	bl	a350 <__errno>
    3522:	4602      	mov	r2, r0
    3524:	2316      	movs	r3, #22
    3526:	6013      	str	r3, [r2, #0]
        return -1;
    3528:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    352c:	e08b      	b.n	3646 <_write+0x16e>
    }

    ssize_t slength = length;
    352e:	9b03      	ldr	r3, [sp, #12]
    3530:	9308      	str	r3, [sp, #32]
    ssize_t written = 0;
    3532:	2300      	movs	r3, #0
    3534:	930b      	str	r3, [sp, #44]	; 0x2c

    if (convert_crlf(fh)) {
    3536:	9805      	ldr	r0, [sp, #20]
    3538:	f7ff ffba 	bl	34b0 <_ZL12convert_crlfi>
    353c:	4603      	mov	r3, r0
    353e:	2b00      	cmp	r3, #0
    3540:	d056      	beq.n	35f0 <_write+0x118>
        // local prev is previous in buffer during seek
        // stdio_out_prev[fh] is last thing actually written
        char prev = stdio_out_prev[fh];
    3542:	4a45      	ldr	r2, [pc, #276]	; (3658 <_write+0x180>)
    3544:	9b05      	ldr	r3, [sp, #20]
    3546:	4413      	add	r3, r2
    3548:	781b      	ldrb	r3, [r3, #0]
    354a:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
        // Seek for '\n' without preceding '\r'; if found flush
        // preceding and insert '\r'. Continue until end of input.
        for (ssize_t cur = 0; cur < slength; cur++) {
    354e:	2300      	movs	r3, #0
    3550:	9309      	str	r3, [sp, #36]	; 0x24
    3552:	9a09      	ldr	r2, [sp, #36]	; 0x24
    3554:	9b08      	ldr	r3, [sp, #32]
    3556:	429a      	cmp	r2, r3
    3558:	da4a      	bge.n	35f0 <_write+0x118>
            if (buffer[cur] == '\n' && prev != '\r') {
    355a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    355c:	9a04      	ldr	r2, [sp, #16]
    355e:	4413      	add	r3, r2
    3560:	781b      	ldrb	r3, [r3, #0]
    3562:	2b0a      	cmp	r3, #10
    3564:	d13a      	bne.n	35dc <_write+0x104>
    3566:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    356a:	2b0d      	cmp	r3, #13
    356c:	d036      	beq.n	35dc <_write+0x104>
                ssize_t r;
                // flush stuff preceding the \n
                if (cur > written) {
    356e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    3570:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3572:	429a      	cmp	r2, r3
    3574:	dd1e      	ble.n	35b4 <_write+0xdc>
                    r = write(fh, buffer + written, cur - written);
    3576:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3578:	9a04      	ldr	r2, [sp, #16]
    357a:	18d1      	adds	r1, r2, r3
    357c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    357e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3580:	1ad3      	subs	r3, r2, r3
    3582:	461a      	mov	r2, r3
    3584:	9805      	ldr	r0, [sp, #20]
    3586:	f000 f86b 	bl	3660 <write>
    358a:	9007      	str	r0, [sp, #28]
                    if (r < 0) {
    358c:	9b07      	ldr	r3, [sp, #28]
    358e:	2b00      	cmp	r3, #0
    3590:	da02      	bge.n	3598 <_write+0xc0>
                        return -1;
    3592:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3596:	e056      	b.n	3646 <_write+0x16e>
                    }
                    written += r;
    3598:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    359a:	9b07      	ldr	r3, [sp, #28]
    359c:	4413      	add	r3, r2
    359e:	930b      	str	r3, [sp, #44]	; 0x2c
                    if (written < cur) {
    35a0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    35a2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    35a4:	429a      	cmp	r2, r3
    35a6:	db4a      	blt.n	363e <_write+0x166>
                        // For some reason, didn't write all - give up now
                        goto finish;
                    }
                    stdio_out_prev[fh] = prev;
    35a8:	4a2b      	ldr	r2, [pc, #172]	; (3658 <_write+0x180>)
    35aa:	9b05      	ldr	r3, [sp, #20]
    35ac:	4413      	add	r3, r2
    35ae:	f89d 202b 	ldrb.w	r2, [sp, #43]	; 0x2b
    35b2:	701a      	strb	r2, [r3, #0]
                }
                // insert a \r now, leaving the \n still to be written
                r = write(fh, "\r", 1);
    35b4:	2201      	movs	r2, #1
    35b6:	4929      	ldr	r1, [pc, #164]	; (365c <_write+0x184>)
    35b8:	9805      	ldr	r0, [sp, #20]
    35ba:	f000 f851 	bl	3660 <write>
    35be:	9007      	str	r0, [sp, #28]
                if (r < 0) {
    35c0:	9b07      	ldr	r3, [sp, #28]
    35c2:	2b00      	cmp	r3, #0
    35c4:	da02      	bge.n	35cc <_write+0xf4>
                    return -1;
    35c6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    35ca:	e03c      	b.n	3646 <_write+0x16e>
                }
                if (r < 1) {
    35cc:	9b07      	ldr	r3, [sp, #28]
    35ce:	2b00      	cmp	r3, #0
    35d0:	dd37      	ble.n	3642 <_write+0x16a>
                    goto finish;
                }
                stdio_out_prev[fh] = '\r';
    35d2:	4a21      	ldr	r2, [pc, #132]	; (3658 <_write+0x180>)
    35d4:	9b05      	ldr	r3, [sp, #20]
    35d6:	4413      	add	r3, r2
    35d8:	220d      	movs	r2, #13
    35da:	701a      	strb	r2, [r3, #0]
            }
            prev = buffer[cur];
    35dc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    35de:	9a04      	ldr	r2, [sp, #16]
    35e0:	4413      	add	r3, r2
    35e2:	781b      	ldrb	r3, [r3, #0]
    35e4:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
        for (ssize_t cur = 0; cur < slength; cur++) {
    35e8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    35ea:	3301      	adds	r3, #1
    35ec:	9309      	str	r3, [sp, #36]	; 0x24
    35ee:	e7b0      	b.n	3552 <_write+0x7a>
        }
    }

    // Flush remaining from conversion, or the whole thing if no conversion
    if (written < slength) {
    35f0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    35f2:	9b08      	ldr	r3, [sp, #32]
    35f4:	429a      	cmp	r2, r3
    35f6:	da25      	bge.n	3644 <_write+0x16c>
        ssize_t r = write(fh, buffer + written, slength - written);
    35f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    35fa:	9a04      	ldr	r2, [sp, #16]
    35fc:	18d1      	adds	r1, r2, r3
    35fe:	9a08      	ldr	r2, [sp, #32]
    3600:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3602:	1ad3      	subs	r3, r2, r3
    3604:	461a      	mov	r2, r3
    3606:	9805      	ldr	r0, [sp, #20]
    3608:	f000 f82a 	bl	3660 <write>
    360c:	9006      	str	r0, [sp, #24]
        if (r < 0) {
    360e:	9b06      	ldr	r3, [sp, #24]
    3610:	2b00      	cmp	r3, #0
    3612:	da02      	bge.n	361a <_write+0x142>
            return -1;
    3614:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3618:	e015      	b.n	3646 <_write+0x16e>
        }
        written += r;
    361a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    361c:	9b06      	ldr	r3, [sp, #24]
    361e:	4413      	add	r3, r2
    3620:	930b      	str	r3, [sp, #44]	; 0x2c
        if (written > 0) {
    3622:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3624:	2b00      	cmp	r3, #0
    3626:	dd0d      	ble.n	3644 <_write+0x16c>
            stdio_out_prev[fh] = buffer[written - 1];
    3628:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    362a:	3b01      	subs	r3, #1
    362c:	9a04      	ldr	r2, [sp, #16]
    362e:	4413      	add	r3, r2
    3630:	7819      	ldrb	r1, [r3, #0]
    3632:	4a09      	ldr	r2, [pc, #36]	; (3658 <_write+0x180>)
    3634:	9b05      	ldr	r3, [sp, #20]
    3636:	4413      	add	r3, r2
    3638:	460a      	mov	r2, r1
    363a:	701a      	strb	r2, [r3, #0]
    363c:	e002      	b.n	3644 <_write+0x16c>
                        goto finish;
    363e:	bf00      	nop
    3640:	e000      	b.n	3644 <_write+0x16c>
                    goto finish;
    3642:	bf00      	nop
        return slength - written;
    } else {
        return written;
    }
#else
    return written;
    3644:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
#endif
}
    3646:	4618      	mov	r0, r3
    3648:	b00d      	add	sp, #52	; 0x34
    364a:	f85d fb04 	ldr.w	pc, [sp], #4
    364e:	bf00      	nop
    3650:	00010e10 	.word	0x00010e10
    3654:	8001012f 	.word	0x8001012f
    3658:	20000de0 	.word	0x20000de0
    365c:	00010e4c 	.word	0x00010e4c

00003660 <write>:

extern "C" ssize_t write(int fildes, const void *buf, size_t length)
{
    3660:	b500      	push	{lr}
    3662:	b087      	sub	sp, #28
    3664:	9003      	str	r0, [sp, #12]
    3666:	9102      	str	r1, [sp, #8]
    3668:	9201      	str	r2, [sp, #4]

    FileHandle *fhc = get_fhc(fildes);
    366a:	9803      	ldr	r0, [sp, #12]
    366c:	f7ff febe 	bl	33ec <_ZL7get_fhci>
    3670:	9005      	str	r0, [sp, #20]
    if (fhc == NULL) {
    3672:	9b05      	ldr	r3, [sp, #20]
    3674:	2b00      	cmp	r3, #0
    3676:	d107      	bne.n	3688 <write+0x28>
        errno = EBADF;
    3678:	f006 fe6a 	bl	a350 <__errno>
    367c:	4602      	mov	r2, r0
    367e:	2309      	movs	r3, #9
    3680:	6013      	str	r3, [r2, #0]
        return -1;
    3682:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3686:	e015      	b.n	36b4 <write+0x54>
    }

    ssize_t ret = fhc->write(buf, length);
    3688:	9b05      	ldr	r3, [sp, #20]
    368a:	681b      	ldr	r3, [r3, #0]
    368c:	330c      	adds	r3, #12
    368e:	681b      	ldr	r3, [r3, #0]
    3690:	9a01      	ldr	r2, [sp, #4]
    3692:	9902      	ldr	r1, [sp, #8]
    3694:	9805      	ldr	r0, [sp, #20]
    3696:	4798      	blx	r3
    3698:	9004      	str	r0, [sp, #16]
    if (ret < 0) {
    369a:	9b04      	ldr	r3, [sp, #16]
    369c:	2b00      	cmp	r3, #0
    369e:	da08      	bge.n	36b2 <write+0x52>
        errno = -ret;
    36a0:	f006 fe56 	bl	a350 <__errno>
    36a4:	4602      	mov	r2, r0
    36a6:	9b04      	ldr	r3, [sp, #16]
    36a8:	425b      	negs	r3, r3
    36aa:	6013      	str	r3, [r2, #0]
        return -1;
    36ac:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    36b0:	e000      	b.n	36b4 <write+0x54>
    } else {
        return ret;
    36b2:	9b04      	ldr	r3, [sp, #16]
    }
}
    36b4:	4618      	mov	r0, r3
    36b6:	b007      	add	sp, #28
    36b8:	f85d fb04 	ldr.w	pc, [sp], #4

000036bc <_read>:
#if defined(__ICCARM__)
extern "C" size_t    __read(int        fh, unsigned char *buffer, size_t       length)
{
#else
extern "C" int PREFIX(_read)(FILEHANDLE fh, unsigned char *buffer, unsigned int length, int mode)
{
    36bc:	b500      	push	{lr}
    36be:	b08b      	sub	sp, #44	; 0x2c
    36c0:	9005      	str	r0, [sp, #20]
    36c2:	9104      	str	r1, [sp, #16]
    36c4:	9203      	str	r2, [sp, #12]
    36c6:	9302      	str	r3, [sp, #8]
#endif

#if defined(MBED_TRAP_ERRORS_ENABLED) && MBED_TRAP_ERRORS_ENABLED && defined(MBED_CONF_RTOS_PRESENT)
    if (core_util_is_isr_active() || !core_util_are_interrupts_enabled()) {
    36c8:	f7ff fa57 	bl	2b7a <core_util_is_isr_active>
    36cc:	4603      	mov	r3, r0
    36ce:	2b00      	cmp	r3, #0
    36d0:	d107      	bne.n	36e2 <_read+0x26>
    36d2:	f7ff fa43 	bl	2b5c <core_util_are_interrupts_enabled>
    36d6:	4603      	mov	r3, r0
    36d8:	f083 0301 	eor.w	r3, r3, #1
    36dc:	b2db      	uxtb	r3, r3
    36de:	2b00      	cmp	r3, #0
    36e0:	d001      	beq.n	36e6 <_read+0x2a>
    36e2:	2301      	movs	r3, #1
    36e4:	e000      	b.n	36e8 <_read+0x2c>
    36e6:	2300      	movs	r3, #0
    36e8:	2b00      	cmp	r3, #0
    36ea:	d007      	beq.n	36fc <_read+0x40>
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_PROHIBITED_IN_ISR_CONTEXT), "Error - reading from a file in an ISR or critical section\r\n", fh);
    36ec:	9a05      	ldr	r2, [sp, #20]
    36ee:	2300      	movs	r3, #0
    36f0:	9300      	str	r3, [sp, #0]
    36f2:	2300      	movs	r3, #0
    36f4:	493f      	ldr	r1, [pc, #252]	; (37f4 <_read+0x138>)
    36f6:	4840      	ldr	r0, [pc, #256]	; (37f8 <_read+0x13c>)
    36f8:	f7ff fb5e 	bl	2db8 <mbed_error>
    }
#endif

    if (length > SSIZE_MAX) {
    36fc:	9b03      	ldr	r3, [sp, #12]
    36fe:	2b00      	cmp	r3, #0
    3700:	da07      	bge.n	3712 <_read+0x56>
        errno = EINVAL;
    3702:	f006 fe25 	bl	a350 <__errno>
    3706:	4602      	mov	r2, r0
    3708:	2316      	movs	r3, #22
    370a:	6013      	str	r3, [r2, #0]
        return -1;
    370c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3710:	e06b      	b.n	37ea <_read+0x12e>
    }

    ssize_t bytes_read = 0;
    3712:	2300      	movs	r3, #0
    3714:	9309      	str	r3, [sp, #36]	; 0x24

    if (convert_crlf(fh)) {
    3716:	9805      	ldr	r0, [sp, #20]
    3718:	f7ff feca 	bl	34b0 <_ZL12convert_crlfi>
    371c:	4603      	mov	r3, r0
    371e:	2b00      	cmp	r3, #0
    3720:	d05c      	beq.n	37dc <_read+0x120>
        while (true) {
            char c;
            ssize_t r = read(fh, &c, 1);
    3722:	f10d 031f 	add.w	r3, sp, #31
    3726:	2201      	movs	r2, #1
    3728:	4619      	mov	r1, r3
    372a:	9805      	ldr	r0, [sp, #20]
    372c:	f000 f868 	bl	3800 <read>
    3730:	9008      	str	r0, [sp, #32]
            if (r < 0) {
    3732:	9b08      	ldr	r3, [sp, #32]
    3734:	2b00      	cmp	r3, #0
    3736:	da02      	bge.n	373e <_read+0x82>
                return -1;
    3738:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    373c:	e055      	b.n	37ea <_read+0x12e>
            }
            if (r == 0) {
    373e:	9b08      	ldr	r3, [sp, #32]
    3740:	2b00      	cmp	r3, #0
    3742:	d101      	bne.n	3748 <_read+0x8c>
                return bytes_read;
    3744:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3746:	e050      	b.n	37ea <_read+0x12e>
            }
            if ((c == '\r' && stdio_in_prev[fh] != '\n') ||
    3748:	f89d 301f 	ldrb.w	r3, [sp, #31]
    374c:	2b0d      	cmp	r3, #13
    374e:	d105      	bne.n	375c <_read+0xa0>
    3750:	4a2a      	ldr	r2, [pc, #168]	; (37fc <_read+0x140>)
    3752:	9b05      	ldr	r3, [sp, #20]
    3754:	4413      	add	r3, r2
    3756:	781b      	ldrb	r3, [r3, #0]
    3758:	2b0a      	cmp	r3, #10
    375a:	d109      	bne.n	3770 <_read+0xb4>
                    (c == '\n' && stdio_in_prev[fh] != '\r')) {
    375c:	f89d 301f 	ldrb.w	r3, [sp, #31]
            if ((c == '\r' && stdio_in_prev[fh] != '\n') ||
    3760:	2b0a      	cmp	r3, #10
    3762:	d110      	bne.n	3786 <_read+0xca>
                    (c == '\n' && stdio_in_prev[fh] != '\r')) {
    3764:	4a25      	ldr	r2, [pc, #148]	; (37fc <_read+0x140>)
    3766:	9b05      	ldr	r3, [sp, #20]
    3768:	4413      	add	r3, r2
    376a:	781b      	ldrb	r3, [r3, #0]
    376c:	2b0d      	cmp	r3, #13
    376e:	d00a      	beq.n	3786 <_read+0xca>
                stdio_in_prev[fh] = c;
    3770:	f89d 101f 	ldrb.w	r1, [sp, #31]
    3774:	4a21      	ldr	r2, [pc, #132]	; (37fc <_read+0x140>)
    3776:	9b05      	ldr	r3, [sp, #20]
    3778:	4413      	add	r3, r2
    377a:	460a      	mov	r2, r1
    377c:	701a      	strb	r2, [r3, #0]
                *buffer = '\n';
    377e:	9b04      	ldr	r3, [sp, #16]
    3780:	220a      	movs	r2, #10
    3782:	701a      	strb	r2, [r3, #0]
                break;
    3784:	e027      	b.n	37d6 <_read+0x11a>
            } else if ((c == '\r' && stdio_in_prev[fh] == '\n') ||
    3786:	f89d 301f 	ldrb.w	r3, [sp, #31]
    378a:	2b0d      	cmp	r3, #13
    378c:	d105      	bne.n	379a <_read+0xde>
    378e:	4a1b      	ldr	r2, [pc, #108]	; (37fc <_read+0x140>)
    3790:	9b05      	ldr	r3, [sp, #20]
    3792:	4413      	add	r3, r2
    3794:	781b      	ldrb	r3, [r3, #0]
    3796:	2b0a      	cmp	r3, #10
    3798:	d009      	beq.n	37ae <_read+0xf2>
                       (c == '\n' && stdio_in_prev[fh] == '\r')) {
    379a:	f89d 301f 	ldrb.w	r3, [sp, #31]
            } else if ((c == '\r' && stdio_in_prev[fh] == '\n') ||
    379e:	2b0a      	cmp	r3, #10
    37a0:	d10d      	bne.n	37be <_read+0x102>
                       (c == '\n' && stdio_in_prev[fh] == '\r')) {
    37a2:	4a16      	ldr	r2, [pc, #88]	; (37fc <_read+0x140>)
    37a4:	9b05      	ldr	r3, [sp, #20]
    37a6:	4413      	add	r3, r2
    37a8:	781b      	ldrb	r3, [r3, #0]
    37aa:	2b0d      	cmp	r3, #13
    37ac:	d107      	bne.n	37be <_read+0x102>
                stdio_in_prev[fh] = c;
    37ae:	f89d 101f 	ldrb.w	r1, [sp, #31]
    37b2:	4a12      	ldr	r2, [pc, #72]	; (37fc <_read+0x140>)
    37b4:	9b05      	ldr	r3, [sp, #20]
    37b6:	4413      	add	r3, r2
    37b8:	460a      	mov	r2, r1
    37ba:	701a      	strb	r2, [r3, #0]
            } else {
                stdio_in_prev[fh] = c;
                *buffer = c;
                break;
            }
        }
    37bc:	e7b1      	b.n	3722 <_read+0x66>
                stdio_in_prev[fh] = c;
    37be:	f89d 101f 	ldrb.w	r1, [sp, #31]
    37c2:	4a0e      	ldr	r2, [pc, #56]	; (37fc <_read+0x140>)
    37c4:	9b05      	ldr	r3, [sp, #20]
    37c6:	4413      	add	r3, r2
    37c8:	460a      	mov	r2, r1
    37ca:	701a      	strb	r2, [r3, #0]
                *buffer = c;
    37cc:	f89d 201f 	ldrb.w	r2, [sp, #31]
    37d0:	9b04      	ldr	r3, [sp, #16]
    37d2:	701a      	strb	r2, [r3, #0]
                break;
    37d4:	bf00      	nop
        bytes_read = 1;
    37d6:	2301      	movs	r3, #1
    37d8:	9309      	str	r3, [sp, #36]	; 0x24
    37da:	e005      	b.n	37e8 <_read+0x12c>
    } else {
        bytes_read = read(fh, buffer, length);
    37dc:	9a03      	ldr	r2, [sp, #12]
    37de:	9904      	ldr	r1, [sp, #16]
    37e0:	9805      	ldr	r0, [sp, #20]
    37e2:	f000 f80d 	bl	3800 <read>
    37e6:	9009      	str	r0, [sp, #36]	; 0x24
        return 0x80000000 | length; // weird EOF indication
    } else {
        return (ssize_t)length - bytes_read;
    }
#else
    return bytes_read;
    37e8:	9b09      	ldr	r3, [sp, #36]	; 0x24
#endif
}
    37ea:	4618      	mov	r0, r3
    37ec:	b00b      	add	sp, #44	; 0x2c
    37ee:	f85d fb04 	ldr.w	pc, [sp], #4
    37f2:	bf00      	nop
    37f4:	00010e50 	.word	0x00010e50
    37f8:	8001012f 	.word	0x8001012f
    37fc:	20000da0 	.word	0x20000da0

00003800 <read>:

extern "C" ssize_t read(int fildes, void *buf, size_t length)
{
    3800:	b500      	push	{lr}
    3802:	b087      	sub	sp, #28
    3804:	9003      	str	r0, [sp, #12]
    3806:	9102      	str	r1, [sp, #8]
    3808:	9201      	str	r2, [sp, #4]

    FileHandle *fhc = get_fhc(fildes);
    380a:	9803      	ldr	r0, [sp, #12]
    380c:	f7ff fdee 	bl	33ec <_ZL7get_fhci>
    3810:	9005      	str	r0, [sp, #20]
    if (fhc == NULL) {
    3812:	9b05      	ldr	r3, [sp, #20]
    3814:	2b00      	cmp	r3, #0
    3816:	d107      	bne.n	3828 <read+0x28>
        errno = EBADF;
    3818:	f006 fd9a 	bl	a350 <__errno>
    381c:	4602      	mov	r2, r0
    381e:	2309      	movs	r3, #9
    3820:	6013      	str	r3, [r2, #0]
        return -1;
    3822:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3826:	e015      	b.n	3854 <read+0x54>
    }

    ssize_t ret = fhc->read(buf, length);
    3828:	9b05      	ldr	r3, [sp, #20]
    382a:	681b      	ldr	r3, [r3, #0]
    382c:	3308      	adds	r3, #8
    382e:	681b      	ldr	r3, [r3, #0]
    3830:	9a01      	ldr	r2, [sp, #4]
    3832:	9902      	ldr	r1, [sp, #8]
    3834:	9805      	ldr	r0, [sp, #20]
    3836:	4798      	blx	r3
    3838:	9004      	str	r0, [sp, #16]
    if (ret < 0) {
    383a:	9b04      	ldr	r3, [sp, #16]
    383c:	2b00      	cmp	r3, #0
    383e:	da08      	bge.n	3852 <read+0x52>
        errno = -ret;
    3840:	f006 fd86 	bl	a350 <__errno>
    3844:	4602      	mov	r2, r0
    3846:	9b04      	ldr	r3, [sp, #16]
    3848:	425b      	negs	r3, r3
    384a:	6013      	str	r3, [r2, #0]
        return -1;
    384c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3850:	e000      	b.n	3854 <read+0x54>
    } else {
        return ret;
    3852:	9b04      	ldr	r3, [sp, #16]
    }
}
    3854:	4618      	mov	r0, r3
    3856:	b007      	add	sp, #28
    3858:	f85d fb04 	ldr.w	pc, [sp], #4

0000385c <_isatty>:
#ifdef __ARMCC_VERSION
extern "C" int PREFIX(_istty)(FILEHANDLE fh)
#else
extern "C" int _isatty(FILEHANDLE fh)
#endif
{
    385c:	b500      	push	{lr}
    385e:	b083      	sub	sp, #12
    3860:	9001      	str	r0, [sp, #4]
    return isatty(fh);
    3862:	9801      	ldr	r0, [sp, #4]
    3864:	f000 f805 	bl	3872 <isatty>
    3868:	4603      	mov	r3, r0
}
    386a:	4618      	mov	r0, r3
    386c:	b003      	add	sp, #12
    386e:	f85d fb04 	ldr.w	pc, [sp], #4

00003872 <isatty>:

extern "C" int isatty(int fildes)
{
    3872:	b500      	push	{lr}
    3874:	b085      	sub	sp, #20
    3876:	9001      	str	r0, [sp, #4]
    FileHandle *fhc = get_fhc(fildes);
    3878:	9801      	ldr	r0, [sp, #4]
    387a:	f7ff fdb7 	bl	33ec <_ZL7get_fhci>
    387e:	9003      	str	r0, [sp, #12]
    if (fhc == NULL) {
    3880:	9b03      	ldr	r3, [sp, #12]
    3882:	2b00      	cmp	r3, #0
    3884:	d106      	bne.n	3894 <isatty+0x22>
        errno = EBADF;
    3886:	f006 fd63 	bl	a350 <__errno>
    388a:	4602      	mov	r2, r0
    388c:	2309      	movs	r3, #9
    388e:	6013      	str	r3, [r2, #0]
        return 0;
    3890:	2300      	movs	r3, #0
    3892:	e012      	b.n	38ba <isatty+0x48>
    }

    int tty = fhc->isatty();
    3894:	9b03      	ldr	r3, [sp, #12]
    3896:	681b      	ldr	r3, [r3, #0]
    3898:	331c      	adds	r3, #28
    389a:	681b      	ldr	r3, [r3, #0]
    389c:	9803      	ldr	r0, [sp, #12]
    389e:	4798      	blx	r3
    38a0:	9002      	str	r0, [sp, #8]
    if (tty < 0) {
    38a2:	9b02      	ldr	r3, [sp, #8]
    38a4:	2b00      	cmp	r3, #0
    38a6:	da07      	bge.n	38b8 <isatty+0x46>
        errno = -tty;
    38a8:	f006 fd52 	bl	a350 <__errno>
    38ac:	4602      	mov	r2, r0
    38ae:	9b02      	ldr	r3, [sp, #8]
    38b0:	425b      	negs	r3, r3
    38b2:	6013      	str	r3, [r2, #0]
        return 0;
    38b4:	2300      	movs	r3, #0
    38b6:	e000      	b.n	38ba <isatty+0x48>
    } else {
        return tty;
    38b8:	9b02      	ldr	r3, [sp, #8]
    }
}
    38ba:	4618      	mov	r0, r3
    38bc:	b005      	add	sp, #20
    38be:	f85d fb04 	ldr.w	pc, [sp], #4

000038c2 <_lseek>:
#elif defined(__ICCARM__)
long __lseek(int fh, long offset, int whence)
#else
int _lseek(FILEHANDLE fh, int offset, int whence)
#endif
{
    38c2:	b500      	push	{lr}
    38c4:	b087      	sub	sp, #28
    38c6:	9003      	str	r0, [sp, #12]
    38c8:	9102      	str	r1, [sp, #8]
    38ca:	9201      	str	r2, [sp, #4]
#if defined(__ARMCC_VERSION)
    int whence = SEEK_SET;
#endif

    off_t off = lseek(fh, offset, whence);
    38cc:	9a01      	ldr	r2, [sp, #4]
    38ce:	9902      	ldr	r1, [sp, #8]
    38d0:	9803      	ldr	r0, [sp, #12]
    38d2:	f000 f806 	bl	38e2 <lseek>
    38d6:	9005      	str	r0, [sp, #20]
    // Assuming INT_MAX = LONG_MAX, so we don't care about prototype difference
    if (off > INT_MAX) {
        errno = EOVERFLOW;
        return -1;
    }
    return off;
    38d8:	9b05      	ldr	r3, [sp, #20]
}
    38da:	4618      	mov	r0, r3
    38dc:	b007      	add	sp, #28
    38de:	f85d fb04 	ldr.w	pc, [sp], #4

000038e2 <lseek>:

extern "C" off_t lseek(int fildes, off_t offset, int whence)
{
    38e2:	b500      	push	{lr}
    38e4:	b087      	sub	sp, #28
    38e6:	9003      	str	r0, [sp, #12]
    38e8:	9102      	str	r1, [sp, #8]
    38ea:	9201      	str	r2, [sp, #4]
    FileHandle *fhc = get_fhc(fildes);
    38ec:	9803      	ldr	r0, [sp, #12]
    38ee:	f7ff fd7d 	bl	33ec <_ZL7get_fhci>
    38f2:	9005      	str	r0, [sp, #20]
    if (fhc == NULL) {
    38f4:	9b05      	ldr	r3, [sp, #20]
    38f6:	2b00      	cmp	r3, #0
    38f8:	d107      	bne.n	390a <lseek+0x28>
        errno = EBADF;
    38fa:	f006 fd29 	bl	a350 <__errno>
    38fe:	4602      	mov	r2, r0
    3900:	2309      	movs	r3, #9
    3902:	6013      	str	r3, [r2, #0]
        return -1;
    3904:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3908:	e015      	b.n	3936 <lseek+0x54>
    }

    off_t off = fhc->seek(offset, whence);
    390a:	9b05      	ldr	r3, [sp, #20]
    390c:	681b      	ldr	r3, [r3, #0]
    390e:	3310      	adds	r3, #16
    3910:	681b      	ldr	r3, [r3, #0]
    3912:	9a01      	ldr	r2, [sp, #4]
    3914:	9902      	ldr	r1, [sp, #8]
    3916:	9805      	ldr	r0, [sp, #20]
    3918:	4798      	blx	r3
    391a:	9004      	str	r0, [sp, #16]
    if (off < 0) {
    391c:	9b04      	ldr	r3, [sp, #16]
    391e:	2b00      	cmp	r3, #0
    3920:	da08      	bge.n	3934 <lseek+0x52>
        errno = -off;
    3922:	f006 fd15 	bl	a350 <__errno>
    3926:	4602      	mov	r2, r0
    3928:	9b04      	ldr	r3, [sp, #16]
    392a:	425b      	negs	r3, r3
    392c:	6013      	str	r3, [r2, #0]
        return -1;
    392e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3932:	e000      	b.n	3936 <lseek+0x54>
    }
    return off;
    3934:	9b04      	ldr	r3, [sp, #16]
}
    3936:	4618      	mov	r0, r3
    3938:	b007      	add	sp, #28
    393a:	f85d fb04 	ldr.w	pc, [sp], #4

0000393e <_fstat>:
#endif


#if !defined(__ARMCC_VERSION) && !defined(__ICCARM__)
extern "C" int _fstat(int fh, struct stat *st)
{
    393e:	b500      	push	{lr}
    3940:	b083      	sub	sp, #12
    3942:	9001      	str	r0, [sp, #4]
    3944:	9100      	str	r1, [sp, #0]
    return fstat(fh, st);
    3946:	9900      	ldr	r1, [sp, #0]
    3948:	9801      	ldr	r0, [sp, #4]
    394a:	f000 f805 	bl	3958 <fstat>
    394e:	4603      	mov	r3, r0
}
    3950:	4618      	mov	r0, r3
    3952:	b003      	add	sp, #12
    3954:	f85d fb04 	ldr.w	pc, [sp], #4

00003958 <fstat>:
#endif

extern "C" int fstat(int fildes, struct stat *st)
{
    3958:	b500      	push	{lr}
    395a:	b085      	sub	sp, #20
    395c:	9001      	str	r0, [sp, #4]
    395e:	9100      	str	r1, [sp, #0]
    FileHandle *fhc = get_fhc(fildes);
    3960:	9801      	ldr	r0, [sp, #4]
    3962:	f7ff fd43 	bl	33ec <_ZL7get_fhci>
    3966:	9003      	str	r0, [sp, #12]
    if (fhc == NULL) {
    3968:	9b03      	ldr	r3, [sp, #12]
    396a:	2b00      	cmp	r3, #0
    396c:	d107      	bne.n	397e <fstat+0x26>
        errno = EBADF;
    396e:	f006 fcef 	bl	a350 <__errno>
    3972:	4602      	mov	r2, r0
    3974:	2309      	movs	r3, #9
    3976:	6013      	str	r3, [r2, #0]
        return -1;
    3978:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    397c:	e019      	b.n	39b2 <fstat+0x5a>
    }

    st->st_mode = fhc->isatty() ? S_IFCHR : S_IFREG;
    397e:	9b03      	ldr	r3, [sp, #12]
    3980:	681b      	ldr	r3, [r3, #0]
    3982:	331c      	adds	r3, #28
    3984:	681b      	ldr	r3, [r3, #0]
    3986:	9803      	ldr	r0, [sp, #12]
    3988:	4798      	blx	r3
    398a:	4603      	mov	r3, r0
    398c:	2b00      	cmp	r3, #0
    398e:	d002      	beq.n	3996 <fstat+0x3e>
    3990:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    3994:	e001      	b.n	399a <fstat+0x42>
    3996:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    399a:	9b00      	ldr	r3, [sp, #0]
    399c:	605a      	str	r2, [r3, #4]
    st->st_size = fhc->size();
    399e:	9b03      	ldr	r3, [sp, #12]
    39a0:	681b      	ldr	r3, [r3, #0]
    39a2:	3328      	adds	r3, #40	; 0x28
    39a4:	681b      	ldr	r3, [r3, #0]
    39a6:	9803      	ldr	r0, [sp, #12]
    39a8:	4798      	blx	r3
    39aa:	4602      	mov	r2, r0
    39ac:	9b00      	ldr	r3, [sp, #0]
    39ae:	611a      	str	r2, [r3, #16]
    return 0;
    39b0:	2300      	movs	r3, #0
}
    39b2:	4618      	mov	r0, r3
    39b4:	b005      	add	sp, #20
    39b6:	f85d fb04 	ldr.w	pc, [sp], #4

000039ba <__cxa_pure_virtual>:
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_CLIB_EXCEPTION), "Exception", 0);
}
}
extern "C" WEAK void __cxa_pure_virtual(void);
extern "C" WEAK void __cxa_pure_virtual(void)
{
    39ba:	b508      	push	{r3, lr}
    exit(1);
    39bc:	2001      	movs	r0, #1
    39be:	f000 f863 	bl	3a88 <__wrap_exit>
	...

000039c4 <_sbrk>:
#else
// Linker defined symbol used by _sbrk to indicate where heap should start.
extern "C" uint32_t __end__;
// Weak attribute allows user to override, e.g. to use external RAM for dynamic memory.
extern "C" WEAK caddr_t _sbrk(int incr)
{
    39c4:	b410      	push	{r4}
    39c6:	b085      	sub	sp, #20
    39c8:	9001      	str	r0, [sp, #4]
    static unsigned char *heap = (unsigned char *)&__end__;
    unsigned char        *prev_heap = heap;
    39ca:	4b1b      	ldr	r3, [pc, #108]	; (3a38 <_sbrk+0x74>)
    39cc:	681b      	ldr	r3, [r3, #0]
    39ce:	9303      	str	r3, [sp, #12]
    unsigned char        *new_heap = heap + incr;
    39d0:	4b19      	ldr	r3, [pc, #100]	; (3a38 <_sbrk+0x74>)
    39d2:	681a      	ldr	r2, [r3, #0]
    39d4:	9b01      	ldr	r3, [sp, #4]
    39d6:	4413      	add	r3, r2
    39d8:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
    39da:	f3ef 8308 	mrs	r3, MSP
    39de:	461c      	mov	r4, r3
  return(result);
    39e0:	4623      	mov	r3, r4

#if defined(TARGET_CORTEX_A)
    if (new_heap >= (unsigned char *)&__HeapLimit) {    /* __HeapLimit is end of heap section */
#else
    if (new_heap >= (unsigned char *)__get_MSP()) {
    39e2:	461a      	mov	r2, r3
    39e4:	9b02      	ldr	r3, [sp, #8]
    39e6:	429a      	cmp	r2, r3
    39e8:	bf94      	ite	ls
    39ea:	2301      	movls	r3, #1
    39ec:	2300      	movhi	r3, #0
    39ee:	b2db      	uxtb	r3, r3
    39f0:	2b00      	cmp	r3, #0
    39f2:	d005      	beq.n	3a00 <_sbrk+0x3c>
#endif
        errno = ENOMEM;
    39f4:	4b11      	ldr	r3, [pc, #68]	; (3a3c <_sbrk+0x78>)
    39f6:	220c      	movs	r2, #12
    39f8:	601a      	str	r2, [r3, #0]
        return (caddr_t) -1;
    39fa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    39fe:	e015      	b.n	3a2c <_sbrk+0x68>
    }

    // Additional heap checking if set
    if (mbed_heap_size && (new_heap >= mbed_heap_start + mbed_heap_size)) {
    3a00:	4b0f      	ldr	r3, [pc, #60]	; (3a40 <_sbrk+0x7c>)
    3a02:	681b      	ldr	r3, [r3, #0]
    3a04:	2b00      	cmp	r3, #0
    3a06:	d00d      	beq.n	3a24 <_sbrk+0x60>
    3a08:	4b0e      	ldr	r3, [pc, #56]	; (3a44 <_sbrk+0x80>)
    3a0a:	681a      	ldr	r2, [r3, #0]
    3a0c:	4b0c      	ldr	r3, [pc, #48]	; (3a40 <_sbrk+0x7c>)
    3a0e:	681b      	ldr	r3, [r3, #0]
    3a10:	441a      	add	r2, r3
    3a12:	9b02      	ldr	r3, [sp, #8]
    3a14:	429a      	cmp	r2, r3
    3a16:	d805      	bhi.n	3a24 <_sbrk+0x60>
        errno = ENOMEM;
    3a18:	4b08      	ldr	r3, [pc, #32]	; (3a3c <_sbrk+0x78>)
    3a1a:	220c      	movs	r2, #12
    3a1c:	601a      	str	r2, [r3, #0]
        return (caddr_t) -1;
    3a1e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3a22:	e003      	b.n	3a2c <_sbrk+0x68>
    }

    heap = new_heap;
    3a24:	4a04      	ldr	r2, [pc, #16]	; (3a38 <_sbrk+0x74>)
    3a26:	9b02      	ldr	r3, [sp, #8]
    3a28:	6013      	str	r3, [r2, #0]
    return (caddr_t) prev_heap;
    3a2a:	9b03      	ldr	r3, [sp, #12]
}
    3a2c:	4618      	mov	r0, r3
    3a2e:	b005      	add	sp, #20
    3a30:	f85d 4b04 	ldr.w	r4, [sp], #4
    3a34:	4770      	bx	lr
    3a36:	bf00      	nop
    3a38:	20000108 	.word	0x20000108
    3a3c:	2000304c 	.word	0x2000304c
    3a40:	20000d9c 	.word	0x20000d9c
    3a44:	20000d98 	.word	0x20000d98

00003a48 <_exit>:
#endif
#endif

#if defined(TOOLCHAIN_GCC_ARM) || defined(TOOLCHAIN_GCC_CR)
extern "C" void _exit(int return_code)
{
    3a48:	b500      	push	{lr}
    3a4a:	b083      	sub	sp, #12
    3a4c:	9001      	str	r0, [sp, #4]
{
#endif

#if DEVICE_STDIO_MESSAGES
#if MBED_CONF_PLATFORM_STDIO_FLUSH_AT_EXIT
    fflush(stdout);
    3a4e:	4b09      	ldr	r3, [pc, #36]	; (3a74 <_exit+0x2c>)
    3a50:	681b      	ldr	r3, [r3, #0]
    3a52:	689b      	ldr	r3, [r3, #8]
    3a54:	4618      	mov	r0, r3
    3a56:	f006 fdad 	bl	a5b4 <fflush>
    fflush(stderr);
    3a5a:	4b06      	ldr	r3, [pc, #24]	; (3a74 <_exit+0x2c>)
    3a5c:	681b      	ldr	r3, [r3, #0]
    3a5e:	68db      	ldr	r3, [r3, #12]
    3a60:	4618      	mov	r0, r3
    3a62:	f006 fda7 	bl	a5b4 <fflush>
#if DEVICE_SEMIHOST
    if (mbed_interface_connected()) {
        semihost_exit();
    }
#endif
    if (return_code) {
    3a66:	9b01      	ldr	r3, [sp, #4]
    3a68:	2b00      	cmp	r3, #0
    3a6a:	d001      	beq.n	3a70 <_exit+0x28>
        mbed_die();
    3a6c:	f7fe ffda 	bl	2a24 <mbed_die>
    }

    while (1);
    3a70:	e7fe      	b.n	3a70 <_exit+0x28>
    3a72:	bf00      	nop
    3a74:	200001c0 	.word	0x200001c0

00003a78 <__aeabi_atexit>:
// In mbed, program never exit properly, it dies.
// More informations about this topic for ARMCC here:
// http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/6449.html
extern "C" {
    int __aeabi_atexit(void *object, void (*dtor)(void * /*this*/), void *handle)
    {
    3a78:	b084      	sub	sp, #16
    3a7a:	9003      	str	r0, [sp, #12]
    3a7c:	9102      	str	r1, [sp, #8]
    3a7e:	9201      	str	r2, [sp, #4]
        return 1;
    3a80:	2301      	movs	r3, #1
    }
    3a82:	4618      	mov	r0, r3
    3a84:	b004      	add	sp, #16
    3a86:	4770      	bx	lr

00003a88 <__wrap_exit>:
     * @brief Retarget of exit for GCC.
     * @details Unlike the standard version, this function doesn't call any function
     * registered with atexit before calling _exit.
     */
    void __wrap_exit(int return_code)
    {
    3a88:	b500      	push	{lr}
    3a8a:	b083      	sub	sp, #12
    3a8c:	9001      	str	r0, [sp, #4]
        _exit(return_code);
    3a8e:	9801      	ldr	r0, [sp, #4]
    3a90:	f7ff ffda 	bl	3a48 <_exit>
    }
    3a94:	bf00      	nop
    3a96:	b003      	add	sp, #12
    3a98:	f85d fb04 	ldr.w	pc, [sp], #4

00003a9c <__wrap_atexit>:
     * @brief Retarget atexit from GCC.
     * @details This function will always fail and never register any handler to be
     * called at exit.
     */
    int __wrap_atexit(void (*func)())
    {
    3a9c:	b082      	sub	sp, #8
    3a9e:	9001      	str	r0, [sp, #4]
        return 1;
    3aa0:	2301      	movs	r3, #1
    }
    3aa2:	4618      	mov	r0, r3
    3aa4:	b002      	add	sp, #8
    3aa6:	4770      	bx	lr

00003aa8 <__malloc_lock>:
extern "C" WEAK void __rtos_malloc_unlock(struct _reent *_r) {}
extern "C" WEAK void __rtos_env_lock(struct _reent *_r) {}
extern "C" WEAK void __rtos_env_unlock(struct _reent *_r) {}

extern "C" void __malloc_lock(struct _reent *_r)
{
    3aa8:	b500      	push	{lr}
    3aaa:	b083      	sub	sp, #12
    3aac:	9001      	str	r0, [sp, #4]
    __rtos_malloc_lock(_r);
    3aae:	9801      	ldr	r0, [sp, #4]
    3ab0:	f000 fc10 	bl	42d4 <__rtos_malloc_lock>
}
    3ab4:	bf00      	nop
    3ab6:	b003      	add	sp, #12
    3ab8:	f85d fb04 	ldr.w	pc, [sp], #4

00003abc <__malloc_unlock>:

extern "C" void __malloc_unlock(struct _reent *_r)
{
    3abc:	b500      	push	{lr}
    3abe:	b083      	sub	sp, #12
    3ac0:	9001      	str	r0, [sp, #4]
    __rtos_malloc_unlock(_r);
    3ac2:	9801      	ldr	r0, [sp, #4]
    3ac4:	f000 fc16 	bl	42f4 <__rtos_malloc_unlock>
}
    3ac8:	bf00      	nop
    3aca:	b003      	add	sp, #12
    3acc:	f85d fb04 	ldr.w	pc, [sp], #4

00003ad0 <__cxa_guard_acquire>:
#define CXA_GUARD_INIT_DONE             (1 << 0)
#define CXA_GUARD_INIT_IN_PROGRESS      (1 << 1)
#define CXA_GUARD_MASK                  (CXA_GUARD_INIT_DONE | CXA_GUARD_INIT_IN_PROGRESS)

extern "C" int __cxa_guard_acquire(int *guard_object_p)
{
    3ad0:	b500      	push	{lr}
    3ad2:	b085      	sub	sp, #20
    3ad4:	9001      	str	r0, [sp, #4]
    uint8_t *guard_object = (uint8_t *)guard_object_p;
    3ad6:	9b01      	ldr	r3, [sp, #4]
    3ad8:	9303      	str	r3, [sp, #12]
    if (CXA_GUARD_INIT_DONE == (*guard_object & CXA_GUARD_MASK)) {
    3ada:	9b03      	ldr	r3, [sp, #12]
    3adc:	781b      	ldrb	r3, [r3, #0]
    3ade:	f003 0303 	and.w	r3, r3, #3
    3ae2:	2b01      	cmp	r3, #1
    3ae4:	d101      	bne.n	3aea <__cxa_guard_acquire+0x1a>
        return 0;
    3ae6:	2300      	movs	r3, #0
    3ae8:	e01f      	b.n	3b2a <__cxa_guard_acquire+0x5a>
    }
    singleton_lock();
    3aea:	f7ff fb4d 	bl	3188 <_ZL14singleton_lockv>
    if (CXA_GUARD_INIT_DONE == (*guard_object & CXA_GUARD_MASK)) {
    3aee:	9b03      	ldr	r3, [sp, #12]
    3af0:	781b      	ldrb	r3, [r3, #0]
    3af2:	f003 0303 	and.w	r3, r3, #3
    3af6:	2b01      	cmp	r3, #1
    3af8:	d103      	bne.n	3b02 <__cxa_guard_acquire+0x32>
        singleton_unlock();
    3afa:	f7ff fb51 	bl	31a0 <_ZL16singleton_unlockv>
        return 0;
    3afe:	2300      	movs	r3, #0
    3b00:	e013      	b.n	3b2a <__cxa_guard_acquire+0x5a>
    }
    MBED_ASSERT(0 == (*guard_object & CXA_GUARD_MASK));
    3b02:	9b03      	ldr	r3, [sp, #12]
    3b04:	781b      	ldrb	r3, [r3, #0]
    3b06:	f003 0303 	and.w	r3, r3, #3
    3b0a:	2b00      	cmp	r3, #0
    3b0c:	d005      	beq.n	3b1a <__cxa_guard_acquire+0x4a>
    3b0e:	f240 52a9 	movw	r2, #1449	; 0x5a9
    3b12:	4908      	ldr	r1, [pc, #32]	; (3b34 <__cxa_guard_acquire+0x64>)
    3b14:	4808      	ldr	r0, [pc, #32]	; (3b38 <__cxa_guard_acquire+0x68>)
    3b16:	f7fe ff6f 	bl	29f8 <mbed_assert_internal>
    *guard_object = *guard_object | CXA_GUARD_INIT_IN_PROGRESS;
    3b1a:	9b03      	ldr	r3, [sp, #12]
    3b1c:	781b      	ldrb	r3, [r3, #0]
    3b1e:	f043 0302 	orr.w	r3, r3, #2
    3b22:	b2da      	uxtb	r2, r3
    3b24:	9b03      	ldr	r3, [sp, #12]
    3b26:	701a      	strb	r2, [r3, #0]
    return 1;
    3b28:	2301      	movs	r3, #1
}
    3b2a:	4618      	mov	r0, r3
    3b2c:	b005      	add	sp, #20
    3b2e:	f85d fb04 	ldr.w	pc, [sp], #4
    3b32:	bf00      	nop
    3b34:	00010e98 	.word	0x00010e98
    3b38:	00010ec0 	.word	0x00010ec0

00003b3c <__cxa_guard_release>:

extern "C" void __cxa_guard_release(int *guard_object_p)
{
    3b3c:	b500      	push	{lr}
    3b3e:	b085      	sub	sp, #20
    3b40:	9001      	str	r0, [sp, #4]
    uint8_t *guard_object = (uint8_t *)guard_object_p;
    3b42:	9b01      	ldr	r3, [sp, #4]
    3b44:	9303      	str	r3, [sp, #12]
    MBED_ASSERT(CXA_GUARD_INIT_IN_PROGRESS == (*guard_object & CXA_GUARD_MASK));
    3b46:	9b03      	ldr	r3, [sp, #12]
    3b48:	781b      	ldrb	r3, [r3, #0]
    3b4a:	f003 0303 	and.w	r3, r3, #3
    3b4e:	2b02      	cmp	r3, #2
    3b50:	d005      	beq.n	3b5e <__cxa_guard_release+0x22>
    3b52:	f240 52b1 	movw	r2, #1457	; 0x5b1
    3b56:	490b      	ldr	r1, [pc, #44]	; (3b84 <__cxa_guard_release+0x48>)
    3b58:	480b      	ldr	r0, [pc, #44]	; (3b88 <__cxa_guard_release+0x4c>)
    3b5a:	f7fe ff4d 	bl	29f8 <mbed_assert_internal>
    *guard_object = (*guard_object & ~CXA_GUARD_MASK) | CXA_GUARD_INIT_DONE;
    3b5e:	9b03      	ldr	r3, [sp, #12]
    3b60:	781b      	ldrb	r3, [r3, #0]
    3b62:	b25b      	sxtb	r3, r3
    3b64:	f023 0303 	bic.w	r3, r3, #3
    3b68:	b25b      	sxtb	r3, r3
    3b6a:	f043 0301 	orr.w	r3, r3, #1
    3b6e:	b25b      	sxtb	r3, r3
    3b70:	b2da      	uxtb	r2, r3
    3b72:	9b03      	ldr	r3, [sp, #12]
    3b74:	701a      	strb	r2, [r3, #0]
    singleton_unlock();
    3b76:	f7ff fb13 	bl	31a0 <_ZL16singleton_unlockv>
}
    3b7a:	bf00      	nop
    3b7c:	b005      	add	sp, #20
    3b7e:	f85d fb04 	ldr.w	pc, [sp], #4
    3b82:	bf00      	nop
    3b84:	00010e98 	.word	0x00010e98
    3b88:	00010ee8 	.word	0x00010ee8

00003b8c <_Znwj>:

extern "C" void *malloc_wrapper(struct _reent *r, size_t size, void *caller);
extern "C" void free_wrapper(struct _reent *r, void *ptr, void *caller);

void *operator new (std::size_t count)
{
    3b8c:	b500      	push	{lr}
    3b8e:	b087      	sub	sp, #28
    3b90:	4672      	mov	r2, lr
    3b92:	9003      	str	r0, [sp, #12]
    void *buffer = malloc_wrapper(_REENT, count, MBED_CALLER_ADDR());
    3b94:	4b0b      	ldr	r3, [pc, #44]	; (3bc4 <_Znwj+0x38>)
    3b96:	681b      	ldr	r3, [r3, #0]
    3b98:	9903      	ldr	r1, [sp, #12]
    3b9a:	4618      	mov	r0, r3
    3b9c:	f7fe fe20 	bl	27e0 <malloc_wrapper>
    3ba0:	9005      	str	r0, [sp, #20]
    if (NULL == buffer) {
    3ba2:	9b05      	ldr	r3, [sp, #20]
    3ba4:	2b00      	cmp	r3, #0
    3ba6:	d107      	bne.n	3bb8 <_Znwj+0x2c>
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_OUT_OF_MEMORY), "Operator new out of memory\r\n", count);
    3ba8:	2300      	movs	r3, #0
    3baa:	9300      	str	r3, [sp, #0]
    3bac:	2300      	movs	r3, #0
    3bae:	9a03      	ldr	r2, [sp, #12]
    3bb0:	4905      	ldr	r1, [pc, #20]	; (3bc8 <_Znwj+0x3c>)
    3bb2:	4806      	ldr	r0, [pc, #24]	; (3bcc <_Znwj+0x40>)
    3bb4:	f7ff f900 	bl	2db8 <mbed_error>
    }
    return buffer;
    3bb8:	9b05      	ldr	r3, [sp, #20]
}
    3bba:	4618      	mov	r0, r3
    3bbc:	b007      	add	sp, #28
    3bbe:	f85d fb04 	ldr.w	pc, [sp], #4
    3bc2:	bf00      	nop
    3bc4:	200001c0 	.word	0x200001c0
    3bc8:	00010f28 	.word	0x00010f28
    3bcc:	8001011f 	.word	0x8001011f

00003bd0 <_ZdlPv>:
{
    return malloc_wrapper(_REENT, count, MBED_CALLER_ADDR());
}

void operator delete (void *ptr)
{
    3bd0:	b500      	push	{lr}
    3bd2:	b083      	sub	sp, #12
    3bd4:	4672      	mov	r2, lr
    3bd6:	9001      	str	r0, [sp, #4]
    free_wrapper(_REENT, ptr, MBED_CALLER_ADDR());
    3bd8:	4b04      	ldr	r3, [pc, #16]	; (3bec <_ZdlPv+0x1c>)
    3bda:	681b      	ldr	r3, [r3, #0]
    3bdc:	9901      	ldr	r1, [sp, #4]
    3bde:	4618      	mov	r0, r3
    3be0:	f7fe fea2 	bl	2928 <free_wrapper>
}
    3be4:	bf00      	nop
    3be6:	b003      	add	sp, #12
    3be8:	f85d fb04 	ldr.w	pc, [sp], #4
    3bec:	200001c0 	.word	0x200001c0

00003bf0 <_ZN12DirectSerialD1Ev>:
class DirectSerial : public FileHandle {
    3bf0:	b500      	push	{lr}
    3bf2:	b083      	sub	sp, #12
    3bf4:	9001      	str	r0, [sp, #4]
    3bf6:	4a06      	ldr	r2, [pc, #24]	; (3c10 <_ZN12DirectSerialD1Ev+0x20>)
    3bf8:	9b01      	ldr	r3, [sp, #4]
    3bfa:	601a      	str	r2, [r3, #0]
    3bfc:	9b01      	ldr	r3, [sp, #4]
    3bfe:	4618      	mov	r0, r3
    3c00:	f7fd ff22 	bl	1a48 <_ZN4mbed10FileHandleD1Ev>
    3c04:	9b01      	ldr	r3, [sp, #4]
    3c06:	4618      	mov	r0, r3
    3c08:	b003      	add	sp, #12
    3c0a:	f85d fb04 	ldr.w	pc, [sp], #4
    3c0e:	bf00      	nop
    3c10:	00012544 	.word	0x00012544

00003c14 <_ZN12DirectSerialD0Ev>:
    3c14:	b500      	push	{lr}
    3c16:	b083      	sub	sp, #12
    3c18:	9001      	str	r0, [sp, #4]
    3c1a:	9801      	ldr	r0, [sp, #4]
    3c1c:	f7ff ffe8 	bl	3bf0 <_ZN12DirectSerialD1Ev>
    3c20:	9801      	ldr	r0, [sp, #4]
    3c22:	f7ff ffd5 	bl	3bd0 <_ZdlPv>
    3c26:	9b01      	ldr	r3, [sp, #4]
    3c28:	4618      	mov	r0, r3
    3c2a:	b003      	add	sp, #12
    3c2c:	f85d fb04 	ldr.w	pc, [sp], #4

00003c30 <mbed_stats_stack_get_each>:
    free(threads);
#endif
}

size_t mbed_stats_stack_get_each(mbed_stats_stack_t *stats, size_t count)
{
    3c30:	b510      	push	{r4, lr}
    3c32:	b086      	sub	sp, #24
    3c34:	9001      	str	r0, [sp, #4]
    3c36:	9100      	str	r1, [sp, #0]
    MBED_ASSERT(stats != NULL);
    3c38:	9b01      	ldr	r3, [sp, #4]
    3c3a:	2b00      	cmp	r3, #0
    3c3c:	d104      	bne.n	3c48 <mbed_stats_stack_get_each+0x18>
    3c3e:	223f      	movs	r2, #63	; 0x3f
    3c40:	4931      	ldr	r1, [pc, #196]	; (3d08 <mbed_stats_stack_get_each+0xd8>)
    3c42:	4832      	ldr	r0, [pc, #200]	; (3d0c <mbed_stats_stack_get_each+0xdc>)
    3c44:	f7fe fed8 	bl	29f8 <mbed_assert_internal>
    memset(stats, 0, count * sizeof(mbed_stats_stack_t));
    3c48:	9b00      	ldr	r3, [sp, #0]
    3c4a:	011b      	lsls	r3, r3, #4
    3c4c:	461a      	mov	r2, r3
    3c4e:	2100      	movs	r1, #0
    3c50:	9801      	ldr	r0, [sp, #4]
    3c52:	f007 fc17 	bl	b484 <memset>

    size_t i = 0;
    3c56:	2300      	movs	r3, #0
    3c58:	9305      	str	r3, [sp, #20]

#if defined(MBED_STACK_STATS_ENABLED) && defined(MBED_CONF_RTOS_PRESENT)
    osThreadId_t *threads;

    threads = malloc(sizeof(osThreadId_t) * count);
    3c5a:	9b00      	ldr	r3, [sp, #0]
    3c5c:	009b      	lsls	r3, r3, #2
    3c5e:	4618      	mov	r0, r3
    3c60:	f007 f8d6 	bl	ae10 <malloc>
    3c64:	9004      	str	r0, [sp, #16]
    MBED_ASSERT(threads != NULL);
    3c66:	9b04      	ldr	r3, [sp, #16]
    3c68:	2b00      	cmp	r3, #0
    3c6a:	d104      	bne.n	3c76 <mbed_stats_stack_get_each+0x46>
    3c6c:	2248      	movs	r2, #72	; 0x48
    3c6e:	4926      	ldr	r1, [pc, #152]	; (3d08 <mbed_stats_stack_get_each+0xd8>)
    3c70:	4827      	ldr	r0, [pc, #156]	; (3d10 <mbed_stats_stack_get_each+0xe0>)
    3c72:	f7fe fec1 	bl	29f8 <mbed_assert_internal>

    osKernelLock();
    3c76:	f001 f91f 	bl	4eb8 <osKernelLock>
    count = osThreadEnumerate(threads, count);
    3c7a:	9900      	ldr	r1, [sp, #0]
    3c7c:	9804      	ldr	r0, [sp, #16]
    3c7e:	f003 ffd1 	bl	7c24 <osThreadEnumerate>
    3c82:	9000      	str	r0, [sp, #0]

    for (i = 0; i < count; i++) {
    3c84:	2300      	movs	r3, #0
    3c86:	9305      	str	r3, [sp, #20]
    3c88:	e031      	b.n	3cee <mbed_stats_stack_get_each+0xbe>
        uint32_t stack_size = osThreadGetStackSize(threads[i]);
    3c8a:	9b05      	ldr	r3, [sp, #20]
    3c8c:	009b      	lsls	r3, r3, #2
    3c8e:	9a04      	ldr	r2, [sp, #16]
    3c90:	4413      	add	r3, r2
    3c92:	681b      	ldr	r3, [r3, #0]
    3c94:	4618      	mov	r0, r3
    3c96:	f003 ff51 	bl	7b3c <osThreadGetStackSize>
    3c9a:	9003      	str	r0, [sp, #12]
        stats[i].max_size = stack_size - osThreadGetStackSpace(threads[i]);
    3c9c:	9b05      	ldr	r3, [sp, #20]
    3c9e:	011b      	lsls	r3, r3, #4
    3ca0:	9a01      	ldr	r2, [sp, #4]
    3ca2:	18d4      	adds	r4, r2, r3
    3ca4:	9b05      	ldr	r3, [sp, #20]
    3ca6:	009b      	lsls	r3, r3, #2
    3ca8:	9a04      	ldr	r2, [sp, #16]
    3caa:	4413      	add	r3, r2
    3cac:	681b      	ldr	r3, [r3, #0]
    3cae:	4618      	mov	r0, r3
    3cb0:	f003 ff68 	bl	7b84 <osThreadGetStackSpace>
    3cb4:	4602      	mov	r2, r0
    3cb6:	9b03      	ldr	r3, [sp, #12]
    3cb8:	1a9b      	subs	r3, r3, r2
    3cba:	6063      	str	r3, [r4, #4]
        stats[i].reserved_size = stack_size;
    3cbc:	9b05      	ldr	r3, [sp, #20]
    3cbe:	011b      	lsls	r3, r3, #4
    3cc0:	9a01      	ldr	r2, [sp, #4]
    3cc2:	4413      	add	r3, r2
    3cc4:	9a03      	ldr	r2, [sp, #12]
    3cc6:	609a      	str	r2, [r3, #8]
        stats[i].thread_id = (uint32_t)threads[i];
    3cc8:	9b05      	ldr	r3, [sp, #20]
    3cca:	011b      	lsls	r3, r3, #4
    3ccc:	9a01      	ldr	r2, [sp, #4]
    3cce:	4413      	add	r3, r2
    3cd0:	9a05      	ldr	r2, [sp, #20]
    3cd2:	0092      	lsls	r2, r2, #2
    3cd4:	9904      	ldr	r1, [sp, #16]
    3cd6:	440a      	add	r2, r1
    3cd8:	6812      	ldr	r2, [r2, #0]
    3cda:	601a      	str	r2, [r3, #0]
        stats[i].stack_cnt = 1;
    3cdc:	9b05      	ldr	r3, [sp, #20]
    3cde:	011b      	lsls	r3, r3, #4
    3ce0:	9a01      	ldr	r2, [sp, #4]
    3ce2:	4413      	add	r3, r2
    3ce4:	2201      	movs	r2, #1
    3ce6:	60da      	str	r2, [r3, #12]
    for (i = 0; i < count; i++) {
    3ce8:	9b05      	ldr	r3, [sp, #20]
    3cea:	3301      	adds	r3, #1
    3cec:	9305      	str	r3, [sp, #20]
    3cee:	9a05      	ldr	r2, [sp, #20]
    3cf0:	9b00      	ldr	r3, [sp, #0]
    3cf2:	429a      	cmp	r2, r3
    3cf4:	d3c9      	bcc.n	3c8a <mbed_stats_stack_get_each+0x5a>
    }
    osKernelUnlock();
    3cf6:	f001 f901 	bl	4efc <osKernelUnlock>

    free(threads);
    3cfa:	9804      	ldr	r0, [sp, #16]
    3cfc:	f007 f890 	bl	ae20 <free>
#endif

    return i;
    3d00:	9b05      	ldr	r3, [sp, #20]
}
    3d02:	4618      	mov	r0, r3
    3d04:	b006      	add	sp, #24
    3d06:	bd10      	pop	{r4, pc}
    3d08:	00010f80 	.word	0x00010f80
    3d0c:	00010fa0 	.word	0x00010fa0
    3d10:	00010fb0 	.word	0x00010fb0

00003d14 <wait>:
#include "rtos/rtos.h"
#include "platform/mbed_critical.h"
#include "platform/mbed_power_mgmt.h"

void wait(float s)
{
    3d14:	b500      	push	{lr}
    3d16:	b083      	sub	sp, #12
    3d18:	9001      	str	r0, [sp, #4]
    wait_us(s * 1000000.0f);
    3d1a:	eddd 7a01 	vldr	s15, [sp, #4]
    3d1e:	ed9f 7a07 	vldr	s14, [pc, #28]	; 3d3c <wait+0x28>
    3d22:	ee67 7a87 	vmul.f32	s15, s15, s14
    3d26:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    3d2a:	ee17 0a90 	vmov	r0, s15
    3d2e:	f000 f817 	bl	3d60 <wait_us>
}
    3d32:	bf00      	nop
    3d34:	b003      	add	sp, #12
    3d36:	f85d fb04 	ldr.w	pc, [sp], #4
    3d3a:	bf00      	nop
    3d3c:	49742400 	.word	0x49742400

00003d40 <wait_ms>:

void wait_ms(int ms)
{
    3d40:	b500      	push	{lr}
    3d42:	b083      	sub	sp, #12
    3d44:	9001      	str	r0, [sp, #4]
    wait_us(ms * 1000);
    3d46:	9b01      	ldr	r3, [sp, #4]
    3d48:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    3d4c:	fb02 f303 	mul.w	r3, r2, r3
    3d50:	4618      	mov	r0, r3
    3d52:	f000 f805 	bl	3d60 <wait_us>
}
    3d56:	bf00      	nop
    3d58:	b003      	add	sp, #12
    3d5a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00003d60 <wait_us>:

void wait_us(int us)
{
    3d60:	b500      	push	{lr}
    3d62:	b085      	sub	sp, #20
    3d64:	9001      	str	r0, [sp, #4]
    const ticker_data_t *const ticker = get_us_ticker_data();
    3d66:	f7fe fcbb 	bl	26e0 <get_us_ticker_data>
    3d6a:	9003      	str	r0, [sp, #12]

    uint32_t start = ticker_read(ticker);
    3d6c:	9803      	ldr	r0, [sp, #12]
    3d6e:	f7fe fc97 	bl	26a0 <ticker_read>
    3d72:	9002      	str	r0, [sp, #8]
    if ((us >= 1000) && core_util_are_interrupts_enabled()) {
    3d74:	9b01      	ldr	r3, [sp, #4]
    3d76:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    3d7a:	db06      	blt.n	3d8a <wait_us+0x2a>
    3d7c:	f7fe feee 	bl	2b5c <core_util_are_interrupts_enabled>
    3d80:	4603      	mov	r3, r0
    3d82:	2b00      	cmp	r3, #0
    3d84:	d001      	beq.n	3d8a <wait_us+0x2a>
    3d86:	2301      	movs	r3, #1
    3d88:	e000      	b.n	3d8c <wait_us+0x2c>
    3d8a:	2300      	movs	r3, #0
    3d8c:	2b00      	cmp	r3, #0
    3d8e:	d00b      	beq.n	3da8 <wait_us+0x48>
        // Use the RTOS to wait for millisecond delays if possible
        sleep_manager_lock_deep_sleep();
    3d90:	f7fe f866 	bl	1e60 <sleep_manager_lock_deep_sleep_internal>
        Thread::wait((uint32_t)us / 1000);
    3d94:	9b01      	ldr	r3, [sp, #4]
    3d96:	4a0e      	ldr	r2, [pc, #56]	; (3dd0 <wait_us+0x70>)
    3d98:	fba2 2303 	umull	r2, r3, r2, r3
    3d9c:	099b      	lsrs	r3, r3, #6
    3d9e:	4618      	mov	r0, r3
    3da0:	f004 f8aa 	bl	7ef8 <_ZN4rtos6Thread4waitEm>
        sleep_manager_unlock_deep_sleep();
    3da4:	f7fe f882 	bl	1eac <sleep_manager_unlock_deep_sleep_internal>
    }
    // Use busy waiting for sub-millisecond delays, or for the whole
    // interval if interrupts are not enabled
    while ((ticker_read(ticker) - start) < (uint32_t)us);
    3da8:	9803      	ldr	r0, [sp, #12]
    3daa:	f7fe fc79 	bl	26a0 <ticker_read>
    3dae:	4602      	mov	r2, r0
    3db0:	9b02      	ldr	r3, [sp, #8]
    3db2:	1ad2      	subs	r2, r2, r3
    3db4:	9b01      	ldr	r3, [sp, #4]
    3db6:	429a      	cmp	r2, r3
    3db8:	bf34      	ite	cc
    3dba:	2301      	movcc	r3, #1
    3dbc:	2300      	movcs	r3, #0
    3dbe:	b2db      	uxtb	r3, r3
    3dc0:	2b00      	cmp	r3, #0
    3dc2:	d000      	beq.n	3dc6 <wait_us+0x66>
    3dc4:	e7f0      	b.n	3da8 <wait_us+0x48>
}
    3dc6:	bf00      	nop
    3dc8:	b005      	add	sp, #20
    3dca:	f85d fb04 	ldr.w	pc, [sp], #4
    3dce:	bf00      	nop
    3dd0:	10624dd3 	.word	0x10624dd3

00003dd4 <_ZN4rtos5MutexC1Ev>:
#include "mbed_error.h"
#include "mbed_assert.h"

namespace rtos {

Mutex::Mutex(): _count(0)
    3dd4:	b500      	push	{lr}
    3dd6:	b083      	sub	sp, #12
    3dd8:	9001      	str	r0, [sp, #4]
    3dda:	9801      	ldr	r0, [sp, #4]
    3ddc:	f000 f870 	bl	3ec0 <_ZN4mbed11NonCopyableIN4rtos5MutexEEC1Ev>
    3de0:	9b01      	ldr	r3, [sp, #4]
    3de2:	2200      	movs	r2, #0
    3de4:	621a      	str	r2, [r3, #32]
{
    constructor();
    3de6:	2100      	movs	r1, #0
    3de8:	9801      	ldr	r0, [sp, #4]
    3dea:	f000 f805 	bl	3df8 <_ZN4rtos5Mutex11constructorEPKc>
}
    3dee:	9b01      	ldr	r3, [sp, #4]
    3df0:	4618      	mov	r0, r3
    3df2:	b003      	add	sp, #12
    3df4:	f85d fb04 	ldr.w	pc, [sp], #4

00003df8 <_ZN4rtos5Mutex11constructorEPKc>:
{
    constructor(name);
}

void Mutex::constructor(const char *name)
{
    3df8:	b500      	push	{lr}
    3dfa:	b087      	sub	sp, #28
    3dfc:	9001      	str	r0, [sp, #4]
    3dfe:	9100      	str	r1, [sp, #0]
    memset(&_obj_mem, 0, sizeof(_obj_mem));
    3e00:	9b01      	ldr	r3, [sp, #4]
    3e02:	3304      	adds	r3, #4
    3e04:	221c      	movs	r2, #28
    3e06:	2100      	movs	r1, #0
    3e08:	4618      	mov	r0, r3
    3e0a:	f007 fb3b 	bl	b484 <memset>
    osMutexAttr_t attr = { 0 };
    3e0e:	ab02      	add	r3, sp, #8
    3e10:	2200      	movs	r2, #0
    3e12:	601a      	str	r2, [r3, #0]
    3e14:	605a      	str	r2, [r3, #4]
    3e16:	609a      	str	r2, [r3, #8]
    3e18:	60da      	str	r2, [r3, #12]
    attr.name = name ? name : "aplication_unnamed_mutex";
    3e1a:	9b00      	ldr	r3, [sp, #0]
    3e1c:	2b00      	cmp	r3, #0
    3e1e:	d001      	beq.n	3e24 <_ZN4rtos5Mutex11constructorEPKc+0x2c>
    3e20:	9b00      	ldr	r3, [sp, #0]
    3e22:	e000      	b.n	3e26 <_ZN4rtos5Mutex11constructorEPKc+0x2e>
    3e24:	4b0e      	ldr	r3, [pc, #56]	; (3e60 <_ZN4rtos5Mutex11constructorEPKc+0x68>)
    3e26:	9302      	str	r3, [sp, #8]
    attr.cb_mem = &_obj_mem;
    3e28:	9b01      	ldr	r3, [sp, #4]
    3e2a:	3304      	adds	r3, #4
    3e2c:	9304      	str	r3, [sp, #16]
    attr.cb_size = sizeof(_obj_mem);
    3e2e:	231c      	movs	r3, #28
    3e30:	9305      	str	r3, [sp, #20]
    attr.attr_bits = osMutexRecursive | osMutexPrioInherit | osMutexRobust;
    3e32:	230b      	movs	r3, #11
    3e34:	9303      	str	r3, [sp, #12]
    _id = osMutexNew(&attr);
    3e36:	ab02      	add	r3, sp, #8
    3e38:	4618      	mov	r0, r3
    3e3a:	f002 fb71 	bl	6520 <osMutexNew>
    3e3e:	4602      	mov	r2, r0
    3e40:	9b01      	ldr	r3, [sp, #4]
    3e42:	601a      	str	r2, [r3, #0]
    MBED_ASSERT(_id);
    3e44:	9b01      	ldr	r3, [sp, #4]
    3e46:	681b      	ldr	r3, [r3, #0]
    3e48:	2b00      	cmp	r3, #0
    3e4a:	d104      	bne.n	3e56 <_ZN4rtos5Mutex11constructorEPKc+0x5e>
    3e4c:	2232      	movs	r2, #50	; 0x32
    3e4e:	4905      	ldr	r1, [pc, #20]	; (3e64 <_ZN4rtos5Mutex11constructorEPKc+0x6c>)
    3e50:	4805      	ldr	r0, [pc, #20]	; (3e68 <_ZN4rtos5Mutex11constructorEPKc+0x70>)
    3e52:	f7fe fdd1 	bl	29f8 <mbed_assert_internal>
}
    3e56:	bf00      	nop
    3e58:	b007      	add	sp, #28
    3e5a:	f85d fb04 	ldr.w	pc, [sp], #4
    3e5e:	bf00      	nop
    3e60:	00010fc0 	.word	0x00010fc0
    3e64:	00010fdc 	.word	0x00010fdc
    3e68:	00010ff8 	.word	0x00010ff8

00003e6c <_ZN4rtos5Mutex4lockEm>:

osStatus Mutex::lock(uint32_t millisec) {
    3e6c:	b500      	push	{lr}
    3e6e:	b085      	sub	sp, #20
    3e70:	9001      	str	r0, [sp, #4]
    3e72:	9100      	str	r1, [sp, #0]
    osStatus status = osMutexAcquire(_id, millisec);
    3e74:	9b01      	ldr	r3, [sp, #4]
    3e76:	681b      	ldr	r3, [r3, #0]
    3e78:	9900      	ldr	r1, [sp, #0]
    3e7a:	4618      	mov	r0, r3
    3e7c:	f002 fb78 	bl	6570 <osMutexAcquire>
    3e80:	9003      	str	r0, [sp, #12]
    if (osOK == status) {
    3e82:	9b03      	ldr	r3, [sp, #12]
    3e84:	2b00      	cmp	r3, #0
    3e86:	d104      	bne.n	3e92 <_ZN4rtos5Mutex4lockEm+0x26>
        _count++;
    3e88:	9b01      	ldr	r3, [sp, #4]
    3e8a:	6a1b      	ldr	r3, [r3, #32]
    3e8c:	1c5a      	adds	r2, r3, #1
    3e8e:	9b01      	ldr	r3, [sp, #4]
    3e90:	621a      	str	r2, [r3, #32]
    }
    return status;
    3e92:	9b03      	ldr	r3, [sp, #12]
}
    3e94:	4618      	mov	r0, r3
    3e96:	b005      	add	sp, #20
    3e98:	f85d fb04 	ldr.w	pc, [sp], #4

00003e9c <_ZN4rtos5Mutex6unlockEv>:
    } else {
        return trylock_for(millisec - now);
    }
}

osStatus Mutex::unlock() {
    3e9c:	b500      	push	{lr}
    3e9e:	b083      	sub	sp, #12
    3ea0:	9001      	str	r0, [sp, #4]
    _count--;
    3ea2:	9b01      	ldr	r3, [sp, #4]
    3ea4:	6a1b      	ldr	r3, [r3, #32]
    3ea6:	1e5a      	subs	r2, r3, #1
    3ea8:	9b01      	ldr	r3, [sp, #4]
    3eaa:	621a      	str	r2, [r3, #32]
    return osMutexRelease(_id);
    3eac:	9b01      	ldr	r3, [sp, #4]
    3eae:	681b      	ldr	r3, [r3, #0]
    3eb0:	4618      	mov	r0, r3
    3eb2:	f002 fb8b 	bl	65cc <osMutexRelease>
    3eb6:	4603      	mov	r3, r0
}
    3eb8:	4618      	mov	r0, r3
    3eba:	b003      	add	sp, #12
    3ebc:	f85d fb04 	ldr.w	pc, [sp], #4

00003ec0 <_ZN4mbed11NonCopyableIN4rtos5MutexEEC1Ev>:
    3ec0:	b082      	sub	sp, #8
    3ec2:	9001      	str	r0, [sp, #4]
    3ec4:	9b01      	ldr	r3, [sp, #4]
    3ec6:	4618      	mov	r0, r3
    3ec8:	b002      	add	sp, #8
    3eca:	4770      	bx	lr

00003ecc <mbed_fault_handler>:
mbed_fault_context_t mbed_fault_context;

//This is a handler function called from Fault handler to print the error information out.
//This runs in fault context and uses special functions(defined in mbed_rtx_fault_handler.c) to print the information without using C-lib support.
void mbed_fault_handler (uint32_t fault_type, void *mbed_fault_context_in, void *osRtxInfoIn)
{
    3ecc:	b500      	push	{lr}
    3ece:	b089      	sub	sp, #36	; 0x24
    3ed0:	9005      	str	r0, [sp, #20]
    3ed2:	9104      	str	r1, [sp, #16]
    3ed4:	9203      	str	r2, [sp, #12]
    mbed_error_status_t faultStatus = MBED_SUCCESS;
    3ed6:	2300      	movs	r3, #0
    3ed8:	9307      	str	r3, [sp, #28]

    mbed_error_printf("\n++ MbedOS Fault Handler ++\n\nFaultType: ");
    3eda:	481b      	ldr	r0, [pc, #108]	; (3f48 <mbed_fault_handler+0x7c>)
    3edc:	f7fe fde1 	bl	2aa2 <mbed_error_printf>

    switch( fault_type ) {
    3ee0:	9b05      	ldr	r3, [sp, #20]
    3ee2:	2b30      	cmp	r3, #48	; 0x30
    3ee4:	d009      	beq.n	3efa <mbed_fault_handler+0x2e>
    3ee6:	2b40      	cmp	r3, #64	; 0x40
    3ee8:	d00d      	beq.n	3f06 <mbed_fault_handler+0x3a>
    3eea:	2b20      	cmp	r3, #32
    3eec:	d111      	bne.n	3f12 <mbed_fault_handler+0x46>
      case MEMMANAGE_FAULT_EXCEPTION:
        mbed_error_printf("MemManageFault");
    3eee:	4817      	ldr	r0, [pc, #92]	; (3f4c <mbed_fault_handler+0x80>)
    3ef0:	f7fe fdd7 	bl	2aa2 <mbed_error_printf>
        faultStatus = MBED_ERROR_MEMMANAGE_EXCEPTION;
    3ef4:	4b16      	ldr	r3, [pc, #88]	; (3f50 <mbed_fault_handler+0x84>)
    3ef6:	9307      	str	r3, [sp, #28]
        break;
    3ef8:	e011      	b.n	3f1e <mbed_fault_handler+0x52>

      case BUS_FAULT_EXCEPTION:
        mbed_error_printf("BusFault");
    3efa:	4816      	ldr	r0, [pc, #88]	; (3f54 <mbed_fault_handler+0x88>)
    3efc:	f7fe fdd1 	bl	2aa2 <mbed_error_printf>
        faultStatus = MBED_ERROR_BUSFAULT_EXCEPTION;
    3f00:	4b15      	ldr	r3, [pc, #84]	; (3f58 <mbed_fault_handler+0x8c>)
    3f02:	9307      	str	r3, [sp, #28]
        break;
    3f04:	e00b      	b.n	3f1e <mbed_fault_handler+0x52>

      case USAGE_FAULT_EXCEPTION:
        mbed_error_printf("UsageFault");
    3f06:	4815      	ldr	r0, [pc, #84]	; (3f5c <mbed_fault_handler+0x90>)
    3f08:	f7fe fdcb 	bl	2aa2 <mbed_error_printf>
        faultStatus = MBED_ERROR_USAGEFAULT_EXCEPTION;
    3f0c:	4b14      	ldr	r3, [pc, #80]	; (3f60 <mbed_fault_handler+0x94>)
    3f0e:	9307      	str	r3, [sp, #28]
        break;
    3f10:	e005      	b.n	3f1e <mbed_fault_handler+0x52>

      //There is no way we can hit this code without getting an exception, so we have the default treated like hardfault
      case HARD_FAULT_EXCEPTION:
      default:
        mbed_error_printf("HardFault");
    3f12:	4814      	ldr	r0, [pc, #80]	; (3f64 <mbed_fault_handler+0x98>)
    3f14:	f7fe fdc5 	bl	2aa2 <mbed_error_printf>
        faultStatus = MBED_ERROR_HARDFAULT_EXCEPTION;
    3f18:	4b13      	ldr	r3, [pc, #76]	; (3f68 <mbed_fault_handler+0x9c>)
    3f1a:	9307      	str	r3, [sp, #28]
        break;
    3f1c:	bf00      	nop
    }
    mbed_error_printf("\n\nContext:");
    3f1e:	4813      	ldr	r0, [pc, #76]	; (3f6c <mbed_fault_handler+0xa0>)
    3f20:	f7fe fdbf 	bl	2aa2 <mbed_error_printf>
    print_context_info();
    3f24:	f000 f82a 	bl	3f7c <print_context_info>

    mbed_error_printf("\n\n-- MbedOS Fault Handler --\n\n");
    3f28:	4811      	ldr	r0, [pc, #68]	; (3f70 <mbed_fault_handler+0xa4>)
    3f2a:	f7fe fdba 	bl	2aa2 <mbed_error_printf>

    //Now call mbed_error, to log the error and halt the system
    mbed_error( faultStatus, "Fault exception", mbed_fault_context.PC_reg, NULL, 0 );
    3f2e:	4b11      	ldr	r3, [pc, #68]	; (3f74 <mbed_fault_handler+0xa8>)
    3f30:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    3f32:	2300      	movs	r3, #0
    3f34:	9300      	str	r3, [sp, #0]
    3f36:	2300      	movs	r3, #0
    3f38:	490f      	ldr	r1, [pc, #60]	; (3f78 <mbed_fault_handler+0xac>)
    3f3a:	9807      	ldr	r0, [sp, #28]
    3f3c:	f7fe ff3c 	bl	2db8 <mbed_error>

}
    3f40:	bf00      	nop
    3f42:	b009      	add	sp, #36	; 0x24
    3f44:	f85d fb04 	ldr.w	pc, [sp], #4
    3f48:	00011034 	.word	0x00011034
    3f4c:	00011060 	.word	0x00011060
    3f50:	80ff013e 	.word	0x80ff013e
    3f54:	00011070 	.word	0x00011070
    3f58:	80ff013f 	.word	0x80ff013f
    3f5c:	0001107c 	.word	0x0001107c
    3f60:	80ff0140 	.word	0x80ff0140
    3f64:	00011088 	.word	0x00011088
    3f68:	80ff013d 	.word	0x80ff013d
    3f6c:	00011094 	.word	0x00011094
    3f70:	000110a0 	.word	0x000110a0
    3f74:	20001e00 	.word	0x20001e00
    3f78:	000110c0 	.word	0x000110c0

00003f7c <print_context_info>:

MBED_NOINLINE void print_context_info(void)
{
    3f7c:	b530      	push	{r4, r5, lr}
    3f7e:	b087      	sub	sp, #28
    //Context Regs
    for(int i=0;i<13;i++) {
    3f80:	2300      	movs	r3, #0
    3f82:	9305      	str	r3, [sp, #20]
    3f84:	e00c      	b.n	3fa0 <print_context_info+0x24>
        mbed_error_printf("\nR%-4d: %08X", i, ((uint32_t *)&mbed_fault_context)[i]);
    3f86:	9b05      	ldr	r3, [sp, #20]
    3f88:	009b      	lsls	r3, r3, #2
    3f8a:	4a44      	ldr	r2, [pc, #272]	; (409c <print_context_info+0x120>)
    3f8c:	4413      	add	r3, r2
    3f8e:	681b      	ldr	r3, [r3, #0]
    3f90:	461a      	mov	r2, r3
    3f92:	9905      	ldr	r1, [sp, #20]
    3f94:	4842      	ldr	r0, [pc, #264]	; (40a0 <print_context_info+0x124>)
    3f96:	f7fe fd84 	bl	2aa2 <mbed_error_printf>
    for(int i=0;i<13;i++) {
    3f9a:	9b05      	ldr	r3, [sp, #20]
    3f9c:	3301      	adds	r3, #1
    3f9e:	9305      	str	r3, [sp, #20]
    3fa0:	9b05      	ldr	r3, [sp, #20]
    3fa2:	2b0c      	cmp	r3, #12
    3fa4:	ddef      	ble.n	3f86 <print_context_info+0xa>
    }

    mbed_error_printf("\nSP   : %08X"
    3fa6:	4b3d      	ldr	r3, [pc, #244]	; (409c <print_context_info+0x120>)
    3fa8:	6b58      	ldr	r0, [r3, #52]	; 0x34
    3faa:	4b3c      	ldr	r3, [pc, #240]	; (409c <print_context_info+0x120>)
    3fac:	6b9c      	ldr	r4, [r3, #56]	; 0x38
    3fae:	4b3b      	ldr	r3, [pc, #236]	; (409c <print_context_info+0x120>)
    3fb0:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
    3fb2:	4b3a      	ldr	r3, [pc, #232]	; (409c <print_context_info+0x120>)
    3fb4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3fb6:	4a39      	ldr	r2, [pc, #228]	; (409c <print_context_info+0x120>)
    3fb8:	6c52      	ldr	r2, [r2, #68]	; 0x44
    3fba:	4938      	ldr	r1, [pc, #224]	; (409c <print_context_info+0x120>)
    3fbc:	6c89      	ldr	r1, [r1, #72]	; 0x48
    3fbe:	9102      	str	r1, [sp, #8]
    3fc0:	9201      	str	r2, [sp, #4]
    3fc2:	9300      	str	r3, [sp, #0]
    3fc4:	462b      	mov	r3, r5
    3fc6:	4622      	mov	r2, r4
    3fc8:	4601      	mov	r1, r0
    3fca:	4836      	ldr	r0, [pc, #216]	; (40a4 <print_context_info+0x128>)
    3fcc:	f7fe fd69 	bl	2aa2 <mbed_error_printf>
                      "\nPSP  : %08X"
                      "\nMSP  : %08X", mbed_fault_context.SP_reg, mbed_fault_context.LR_reg, mbed_fault_context.PC_reg,
                                     mbed_fault_context.xPSR, mbed_fault_context.PSP, mbed_fault_context.MSP );

    //Capture CPUID to get core/cpu info
    mbed_error_printf("\nCPUID: %08X", SCB->CPUID);
    3fd0:	4b35      	ldr	r3, [pc, #212]	; (40a8 <print_context_info+0x12c>)
    3fd2:	681b      	ldr	r3, [r3, #0]
    3fd4:	4619      	mov	r1, r3
    3fd6:	4835      	ldr	r0, [pc, #212]	; (40ac <print_context_info+0x130>)
    3fd8:	f7fe fd63 	bl	2aa2 <mbed_error_printf>
                    "\nMMFSR: %08X"
                    "\nBFSR : %08X"
                    "\nUFSR : %08X"
                    "\nDFSR : %08X"
                    "\nAFSR : %08X"  ////Split/Capture CFSR into MMFSR, BFSR, UFSR
                    ,SCB->HFSR, (0xFF & SCB->CFSR), ((0xFF00 & SCB->CFSR) >> 8), ((0xFFFF0000 & SCB->CFSR) >> 16), SCB->DFSR, SCB->AFSR );
    3fdc:	4b32      	ldr	r3, [pc, #200]	; (40a8 <print_context_info+0x12c>)
    mbed_error_printf("\nHFSR : %08X"
    3fde:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
                    ,SCB->HFSR, (0xFF & SCB->CFSR), ((0xFF00 & SCB->CFSR) >> 8), ((0xFFFF0000 & SCB->CFSR) >> 16), SCB->DFSR, SCB->AFSR );
    3fe0:	4b31      	ldr	r3, [pc, #196]	; (40a8 <print_context_info+0x12c>)
    3fe2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    mbed_error_printf("\nHFSR : %08X"
    3fe4:	b2dc      	uxtb	r4, r3
                    ,SCB->HFSR, (0xFF & SCB->CFSR), ((0xFF00 & SCB->CFSR) >> 8), ((0xFFFF0000 & SCB->CFSR) >> 16), SCB->DFSR, SCB->AFSR );
    3fe6:	4b30      	ldr	r3, [pc, #192]	; (40a8 <print_context_info+0x12c>)
    3fe8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3fea:	0a1b      	lsrs	r3, r3, #8
    mbed_error_printf("\nHFSR : %08X"
    3fec:	b2dd      	uxtb	r5, r3
                    ,SCB->HFSR, (0xFF & SCB->CFSR), ((0xFF00 & SCB->CFSR) >> 8), ((0xFFFF0000 & SCB->CFSR) >> 16), SCB->DFSR, SCB->AFSR );
    3fee:	4b2e      	ldr	r3, [pc, #184]	; (40a8 <print_context_info+0x12c>)
    3ff0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3ff2:	0c1b      	lsrs	r3, r3, #16
    mbed_error_printf("\nHFSR : %08X"
    3ff4:	b29b      	uxth	r3, r3
                    ,SCB->HFSR, (0xFF & SCB->CFSR), ((0xFF00 & SCB->CFSR) >> 8), ((0xFFFF0000 & SCB->CFSR) >> 16), SCB->DFSR, SCB->AFSR );
    3ff6:	4a2c      	ldr	r2, [pc, #176]	; (40a8 <print_context_info+0x12c>)
    mbed_error_printf("\nHFSR : %08X"
    3ff8:	6b12      	ldr	r2, [r2, #48]	; 0x30
                    ,SCB->HFSR, (0xFF & SCB->CFSR), ((0xFF00 & SCB->CFSR) >> 8), ((0xFFFF0000 & SCB->CFSR) >> 16), SCB->DFSR, SCB->AFSR );
    3ffa:	492b      	ldr	r1, [pc, #172]	; (40a8 <print_context_info+0x12c>)
    mbed_error_printf("\nHFSR : %08X"
    3ffc:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
    3ffe:	9102      	str	r1, [sp, #8]
    4000:	9201      	str	r2, [sp, #4]
    4002:	9300      	str	r3, [sp, #0]
    4004:	462b      	mov	r3, r5
    4006:	4622      	mov	r2, r4
    4008:	4601      	mov	r1, r0
    400a:	4829      	ldr	r0, [pc, #164]	; (40b0 <print_context_info+0x134>)
    400c:	f7fe fd49 	bl	2aa2 <mbed_error_printf>

    //Print MMFAR only if its valid as indicated by MMFSR
    if ((0xFF & SCB->CFSR) & 0x80) {
    4010:	4b25      	ldr	r3, [pc, #148]	; (40a8 <print_context_info+0x12c>)
    4012:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4014:	f003 0380 	and.w	r3, r3, #128	; 0x80
    4018:	2b00      	cmp	r3, #0
    401a:	d005      	beq.n	4028 <print_context_info+0xac>
        mbed_error_printf("\nMMFAR: %08X",SCB->MMFAR);
    401c:	4b22      	ldr	r3, [pc, #136]	; (40a8 <print_context_info+0x12c>)
    401e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    4020:	4619      	mov	r1, r3
    4022:	4824      	ldr	r0, [pc, #144]	; (40b4 <print_context_info+0x138>)
    4024:	f7fe fd3d 	bl	2aa2 <mbed_error_printf>
    }
    //Print BFAR only if its valid as indicated by BFSR
    if (((0xFF00 & SCB->CFSR) >> 8) & 0x80) {
    4028:	4b1f      	ldr	r3, [pc, #124]	; (40a8 <print_context_info+0x12c>)
    402a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    402c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
    4030:	2b00      	cmp	r3, #0
    4032:	d005      	beq.n	4040 <print_context_info+0xc4>
        mbed_error_printf("\nBFAR : %08X",SCB->BFAR);
    4034:	4b1c      	ldr	r3, [pc, #112]	; (40a8 <print_context_info+0x12c>)
    4036:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    4038:	4619      	mov	r1, r3
    403a:	481f      	ldr	r0, [pc, #124]	; (40b8 <print_context_info+0x13c>)
    403c:	f7fe fd31 	bl	2aa2 <mbed_error_printf>
    }
#endif

    //Print Mode
    if (mbed_fault_context.EXC_RETURN & 0x8) {
    4040:	4b16      	ldr	r3, [pc, #88]	; (409c <print_context_info+0x120>)
    4042:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    4044:	f003 0308 	and.w	r3, r3, #8
    4048:	2b00      	cmp	r3, #0
    404a:	d010      	beq.n	406e <print_context_info+0xf2>
        mbed_error_printf("\nMode : Thread");
    404c:	481b      	ldr	r0, [pc, #108]	; (40bc <print_context_info+0x140>)
    404e:	f7fe fd28 	bl	2aa2 <mbed_error_printf>
        //Print Priv level in Thread mode - We capture CONTROL reg which reflects the privilege.
        //Note that the CONTROL register captured still reflects the privilege status of the
        //thread mode eventhough we are in Handler mode by the time we capture it.
        if(mbed_fault_context.CONTROL & 0x1) {
    4052:	4b12      	ldr	r3, [pc, #72]	; (409c <print_context_info+0x120>)
    4054:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    4056:	f003 0301 	and.w	r3, r3, #1
    405a:	2b00      	cmp	r3, #0
    405c:	d003      	beq.n	4066 <print_context_info+0xea>
            mbed_error_printf("\nPriv : User");
    405e:	4818      	ldr	r0, [pc, #96]	; (40c0 <print_context_info+0x144>)
    4060:	f7fe fd1f 	bl	2aa2 <mbed_error_printf>
    4064:	e009      	b.n	407a <print_context_info+0xfe>
        } else {
            mbed_error_printf("\nPriv : Privileged");
    4066:	4817      	ldr	r0, [pc, #92]	; (40c4 <print_context_info+0x148>)
    4068:	f7fe fd1b 	bl	2aa2 <mbed_error_printf>
    406c:	e005      	b.n	407a <print_context_info+0xfe>
        }
    } else {
        mbed_error_printf("\nMode : Handler");
    406e:	4816      	ldr	r0, [pc, #88]	; (40c8 <print_context_info+0x14c>)
    4070:	f7fe fd17 	bl	2aa2 <mbed_error_printf>
        mbed_error_printf("\nPriv : Privileged");
    4074:	4813      	ldr	r0, [pc, #76]	; (40c4 <print_context_info+0x148>)
    4076:	f7fe fd14 	bl	2aa2 <mbed_error_printf>
    }
    //Print Return Stack
    if (mbed_fault_context.EXC_RETURN & 0x4) {
    407a:	4b08      	ldr	r3, [pc, #32]	; (409c <print_context_info+0x120>)
    407c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    407e:	f003 0304 	and.w	r3, r3, #4
    4082:	2b00      	cmp	r3, #0
    4084:	d003      	beq.n	408e <print_context_info+0x112>
        mbed_error_printf("\nStack: PSP");
    4086:	4811      	ldr	r0, [pc, #68]	; (40cc <print_context_info+0x150>)
    4088:	f7fe fd0b 	bl	2aa2 <mbed_error_printf>
    } else {
        mbed_error_printf("\nStack: MSP");
    }
}
    408c:	e002      	b.n	4094 <print_context_info+0x118>
        mbed_error_printf("\nStack: MSP");
    408e:	4810      	ldr	r0, [pc, #64]	; (40d0 <print_context_info+0x154>)
    4090:	f7fe fd07 	bl	2aa2 <mbed_error_printf>
}
    4094:	bf00      	nop
    4096:	b007      	add	sp, #28
    4098:	bd30      	pop	{r4, r5, pc}
    409a:	bf00      	nop
    409c:	20001e00 	.word	0x20001e00
    40a0:	000110d0 	.word	0x000110d0
    40a4:	000110e0 	.word	0x000110e0
    40a8:	e000ed00 	.word	0xe000ed00
    40ac:	0001112c 	.word	0x0001112c
    40b0:	0001113c 	.word	0x0001113c
    40b4:	00011188 	.word	0x00011188
    40b8:	00011198 	.word	0x00011198
    40bc:	000111a8 	.word	0x000111a8
    40c0:	000111b8 	.word	0x000111b8
    40c4:	000111c8 	.word	0x000111c8
    40c8:	000111dc 	.word	0x000111dc
    40cc:	000111ec 	.word	0x000111ec
    40d0:	000111f8 	.word	0x000111f8

000040d4 <mbed_set_stack_heap>:
 * -mbed_heap_start
 * -mbed_heap_size
 * -mbed_stack_isr_start
 * -mbed_stack_isr_size
 */
void mbed_set_stack_heap(void) {
    40d4:	b082      	sub	sp, #8

    unsigned char *free_start = HEAP_START;
    40d6:	4b13      	ldr	r3, [pc, #76]	; (4124 <mbed_set_stack_heap+0x50>)
    40d8:	9301      	str	r3, [sp, #4]
    uint32_t free_size = HEAP_SIZE;
    40da:	4b12      	ldr	r3, [pc, #72]	; (4124 <mbed_set_stack_heap+0x50>)
    40dc:	f1c3 5300 	rsb	r3, r3, #536870912	; 0x20000000
    40e0:	f503 3340 	add.w	r3, r3, #196608	; 0x30000
    40e4:	9300      	str	r3, [sp, #0]
    /* Interrupt stack explicitly specified */
    mbed_stack_isr_size = ISR_STACK_SIZE;
    mbed_stack_isr_start = ISR_STACK_START;
#else
    /* Interrupt stack -  reserve space at the end of the free block */
    mbed_stack_isr_size = ISR_STACK_SIZE < free_size ? ISR_STACK_SIZE : free_size;
    40e6:	9b00      	ldr	r3, [sp, #0]
    40e8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    40ec:	bf28      	it	cs
    40ee:	f44f 6380 	movcs.w	r3, #1024	; 0x400
    40f2:	4a0d      	ldr	r2, [pc, #52]	; (4128 <mbed_set_stack_heap+0x54>)
    40f4:	6013      	str	r3, [r2, #0]
    mbed_stack_isr_start = free_start + free_size - mbed_stack_isr_size;
    40f6:	4b0c      	ldr	r3, [pc, #48]	; (4128 <mbed_set_stack_heap+0x54>)
    40f8:	681b      	ldr	r3, [r3, #0]
    40fa:	9a00      	ldr	r2, [sp, #0]
    40fc:	1ad3      	subs	r3, r2, r3
    40fe:	9a01      	ldr	r2, [sp, #4]
    4100:	4413      	add	r3, r2
    4102:	4a0a      	ldr	r2, [pc, #40]	; (412c <mbed_set_stack_heap+0x58>)
    4104:	6013      	str	r3, [r2, #0]
    free_size -= mbed_stack_isr_size;
    4106:	4b08      	ldr	r3, [pc, #32]	; (4128 <mbed_set_stack_heap+0x54>)
    4108:	681b      	ldr	r3, [r3, #0]
    410a:	9a00      	ldr	r2, [sp, #0]
    410c:	1ad3      	subs	r3, r2, r3
    410e:	9300      	str	r3, [sp, #0]
#endif

    /* Heap - everything else */
    mbed_heap_size = free_size;
    4110:	4a07      	ldr	r2, [pc, #28]	; (4130 <mbed_set_stack_heap+0x5c>)
    4112:	9b00      	ldr	r3, [sp, #0]
    4114:	6013      	str	r3, [r2, #0]
    mbed_heap_start = free_start;
    4116:	4a07      	ldr	r2, [pc, #28]	; (4134 <mbed_set_stack_heap+0x60>)
    4118:	9b01      	ldr	r3, [sp, #4]
    411a:	6013      	str	r3, [r2, #0]
}
    411c:	bf00      	nop
    411e:	b002      	add	sp, #8
    4120:	4770      	bx	lr
    4122:	bf00      	nop
    4124:	20003050 	.word	0x20003050
    4128:	20000e2c 	.word	0x20000e2c
    412c:	20000e28 	.word	0x20000e28
    4130:	20000d9c 	.word	0x20000d9c
    4134:	20000d98 	.word	0x20000d98

00004138 <mbed_cpy_nvic>:

static void mbed_cpy_nvic(void)
{
    4138:	b084      	sub	sp, #16
    VTOR register and for A9 for which CMSIS doesn't define NVIC_SetVector; in both cases target code is
    responsible for correctly handling the vectors.
    */
#if !defined(__CORTEX_M0) && !defined(__CORTEX_A9)
#ifdef NVIC_RAM_VECTOR_ADDRESS
    uint32_t *old_vectors = (uint32_t *)SCB->VTOR;
    413a:	4b0f      	ldr	r3, [pc, #60]	; (4178 <mbed_cpy_nvic+0x40>)
    413c:	689b      	ldr	r3, [r3, #8]
    413e:	9302      	str	r3, [sp, #8]
    uint32_t *vectors = (uint32_t*)NVIC_RAM_VECTOR_ADDRESS;
    4140:	4b0e      	ldr	r3, [pc, #56]	; (417c <mbed_cpy_nvic+0x44>)
    4142:	9301      	str	r3, [sp, #4]
    for (int i = 0; i < NVIC_NUM_VECTORS; i++) {
    4144:	2300      	movs	r3, #0
    4146:	9303      	str	r3, [sp, #12]
    4148:	e00c      	b.n	4164 <mbed_cpy_nvic+0x2c>
        vectors[i] = old_vectors[i];
    414a:	9b03      	ldr	r3, [sp, #12]
    414c:	009b      	lsls	r3, r3, #2
    414e:	9a01      	ldr	r2, [sp, #4]
    4150:	4413      	add	r3, r2
    4152:	9a03      	ldr	r2, [sp, #12]
    4154:	0092      	lsls	r2, r2, #2
    4156:	9902      	ldr	r1, [sp, #8]
    4158:	440a      	add	r2, r1
    415a:	6812      	ldr	r2, [r2, #0]
    415c:	601a      	str	r2, [r3, #0]
    for (int i = 0; i < NVIC_NUM_VECTORS; i++) {
    415e:	9b03      	ldr	r3, [sp, #12]
    4160:	3301      	adds	r3, #1
    4162:	9303      	str	r3, [sp, #12]
    4164:	9b03      	ldr	r3, [sp, #12]
    4166:	2b65      	cmp	r3, #101	; 0x65
    4168:	ddef      	ble.n	414a <mbed_cpy_nvic+0x12>
    }
    SCB->VTOR = (uint32_t)NVIC_RAM_VECTOR_ADDRESS;
    416a:	4b03      	ldr	r3, [pc, #12]	; (4178 <mbed_cpy_nvic+0x40>)
    416c:	4a03      	ldr	r2, [pc, #12]	; (417c <mbed_cpy_nvic+0x44>)
    416e:	609a      	str	r2, [r3, #8]
#endif /* NVIC_RAM_VECTOR_ADDRESS */
#endif /* !defined(__CORTEX_M0) && !defined(__CORTEX_A9) */
}
    4170:	bf00      	nop
    4172:	b004      	add	sp, #16
    4174:	4770      	bx	lr
    4176:	bf00      	nop
    4178:	e000ed00 	.word	0xe000ed00
    417c:	1fff0000 	.word	0x1fff0000

00004180 <mbed_main>:
 * mbed_main(), it is not meant for user code, but for the SDK itself to perform
 * initializations before main() is called.
 */
WEAK void mbed_main(void) {

}
    4180:	bf00      	nop
    4182:	4770      	bx	lr

00004184 <mbed_start_main>:
void mbed_sdk_init(void);
WEAK void mbed_sdk_init(void) {
}

void mbed_start_main(void)
{
    4184:	b500      	push	{lr}
    4186:	b085      	sub	sp, #20
    _main_thread_attr.stack_mem = _main_stack;
    4188:	4b14      	ldr	r3, [pc, #80]	; (41dc <mbed_start_main+0x58>)
    418a:	4a15      	ldr	r2, [pc, #84]	; (41e0 <mbed_start_main+0x5c>)
    418c:	611a      	str	r2, [r3, #16]
    _main_thread_attr.stack_size = sizeof(_main_stack);
    418e:	4b13      	ldr	r3, [pc, #76]	; (41dc <mbed_start_main+0x58>)
    4190:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    4194:	615a      	str	r2, [r3, #20]
    _main_thread_attr.cb_size = sizeof(_main_obj);
    4196:	4b11      	ldr	r3, [pc, #68]	; (41dc <mbed_start_main+0x58>)
    4198:	2248      	movs	r2, #72	; 0x48
    419a:	60da      	str	r2, [r3, #12]
    _main_thread_attr.cb_mem = &_main_obj;
    419c:	4b0f      	ldr	r3, [pc, #60]	; (41dc <mbed_start_main+0x58>)
    419e:	4a11      	ldr	r2, [pc, #68]	; (41e4 <mbed_start_main+0x60>)
    41a0:	609a      	str	r2, [r3, #8]
    _main_thread_attr.priority = osPriorityNormal;
    41a2:	4b0e      	ldr	r3, [pc, #56]	; (41dc <mbed_start_main+0x58>)
    41a4:	2218      	movs	r2, #24
    41a6:	619a      	str	r2, [r3, #24]
    _main_thread_attr.name = "main_thread";
    41a8:	4b0c      	ldr	r3, [pc, #48]	; (41dc <mbed_start_main+0x58>)
    41aa:	4a0f      	ldr	r2, [pc, #60]	; (41e8 <mbed_start_main+0x64>)
    41ac:	601a      	str	r2, [r3, #0]
    /* Allow non-secure main thread to call secure functions */
#if defined(DOMAIN_NS) && (DOMAIN_NS == 1U)
    _main_thread_attr.tz_module = 1U;
#endif

    osThreadId_t result = osThreadNew((osThreadFunc_t)pre_main, NULL, &_main_thread_attr);
    41ae:	4a0b      	ldr	r2, [pc, #44]	; (41dc <mbed_start_main+0x58>)
    41b0:	2100      	movs	r1, #0
    41b2:	480e      	ldr	r0, [pc, #56]	; (41ec <mbed_start_main+0x68>)
    41b4:	f003 fc5c 	bl	7a70 <osThreadNew>
    41b8:	9003      	str	r0, [sp, #12]
    if ((void *)result == NULL) {
    41ba:	9b03      	ldr	r3, [sp, #12]
    41bc:	2b00      	cmp	r3, #0
    41be:	d107      	bne.n	41d0 <mbed_start_main+0x4c>
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_INITIALIZATION_FAILED), "Pre main thread not created", &_main_thread_attr);
    41c0:	4a06      	ldr	r2, [pc, #24]	; (41dc <mbed_start_main+0x58>)
    41c2:	2300      	movs	r3, #0
    41c4:	9300      	str	r3, [sp, #0]
    41c6:	2300      	movs	r3, #0
    41c8:	4909      	ldr	r1, [pc, #36]	; (41f0 <mbed_start_main+0x6c>)
    41ca:	480a      	ldr	r0, [pc, #40]	; (41f4 <mbed_start_main+0x70>)
    41cc:	f7fe fdf4 	bl	2db8 <mbed_error>
    }

    osKernelStart();
    41d0:	f000 fe3c 	bl	4e4c <osKernelStart>
}
    41d4:	bf00      	nop
    41d6:	b005      	add	sp, #20
    41d8:	f85d fb04 	ldr.w	pc, [sp], #4
    41dc:	20001ea8 	.word	0x20001ea8
    41e0:	20001f58 	.word	0x20001f58
    41e4:	20001f0c 	.word	0x20001f0c
    41e8:	00011204 	.word	0x00011204
    41ec:	00004209 	.word	0x00004209
    41f0:	00011210 	.word	0x00011210
    41f4:	8001011d 	.word	0x8001011d

000041f8 <__wrap_main>:

#ifdef  FEATURE_UVISOR
#include "uvisor-lib/uvisor-lib.h"
#endif/* FEATURE_UVISOR */

int __wrap_main(void) {
    41f8:	b508      	push	{r3, lr}
    mbed_main();
    41fa:	f7ff ffc1 	bl	4180 <mbed_main>
    return __real_main();
    41fe:	f7fd fb1d 	bl	183c <main>
    4202:	4603      	mov	r3, r0
}
    4204:	4618      	mov	r0, r3
    4206:	bd08      	pop	{r3, pc}

00004208 <pre_main>:

void pre_main(void)
{
    4208:	b508      	push	{r3, lr}
    singleton_mutex_attr.name = "singleton_mutex";
    420a:	4b1f      	ldr	r3, [pc, #124]	; (4288 <pre_main+0x80>)
    420c:	4a1f      	ldr	r2, [pc, #124]	; (428c <pre_main+0x84>)
    420e:	601a      	str	r2, [r3, #0]
    singleton_mutex_attr.attr_bits = osMutexRecursive | osMutexPrioInherit | osMutexRobust;
    4210:	4b1d      	ldr	r3, [pc, #116]	; (4288 <pre_main+0x80>)
    4212:	220b      	movs	r2, #11
    4214:	605a      	str	r2, [r3, #4]
    singleton_mutex_attr.cb_size = sizeof(singleton_mutex_obj);
    4216:	4b1c      	ldr	r3, [pc, #112]	; (4288 <pre_main+0x80>)
    4218:	221c      	movs	r2, #28
    421a:	60da      	str	r2, [r3, #12]
    singleton_mutex_attr.cb_mem = &singleton_mutex_obj;
    421c:	4b1a      	ldr	r3, [pc, #104]	; (4288 <pre_main+0x80>)
    421e:	4a1c      	ldr	r2, [pc, #112]	; (4290 <pre_main+0x88>)
    4220:	609a      	str	r2, [r3, #8]
    singleton_mutex_id = osMutexNew(&singleton_mutex_attr);
    4222:	4819      	ldr	r0, [pc, #100]	; (4288 <pre_main+0x80>)
    4224:	f002 f97c 	bl	6520 <osMutexNew>
    4228:	4602      	mov	r2, r0
    422a:	4b1a      	ldr	r3, [pc, #104]	; (4294 <pre_main+0x8c>)
    422c:	601a      	str	r2, [r3, #0]

    malloc_mutex_attr.name = "malloc_mutex";
    422e:	4b1a      	ldr	r3, [pc, #104]	; (4298 <pre_main+0x90>)
    4230:	4a1a      	ldr	r2, [pc, #104]	; (429c <pre_main+0x94>)
    4232:	601a      	str	r2, [r3, #0]
    malloc_mutex_attr.attr_bits = osMutexRecursive | osMutexPrioInherit | osMutexRobust;
    4234:	4b18      	ldr	r3, [pc, #96]	; (4298 <pre_main+0x90>)
    4236:	220b      	movs	r2, #11
    4238:	605a      	str	r2, [r3, #4]
    malloc_mutex_attr.cb_size = sizeof(malloc_mutex_obj);
    423a:	4b17      	ldr	r3, [pc, #92]	; (4298 <pre_main+0x90>)
    423c:	221c      	movs	r2, #28
    423e:	60da      	str	r2, [r3, #12]
    malloc_mutex_attr.cb_mem = &malloc_mutex_obj;
    4240:	4b15      	ldr	r3, [pc, #84]	; (4298 <pre_main+0x90>)
    4242:	4a17      	ldr	r2, [pc, #92]	; (42a0 <pre_main+0x98>)
    4244:	609a      	str	r2, [r3, #8]
    malloc_mutex_id = osMutexNew(&malloc_mutex_attr);
    4246:	4814      	ldr	r0, [pc, #80]	; (4298 <pre_main+0x90>)
    4248:	f002 f96a 	bl	6520 <osMutexNew>
    424c:	4602      	mov	r2, r0
    424e:	4b15      	ldr	r3, [pc, #84]	; (42a4 <pre_main+0x9c>)
    4250:	601a      	str	r2, [r3, #0]

    env_mutex_attr.name = "env_mutex";
    4252:	4b15      	ldr	r3, [pc, #84]	; (42a8 <pre_main+0xa0>)
    4254:	4a15      	ldr	r2, [pc, #84]	; (42ac <pre_main+0xa4>)
    4256:	601a      	str	r2, [r3, #0]
    env_mutex_attr.attr_bits = osMutexRecursive | osMutexPrioInherit | osMutexRobust;
    4258:	4b13      	ldr	r3, [pc, #76]	; (42a8 <pre_main+0xa0>)
    425a:	220b      	movs	r2, #11
    425c:	605a      	str	r2, [r3, #4]
    env_mutex_attr.cb_size = sizeof(env_mutex_obj);
    425e:	4b12      	ldr	r3, [pc, #72]	; (42a8 <pre_main+0xa0>)
    4260:	221c      	movs	r2, #28
    4262:	60da      	str	r2, [r3, #12]
    env_mutex_attr.cb_mem = &env_mutex_obj;
    4264:	4b10      	ldr	r3, [pc, #64]	; (42a8 <pre_main+0xa0>)
    4266:	4a12      	ldr	r2, [pc, #72]	; (42b0 <pre_main+0xa8>)
    4268:	609a      	str	r2, [r3, #8]
    env_mutex_id = osMutexNew(&env_mutex_attr);
    426a:	480f      	ldr	r0, [pc, #60]	; (42a8 <pre_main+0xa0>)
    426c:	f002 f958 	bl	6520 <osMutexNew>
    4270:	4602      	mov	r2, r0
    4272:	4b10      	ldr	r3, [pc, #64]	; (42b4 <pre_main+0xac>)
    4274:	601a      	str	r2, [r3, #0]

    __libc_init_array();
    4276:	f006 fd15 	bl	aca4 <__libc_init_array>

    main(0, NULL);
    427a:	2100      	movs	r1, #0
    427c:	2000      	movs	r0, #0
    427e:	f7ff ffbb 	bl	41f8 <__wrap_main>
}
    4282:	bf00      	nop
    4284:	bd08      	pop	{r3, pc}
    4286:	bf00      	nop
    4288:	20001e84 	.word	0x20001e84
    428c:	0001122c 	.word	0x0001122c
    4290:	20001e58 	.word	0x20001e58
    4294:	20001ed0 	.word	0x20001ed0
    4298:	20001e74 	.word	0x20001e74
    429c:	0001123c 	.word	0x0001123c
    42a0:	20001ed4 	.word	0x20001ed4
    42a4:	20001ecc 	.word	0x20001ecc
    42a8:	20001e94 	.word	0x20001e94
    42ac:	0001124c 	.word	0x0001124c
    42b0:	20001ef0 	.word	0x20001ef0
    42b4:	20001ea4 	.word	0x20001ea4

000042b8 <software_init_hook>:

void software_init_hook(void)
{
    42b8:	b508      	push	{r3, lr}
    mbed_set_stack_heap();
    42ba:	f7ff ff0b 	bl	40d4 <mbed_set_stack_heap>
    /* Copy the vector table to RAM only if uVisor is not in use. */
#if !(defined(FEATURE_UVISOR) && defined(TARGET_UVISOR_SUPPORTED))
    mbed_cpy_nvic();
    42be:	f7ff ff3b 	bl	4138 <mbed_cpy_nvic>
#endif
    mbed_sdk_init();
    42c2:	f003 fe61 	bl	7f88 <mbed_sdk_init>
    osKernelInitialize();
    42c6:	f000 fd7d 	bl	4dc4 <osKernelInitialize>
    return_code = uvisor_lib_init();
    if (return_code) {
        mbed_die();
    }
#endif/* FEATURE_UVISOR */
    mbed_start_main();
    42ca:	f7ff ff5b 	bl	4184 <mbed_start_main>
}
    42ce:	bf00      	nop
    42d0:	bd08      	pop	{r3, pc}
	...

000042d4 <__rtos_malloc_lock>:

/* Opaque declaration of _reent structure */
struct _reent;

void __rtos_malloc_lock( struct _reent *_r )
{
    42d4:	b500      	push	{lr}
    42d6:	b083      	sub	sp, #12
    42d8:	9001      	str	r0, [sp, #4]
    osMutexAcquire(malloc_mutex_id, osWaitForever);
    42da:	4b05      	ldr	r3, [pc, #20]	; (42f0 <__rtos_malloc_lock+0x1c>)
    42dc:	681b      	ldr	r3, [r3, #0]
    42de:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    42e2:	4618      	mov	r0, r3
    42e4:	f002 f944 	bl	6570 <osMutexAcquire>
}
    42e8:	bf00      	nop
    42ea:	b003      	add	sp, #12
    42ec:	f85d fb04 	ldr.w	pc, [sp], #4
    42f0:	20001ecc 	.word	0x20001ecc

000042f4 <__rtos_malloc_unlock>:

void __rtos_malloc_unlock( struct _reent *_r )
{
    42f4:	b500      	push	{lr}
    42f6:	b083      	sub	sp, #12
    42f8:	9001      	str	r0, [sp, #4]
    osMutexRelease(malloc_mutex_id);
    42fa:	4b04      	ldr	r3, [pc, #16]	; (430c <__rtos_malloc_unlock+0x18>)
    42fc:	681b      	ldr	r3, [r3, #0]
    42fe:	4618      	mov	r0, r3
    4300:	f002 f964 	bl	65cc <osMutexRelease>
}
    4304:	bf00      	nop
    4306:	b003      	add	sp, #12
    4308:	f85d fb04 	ldr.w	pc, [sp], #4
    430c:	20001ecc 	.word	0x20001ecc

00004310 <osRtxIdleThread>:

extern void rtos_idle_loop(void);
extern void thread_terminate_hook(osThreadId_t id);

__NO_RETURN void osRtxIdleThread (void *argument)
{
    4310:	b500      	push	{lr}
    4312:	b083      	sub	sp, #12
    4314:	9001      	str	r0, [sp, #4]
    for (;;) {
      rtos_idle_loop();
    4316:	f000 f911 	bl	453c <rtos_idle_loop>
    431a:	e7fc      	b.n	4316 <osRtxIdleThread+0x6>

0000431c <osRtxErrorNotify>:
    }
}

__NO_RETURN uint32_t osRtxErrorNotify (uint32_t code, void *object_id)
{
    431c:	b500      	push	{lr}
    431e:	b087      	sub	sp, #28
    4320:	9003      	str	r0, [sp, #12]
    4322:	9102      	str	r1, [sp, #8]
    osThreadId_t tid = osThreadGetId();
    4324:	f003 fbec 	bl	7b00 <osThreadGetId>
    4328:	9005      	str	r0, [sp, #20]

    switch (code) {
    432a:	9b03      	ldr	r3, [sp, #12]
    432c:	3b01      	subs	r3, #1
    432e:	2b04      	cmp	r3, #4
    4330:	d839      	bhi.n	43a6 <osRtxErrorNotify+0x8a>
    4332:	a201      	add	r2, pc, #4	; (adr r2, 4338 <osRtxErrorNotify+0x1c>)
    4334:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    4338:	0000434d 	.word	0x0000434d
    433c:	0000435f 	.word	0x0000435f
    4340:	00004371 	.word	0x00004371
    4344:	00004383 	.word	0x00004383
    4348:	00004395 	.word	0x00004395
      case osRtxErrorStackUnderflow:
        // Stack underflow detected for thread (thread_id=object_id)
        // Note: "overflow" is printed instead of "underflow" due to end user familiarity with overflow errors
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_KERNEL, MBED_ERROR_CODE_STACK_OVERFLOW), "CMSIS-RTOS error: Stack overflow", code);
    434c:	2300      	movs	r3, #0
    434e:	9300      	str	r3, [sp, #0]
    4350:	2300      	movs	r3, #0
    4352:	9a03      	ldr	r2, [sp, #12]
    4354:	4919      	ldr	r1, [pc, #100]	; (43bc <osRtxErrorNotify+0xa0>)
    4356:	481a      	ldr	r0, [pc, #104]	; (43c0 <osRtxErrorNotify+0xa4>)
    4358:	f7fe fd2e 	bl	2db8 <mbed_error>
        break;
    435c:	e02c      	b.n	43b8 <osRtxErrorNotify+0x9c>
      case osRtxErrorISRQueueOverflow:
        // ISR Queue overflow detected when inserting object (object_id)
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_KERNEL, MBED_ERROR_CODE_ISR_QUEUE_OVERFLOW), "CMSIS-RTOS error: ISR Queue overflow", code);
    435e:	2300      	movs	r3, #0
    4360:	9300      	str	r3, [sp, #0]
    4362:	2300      	movs	r3, #0
    4364:	9a03      	ldr	r2, [sp, #12]
    4366:	4917      	ldr	r1, [pc, #92]	; (43c4 <osRtxErrorNotify+0xa8>)
    4368:	4817      	ldr	r0, [pc, #92]	; (43c8 <osRtxErrorNotify+0xac>)
    436a:	f7fe fd25 	bl	2db8 <mbed_error>
        break;
    436e:	e023      	b.n	43b8 <osRtxErrorNotify+0x9c>
      case osRtxErrorTimerQueueOverflow:
        // User Timer Callback Queue overflow detected for timer (timer_id=object_id)
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_KERNEL, MBED_ERROR_CODE_TIMER_QUEUE_OVERFLOW), "CMSIS-RTOS error: User Timer Callback Queue overflow", code);
    4370:	2300      	movs	r3, #0
    4372:	9300      	str	r3, [sp, #0]
    4374:	2300      	movs	r3, #0
    4376:	9a03      	ldr	r2, [sp, #12]
    4378:	4914      	ldr	r1, [pc, #80]	; (43cc <osRtxErrorNotify+0xb0>)
    437a:	4815      	ldr	r0, [pc, #84]	; (43d0 <osRtxErrorNotify+0xb4>)
    437c:	f7fe fd1c 	bl	2db8 <mbed_error>
        break;
    4380:	e01a      	b.n	43b8 <osRtxErrorNotify+0x9c>
      case osRtxErrorClibSpace:
        // Standard C/C++ library libspace not available: increase OS_THREAD_LIBSPACE_NUM
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_KERNEL, MBED_ERROR_CODE_CLIB_SPACE_UNAVAILABLE), "CMSIS-RTOS error: STD C/C++ library libspace not available", code);
    4382:	2300      	movs	r3, #0
    4384:	9300      	str	r3, [sp, #0]
    4386:	2300      	movs	r3, #0
    4388:	9a03      	ldr	r2, [sp, #12]
    438a:	4912      	ldr	r1, [pc, #72]	; (43d4 <osRtxErrorNotify+0xb8>)
    438c:	4812      	ldr	r0, [pc, #72]	; (43d8 <osRtxErrorNotify+0xbc>)
    438e:	f7fe fd13 	bl	2db8 <mbed_error>
        break;
    4392:	e011      	b.n	43b8 <osRtxErrorNotify+0x9c>
      case osRtxErrorClibMutex:
        // Standard C/C++ library mutex initialization failed
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_KERNEL, MBED_ERROR_CODE_CLIB_MUTEX_INIT_FAILURE), "CMSIS-RTOS error: STD C/C++ library mutex initialization failed", code);
    4394:	2300      	movs	r3, #0
    4396:	9300      	str	r3, [sp, #0]
    4398:	2300      	movs	r3, #0
    439a:	9a03      	ldr	r2, [sp, #12]
    439c:	490f      	ldr	r1, [pc, #60]	; (43dc <osRtxErrorNotify+0xc0>)
    439e:	4810      	ldr	r0, [pc, #64]	; (43e0 <osRtxErrorNotify+0xc4>)
    43a0:	f7fe fd0a 	bl	2db8 <mbed_error>
        break;
    43a4:	e008      	b.n	43b8 <osRtxErrorNotify+0x9c>
      default:
        //Unknown error flagged from kernel
        MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_KERNEL, MBED_ERROR_CODE_UNKNOWN), "CMSIS-RTOS error: Unknown", code);
    43a6:	2300      	movs	r3, #0
    43a8:	9300      	str	r3, [sp, #0]
    43aa:	2300      	movs	r3, #0
    43ac:	9a03      	ldr	r2, [sp, #12]
    43ae:	490d      	ldr	r1, [pc, #52]	; (43e4 <osRtxErrorNotify+0xc8>)
    43b0:	480d      	ldr	r0, [pc, #52]	; (43e8 <osRtxErrorNotify+0xcc>)
    43b2:	f7fe fd01 	bl	2db8 <mbed_error>
        break;
    43b6:	bf00      	nop
    }

    /* That shouldn't be reached */
    for (;;) {}
    43b8:	e7fe      	b.n	43b8 <osRtxErrorNotify+0x9c>
    43ba:	bf00      	nop
    43bc:	00011258 	.word	0x00011258
    43c0:	80020125 	.word	0x80020125
    43c4:	0001127c 	.word	0x0001127c
    43c8:	80020126 	.word	0x80020126
    43cc:	000112a4 	.word	0x000112a4
    43d0:	80020127 	.word	0x80020127
    43d4:	000112dc 	.word	0x000112dc
    43d8:	80020128 	.word	0x80020128
    43dc:	00011318 	.word	0x00011318
    43e0:	8002012a 	.word	0x8002012a
    43e4:	00011358 	.word	0x00011358
    43e8:	80020100 	.word	0x80020100

000043ec <error_msg>:
}

#if defined(MBED_TRAP_ERRORS_ENABLED) && MBED_TRAP_ERRORS_ENABLED

static const char* error_msg(int32_t status)
{
    43ec:	b082      	sub	sp, #8
    43ee:	9001      	str	r0, [sp, #4]
    switch (status) {
    43f0:	9b01      	ldr	r3, [sp, #4]
    43f2:	3306      	adds	r3, #6
    43f4:	2b05      	cmp	r3, #5
    43f6:	d81b      	bhi.n	4430 <error_msg+0x44>
    43f8:	a201      	add	r2, pc, #4	; (adr r2, 4400 <error_msg+0x14>)
    43fa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    43fe:	bf00      	nop
    4400:	0000442d 	.word	0x0000442d
    4404:	00004429 	.word	0x00004429
    4408:	00004425 	.word	0x00004425
    440c:	00004421 	.word	0x00004421
    4410:	0000441d 	.word	0x0000441d
    4414:	00004419 	.word	0x00004419
    case osError:
        return "Unspecified RTOS error";
    4418:	4b07      	ldr	r3, [pc, #28]	; (4438 <error_msg+0x4c>)
    441a:	e00a      	b.n	4432 <error_msg+0x46>
    case osErrorTimeout:
        return "Operation not completed within the timeout period";
    441c:	4b07      	ldr	r3, [pc, #28]	; (443c <error_msg+0x50>)
    441e:	e008      	b.n	4432 <error_msg+0x46>
    case osErrorResource:
        return "Resource not available";
    4420:	4b07      	ldr	r3, [pc, #28]	; (4440 <error_msg+0x54>)
    4422:	e006      	b.n	4432 <error_msg+0x46>
    case osErrorParameter:
        return "Parameter error";
    4424:	4b07      	ldr	r3, [pc, #28]	; (4444 <error_msg+0x58>)
    4426:	e004      	b.n	4432 <error_msg+0x46>
    case osErrorNoMemory:
        return "System is out of memory";
    4428:	4b07      	ldr	r3, [pc, #28]	; (4448 <error_msg+0x5c>)
    442a:	e002      	b.n	4432 <error_msg+0x46>
    case osErrorISR:
        return "Not allowed in ISR context";
    442c:	4b07      	ldr	r3, [pc, #28]	; (444c <error_msg+0x60>)
    442e:	e000      	b.n	4432 <error_msg+0x46>
    default:
        return "Unknown";
    4430:	4b07      	ldr	r3, [pc, #28]	; (4450 <error_msg+0x64>)
    }
}
    4432:	4618      	mov	r0, r3
    4434:	b002      	add	sp, #8
    4436:	4770      	bx	lr
    4438:	00011374 	.word	0x00011374
    443c:	0001138c 	.word	0x0001138c
    4440:	000113c0 	.word	0x000113c0
    4444:	000113d8 	.word	0x000113d8
    4448:	000113e8 	.word	0x000113e8
    444c:	00011400 	.word	0x00011400
    4450:	0001141c 	.word	0x0001141c

00004454 <EvrRtxKernelError>:

void EvrRtxKernelError (int32_t status)
{
    4454:	b500      	push	{lr}
    4456:	b085      	sub	sp, #20
    4458:	9003      	str	r0, [sp, #12]
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_RTOS_EVENT), error_msg(status), status);
    445a:	9803      	ldr	r0, [sp, #12]
    445c:	f7ff ffc6 	bl	43ec <error_msg>
    4460:	4601      	mov	r1, r0
    4462:	9a03      	ldr	r2, [sp, #12]
    4464:	2300      	movs	r3, #0
    4466:	9300      	str	r3, [sp, #0]
    4468:	2300      	movs	r3, #0
    446a:	4803      	ldr	r0, [pc, #12]	; (4478 <EvrRtxKernelError+0x24>)
    446c:	f7fe fca4 	bl	2db8 <mbed_error>
}
    4470:	bf00      	nop
    4472:	b005      	add	sp, #20
    4474:	f85d fb04 	ldr.w	pc, [sp], #4
    4478:	80010131 	.word	0x80010131

0000447c <EvrRtxThreadError>:

void EvrRtxThreadError (osThreadId_t thread_id, int32_t status)
{
    447c:	b500      	push	{lr}
    447e:	b085      	sub	sp, #20
    4480:	9003      	str	r0, [sp, #12]
    4482:	9102      	str	r1, [sp, #8]
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_RTOS_THREAD_EVENT), error_msg(status), thread_id);
    4484:	9802      	ldr	r0, [sp, #8]
    4486:	f7ff ffb1 	bl	43ec <error_msg>
    448a:	4601      	mov	r1, r0
    448c:	9a03      	ldr	r2, [sp, #12]
    448e:	2300      	movs	r3, #0
    4490:	9300      	str	r3, [sp, #0]
    4492:	2300      	movs	r3, #0
    4494:	4803      	ldr	r0, [pc, #12]	; (44a4 <EvrRtxThreadError+0x28>)
    4496:	f7fe fc8f 	bl	2db8 <mbed_error>
}
    449a:	bf00      	nop
    449c:	b005      	add	sp, #20
    449e:	f85d fb04 	ldr.w	pc, [sp], #4
    44a2:	bf00      	nop
    44a4:	80010132 	.word	0x80010132

000044a8 <EvrRtxMutexError>:
{
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_RTOS_EVENT_FLAGS_EVENT), error_msg(status), ef_id);
}

void EvrRtxMutexError (osMutexId_t mutex_id, int32_t status)
{
    44a8:	b500      	push	{lr}
    44aa:	b085      	sub	sp, #20
    44ac:	9003      	str	r0, [sp, #12]
    44ae:	9102      	str	r1, [sp, #8]
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_RTOS_MUTEX_EVENT), error_msg(status), mutex_id);
    44b0:	9802      	ldr	r0, [sp, #8]
    44b2:	f7ff ff9b 	bl	43ec <error_msg>
    44b6:	4601      	mov	r1, r0
    44b8:	9a03      	ldr	r2, [sp, #12]
    44ba:	2300      	movs	r3, #0
    44bc:	9300      	str	r3, [sp, #0]
    44be:	2300      	movs	r3, #0
    44c0:	4803      	ldr	r0, [pc, #12]	; (44d0 <EvrRtxMutexError+0x28>)
    44c2:	f7fe fc79 	bl	2db8 <mbed_error>
}
    44c6:	bf00      	nop
    44c8:	b005      	add	sp, #20
    44ca:	f85d fb04 	ldr.w	pc, [sp], #4
    44ce:	bf00      	nop
    44d0:	80010133 	.word	0x80010133

000044d4 <EvrRtxMessageQueueError>:
{
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_RTOS_MEMORY_POOL_EVENT), error_msg(status), mp_id);
}

void EvrRtxMessageQueueError (osMessageQueueId_t mq_id, int32_t status)
{
    44d4:	b500      	push	{lr}
    44d6:	b085      	sub	sp, #20
    44d8:	9003      	str	r0, [sp, #12]
    44da:	9102      	str	r1, [sp, #8]
    MBED_ERROR1(MBED_MAKE_ERROR(MBED_MODULE_PLATFORM, MBED_ERROR_CODE_RTOS_MESSAGE_QUEUE_EVENT), error_msg(status), mq_id);
    44dc:	9802      	ldr	r0, [sp, #8]
    44de:	f7ff ff85 	bl	43ec <error_msg>
    44e2:	4601      	mov	r1, r0
    44e4:	9a03      	ldr	r2, [sp, #12]
    44e6:	2300      	movs	r3, #0
    44e8:	9300      	str	r3, [sp, #0]
    44ea:	2300      	movs	r3, #0
    44ec:	4803      	ldr	r0, [pc, #12]	; (44fc <EvrRtxMessageQueueError+0x28>)
    44ee:	f7fe fc63 	bl	2db8 <mbed_error>
}
    44f2:	bf00      	nop
    44f4:	b005      	add	sp, #20
    44f6:	f85d fb04 	ldr.w	pc, [sp], #4
    44fa:	bf00      	nop
    44fc:	80010138 	.word	0x80010138

00004500 <EvrRtxThreadExit>:

#endif

// RTX hook which gets called when a thread terminates, using the event function to call hook
void EvrRtxThreadExit (void)
{
    4500:	b500      	push	{lr}
    4502:	b083      	sub	sp, #12
    osThreadId_t thread_id = osThreadGetId();
    4504:	f003 fafc 	bl	7b00 <osThreadGetId>
    4508:	9001      	str	r0, [sp, #4]
    thread_terminate_hook(thread_id);
    450a:	9801      	ldr	r0, [sp, #4]
    450c:	f003 fce2 	bl	7ed4 <thread_terminate_hook>
#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_EXIT_DISABLE) && defined(RTE_Compiler_EventRecorder))
    EventRecord2(EvtRtxThreadExit, 0U, 0U);
#endif
}
    4510:	bf00      	nop
    4512:	b003      	add	sp, #12
    4514:	f85d fb04 	ldr.w	pc, [sp], #4

00004518 <sleep>:
 *  The mbed interface semihosting is disconnected as part of going to sleep, and can not be restored.
 * Flash re-programming and the USB serial port will remain active, but the mbed program will no longer be
 * able to access the LocalFileSystem
 */
static inline void sleep(void)
{
    4518:	b508      	push	{r3, lr}
#if !(defined(FEATURE_UVISOR) && defined(TARGET_UVISOR_SUPPORTED))
#if DEVICE_SLEEP
#if (MBED_CONF_RTOS_PRESENT == 0) || (DEVICE_STCLK_OFF_DURING_SLEEP == 0) || defined(MBED_TICKLESS)
    sleep_manager_sleep_auto();
    451a:	f7fd fceb 	bl	1ef4 <sleep_manager_sleep_auto>
#endif /* (MBED_CONF_RTOS_PRESENT == 0) || (DEVICE_STCLK_OFF_DURING_SLEEP == 0) || defined(MBED_TICKLESS) */
#endif /* DEVICE_SLEEP */
#endif /* !(defined(FEATURE_UVISOR) && defined(TARGET_UVISOR_SUPPORTED)) */
}
    451e:	bf00      	nop
    4520:	bd08      	pop	{r3, pc}

00004522 <_ZL17default_idle_hookv>:
}

#else

static void default_idle_hook(void)
{
    4522:	b508      	push	{r3, lr}
    // critical section to complete sleep with locked deepsleep
    core_util_critical_section_enter();
    4524:	f7fe fb36 	bl	2b94 <core_util_critical_section_enter>
    sleep_manager_lock_deep_sleep();
    4528:	f7fd fc9a 	bl	1e60 <sleep_manager_lock_deep_sleep_internal>
    sleep();
    452c:	f7ff fff4 	bl	4518 <sleep>
    sleep_manager_unlock_deep_sleep();
    4530:	f7fd fcbc 	bl	1eac <sleep_manager_unlock_deep_sleep_internal>
    core_util_critical_section_exit();
    4534:	f7fe fb48 	bl	2bc8 <core_util_critical_section_exit>
}
    4538:	bf00      	nop
    453a:	bd08      	pop	{r3, pc}

0000453c <rtos_idle_loop>:
        idle_hook_fptr = default_idle_hook;
    }
}

extern "C" void rtos_idle_loop(void)
{
    453c:	b508      	push	{r3, lr}
    //Continuously call the idle hook function pointer
    while (1) {
        idle_hook_fptr();
    453e:	4b02      	ldr	r3, [pc, #8]	; (4548 <rtos_idle_loop+0xc>)
    4540:	681b      	ldr	r3, [r3, #0]
    4542:	4798      	blx	r3
    4544:	e7fb      	b.n	453e <rtos_idle_loop+0x2>
    4546:	bf00      	nop
    4548:	2000010c 	.word	0x2000010c

0000454c <IsIrqMode>:
  return ((__get_CONTROL() & 1U) == 0U);
}

/// Check if in IRQ Mode
/// \return     true=IRQ, false=thread
__STATIC_INLINE bool_t IsIrqMode (void) {
    454c:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    454e:	f3ef 8305 	mrs	r3, IPSR
    4552:	9301      	str	r3, [sp, #4]
  return(result);
    4554:	9b01      	ldr	r3, [sp, #4]
  return (__get_IPSR() != 0U);
    4556:	2b00      	cmp	r3, #0
    4558:	bf14      	ite	ne
    455a:	2301      	movne	r3, #1
    455c:	2300      	moveq	r3, #0
    455e:	b2db      	uxtb	r3, r3
}
    4560:	4618      	mov	r0, r3
    4562:	b002      	add	sp, #8
    4564:	4770      	bx	lr

00004566 <IsIrqMasked>:

/// Check if IRQ is Masked
/// \return     true=masked, false=not masked
__STATIC_INLINE bool_t IsIrqMasked (void) {
    4566:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    4568:	f3ef 8310 	mrs	r3, PRIMASK
    456c:	9301      	str	r3, [sp, #4]
  return(result);
    456e:	9b01      	ldr	r3, [sp, #4]
#if   ((defined(__ARM_ARCH_7M__)      && (__ARM_ARCH_7M__      != 0)) || \
       (defined(__ARM_ARCH_7EM__)     && (__ARM_ARCH_7EM__     != 0)) || \
       (defined(__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ != 0)))
  return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
    4570:	2b00      	cmp	r3, #0
    4572:	d105      	bne.n	4580 <IsIrqMasked+0x1a>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
    4574:	f3ef 8311 	mrs	r3, BASEPRI
    4578:	9300      	str	r3, [sp, #0]
  return(result);
    457a:	9b00      	ldr	r3, [sp, #0]
    457c:	2b00      	cmp	r3, #0
    457e:	d001      	beq.n	4584 <IsIrqMasked+0x1e>
    4580:	2301      	movs	r3, #1
    4582:	e000      	b.n	4586 <IsIrqMasked+0x20>
    4584:	2300      	movs	r3, #0
    4586:	f003 0301 	and.w	r3, r3, #1
    458a:	b2db      	uxtb	r3, r3
#else
  return  (__get_PRIMASK() != 0U);
#endif
}
    458c:	4618      	mov	r0, r3
    458e:	b002      	add	sp, #8
    4590:	4770      	bx	lr

00004592 <svcRtxDelay>:

//  ==== Service Calls ====

/// Wait for Timeout (Time Delay).
/// \note API identical to osDelay
static osStatus_t svcRtxDelay (uint32_t ticks) {
    4592:	b500      	push	{lr}
    4594:	b083      	sub	sp, #12
    4596:	9001      	str	r0, [sp, #4]

  if (ticks != 0U) {
    4598:	9b01      	ldr	r3, [sp, #4]
    459a:	2b00      	cmp	r3, #0
    459c:	d00b      	beq.n	45b6 <svcRtxDelay+0x24>
    if (!osRtxThreadWaitEnter(osRtxThreadWaitingDelay, ticks)) {
    459e:	9901      	ldr	r1, [sp, #4]
    45a0:	2013      	movs	r0, #19
    45a2:	f002 fdd1 	bl	7148 <osRtxThreadWaitEnter>
    45a6:	4603      	mov	r3, r0
    45a8:	f083 0301 	eor.w	r3, r3, #1
    45ac:	b2db      	uxtb	r3, r3
    45ae:	2b00      	cmp	r3, #0
    45b0:	d001      	beq.n	45b6 <svcRtxDelay+0x24>
      EvrRtxThreadDelayCompleted();
    45b2:	f000 f8cb 	bl	474c <EvrRtxThreadDelayCompleted>
    }
  }

  return osOK;
    45b6:	2300      	movs	r3, #0
}
    45b8:	4618      	mov	r0, r3
    45ba:	b003      	add	sp, #12
    45bc:	f85d fb04 	ldr.w	pc, [sp], #4

000045c0 <osDelay>:


//  ==== Public API ====

/// Wait for Timeout (Time Delay).
osStatus_t osDelay (uint32_t ticks) {
    45c0:	b500      	push	{lr}
    45c2:	b085      	sub	sp, #20
    45c4:	9001      	str	r0, [sp, #4]
  osStatus_t status;

  EvrRtxThreadDelay(ticks);
    45c6:	9801      	ldr	r0, [sp, #4]
    45c8:	f000 f8bb 	bl	4742 <EvrRtxThreadDelay>
  if (IsIrqMode() || IsIrqMasked()) {
    45cc:	f7ff ffbe 	bl	454c <IsIrqMode>
    45d0:	4603      	mov	r3, r0
    45d2:	2b00      	cmp	r3, #0
    45d4:	d104      	bne.n	45e0 <osDelay+0x20>
    45d6:	f7ff ffc6 	bl	4566 <IsIrqMasked>
    45da:	4603      	mov	r3, r0
    45dc:	2b00      	cmp	r3, #0
    45de:	d008      	beq.n	45f2 <osDelay+0x32>
    EvrRtxThreadError(NULL, (int32_t)osErrorISR);
    45e0:	f06f 0105 	mvn.w	r1, #5
    45e4:	2000      	movs	r0, #0
    45e6:	f7ff ff49 	bl	447c <EvrRtxThreadError>
    status = osErrorISR;
    45ea:	f06f 0305 	mvn.w	r3, #5
    45ee:	9303      	str	r3, [sp, #12]
    45f0:	e007      	b.n	4602 <osDelay+0x42>
    45f2:	9b01      	ldr	r3, [sp, #4]
    45f4:	9302      	str	r3, [sp, #8]
SVC0_1(Delay,      osStatus_t, uint32_t)
    45f6:	9802      	ldr	r0, [sp, #8]
    45f8:	4b04      	ldr	r3, [pc, #16]	; (460c <osDelay+0x4c>)
    45fa:	469c      	mov	ip, r3
    45fc:	df00      	svc	0
    45fe:	4603      	mov	r3, r0
  } else {
    status = __svcDelay(ticks);
    4600:	9303      	str	r3, [sp, #12]
  }
  return status;
    4602:	9b03      	ldr	r3, [sp, #12]
}
    4604:	4618      	mov	r0, r3
    4606:	b005      	add	sp, #20
    4608:	f85d fb04 	ldr.w	pc, [sp], #4
    460c:	00004593 	.word	0x00004593

00004610 <EvrRtxMemoryInit>:


//  ==== Memory Events ====

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_INIT_DISABLE))
__WEAK void EvrRtxMemoryInit (void *mem, uint32_t size, uint32_t result) {
    4610:	b084      	sub	sp, #16
    4612:	9003      	str	r0, [sp, #12]
    4614:	9102      	str	r1, [sp, #8]
    4616:	9201      	str	r2, [sp, #4]
#else
  (void)mem;
  (void)size;
  (void)result;
#endif
}
    4618:	bf00      	nop
    461a:	b004      	add	sp, #16
    461c:	4770      	bx	lr

0000461e <EvrRtxMemoryAlloc>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_ALLOC_DISABLE))
__WEAK void EvrRtxMemoryAlloc (void *mem, uint32_t size, uint32_t type, void *block) {
    461e:	b084      	sub	sp, #16
    4620:	9003      	str	r0, [sp, #12]
    4622:	9102      	str	r1, [sp, #8]
    4624:	9201      	str	r2, [sp, #4]
    4626:	9300      	str	r3, [sp, #0]
  (void)mem;
  (void)size;
  (void)type;
  (void)block;
#endif
}
    4628:	bf00      	nop
    462a:	b004      	add	sp, #16
    462c:	4770      	bx	lr

0000462e <EvrRtxMemoryFree>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_FREE_DISABLE))
__WEAK void EvrRtxMemoryFree (void *mem, void *block, uint32_t result) {
    462e:	b084      	sub	sp, #16
    4630:	9003      	str	r0, [sp, #12]
    4632:	9102      	str	r1, [sp, #8]
    4634:	9201      	str	r2, [sp, #4]
#else
  (void)mem;
  (void)block;
  (void)result;
#endif
}
    4636:	bf00      	nop
    4638:	b004      	add	sp, #16
    463a:	4770      	bx	lr

0000463c <EvrRtxMemoryBlockInit>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_BLOCK_INIT_DISABLE))
__WEAK void EvrRtxMemoryBlockInit (osRtxMpInfo_t *mp_info, uint32_t block_count, uint32_t block_size, void *block_mem) {
    463c:	b084      	sub	sp, #16
    463e:	9003      	str	r0, [sp, #12]
    4640:	9102      	str	r1, [sp, #8]
    4642:	9201      	str	r2, [sp, #4]
    4644:	9300      	str	r3, [sp, #0]
  (void)mp_info;
  (void)block_count;
  (void)block_size;
  (void)block_mem;
#endif
}
    4646:	bf00      	nop
    4648:	b004      	add	sp, #16
    464a:	4770      	bx	lr

0000464c <EvrRtxMemoryBlockAlloc>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_BLOCK_ALLOC_DISABLE))
__WEAK void EvrRtxMemoryBlockAlloc (osRtxMpInfo_t *mp_info, void *block) {
    464c:	b082      	sub	sp, #8
    464e:	9001      	str	r0, [sp, #4]
    4650:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMemoryBlockAlloc, (uint32_t)mp_info, (uint32_t)block);
#else
  (void)mp_info;
  (void)block;
#endif
}
    4652:	bf00      	nop
    4654:	b002      	add	sp, #8
    4656:	4770      	bx	lr

00004658 <EvrRtxMemoryBlockFree>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMORY != 0) && !defined(EVR_RTX_MEMORY_BLOCK_FREE_DISABLE))
__WEAK void EvrRtxMemoryBlockFree (osRtxMpInfo_t *mp_info, void *block, int32_t status) {
    4658:	b084      	sub	sp, #16
    465a:	9003      	str	r0, [sp, #12]
    465c:	9102      	str	r1, [sp, #8]
    465e:	9201      	str	r2, [sp, #4]
#else
  (void)mp_info;
  (void)block;
  (void)status;
#endif
}
    4660:	bf00      	nop
    4662:	b004      	add	sp, #16
    4664:	4770      	bx	lr

00004666 <EvrRtxKernelInitialize>:
__WEAK void EvrRtxKernelInitialize (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelInitialize, 0U, 0U);
#else
#endif
}
    4666:	bf00      	nop
    4668:	4770      	bx	lr

0000466a <EvrRtxKernelInitializeCompleted>:
__WEAK void EvrRtxKernelInitializeCompleted (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelInitializeCompleted, 0U, 0U);
#else
#endif
}
    466a:	bf00      	nop
    466c:	4770      	bx	lr

0000466e <EvrRtxKernelGetState>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_GET_STATE_DISABLE))
__WEAK void EvrRtxKernelGetState (osKernelState_t state) {
    466e:	b082      	sub	sp, #8
    4670:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelGetState, (uint32_t)state, 0U);
#else
  (void)state;
#endif
}
    4672:	bf00      	nop
    4674:	b002      	add	sp, #8
    4676:	4770      	bx	lr

00004678 <EvrRtxKernelStart>:
__WEAK void EvrRtxKernelStart (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelStart, 0U, 0U);
#else
#endif
}
    4678:	bf00      	nop
    467a:	4770      	bx	lr

0000467c <EvrRtxKernelStarted>:
__WEAK void EvrRtxKernelStarted (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelStarted, 0U, 0U);
#else
#endif
}
    467c:	bf00      	nop
    467e:	4770      	bx	lr

00004680 <EvrRtxKernelLock>:
__WEAK void EvrRtxKernelLock (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelLock, 0U, 0U);
#else
#endif
}
    4680:	bf00      	nop
    4682:	4770      	bx	lr

00004684 <EvrRtxKernelLocked>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_LOCKED_DISABLE))
__WEAK void EvrRtxKernelLocked (int32_t lock) {
    4684:	b082      	sub	sp, #8
    4686:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelLocked, (uint32_t)lock, 0U);
#else
  (void)lock;
#endif
}
    4688:	bf00      	nop
    468a:	b002      	add	sp, #8
    468c:	4770      	bx	lr

0000468e <EvrRtxKernelUnlock>:
__WEAK void EvrRtxKernelUnlock (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelUnlock, 0U, 0U);
#else
#endif
}
    468e:	bf00      	nop
    4690:	4770      	bx	lr

00004692 <EvrRtxKernelUnlocked>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_KERNEL != 0) && !defined(EVR_RTX_KERNEL_UNLOCKED_DISABLE))
__WEAK void EvrRtxKernelUnlocked (int32_t lock) {
    4692:	b082      	sub	sp, #8
    4694:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxKernelUnlocked, (uint32_t)lock, 0U);
#else
  (void)lock;
#endif
}
    4696:	bf00      	nop
    4698:	b002      	add	sp, #8
    469a:	4770      	bx	lr

0000469c <EvrRtxThreadNew>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_NEW_DISABLE))
__WEAK void EvrRtxThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
    469c:	b084      	sub	sp, #16
    469e:	9003      	str	r0, [sp, #12]
    46a0:	9102      	str	r1, [sp, #8]
    46a2:	9201      	str	r2, [sp, #4]
#else
  (void)func;
  (void)argument;
  (void)attr;
#endif
}
    46a4:	bf00      	nop
    46a6:	b004      	add	sp, #16
    46a8:	4770      	bx	lr

000046aa <EvrRtxThreadCreated>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_CREATED_DISABLE))
__WEAK void EvrRtxThreadCreated (osThreadId_t thread_id, uint32_t thread_addr) {
    46aa:	b082      	sub	sp, #8
    46ac:	9001      	str	r0, [sp, #4]
    46ae:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxThreadCreated, (uint32_t)thread_id, thread_addr);
#else
  (void)thread_id;
  (void)thread_addr;
#endif
}
    46b0:	bf00      	nop
    46b2:	b002      	add	sp, #8
    46b4:	4770      	bx	lr

000046b6 <EvrRtxThreadGetId>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_GET_ID_DISABLE))
__WEAK void EvrRtxThreadGetId (osThreadId_t thread_id) {
    46b6:	b082      	sub	sp, #8
    46b8:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadGetId, (uint32_t)thread_id, 0U);
#else
  (void)thread_id;
#endif
}
    46ba:	bf00      	nop
    46bc:	b002      	add	sp, #8
    46be:	4770      	bx	lr

000046c0 <EvrRtxThreadGetStackSize>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_GET_STACK_SIZE_DISABLE))
__WEAK void EvrRtxThreadGetStackSize (osThreadId_t thread_id, uint32_t stack_size) {
    46c0:	b082      	sub	sp, #8
    46c2:	9001      	str	r0, [sp, #4]
    46c4:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxThreadGetStackSize, (uint32_t)thread_id, stack_size);
#else
  (void)thread_id;
  (void)stack_size;
#endif
}
    46c6:	bf00      	nop
    46c8:	b002      	add	sp, #8
    46ca:	4770      	bx	lr

000046cc <EvrRtxThreadGetStackSpace>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_GET_STACK_SPACE_DISABLE))
__WEAK void EvrRtxThreadGetStackSpace (osThreadId_t thread_id, uint32_t stack_space) {
    46cc:	b082      	sub	sp, #8
    46ce:	9001      	str	r0, [sp, #4]
    46d0:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxThreadGetStackSpace, (uint32_t)thread_id, stack_space);
#else
  (void)thread_id;
  (void)stack_space;
#endif
}
    46d2:	bf00      	nop
    46d4:	b002      	add	sp, #8
    46d6:	4770      	bx	lr

000046d8 <EvrRtxThreadJoined>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_JOINED_DISABLE))
__WEAK void EvrRtxThreadJoined (osThreadId_t thread_id) {
    46d8:	b082      	sub	sp, #8
    46da:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadJoined, (uint32_t)thread_id, 0U);
#else
  (void)thread_id;
#endif
}
    46dc:	bf00      	nop
    46de:	b002      	add	sp, #8
    46e0:	4770      	bx	lr

000046e2 <EvrRtxThreadBlocked>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_BLOCKED_DISABLE))
__WEAK void EvrRtxThreadBlocked (osThreadId_t thread_id, uint32_t timeout) {
    46e2:	b082      	sub	sp, #8
    46e4:	9001      	str	r0, [sp, #4]
    46e6:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxThreadBlocked, (uint32_t)thread_id, timeout);
#else
  (void)thread_id;
  (void)timeout;
#endif
}
    46e8:	bf00      	nop
    46ea:	b002      	add	sp, #8
    46ec:	4770      	bx	lr

000046ee <EvrRtxThreadUnblocked>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_UNBLOCKED_DISABLE))
__WEAK void EvrRtxThreadUnblocked (osThreadId_t thread_id, uint32_t ret_val) {
    46ee:	b082      	sub	sp, #8
    46f0:	9001      	str	r0, [sp, #4]
    46f2:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxThreadUnblocked, (uint32_t)thread_id, ret_val);
#else
  (void)thread_id;
  (void)ret_val;
#endif
}
    46f4:	bf00      	nop
    46f6:	b002      	add	sp, #8
    46f8:	4770      	bx	lr

000046fa <EvrRtxThreadPreempted>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_PREEMPTED_DISABLE))
__WEAK void EvrRtxThreadPreempted (osThreadId_t thread_id) {
    46fa:	b082      	sub	sp, #8
    46fc:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadPreempted, (uint32_t)thread_id, 0U);
#else
  (void)thread_id;
#endif
}
    46fe:	bf00      	nop
    4700:	b002      	add	sp, #8
    4702:	4770      	bx	lr

00004704 <EvrRtxThreadSwitched>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_SWITCHED_DISABLE))
__WEAK void EvrRtxThreadSwitched (osThreadId_t thread_id) {
    4704:	b082      	sub	sp, #8
    4706:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadSwitched, (uint32_t)thread_id, 0U);
#else
  (void)thread_id;
#endif
}
    4708:	bf00      	nop
    470a:	b002      	add	sp, #8
    470c:	4770      	bx	lr

0000470e <EvrRtxThreadDestroyed>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_DESTROYED_DISABLE))
__WEAK void EvrRtxThreadDestroyed (osThreadId_t thread_id) {
    470e:	b082      	sub	sp, #8
    4710:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadDestroyed, (uint32_t)thread_id, 0U);
#else
  (void)thread_id;
#endif
}
    4712:	bf00      	nop
    4714:	b002      	add	sp, #8
    4716:	4770      	bx	lr

00004718 <EvrRtxThreadGetCount>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_GET_COUNT_DISABLE))
__WEAK void EvrRtxThreadGetCount (uint32_t count) {
    4718:	b082      	sub	sp, #8
    471a:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadGetCount, count, 0U);
#else
  (void)count;
#endif
}
    471c:	bf00      	nop
    471e:	b002      	add	sp, #8
    4720:	4770      	bx	lr

00004722 <EvrRtxThreadEnumerate>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_ENUMERATE_DISABLE))
__WEAK void EvrRtxThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items, uint32_t count) {
    4722:	b084      	sub	sp, #16
    4724:	9003      	str	r0, [sp, #12]
    4726:	9102      	str	r1, [sp, #8]
    4728:	9201      	str	r2, [sp, #4]
#else
  (void)thread_array;
  (void)array_items;
  (void)count;
#endif
}
    472a:	bf00      	nop
    472c:	b004      	add	sp, #16
    472e:	4770      	bx	lr

00004730 <EvrRtxThreadFlagsWaitTimeout>:
#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_FLAGS_WAIT_TIMEOUT_DISABLE))
__WEAK void EvrRtxThreadFlagsWaitTimeout (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadFlagsWaitTimeout, 0U, 0U);
#endif
}
    4730:	bf00      	nop
    4732:	4770      	bx	lr

00004734 <EvrRtxThreadFlagsWaitCompleted>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_FLAGS_WAIT_COMPLETED_DISABLE))
__WEAK void EvrRtxThreadFlagsWaitCompleted (uint32_t flags, uint32_t options, uint32_t thread_flags) {
    4734:	b084      	sub	sp, #16
    4736:	9003      	str	r0, [sp, #12]
    4738:	9102      	str	r1, [sp, #8]
    473a:	9201      	str	r2, [sp, #4]
#else
  (void)flags;
  (void)options;
  (void)thread_flags;
#endif
}
    473c:	bf00      	nop
    473e:	b004      	add	sp, #16
    4740:	4770      	bx	lr

00004742 <EvrRtxThreadDelay>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_DELAY_DISABLE))
__WEAK void EvrRtxThreadDelay (uint32_t ticks) {
    4742:	b082      	sub	sp, #8
    4744:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadDelay, ticks, 0U);
#else
  (void)ticks;
#endif
}
    4746:	bf00      	nop
    4748:	b002      	add	sp, #8
    474a:	4770      	bx	lr

0000474c <EvrRtxThreadDelayCompleted>:
#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_THREAD != 0) && !defined(EVR_RTX_THREAD_DELAY_COMPLETED_DISABLE))
__WEAK void EvrRtxThreadDelayCompleted (void) {
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxThreadDelayCompleted, 0U, 0U);
#endif
}
    474c:	bf00      	nop
    474e:	4770      	bx	lr

00004750 <EvrRtxTimerCallback>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_TIMER != 0) && !defined(EVR_RTX_TIMER_CALLBACK_DISABLE))
__WEAK void EvrRtxTimerCallback (osTimerFunc_t func, void *argument) {
    4750:	b082      	sub	sp, #8
    4752:	9001      	str	r0, [sp, #4]
    4754:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxTimerCallback, (uint32_t)func, (uint32_t)argument);
#else
  (void)func;
  (void)argument;
#endif
}
    4756:	bf00      	nop
    4758:	b002      	add	sp, #8
    475a:	4770      	bx	lr

0000475c <EvrRtxEventFlagsWaitTimeout>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_EVFLAGS != 0) && !defined(EVR_RTX_EVENT_FLAGS_WAIT_TIMEOUT_DISABLE))
__WEAK void EvrRtxEventFlagsWaitTimeout (osEventFlagsId_t ef_id) {
    475c:	b082      	sub	sp, #8
    475e:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxEventFlagsWaitTimeout, (uint32_t)ef_id, 0U);
#else
  (void)ef_id;
#endif
}
    4760:	bf00      	nop
    4762:	b002      	add	sp, #8
    4764:	4770      	bx	lr

00004766 <EvrRtxMutexNew>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_NEW_DISABLE))
__WEAK void EvrRtxMutexNew (const osMutexAttr_t *attr) {
    4766:	b082      	sub	sp, #8
    4768:	9001      	str	r0, [sp, #4]
    (void)EventRecordData(EvtRtxMutexNew_Detail, attr, sizeof (osMutexAttr_t));
  }
#else
  (void)attr;
#endif
}
    476a:	bf00      	nop
    476c:	b002      	add	sp, #8
    476e:	4770      	bx	lr

00004770 <EvrRtxMutexCreated>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_CREATED_DISABLE))
__WEAK void EvrRtxMutexCreated (osMutexId_t mutex_id, const char *name) {
    4770:	b082      	sub	sp, #8
    4772:	9001      	str	r0, [sp, #4]
    4774:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMutexCreated, (uint32_t)mutex_id, (uint32_t)name);
#else
  (void)mutex_id;
  (void)name;
#endif
}
    4776:	bf00      	nop
    4778:	b002      	add	sp, #8
    477a:	4770      	bx	lr

0000477c <EvrRtxMutexAcquire>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_ACQUIRE_DISABLE))
__WEAK void EvrRtxMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
    477c:	b082      	sub	sp, #8
    477e:	9001      	str	r0, [sp, #4]
    4780:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMutexAcquire, (uint32_t)mutex_id, timeout);
#else
  (void)mutex_id;
  (void)timeout;
#endif
}
    4782:	bf00      	nop
    4784:	b002      	add	sp, #8
    4786:	4770      	bx	lr

00004788 <EvrRtxMutexAcquirePending>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_ACQUIRE_PENDING_DISABLE))
__WEAK void EvrRtxMutexAcquirePending (osMutexId_t mutex_id, uint32_t timeout) {
    4788:	b082      	sub	sp, #8
    478a:	9001      	str	r0, [sp, #4]
    478c:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMutexAcquirePending, (uint32_t)mutex_id, timeout);
#else
  (void)mutex_id;
  (void)timeout;
#endif
}
    478e:	bf00      	nop
    4790:	b002      	add	sp, #8
    4792:	4770      	bx	lr

00004794 <EvrRtxMutexAcquireTimeout>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_ACQUIRE_TIMEOUT_DISABLE))
__WEAK void EvrRtxMutexAcquireTimeout (osMutexId_t mutex_id) {
    4794:	b082      	sub	sp, #8
    4796:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxMutexAcquireTimeout, (uint32_t)mutex_id, 0U);
#else
  (void)mutex_id;
#endif
}
    4798:	bf00      	nop
    479a:	b002      	add	sp, #8
    479c:	4770      	bx	lr

0000479e <EvrRtxMutexAcquired>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_ACQUIRED_DISABLE))
__WEAK void EvrRtxMutexAcquired (osMutexId_t mutex_id, uint32_t lock) {
    479e:	b082      	sub	sp, #8
    47a0:	9001      	str	r0, [sp, #4]
    47a2:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMutexAcquired, (uint32_t)mutex_id, lock);
#else
  (void)mutex_id;
  (void)lock;
#endif
}
    47a4:	bf00      	nop
    47a6:	b002      	add	sp, #8
    47a8:	4770      	bx	lr

000047aa <EvrRtxMutexNotAcquired>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_NOT_ACQUIRED_DISABLE))
__WEAK void EvrRtxMutexNotAcquired (osMutexId_t mutex_id) {
    47aa:	b082      	sub	sp, #8
    47ac:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxMutexNotAcquired, (uint32_t)mutex_id, 0U);
#else
  (void)mutex_id;
#endif
}
    47ae:	bf00      	nop
    47b0:	b002      	add	sp, #8
    47b2:	4770      	bx	lr

000047b4 <EvrRtxMutexRelease>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_RELEASE_DISABLE))
__WEAK void EvrRtxMutexRelease (osMutexId_t mutex_id) {
    47b4:	b082      	sub	sp, #8
    47b6:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxMutexRelease, (uint32_t)mutex_id, 0U);
#else
  (void)mutex_id;
#endif
}
    47b8:	bf00      	nop
    47ba:	b002      	add	sp, #8
    47bc:	4770      	bx	lr

000047be <EvrRtxMutexReleased>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MUTEX != 0) && !defined(EVR_RTX_MUTEX_RELEASED_DISABLE))
__WEAK void EvrRtxMutexReleased (osMutexId_t mutex_id, uint32_t lock) {
    47be:	b082      	sub	sp, #8
    47c0:	9001      	str	r0, [sp, #4]
    47c2:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMutexReleased, (uint32_t)mutex_id, lock);
#else
  (void)mutex_id;
  (void)lock;
#endif
}
    47c4:	bf00      	nop
    47c6:	b002      	add	sp, #8
    47c8:	4770      	bx	lr

000047ca <EvrRtxSemaphoreAcquireTimeout>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_SEMAPHORE != 0) && !defined(EVR_RTX_SEMAPHORE_ACQUIRE_TIMEOUT_DISABLE))
__WEAK void EvrRtxSemaphoreAcquireTimeout (osSemaphoreId_t semaphore_id) {
    47ca:	b082      	sub	sp, #8
    47cc:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxSemaphoreAcquireTimeout, (uint32_t)semaphore_id, 0U);
#else
  (void)semaphore_id;
#endif
}
    47ce:	bf00      	nop
    47d0:	b002      	add	sp, #8
    47d2:	4770      	bx	lr

000047d4 <EvrRtxMemoryPoolAllocTimeout>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MEMPOOL != 0) && !defined(EVR_RTX_MEMORY_POOL_ALLOC_TIMEOUT_DISABLE))
__WEAK void EvrRtxMemoryPoolAllocTimeout (osMemoryPoolId_t mp_id) {
    47d4:	b082      	sub	sp, #8
    47d6:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxMemoryPoolAllocTimeout, (uint32_t)mp_id, 0U);
#else
  (void)mp_id;
#endif
}
    47d8:	bf00      	nop
    47da:	b002      	add	sp, #8
    47dc:	4770      	bx	lr

000047de <EvrRtxMessageQueueNew>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_NEW_DISABLE))
__WEAK void EvrRtxMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
    47de:	b084      	sub	sp, #16
    47e0:	9003      	str	r0, [sp, #12]
    47e2:	9102      	str	r1, [sp, #8]
    47e4:	9201      	str	r2, [sp, #4]
#else
  (void)msg_count;
  (void)msg_size;
  (void)attr;
#endif
}
    47e6:	bf00      	nop
    47e8:	b004      	add	sp, #16
    47ea:	4770      	bx	lr

000047ec <EvrRtxMessageQueueCreated>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_CREATED_DISABLE))
__WEAK void EvrRtxMessageQueueCreated (osMessageQueueId_t mq_id, const char *name) {
    47ec:	b082      	sub	sp, #8
    47ee:	9001      	str	r0, [sp, #4]
    47f0:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMessageQueueCreated, (uint32_t)mq_id, (uint32_t)name);
#else
  (void)mq_id;
  (void)name;
#endif
}
    47f2:	bf00      	nop
    47f4:	b002      	add	sp, #8
    47f6:	4770      	bx	lr

000047f8 <EvrRtxMessageQueuePut>:
#endif
}
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_PUT_DISABLE))
__WEAK void EvrRtxMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
    47f8:	b084      	sub	sp, #16
    47fa:	9003      	str	r0, [sp, #12]
    47fc:	9102      	str	r1, [sp, #8]
    47fe:	9300      	str	r3, [sp, #0]
    4800:	4613      	mov	r3, r2
    4802:	f88d 3007 	strb.w	r3, [sp, #7]
  (void)mq_id;
  (void)msg_ptr;
  (void)msg_prio;
  (void)timeout;
#endif
}
    4806:	bf00      	nop
    4808:	b004      	add	sp, #16
    480a:	4770      	bx	lr

0000480c <EvrRtxMessageQueuePutPending>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_PUT_PENDING_DISABLE))
__WEAK void EvrRtxMessageQueuePutPending (osMessageQueueId_t mq_id, const void *msg_ptr, uint32_t timeout) {
    480c:	b084      	sub	sp, #16
    480e:	9003      	str	r0, [sp, #12]
    4810:	9102      	str	r1, [sp, #8]
    4812:	9201      	str	r2, [sp, #4]
#else
  (void)mq_id;
  (void)msg_ptr;
  (void)timeout;
#endif
}
    4814:	bf00      	nop
    4816:	b004      	add	sp, #16
    4818:	4770      	bx	lr

0000481a <EvrRtxMessageQueuePutTimeout>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_PUT_TIMEOUT_DISABLE))
__WEAK void EvrRtxMessageQueuePutTimeout (osMessageQueueId_t mq_id) {
    481a:	b082      	sub	sp, #8
    481c:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxMessageQueuePutTimeout, (uint32_t)mq_id, 0U);
#else
  (void)mq_id;
#endif
}
    481e:	bf00      	nop
    4820:	b002      	add	sp, #8
    4822:	4770      	bx	lr

00004824 <EvrRtxMessageQueueInsertPending>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_INSERT_PENDING_DISABLE))
__WEAK void EvrRtxMessageQueueInsertPending (osMessageQueueId_t mq_id, const void *msg_ptr) {
    4824:	b082      	sub	sp, #8
    4826:	9001      	str	r0, [sp, #4]
    4828:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMessageQueueInsertPending, (uint32_t)mq_id, (uint32_t)msg_ptr);
#else
  (void)mq_id;
  (void)msg_ptr;
#endif
}
    482a:	bf00      	nop
    482c:	b002      	add	sp, #8
    482e:	4770      	bx	lr

00004830 <EvrRtxMessageQueueInserted>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_INSERTED_DISABLE))
__WEAK void EvrRtxMessageQueueInserted (osMessageQueueId_t mq_id, const void *msg_ptr) {
    4830:	b082      	sub	sp, #8
    4832:	9001      	str	r0, [sp, #4]
    4834:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMessageQueueInserted, (uint32_t)mq_id, (uint32_t)msg_ptr);
#else
  (void)mq_id;
  (void)msg_ptr;
#endif
}
    4836:	bf00      	nop
    4838:	b002      	add	sp, #8
    483a:	4770      	bx	lr

0000483c <EvrRtxMessageQueueNotInserted>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_NOT_INSERTED_DISABLE))
__WEAK void EvrRtxMessageQueueNotInserted (osMessageQueueId_t mq_id, const void *msg_ptr) {
    483c:	b082      	sub	sp, #8
    483e:	9001      	str	r0, [sp, #4]
    4840:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMessageQueueNotInserted, (uint32_t)mq_id, (uint32_t)msg_ptr);
#else
  (void)mq_id;
  (void)msg_ptr;
#endif
}
    4842:	bf00      	nop
    4844:	b002      	add	sp, #8
    4846:	4770      	bx	lr

00004848 <EvrRtxMessageQueueGet>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_GET_DISABLE))
__WEAK void EvrRtxMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
    4848:	b084      	sub	sp, #16
    484a:	9003      	str	r0, [sp, #12]
    484c:	9102      	str	r1, [sp, #8]
    484e:	9201      	str	r2, [sp, #4]
    4850:	9300      	str	r3, [sp, #0]
  (void)mq_id;
  (void)msg_ptr;
  (void)msg_prio;
  (void)timeout;
#endif
}
    4852:	bf00      	nop
    4854:	b004      	add	sp, #16
    4856:	4770      	bx	lr

00004858 <EvrRtxMessageQueueGetPending>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_GET_PENDING_DISABLE))
__WEAK void EvrRtxMessageQueueGetPending (osMessageQueueId_t mq_id, void *msg_ptr, uint32_t timeout) {
    4858:	b084      	sub	sp, #16
    485a:	9003      	str	r0, [sp, #12]
    485c:	9102      	str	r1, [sp, #8]
    485e:	9201      	str	r2, [sp, #4]
#else
  (void)mq_id;
  (void)msg_ptr;
  (void)timeout;
#endif
}
    4860:	bf00      	nop
    4862:	b004      	add	sp, #16
    4864:	4770      	bx	lr

00004866 <EvrRtxMessageQueueGetTimeout>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_GET_TIMEOUT_DISABLE))
__WEAK void EvrRtxMessageQueueGetTimeout (osMessageQueueId_t mq_id) {
    4866:	b082      	sub	sp, #8
    4868:	9001      	str	r0, [sp, #4]
#if defined(RTE_Compiler_EventRecorder)
  (void)EventRecord2(EvtRtxMessageQueueGetTimeout, (uint32_t)mq_id, 0U);
#else
  (void)mq_id;
#endif
}
    486a:	bf00      	nop
    486c:	b002      	add	sp, #8
    486e:	4770      	bx	lr

00004870 <EvrRtxMessageQueueRetrieved>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_RETRIEVED_DISABLE))
__WEAK void EvrRtxMessageQueueRetrieved (osMessageQueueId_t mq_id, void *msg_ptr) {
    4870:	b082      	sub	sp, #8
    4872:	9001      	str	r0, [sp, #4]
    4874:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMessageQueueRetrieved, (uint32_t)mq_id, (uint32_t)msg_ptr);
#else
  (void)mq_id;
  (void)msg_ptr;
#endif
}
    4876:	bf00      	nop
    4878:	b002      	add	sp, #8
    487a:	4770      	bx	lr

0000487c <EvrRtxMessageQueueNotRetrieved>:
#endif

#if (!defined(EVR_RTX_DISABLE) && (OS_EVR_MSGQUEUE != 0) && !defined(EVR_RTX_MESSAGE_QUEUE_NOT_RETRIEVED_DISABLE))
__WEAK void EvrRtxMessageQueueNotRetrieved (osMessageQueueId_t mq_id, void *msg_ptr) {
    487c:	b082      	sub	sp, #8
    487e:	9001      	str	r0, [sp, #4]
    4880:	9100      	str	r1, [sp, #0]
  (void)EventRecord2(EvtRtxMessageQueueNotRetrieved, (uint32_t)mq_id, (uint32_t)msg_ptr);
#else
  (void)mq_id;
  (void)msg_ptr;
#endif
}
    4882:	bf00      	nop
    4884:	b002      	add	sp, #8
    4886:	4770      	bx	lr

00004888 <__NVIC_GetPriorityGrouping>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
    4888:	4b03      	ldr	r3, [pc, #12]	; (4898 <__NVIC_GetPriorityGrouping+0x10>)
    488a:	68db      	ldr	r3, [r3, #12]
    488c:	0a1b      	lsrs	r3, r3, #8
    488e:	f003 0307 	and.w	r3, r3, #7
}
    4892:	4618      	mov	r0, r3
    4894:	4770      	bx	lr
    4896:	bf00      	nop
    4898:	e000ed00 	.word	0xe000ed00

0000489c <IsPrivileged>:
__STATIC_INLINE bool_t IsPrivileged (void) {
    489c:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, control" : "=r" (result) );
    489e:	f3ef 8314 	mrs	r3, CONTROL
    48a2:	9301      	str	r3, [sp, #4]
  return(result);
    48a4:	9b01      	ldr	r3, [sp, #4]
  return ((__get_CONTROL() & 1U) == 0U);
    48a6:	f003 0301 	and.w	r3, r3, #1
    48aa:	2b00      	cmp	r3, #0
    48ac:	bf0c      	ite	eq
    48ae:	2301      	moveq	r3, #1
    48b0:	2300      	movne	r3, #0
    48b2:	b2db      	uxtb	r3, r3
}
    48b4:	4618      	mov	r0, r3
    48b6:	b002      	add	sp, #8
    48b8:	4770      	bx	lr

000048ba <IsIrqMode>:
__STATIC_INLINE bool_t IsIrqMode (void) {
    48ba:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    48bc:	f3ef 8305 	mrs	r3, IPSR
    48c0:	9301      	str	r3, [sp, #4]
  return(result);
    48c2:	9b01      	ldr	r3, [sp, #4]
  return (__get_IPSR() != 0U);
    48c4:	2b00      	cmp	r3, #0
    48c6:	bf14      	ite	ne
    48c8:	2301      	movne	r3, #1
    48ca:	2300      	moveq	r3, #0
    48cc:	b2db      	uxtb	r3, r3
}
    48ce:	4618      	mov	r0, r3
    48d0:	b002      	add	sp, #8
    48d2:	4770      	bx	lr

000048d4 <IsIrqMasked>:
__STATIC_INLINE bool_t IsIrqMasked (void) {
    48d4:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    48d6:	f3ef 8310 	mrs	r3, PRIMASK
    48da:	9301      	str	r3, [sp, #4]
  return(result);
    48dc:	9b01      	ldr	r3, [sp, #4]
  return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
    48de:	2b00      	cmp	r3, #0
    48e0:	d105      	bne.n	48ee <IsIrqMasked+0x1a>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
    48e2:	f3ef 8311 	mrs	r3, BASEPRI
    48e6:	9300      	str	r3, [sp, #0]
  return(result);
    48e8:	9b00      	ldr	r3, [sp, #0]
    48ea:	2b00      	cmp	r3, #0
    48ec:	d001      	beq.n	48f2 <IsIrqMasked+0x1e>
    48ee:	2301      	movs	r3, #1
    48f0:	e000      	b.n	48f4 <IsIrqMasked+0x20>
    48f2:	2300      	movs	r3, #0
    48f4:	f003 0301 	and.w	r3, r3, #1
    48f8:	b2db      	uxtb	r3, r3
}
    48fa:	4618      	mov	r0, r3
    48fc:	b002      	add	sp, #8
    48fe:	4770      	bx	lr

00004900 <SVC_Setup>:


//  ==== Core Peripherals functions ====

/// Setup SVC and PendSV System Service Calls
__STATIC_INLINE void SVC_Setup (void) {
    4900:	b500      	push	{lr}
    4902:	b083      	sub	sp, #12
  SCB->SHPR[0] |= (n << (8+1)) & 0xFC000000U;
#elif ((defined(__ARM_ARCH_7M__)      && (__ARM_ARCH_7M__      != 0)) || \
       (defined(__ARM_ARCH_7EM__)     && (__ARM_ARCH_7EM__     != 0)))
  uint32_t p, n;

  SCB->SHP[10] = 0xFFU;
    4904:	4b12      	ldr	r3, [pc, #72]	; (4950 <SVC_Setup+0x50>)
    4906:	22ff      	movs	r2, #255	; 0xff
    4908:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  n = 32U - (uint32_t)__CLZ(~(SCB->SHP[10] | 0xFFFFFF00U));
    490c:	4b10      	ldr	r3, [pc, #64]	; (4950 <SVC_Setup+0x50>)
    490e:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    4912:	b2db      	uxtb	r3, r3
    4914:	f063 03ff 	orn	r3, r3, #255	; 0xff
    4918:	43db      	mvns	r3, r3
    491a:	fab3 f383 	clz	r3, r3
    491e:	b2db      	uxtb	r3, r3
    4920:	f1c3 0320 	rsb	r3, r3, #32
    4924:	9301      	str	r3, [sp, #4]
  p = NVIC_GetPriorityGrouping();
    4926:	f7ff ffaf 	bl	4888 <__NVIC_GetPriorityGrouping>
    492a:	9000      	str	r0, [sp, #0]
  if (p >= n) {
    492c:	9a00      	ldr	r2, [sp, #0]
    492e:	9b01      	ldr	r3, [sp, #4]
    4930:	429a      	cmp	r2, r3
    4932:	d302      	bcc.n	493a <SVC_Setup+0x3a>
    n = p + 1U;
    4934:	9b00      	ldr	r3, [sp, #0]
    4936:	3301      	adds	r3, #1
    4938:	9301      	str	r3, [sp, #4]
  }
  /* Only change the SVCall priority if uVisor is not present. */
  #if !(defined(FEATURE_UVISOR) && defined(TARGET_UVISOR_SUPPORTED))
  SCB->SHP[7] = (uint8_t)(0xFEU << n);
    493a:	4a05      	ldr	r2, [pc, #20]	; (4950 <SVC_Setup+0x50>)
    493c:	21fe      	movs	r1, #254	; 0xfe
    493e:	9b01      	ldr	r3, [sp, #4]
    4940:	fa01 f303 	lsl.w	r3, r1, r3
    4944:	b2db      	uxtb	r3, r3
    4946:	77d3      	strb	r3, [r2, #31]

  SCB->SHP[1] |= 0x00FF0000U;
  n = SCB->SHP[1];
  SCB->SHP[0] |= (n << (8+1)) & 0xFC000000U;
#endif
}
    4948:	bf00      	nop
    494a:	b003      	add	sp, #12
    494c:	f85d fb04 	ldr.w	pc, [sp], #4
    4950:	e000ed00 	.word	0xe000ed00

00004954 <osRtxKernelState>:
}

// Kernel State
__STATIC_INLINE osKernelState_t osRtxKernelState (void) {
  //lint -e{9030} -e{9034} "cast to enum"
  return ((osKernelState_t)(osRtxInfo.kernel.state));
    4954:	4b01      	ldr	r3, [pc, #4]	; (495c <osRtxKernelState+0x8>)
    4956:	7a1b      	ldrb	r3, [r3, #8]
}
    4958:	4618      	mov	r0, r3
    495a:	4770      	bx	lr
    495c:	20000110 	.word	0x20000110

00004960 <svcRtxKernelInitialize>:

//  ==== Service Calls ====

/// Initialize the RTOS Kernel.
/// \note API identical to osKernelInitialize
static osStatus_t svcRtxKernelInitialize (void) {
    4960:	b508      	push	{r3, lr}

  if (osRtxInfo.kernel.state == osRtxKernelReady) {
    4962:	4b44      	ldr	r3, [pc, #272]	; (4a74 <svcRtxKernelInitialize+0x114>)
    4964:	7a1b      	ldrb	r3, [r3, #8]
    4966:	2b01      	cmp	r3, #1
    4968:	d103      	bne.n	4972 <svcRtxKernelInitialize+0x12>
    EvrRtxKernelInitializeCompleted();
    496a:	f7ff fe7e 	bl	466a <EvrRtxKernelInitializeCompleted>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osOK;
    496e:	2300      	movs	r3, #0
    4970:	e159      	b.n	4c26 <svcRtxKernelInitialize+0x2c6>
  }
  if (osRtxInfo.kernel.state != osRtxKernelInactive) {
    4972:	4b40      	ldr	r3, [pc, #256]	; (4a74 <svcRtxKernelInitialize+0x114>)
    4974:	7a1b      	ldrb	r3, [r3, #8]
    4976:	2b00      	cmp	r3, #0
    4978:	d006      	beq.n	4988 <svcRtxKernelInitialize+0x28>
    EvrRtxKernelError((int32_t)osError);
    497a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    497e:	f7ff fd69 	bl	4454 <EvrRtxKernelError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    4982:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4986:	e14e      	b.n	4c26 <svcRtxKernelInitialize+0x2c6>
  }

  if (osRtxConfig.thread_stack_size < (64U + 8U)) {
    4988:	4b3b      	ldr	r3, [pc, #236]	; (4a78 <svcRtxKernelInitialize+0x118>)
    498a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    498c:	2b47      	cmp	r3, #71	; 0x47
    498e:	d806      	bhi.n	499e <svcRtxKernelInitialize+0x3e>
    EvrRtxKernelError(osRtxErrorInvalidThreadStack);
    4990:	f06f 000a 	mvn.w	r0, #10
    4994:	f7ff fd5e 	bl	4454 <EvrRtxKernelError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    4998:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    499c:	e143      	b.n	4c26 <svcRtxKernelInitialize+0x2c6>
  }

  if ((osRtxConfig.isr_queue.data == NULL) || (osRtxConfig.isr_queue.max == 0U)) {
    499e:	4b36      	ldr	r3, [pc, #216]	; (4a78 <svcRtxKernelInitialize+0x118>)
    49a0:	68db      	ldr	r3, [r3, #12]
    49a2:	2b00      	cmp	r3, #0
    49a4:	d003      	beq.n	49ae <svcRtxKernelInitialize+0x4e>
    49a6:	4b34      	ldr	r3, [pc, #208]	; (4a78 <svcRtxKernelInitialize+0x118>)
    49a8:	8a1b      	ldrh	r3, [r3, #16]
    49aa:	2b00      	cmp	r3, #0
    49ac:	d106      	bne.n	49bc <svcRtxKernelInitialize+0x5c>
    EvrRtxKernelError((int32_t)osError);
    49ae:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    49b2:	f7ff fd4f 	bl	4454 <EvrRtxKernelError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    49b6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    49ba:	e134      	b.n	4c26 <svcRtxKernelInitialize+0x2c6>
    return osError;
  }
#endif

  // Initialize osRtxInfo
  memset(&osRtxInfo.kernel, 0, sizeof(osRtxInfo) - offsetof(osRtxInfo_t, kernel));
    49bc:	229c      	movs	r2, #156	; 0x9c
    49be:	2100      	movs	r1, #0
    49c0:	482e      	ldr	r0, [pc, #184]	; (4a7c <svcRtxKernelInitialize+0x11c>)
    49c2:	f006 fd5f 	bl	b484 <memset>

  osRtxInfo.isr_queue.data = osRtxConfig.isr_queue.data;
    49c6:	4b2c      	ldr	r3, [pc, #176]	; (4a78 <svcRtxKernelInitialize+0x118>)
    49c8:	68db      	ldr	r3, [r3, #12]
    49ca:	4a2a      	ldr	r2, [pc, #168]	; (4a74 <svcRtxKernelInitialize+0x114>)
    49cc:	65d3      	str	r3, [r2, #92]	; 0x5c
  osRtxInfo.isr_queue.max  = osRtxConfig.isr_queue.max;
    49ce:	4b2a      	ldr	r3, [pc, #168]	; (4a78 <svcRtxKernelInitialize+0x118>)
    49d0:	8a1a      	ldrh	r2, [r3, #16]
    49d2:	4b28      	ldr	r3, [pc, #160]	; (4a74 <svcRtxKernelInitialize+0x114>)
    49d4:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54

  osRtxInfo.thread.robin.timeout = osRtxConfig.robin_timeout;
    49d8:	4b27      	ldr	r3, [pc, #156]	; (4a78 <svcRtxKernelInitialize+0x118>)
    49da:	689b      	ldr	r3, [r3, #8]
    49dc:	4a25      	ldr	r2, [pc, #148]	; (4a74 <svcRtxKernelInitialize+0x114>)
    49de:	6413      	str	r3, [r2, #64]	; 0x40

  // Initialize Memory Pools (Variable Block Size)
  if (osRtxMemoryInit(osRtxConfig.mem.common_addr, osRtxConfig.mem.common_size) != 0U) {
    49e0:	4b25      	ldr	r3, [pc, #148]	; (4a78 <svcRtxKernelInitialize+0x118>)
    49e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    49e4:	4b24      	ldr	r3, [pc, #144]	; (4a78 <svcRtxKernelInitialize+0x118>)
    49e6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    49e8:	4619      	mov	r1, r3
    49ea:	4610      	mov	r0, r2
    49ec:	f000 fabb 	bl	4f66 <osRtxMemoryInit>
    49f0:	4603      	mov	r3, r0
    49f2:	2b00      	cmp	r3, #0
    49f4:	d004      	beq.n	4a00 <svcRtxKernelInitialize+0xa0>
    osRtxInfo.mem.common = osRtxConfig.mem.common_addr;
    49f6:	4b20      	ldr	r3, [pc, #128]	; (4a78 <svcRtxKernelInitialize+0x118>)
    49f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    49fa:	4a1e      	ldr	r2, [pc, #120]	; (4a74 <svcRtxKernelInitialize+0x114>)
    49fc:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  }
  if (osRtxMemoryInit(osRtxConfig.mem.stack_addr, osRtxConfig.mem.stack_size) != 0U) {
    4a00:	4b1d      	ldr	r3, [pc, #116]	; (4a78 <svcRtxKernelInitialize+0x118>)
    4a02:	695a      	ldr	r2, [r3, #20]
    4a04:	4b1c      	ldr	r3, [pc, #112]	; (4a78 <svcRtxKernelInitialize+0x118>)
    4a06:	699b      	ldr	r3, [r3, #24]
    4a08:	4619      	mov	r1, r3
    4a0a:	4610      	mov	r0, r2
    4a0c:	f000 faab 	bl	4f66 <osRtxMemoryInit>
    4a10:	4603      	mov	r3, r0
    4a12:	2b00      	cmp	r3, #0
    4a14:	d004      	beq.n	4a20 <svcRtxKernelInitialize+0xc0>
    osRtxInfo.mem.stack = osRtxConfig.mem.stack_addr;
    4a16:	4b18      	ldr	r3, [pc, #96]	; (4a78 <svcRtxKernelInitialize+0x118>)
    4a18:	695b      	ldr	r3, [r3, #20]
    4a1a:	4a16      	ldr	r2, [pc, #88]	; (4a74 <svcRtxKernelInitialize+0x114>)
    4a1c:	6753      	str	r3, [r2, #116]	; 0x74
    4a1e:	e004      	b.n	4a2a <svcRtxKernelInitialize+0xca>
  } else {
    osRtxInfo.mem.stack = osRtxInfo.mem.common;
    4a20:	4b14      	ldr	r3, [pc, #80]	; (4a74 <svcRtxKernelInitialize+0x114>)
    4a22:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    4a26:	4a13      	ldr	r2, [pc, #76]	; (4a74 <svcRtxKernelInitialize+0x114>)
    4a28:	6753      	str	r3, [r2, #116]	; 0x74
  }
  if (osRtxMemoryInit(osRtxConfig.mem.mp_data_addr, osRtxConfig.mem.mp_data_size) != 0U) {
    4a2a:	4b13      	ldr	r3, [pc, #76]	; (4a78 <svcRtxKernelInitialize+0x118>)
    4a2c:	69da      	ldr	r2, [r3, #28]
    4a2e:	4b12      	ldr	r3, [pc, #72]	; (4a78 <svcRtxKernelInitialize+0x118>)
    4a30:	6a1b      	ldr	r3, [r3, #32]
    4a32:	4619      	mov	r1, r3
    4a34:	4610      	mov	r0, r2
    4a36:	f000 fa96 	bl	4f66 <osRtxMemoryInit>
    4a3a:	4603      	mov	r3, r0
    4a3c:	2b00      	cmp	r3, #0
    4a3e:	d004      	beq.n	4a4a <svcRtxKernelInitialize+0xea>
    osRtxInfo.mem.mp_data = osRtxConfig.mem.mp_data_addr;
    4a40:	4b0d      	ldr	r3, [pc, #52]	; (4a78 <svcRtxKernelInitialize+0x118>)
    4a42:	69db      	ldr	r3, [r3, #28]
    4a44:	4a0b      	ldr	r2, [pc, #44]	; (4a74 <svcRtxKernelInitialize+0x114>)
    4a46:	6793      	str	r3, [r2, #120]	; 0x78
    4a48:	e004      	b.n	4a54 <svcRtxKernelInitialize+0xf4>
  } else {
    osRtxInfo.mem.mp_data = osRtxInfo.mem.common;
    4a4a:	4b0a      	ldr	r3, [pc, #40]	; (4a74 <svcRtxKernelInitialize+0x114>)
    4a4c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    4a50:	4a08      	ldr	r2, [pc, #32]	; (4a74 <svcRtxKernelInitialize+0x114>)
    4a52:	6793      	str	r3, [r2, #120]	; 0x78
  }
  if (osRtxMemoryInit(osRtxConfig.mem.mq_data_addr, osRtxConfig.mem.mq_data_size) != 0U) {
    4a54:	4b08      	ldr	r3, [pc, #32]	; (4a78 <svcRtxKernelInitialize+0x118>)
    4a56:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    4a58:	4b07      	ldr	r3, [pc, #28]	; (4a78 <svcRtxKernelInitialize+0x118>)
    4a5a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4a5c:	4619      	mov	r1, r3
    4a5e:	4610      	mov	r0, r2
    4a60:	f000 fa81 	bl	4f66 <osRtxMemoryInit>
    4a64:	4603      	mov	r3, r0
    4a66:	2b00      	cmp	r3, #0
    4a68:	d00a      	beq.n	4a80 <svcRtxKernelInitialize+0x120>
    osRtxInfo.mem.mq_data = osRtxConfig.mem.mq_data_addr;
    4a6a:	4b03      	ldr	r3, [pc, #12]	; (4a78 <svcRtxKernelInitialize+0x118>)
    4a6c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    4a6e:	4a01      	ldr	r2, [pc, #4]	; (4a74 <svcRtxKernelInitialize+0x114>)
    4a70:	67d3      	str	r3, [r2, #124]	; 0x7c
    4a72:	e00a      	b.n	4a8a <svcRtxKernelInitialize+0x12a>
    4a74:	20000110 	.word	0x20000110
    4a78:	0001144c 	.word	0x0001144c
    4a7c:	20000118 	.word	0x20000118
  } else {
    osRtxInfo.mem.mq_data = osRtxInfo.mem.common;
    4a80:	4b6a      	ldr	r3, [pc, #424]	; (4c2c <svcRtxKernelInitialize+0x2cc>)
    4a82:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    4a86:	4a69      	ldr	r2, [pc, #420]	; (4c2c <svcRtxKernelInitialize+0x2cc>)
    4a88:	67d3      	str	r3, [r2, #124]	; 0x7c
  }

  // Initialize Memory Pools (Fixed Block Size)
  if (osRtxConfig.mpi.stack != NULL) {
    4a8a:	4b69      	ldr	r3, [pc, #420]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4a8c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    4a8e:	2b00      	cmp	r3, #0
    4a90:	d014      	beq.n	4abc <svcRtxKernelInitialize+0x15c>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.stack,
    4a92:	4b67      	ldr	r3, [pc, #412]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4a94:	6b58      	ldr	r0, [r3, #52]	; 0x34
                            osRtxConfig.mpi.stack->max_blocks,
    4a96:	4b66      	ldr	r3, [pc, #408]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4a98:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.stack,
    4a9a:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.stack->block_size,
    4a9c:	4b64      	ldr	r3, [pc, #400]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4a9e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.stack,
    4aa0:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.stack->block_base) != 0U) {
    4aa2:	4b63      	ldr	r3, [pc, #396]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4aa4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.stack,
    4aa6:	68db      	ldr	r3, [r3, #12]
    4aa8:	f000 fbf2 	bl	5290 <osRtxMemoryPoolInit>
    4aac:	4603      	mov	r3, r0
    4aae:	2b00      	cmp	r3, #0
    4ab0:	d004      	beq.n	4abc <svcRtxKernelInitialize+0x15c>
      osRtxInfo.mpi.stack = osRtxConfig.mpi.stack;
    4ab2:	4b5f      	ldr	r3, [pc, #380]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4ab4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    4ab6:	4a5d      	ldr	r2, [pc, #372]	; (4c2c <svcRtxKernelInitialize+0x2cc>)
    4ab8:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    }
  }
  if (osRtxConfig.mpi.thread != NULL) {
    4abc:	4b5c      	ldr	r3, [pc, #368]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4abe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    4ac0:	2b00      	cmp	r3, #0
    4ac2:	d014      	beq.n	4aee <svcRtxKernelInitialize+0x18e>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.thread,
    4ac4:	4b5a      	ldr	r3, [pc, #360]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4ac6:	6b98      	ldr	r0, [r3, #56]	; 0x38
                            osRtxConfig.mpi.thread->max_blocks,
    4ac8:	4b59      	ldr	r3, [pc, #356]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4aca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.thread,
    4acc:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.thread->block_size,
    4ace:	4b58      	ldr	r3, [pc, #352]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4ad0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.thread,
    4ad2:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.thread->block_base) != 0U) {
    4ad4:	4b56      	ldr	r3, [pc, #344]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4ad6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.thread,
    4ad8:	68db      	ldr	r3, [r3, #12]
    4ada:	f000 fbd9 	bl	5290 <osRtxMemoryPoolInit>
    4ade:	4603      	mov	r3, r0
    4ae0:	2b00      	cmp	r3, #0
    4ae2:	d004      	beq.n	4aee <svcRtxKernelInitialize+0x18e>
      osRtxInfo.mpi.thread = osRtxConfig.mpi.thread;
    4ae4:	4b52      	ldr	r3, [pc, #328]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4ae6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    4ae8:	4a50      	ldr	r2, [pc, #320]	; (4c2c <svcRtxKernelInitialize+0x2cc>)
    4aea:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    }
  }
  if (osRtxConfig.mpi.timer != NULL) {
    4aee:	4b50      	ldr	r3, [pc, #320]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4af0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    4af2:	2b00      	cmp	r3, #0
    4af4:	d014      	beq.n	4b20 <svcRtxKernelInitialize+0x1c0>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.timer,
    4af6:	4b4e      	ldr	r3, [pc, #312]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4af8:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
                            osRtxConfig.mpi.timer->max_blocks,
    4afa:	4b4d      	ldr	r3, [pc, #308]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4afc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.timer,
    4afe:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.timer->block_size,
    4b00:	4b4b      	ldr	r3, [pc, #300]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b02:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.timer,
    4b04:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.timer->block_base) != 0U) {
    4b06:	4b4a      	ldr	r3, [pc, #296]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b08:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.timer,
    4b0a:	68db      	ldr	r3, [r3, #12]
    4b0c:	f000 fbc0 	bl	5290 <osRtxMemoryPoolInit>
    4b10:	4603      	mov	r3, r0
    4b12:	2b00      	cmp	r3, #0
    4b14:	d004      	beq.n	4b20 <svcRtxKernelInitialize+0x1c0>
      osRtxInfo.mpi.timer = osRtxConfig.mpi.timer;
    4b16:	4b46      	ldr	r3, [pc, #280]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b18:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    4b1a:	4a44      	ldr	r2, [pc, #272]	; (4c2c <svcRtxKernelInitialize+0x2cc>)
    4b1c:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    }
  }
  if (osRtxConfig.mpi.event_flags != NULL) {
    4b20:	4b43      	ldr	r3, [pc, #268]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b22:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4b24:	2b00      	cmp	r3, #0
    4b26:	d014      	beq.n	4b52 <svcRtxKernelInitialize+0x1f2>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.event_flags,
    4b28:	4b41      	ldr	r3, [pc, #260]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b2a:	6c18      	ldr	r0, [r3, #64]	; 0x40
                            osRtxConfig.mpi.event_flags->max_blocks,
    4b2c:	4b40      	ldr	r3, [pc, #256]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b2e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.event_flags,
    4b30:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.event_flags->block_size,
    4b32:	4b3f      	ldr	r3, [pc, #252]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b34:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.event_flags,
    4b36:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.event_flags->block_base) != 0U) {
    4b38:	4b3d      	ldr	r3, [pc, #244]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b3a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.event_flags,
    4b3c:	68db      	ldr	r3, [r3, #12]
    4b3e:	f000 fba7 	bl	5290 <osRtxMemoryPoolInit>
    4b42:	4603      	mov	r3, r0
    4b44:	2b00      	cmp	r3, #0
    4b46:	d004      	beq.n	4b52 <svcRtxKernelInitialize+0x1f2>
      osRtxInfo.mpi.event_flags = osRtxConfig.mpi.event_flags;
    4b48:	4b39      	ldr	r3, [pc, #228]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b4a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4b4c:	4a37      	ldr	r2, [pc, #220]	; (4c2c <svcRtxKernelInitialize+0x2cc>)
    4b4e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
    }
  }
  if (osRtxConfig.mpi.mutex != NULL) {
    4b52:	4b37      	ldr	r3, [pc, #220]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b54:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    4b56:	2b00      	cmp	r3, #0
    4b58:	d014      	beq.n	4b84 <svcRtxKernelInitialize+0x224>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.mutex,
    4b5a:	4b35      	ldr	r3, [pc, #212]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b5c:	6c58      	ldr	r0, [r3, #68]	; 0x44
                            osRtxConfig.mpi.mutex->max_blocks,
    4b5e:	4b34      	ldr	r3, [pc, #208]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b60:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.mutex,
    4b62:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.mutex->block_size,
    4b64:	4b32      	ldr	r3, [pc, #200]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b66:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.mutex,
    4b68:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.mutex->block_base) != 0U) {
    4b6a:	4b31      	ldr	r3, [pc, #196]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b6c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.mutex,
    4b6e:	68db      	ldr	r3, [r3, #12]
    4b70:	f000 fb8e 	bl	5290 <osRtxMemoryPoolInit>
    4b74:	4603      	mov	r3, r0
    4b76:	2b00      	cmp	r3, #0
    4b78:	d004      	beq.n	4b84 <svcRtxKernelInitialize+0x224>
      osRtxInfo.mpi.mutex = osRtxConfig.mpi.mutex;
    4b7a:	4b2d      	ldr	r3, [pc, #180]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b7c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    4b7e:	4a2b      	ldr	r2, [pc, #172]	; (4c2c <svcRtxKernelInitialize+0x2cc>)
    4b80:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    }
  }
  if (osRtxConfig.mpi.semaphore != NULL) {
    4b84:	4b2a      	ldr	r3, [pc, #168]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b86:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    4b88:	2b00      	cmp	r3, #0
    4b8a:	d014      	beq.n	4bb6 <svcRtxKernelInitialize+0x256>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.semaphore,
    4b8c:	4b28      	ldr	r3, [pc, #160]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b8e:	6c98      	ldr	r0, [r3, #72]	; 0x48
                            osRtxConfig.mpi.semaphore->max_blocks,
    4b90:	4b27      	ldr	r3, [pc, #156]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b92:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.semaphore,
    4b94:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.semaphore->block_size,
    4b96:	4b26      	ldr	r3, [pc, #152]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b98:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.semaphore,
    4b9a:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.semaphore->block_base) != 0U) {
    4b9c:	4b24      	ldr	r3, [pc, #144]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4b9e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.semaphore,
    4ba0:	68db      	ldr	r3, [r3, #12]
    4ba2:	f000 fb75 	bl	5290 <osRtxMemoryPoolInit>
    4ba6:	4603      	mov	r3, r0
    4ba8:	2b00      	cmp	r3, #0
    4baa:	d004      	beq.n	4bb6 <svcRtxKernelInitialize+0x256>
      osRtxInfo.mpi.semaphore = osRtxConfig.mpi.semaphore;
    4bac:	4b20      	ldr	r3, [pc, #128]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4bae:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    4bb0:	4a1e      	ldr	r2, [pc, #120]	; (4c2c <svcRtxKernelInitialize+0x2cc>)
    4bb2:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
    }
  }
  if (osRtxConfig.mpi.memory_pool != NULL) {
    4bb6:	4b1e      	ldr	r3, [pc, #120]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4bb8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    4bba:	2b00      	cmp	r3, #0
    4bbc:	d014      	beq.n	4be8 <svcRtxKernelInitialize+0x288>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.memory_pool,
    4bbe:	4b1c      	ldr	r3, [pc, #112]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4bc0:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
                            osRtxConfig.mpi.memory_pool->max_blocks,
    4bc2:	4b1b      	ldr	r3, [pc, #108]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4bc4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.memory_pool,
    4bc6:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.memory_pool->block_size,
    4bc8:	4b19      	ldr	r3, [pc, #100]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4bca:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.memory_pool,
    4bcc:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.memory_pool->block_base) != 0U) {
    4bce:	4b18      	ldr	r3, [pc, #96]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4bd0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.memory_pool,
    4bd2:	68db      	ldr	r3, [r3, #12]
    4bd4:	f000 fb5c 	bl	5290 <osRtxMemoryPoolInit>
    4bd8:	4603      	mov	r3, r0
    4bda:	2b00      	cmp	r3, #0
    4bdc:	d004      	beq.n	4be8 <svcRtxKernelInitialize+0x288>
      osRtxInfo.mpi.memory_pool = osRtxConfig.mpi.memory_pool;
    4bde:	4b14      	ldr	r3, [pc, #80]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4be0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    4be2:	4a12      	ldr	r2, [pc, #72]	; (4c2c <svcRtxKernelInitialize+0x2cc>)
    4be4:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
    }
  }
  if (osRtxConfig.mpi.message_queue != NULL) {
    4be8:	4b11      	ldr	r3, [pc, #68]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4bea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    4bec:	2b00      	cmp	r3, #0
    4bee:	d014      	beq.n	4c1a <svcRtxKernelInitialize+0x2ba>
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.message_queue,
    4bf0:	4b0f      	ldr	r3, [pc, #60]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4bf2:	6d18      	ldr	r0, [r3, #80]	; 0x50
                            osRtxConfig.mpi.message_queue->max_blocks,
    4bf4:	4b0e      	ldr	r3, [pc, #56]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4bf6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.message_queue,
    4bf8:	6819      	ldr	r1, [r3, #0]
                            osRtxConfig.mpi.message_queue->block_size,
    4bfa:	4b0d      	ldr	r3, [pc, #52]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4bfc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.message_queue,
    4bfe:	689a      	ldr	r2, [r3, #8]
                            osRtxConfig.mpi.message_queue->block_base) != 0U) {
    4c00:	4b0b      	ldr	r3, [pc, #44]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4c02:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    if (osRtxMemoryPoolInit(osRtxConfig.mpi.message_queue,
    4c04:	68db      	ldr	r3, [r3, #12]
    4c06:	f000 fb43 	bl	5290 <osRtxMemoryPoolInit>
    4c0a:	4603      	mov	r3, r0
    4c0c:	2b00      	cmp	r3, #0
    4c0e:	d004      	beq.n	4c1a <svcRtxKernelInitialize+0x2ba>
      osRtxInfo.mpi.message_queue = osRtxConfig.mpi.message_queue;
    4c10:	4b07      	ldr	r3, [pc, #28]	; (4c30 <svcRtxKernelInitialize+0x2d0>)
    4c12:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    4c14:	4a05      	ldr	r2, [pc, #20]	; (4c2c <svcRtxKernelInitialize+0x2cc>)
    4c16:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
    }
  }

  osRtxInfo.kernel.state = osRtxKernelReady;
    4c1a:	4b04      	ldr	r3, [pc, #16]	; (4c2c <svcRtxKernelInitialize+0x2cc>)
    4c1c:	2201      	movs	r2, #1
    4c1e:	721a      	strb	r2, [r3, #8]

  EvrRtxKernelInitializeCompleted();
    4c20:	f7ff fd23 	bl	466a <EvrRtxKernelInitializeCompleted>

  return osOK;
    4c24:	2300      	movs	r3, #0
}
    4c26:	4618      	mov	r0, r3
    4c28:	bd08      	pop	{r3, pc}
    4c2a:	bf00      	nop
    4c2c:	20000110 	.word	0x20000110
    4c30:	0001144c 	.word	0x0001144c

00004c34 <svcRtxKernelGetState>:
  return osOK;
}

/// Get the current RTOS Kernel state.
/// \note API identical to osKernelGetState
static osKernelState_t svcRtxKernelGetState (void) {
    4c34:	b500      	push	{lr}
    4c36:	b083      	sub	sp, #12
  osKernelState_t state = osRtxKernelState();
    4c38:	f7ff fe8c 	bl	4954 <osRtxKernelState>
    4c3c:	9001      	str	r0, [sp, #4]
  EvrRtxKernelGetState(state);
    4c3e:	9801      	ldr	r0, [sp, #4]
    4c40:	f7ff fd15 	bl	466e <EvrRtxKernelGetState>
  return state;
    4c44:	9b01      	ldr	r3, [sp, #4]
}
    4c46:	4618      	mov	r0, r3
    4c48:	b003      	add	sp, #12
    4c4a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00004c50 <svcRtxKernelStart>:

/// Start the RTOS Kernel scheduler.
/// \note API identical to osKernelStart
static osStatus_t svcRtxKernelStart (void) {
    4c50:	b500      	push	{lr}
    4c52:	b085      	sub	sp, #20
  os_thread_t *thread;

  if (osRtxInfo.kernel.state != osRtxKernelReady) {
    4c54:	4b2f      	ldr	r3, [pc, #188]	; (4d14 <svcRtxKernelStart+0xc4>)
    4c56:	7a1b      	ldrb	r3, [r3, #8]
    4c58:	2b01      	cmp	r3, #1
    4c5a:	d006      	beq.n	4c6a <svcRtxKernelStart+0x1a>
    EvrRtxKernelError(osRtxErrorKernelNotReady);
    4c5c:	f06f 0006 	mvn.w	r0, #6
    4c60:	f7ff fbf8 	bl	4454 <EvrRtxKernelError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    4c64:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4c68:	e04f      	b.n	4d0a <svcRtxKernelStart+0xba>
  }

  // Thread startup (Idle and Timer Thread)
  if (!osRtxThreadStartup()) {
    4c6a:	f002 feb7 	bl	79dc <osRtxThreadStartup>
    4c6e:	4603      	mov	r3, r0
    4c70:	f083 0301 	eor.w	r3, r3, #1
    4c74:	b2db      	uxtb	r3, r3
    4c76:	2b00      	cmp	r3, #0
    4c78:	d006      	beq.n	4c88 <svcRtxKernelStart+0x38>
    EvrRtxKernelError((int32_t)osError);
    4c7a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4c7e:	f7ff fbe9 	bl	4454 <EvrRtxKernelError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    4c82:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4c86:	e040      	b.n	4d0a <svcRtxKernelStart+0xba>
  }

  // Setup SVC and PendSV System Service Calls
  SVC_Setup();
    4c88:	f7ff fe3a 	bl	4900 <SVC_Setup>

  // Setup RTOS Tick
  if (OS_Tick_Setup(osRtxConfig.tick_freq, OS_TICK_HANDLER) != 0) {
    4c8c:	4b22      	ldr	r3, [pc, #136]	; (4d18 <svcRtxKernelStart+0xc8>)
    4c8e:	685b      	ldr	r3, [r3, #4]
    4c90:	4922      	ldr	r1, [pc, #136]	; (4d1c <svcRtxKernelStart+0xcc>)
    4c92:	4618      	mov	r0, r3
    4c94:	f003 f8c6 	bl	7e24 <OS_Tick_Setup>
    4c98:	4603      	mov	r3, r0
    4c9a:	2b00      	cmp	r3, #0
    4c9c:	d006      	beq.n	4cac <svcRtxKernelStart+0x5c>
    EvrRtxKernelError((int32_t)osError);
    4c9e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4ca2:	f7ff fbd7 	bl	4454 <EvrRtxKernelError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    4ca6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4caa:	e02e      	b.n	4d0a <svcRtxKernelStart+0xba>
  }
  osRtxInfo.tick_irqn = OS_Tick_GetIRQn();
    4cac:	f003 f90e 	bl	7ecc <OS_Tick_GetIRQn>
    4cb0:	4602      	mov	r2, r0
    4cb2:	4b18      	ldr	r3, [pc, #96]	; (4d14 <svcRtxKernelStart+0xc4>)
    4cb4:	611a      	str	r2, [r3, #16]

  // Enable RTOS Tick
  OS_Tick_Enable();
    4cb6:	f003 f8e9 	bl	7e8c <OS_Tick_Enable>

  // Switch to Ready Thread with highest Priority
  thread = osRtxThreadListGet(&osRtxInfo.thread.ready);
    4cba:	4819      	ldr	r0, [pc, #100]	; (4d20 <svcRtxKernelStart+0xd0>)
    4cbc:	f001 ff80 	bl	6bc0 <osRtxThreadListGet>
    4cc0:	9003      	str	r0, [sp, #12]
  if (thread == NULL) {
    4cc2:	9b03      	ldr	r3, [sp, #12]
    4cc4:	2b00      	cmp	r3, #0
    4cc6:	d106      	bne.n	4cd6 <svcRtxKernelStart+0x86>
    EvrRtxKernelError((int32_t)osError);
    4cc8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4ccc:	f7ff fbc2 	bl	4454 <EvrRtxKernelError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    4cd0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4cd4:	e019      	b.n	4d0a <svcRtxKernelStart+0xba>
  }
  osRtxThreadSwitch(thread);
    4cd6:	9803      	ldr	r0, [sp, #12]
    4cd8:	f002 f988 	bl	6fec <osRtxThreadSwitch>

  if ((osRtxConfig.flags & osRtxConfigPrivilegedMode) != 0U) {
    4cdc:	4b0e      	ldr	r3, [pc, #56]	; (4d18 <svcRtxKernelStart+0xc8>)
    4cde:	681b      	ldr	r3, [r3, #0]
    4ce0:	f003 0301 	and.w	r3, r3, #1
    4ce4:	2b00      	cmp	r3, #0
    4ce6:	d005      	beq.n	4cf4 <svcRtxKernelStart+0xa4>
    4ce8:	2302      	movs	r3, #2
    4cea:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
    4cec:	9b02      	ldr	r3, [sp, #8]
    4cee:	f383 8814 	msr	CONTROL, r3
    4cf2:	e004      	b.n	4cfe <svcRtxKernelStart+0xae>
    4cf4:	2303      	movs	r3, #3
    4cf6:	9301      	str	r3, [sp, #4]
    4cf8:	9b01      	ldr	r3, [sp, #4]
    4cfa:	f383 8814 	msr	CONTROL, r3
  } else {
    // Unprivileged Thread mode & PSP
    __set_CONTROL(0x03U);
  }

  osRtxInfo.kernel.state = osRtxKernelRunning;
    4cfe:	4b05      	ldr	r3, [pc, #20]	; (4d14 <svcRtxKernelStart+0xc4>)
    4d00:	2202      	movs	r2, #2
    4d02:	721a      	strb	r2, [r3, #8]

  EvrRtxKernelStarted();
    4d04:	f7ff fcba 	bl	467c <EvrRtxKernelStarted>

  return osOK;
    4d08:	2300      	movs	r3, #0
}
    4d0a:	4618      	mov	r0, r3
    4d0c:	b005      	add	sp, #20
    4d0e:	f85d fb04 	ldr.w	pc, [sp], #4
    4d12:	bf00      	nop
    4d14:	20000110 	.word	0x20000110
    4d18:	0001144c 	.word	0x0001144c
    4d1c:	00000677 	.word	0x00000677
    4d20:	2000012c 	.word	0x2000012c

00004d24 <svcRtxKernelLock>:

/// Lock the RTOS Kernel scheduler.
/// \note API identical to osKernelLock
int32_t svcRtxKernelLock (void) {
    4d24:	b500      	push	{lr}
    4d26:	b083      	sub	sp, #12
  int32_t lock;

  switch (osRtxInfo.kernel.state) {
    4d28:	4b11      	ldr	r3, [pc, #68]	; (4d70 <svcRtxKernelLock+0x4c>)
    4d2a:	7a1b      	ldrb	r3, [r3, #8]
    4d2c:	2b02      	cmp	r3, #2
    4d2e:	d002      	beq.n	4d36 <svcRtxKernelLock+0x12>
    4d30:	2b03      	cmp	r3, #3
    4d32:	d009      	beq.n	4d48 <svcRtxKernelLock+0x24>
    4d34:	e00e      	b.n	4d54 <svcRtxKernelLock+0x30>
    case osRtxKernelRunning:
      osRtxInfo.kernel.state = osRtxKernelLocked;
    4d36:	4b0e      	ldr	r3, [pc, #56]	; (4d70 <svcRtxKernelLock+0x4c>)
    4d38:	2203      	movs	r2, #3
    4d3a:	721a      	strb	r2, [r3, #8]
      EvrRtxKernelLocked(0);
    4d3c:	2000      	movs	r0, #0
    4d3e:	f7ff fca1 	bl	4684 <EvrRtxKernelLocked>
      lock = 0;
    4d42:	2300      	movs	r3, #0
    4d44:	9301      	str	r3, [sp, #4]
      break;
    4d46:	e00d      	b.n	4d64 <svcRtxKernelLock+0x40>
    case osRtxKernelLocked:
      EvrRtxKernelLocked(1);
    4d48:	2001      	movs	r0, #1
    4d4a:	f7ff fc9b 	bl	4684 <EvrRtxKernelLocked>
      lock = 1;
    4d4e:	2301      	movs	r3, #1
    4d50:	9301      	str	r3, [sp, #4]
      break;
    4d52:	e007      	b.n	4d64 <svcRtxKernelLock+0x40>
    default:
      EvrRtxKernelError((int32_t)osError);
    4d54:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4d58:	f7ff fb7c 	bl	4454 <EvrRtxKernelError>
      lock = (int32_t)osError;
    4d5c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4d60:	9301      	str	r3, [sp, #4]
      break;
    4d62:	bf00      	nop
  }
  return lock;
    4d64:	9b01      	ldr	r3, [sp, #4]
}
    4d66:	4618      	mov	r0, r3
    4d68:	b003      	add	sp, #12
    4d6a:	f85d fb04 	ldr.w	pc, [sp], #4
    4d6e:	bf00      	nop
    4d70:	20000110 	.word	0x20000110

00004d74 <svcRtxKernelUnlock>:

/// Unlock the RTOS Kernel scheduler.
/// \note API identical to osKernelUnlock
int32_t svcRtxKernelUnlock (void) {
    4d74:	b500      	push	{lr}
    4d76:	b083      	sub	sp, #12
  int32_t lock;

  switch (osRtxInfo.kernel.state) {
    4d78:	4b11      	ldr	r3, [pc, #68]	; (4dc0 <svcRtxKernelUnlock+0x4c>)
    4d7a:	7a1b      	ldrb	r3, [r3, #8]
    4d7c:	2b02      	cmp	r3, #2
    4d7e:	d002      	beq.n	4d86 <svcRtxKernelUnlock+0x12>
    4d80:	2b03      	cmp	r3, #3
    4d82:	d006      	beq.n	4d92 <svcRtxKernelUnlock+0x1e>
    4d84:	e00e      	b.n	4da4 <svcRtxKernelUnlock+0x30>
    case osRtxKernelRunning:
      EvrRtxKernelUnlocked(0);
    4d86:	2000      	movs	r0, #0
    4d88:	f7ff fc83 	bl	4692 <EvrRtxKernelUnlocked>
      lock = 0;
    4d8c:	2300      	movs	r3, #0
    4d8e:	9301      	str	r3, [sp, #4]
      break;
    4d90:	e010      	b.n	4db4 <svcRtxKernelUnlock+0x40>
    case osRtxKernelLocked:
      osRtxInfo.kernel.state = osRtxKernelRunning;
    4d92:	4b0b      	ldr	r3, [pc, #44]	; (4dc0 <svcRtxKernelUnlock+0x4c>)
    4d94:	2202      	movs	r2, #2
    4d96:	721a      	strb	r2, [r3, #8]
      EvrRtxKernelUnlocked(1);
    4d98:	2001      	movs	r0, #1
    4d9a:	f7ff fc7a 	bl	4692 <EvrRtxKernelUnlocked>
      lock = 1;
    4d9e:	2301      	movs	r3, #1
    4da0:	9301      	str	r3, [sp, #4]
      break;
    4da2:	e007      	b.n	4db4 <svcRtxKernelUnlock+0x40>
    default:
      EvrRtxKernelError((int32_t)osError);
    4da4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4da8:	f7ff fb54 	bl	4454 <EvrRtxKernelError>
      lock = (int32_t)osError;
    4dac:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4db0:	9301      	str	r3, [sp, #4]
      break;
    4db2:	bf00      	nop
  }
  return lock;
    4db4:	9b01      	ldr	r3, [sp, #4]
}
    4db6:	4618      	mov	r0, r3
    4db8:	b003      	add	sp, #12
    4dba:	f85d fb04 	ldr.w	pc, [sp], #4
    4dbe:	bf00      	nop
    4dc0:	20000110 	.word	0x20000110

00004dc4 <osKernelInitialize>:


//  ==== Public API ====

/// Initialize the RTOS Kernel.
osStatus_t osKernelInitialize (void) {
    4dc4:	b500      	push	{lr}
    4dc6:	b083      	sub	sp, #12
  osStatus_t status;

  EvrRtxKernelInitialize();
    4dc8:	f7ff fc4d 	bl	4666 <EvrRtxKernelInitialize>
  if (IsIrqMode() || IsIrqMasked()) {
    4dcc:	f7ff fd75 	bl	48ba <IsIrqMode>
    4dd0:	4603      	mov	r3, r0
    4dd2:	2b00      	cmp	r3, #0
    4dd4:	d104      	bne.n	4de0 <osKernelInitialize+0x1c>
    4dd6:	f7ff fd7d 	bl	48d4 <IsIrqMasked>
    4dda:	4603      	mov	r3, r0
    4ddc:	2b00      	cmp	r3, #0
    4dde:	d007      	beq.n	4df0 <osKernelInitialize+0x2c>
    EvrRtxKernelError((int32_t)osErrorISR);
    4de0:	f06f 0005 	mvn.w	r0, #5
    4de4:	f7ff fb36 	bl	4454 <EvrRtxKernelError>
    status = osErrorISR;
    4de8:	f06f 0305 	mvn.w	r3, #5
    4dec:	9301      	str	r3, [sp, #4]
    4dee:	e004      	b.n	4dfa <osKernelInitialize+0x36>
SVC0_0 (KernelInitialize,       osStatus_t)
    4df0:	4b04      	ldr	r3, [pc, #16]	; (4e04 <osKernelInitialize+0x40>)
    4df2:	469c      	mov	ip, r3
    4df4:	df00      	svc	0
    4df6:	4603      	mov	r3, r0
  } else {
    status = __svcKernelInitialize();
    4df8:	9301      	str	r3, [sp, #4]
  }
  return status;
    4dfa:	9b01      	ldr	r3, [sp, #4]
}
    4dfc:	4618      	mov	r0, r3
    4dfe:	b003      	add	sp, #12
    4e00:	f85d fb04 	ldr.w	pc, [sp], #4
    4e04:	00004961 	.word	0x00004961

00004e08 <osKernelGetState>:
  }
  return status;
}

/// Get the current RTOS Kernel state.
osKernelState_t osKernelGetState (void) {
    4e08:	b500      	push	{lr}
    4e0a:	b083      	sub	sp, #12
  osKernelState_t state;

  if (IsPrivileged() || IsIrqMode() || IsIrqMasked()) {
    4e0c:	f7ff fd46 	bl	489c <IsPrivileged>
    4e10:	4603      	mov	r3, r0
    4e12:	2b00      	cmp	r3, #0
    4e14:	d109      	bne.n	4e2a <osKernelGetState+0x22>
    4e16:	f7ff fd50 	bl	48ba <IsIrqMode>
    4e1a:	4603      	mov	r3, r0
    4e1c:	2b00      	cmp	r3, #0
    4e1e:	d104      	bne.n	4e2a <osKernelGetState+0x22>
    4e20:	f7ff fd58 	bl	48d4 <IsIrqMasked>
    4e24:	4603      	mov	r3, r0
    4e26:	2b00      	cmp	r3, #0
    4e28:	d003      	beq.n	4e32 <osKernelGetState+0x2a>
    state = svcRtxKernelGetState();
    4e2a:	f7ff ff03 	bl	4c34 <svcRtxKernelGetState>
    4e2e:	9001      	str	r0, [sp, #4]
    4e30:	e004      	b.n	4e3c <osKernelGetState+0x34>
SVC0_0 (KernelGetState,         osKernelState_t)
    4e32:	4b05      	ldr	r3, [pc, #20]	; (4e48 <osKernelGetState+0x40>)
    4e34:	469c      	mov	ip, r3
    4e36:	df00      	svc	0
    4e38:	4603      	mov	r3, r0
  } else {
    state =  __svcKernelGetState();
    4e3a:	9301      	str	r3, [sp, #4]
  }
  return state;
    4e3c:	9b01      	ldr	r3, [sp, #4]
}
    4e3e:	4618      	mov	r0, r3
    4e40:	b003      	add	sp, #12
    4e42:	f85d fb04 	ldr.w	pc, [sp], #4
    4e46:	bf00      	nop
    4e48:	00004c35 	.word	0x00004c35

00004e4c <osKernelStart>:

/// Start the RTOS Kernel scheduler.
osStatus_t osKernelStart (void) {
    4e4c:	b500      	push	{lr}
    4e4e:	b083      	sub	sp, #12
  osStatus_t status;

  EvrRtxKernelStart();
    4e50:	f7ff fc12 	bl	4678 <EvrRtxKernelStart>
  if (IsIrqMode() || IsIrqMasked()) {
    4e54:	f7ff fd31 	bl	48ba <IsIrqMode>
    4e58:	4603      	mov	r3, r0
    4e5a:	2b00      	cmp	r3, #0
    4e5c:	d104      	bne.n	4e68 <osKernelStart+0x1c>
    4e5e:	f7ff fd39 	bl	48d4 <IsIrqMasked>
    4e62:	4603      	mov	r3, r0
    4e64:	2b00      	cmp	r3, #0
    4e66:	d007      	beq.n	4e78 <osKernelStart+0x2c>
    EvrRtxKernelError((int32_t)osErrorISR);
    4e68:	f06f 0005 	mvn.w	r0, #5
    4e6c:	f7ff faf2 	bl	4454 <EvrRtxKernelError>
    status = osErrorISR;
    4e70:	f06f 0305 	mvn.w	r3, #5
    4e74:	9301      	str	r3, [sp, #4]
    4e76:	e016      	b.n	4ea6 <osKernelStart+0x5a>
  } else {
    /* Call the pre-start event (from unprivileged mode) if the handler exists
    * and the kernel is not running. */
    /* FIXME osEventObs needs to be readable but not writable from unprivileged
    * code. */
    if (osKernelGetState() != osKernelRunning && osEventObs && osEventObs->pre_start) {
    4e78:	f7ff ffc6 	bl	4e08 <osKernelGetState>
    4e7c:	4603      	mov	r3, r0
    4e7e:	2b02      	cmp	r3, #2
    4e80:	d00c      	beq.n	4e9c <osKernelStart+0x50>
    4e82:	4b0b      	ldr	r3, [pc, #44]	; (4eb0 <osKernelStart+0x64>)
    4e84:	681b      	ldr	r3, [r3, #0]
    4e86:	2b00      	cmp	r3, #0
    4e88:	d008      	beq.n	4e9c <osKernelStart+0x50>
    4e8a:	4b09      	ldr	r3, [pc, #36]	; (4eb0 <osKernelStart+0x64>)
    4e8c:	681b      	ldr	r3, [r3, #0]
    4e8e:	685b      	ldr	r3, [r3, #4]
    4e90:	2b00      	cmp	r3, #0
    4e92:	d003      	beq.n	4e9c <osKernelStart+0x50>
      osEventObs->pre_start();
    4e94:	4b06      	ldr	r3, [pc, #24]	; (4eb0 <osKernelStart+0x64>)
    4e96:	681b      	ldr	r3, [r3, #0]
    4e98:	685b      	ldr	r3, [r3, #4]
    4e9a:	4798      	blx	r3
SVC0_0 (KernelStart,            osStatus_t)
    4e9c:	4b05      	ldr	r3, [pc, #20]	; (4eb4 <osKernelStart+0x68>)
    4e9e:	469c      	mov	ip, r3
    4ea0:	df00      	svc	0
    4ea2:	4603      	mov	r3, r0
    }
    status = __svcKernelStart();
    4ea4:	9301      	str	r3, [sp, #4]
  }
  return status;
    4ea6:	9b01      	ldr	r3, [sp, #4]
}
    4ea8:	4618      	mov	r0, r3
    4eaa:	b003      	add	sp, #12
    4eac:	f85d fb04 	ldr.w	pc, [sp], #4
    4eb0:	20002f58 	.word	0x20002f58
    4eb4:	00004c51 	.word	0x00004c51

00004eb8 <osKernelLock>:

/// Lock the RTOS Kernel scheduler.
int32_t osKernelLock (void) {
    4eb8:	b500      	push	{lr}
    4eba:	b083      	sub	sp, #12
  int32_t lock;

  EvrRtxKernelLock();
    4ebc:	f7ff fbe0 	bl	4680 <EvrRtxKernelLock>
  if (IsIrqMode() || IsIrqMasked()) {
    4ec0:	f7ff fcfb 	bl	48ba <IsIrqMode>
    4ec4:	4603      	mov	r3, r0
    4ec6:	2b00      	cmp	r3, #0
    4ec8:	d104      	bne.n	4ed4 <osKernelLock+0x1c>
    4eca:	f7ff fd03 	bl	48d4 <IsIrqMasked>
    4ece:	4603      	mov	r3, r0
    4ed0:	2b00      	cmp	r3, #0
    4ed2:	d007      	beq.n	4ee4 <osKernelLock+0x2c>
    EvrRtxKernelError((int32_t)osErrorISR);
    4ed4:	f06f 0005 	mvn.w	r0, #5
    4ed8:	f7ff fabc 	bl	4454 <EvrRtxKernelError>
    lock = (int32_t)osErrorISR;
    4edc:	f06f 0305 	mvn.w	r3, #5
    4ee0:	9301      	str	r3, [sp, #4]
    4ee2:	e004      	b.n	4eee <osKernelLock+0x36>
SVC0_0 (KernelLock,             int32_t)
    4ee4:	4b04      	ldr	r3, [pc, #16]	; (4ef8 <osKernelLock+0x40>)
    4ee6:	469c      	mov	ip, r3
    4ee8:	df00      	svc	0
    4eea:	4603      	mov	r3, r0
  } else {
    lock = __svcKernelLock();
    4eec:	9301      	str	r3, [sp, #4]
  }
  return lock;
    4eee:	9b01      	ldr	r3, [sp, #4]
}
    4ef0:	4618      	mov	r0, r3
    4ef2:	b003      	add	sp, #12
    4ef4:	f85d fb04 	ldr.w	pc, [sp], #4
    4ef8:	00004d25 	.word	0x00004d25

00004efc <osKernelUnlock>:

/// Unlock the RTOS Kernel scheduler.
int32_t osKernelUnlock (void) {
    4efc:	b500      	push	{lr}
    4efe:	b083      	sub	sp, #12
  int32_t lock;

  EvrRtxKernelUnlock();
    4f00:	f7ff fbc5 	bl	468e <EvrRtxKernelUnlock>
  if (IsIrqMode() || IsIrqMasked()) {
    4f04:	f7ff fcd9 	bl	48ba <IsIrqMode>
    4f08:	4603      	mov	r3, r0
    4f0a:	2b00      	cmp	r3, #0
    4f0c:	d104      	bne.n	4f18 <osKernelUnlock+0x1c>
    4f0e:	f7ff fce1 	bl	48d4 <IsIrqMasked>
    4f12:	4603      	mov	r3, r0
    4f14:	2b00      	cmp	r3, #0
    4f16:	d007      	beq.n	4f28 <osKernelUnlock+0x2c>
    EvrRtxKernelError((int32_t)osErrorISR);
    4f18:	f06f 0005 	mvn.w	r0, #5
    4f1c:	f7ff fa9a 	bl	4454 <EvrRtxKernelError>
    lock = (int32_t)osErrorISR;
    4f20:	f06f 0305 	mvn.w	r3, #5
    4f24:	9301      	str	r3, [sp, #4]
    4f26:	e004      	b.n	4f32 <osKernelUnlock+0x36>
SVC0_0 (KernelUnlock,           int32_t)
    4f28:	4b04      	ldr	r3, [pc, #16]	; (4f3c <osKernelUnlock+0x40>)
    4f2a:	469c      	mov	ip, r3
    4f2c:	df00      	svc	0
    4f2e:	4603      	mov	r3, r0
  } else {
    lock = __svcKernelUnlock();
    4f30:	9301      	str	r3, [sp, #4]
  }
  return lock;
    4f32:	9b01      	ldr	r3, [sp, #4]
}
    4f34:	4618      	mov	r0, r3
    4f36:	b003      	add	sp, #12
    4f38:	f85d fb04 	ldr.w	pc, [sp], #4
    4f3c:	00004d75 	.word	0x00004d75

00004f40 <MemHeadPtr>:
//  Memory Block Info: Length = <31:2>:'00', Type = <1:0>
#define MB_INFO_LEN_MASK        0xFFFFFFFCU     // Length mask
#define MB_INFO_TYPE_MASK       0x00000003U     // Type mask

//  Memory Head Pointer
__STATIC_INLINE mem_head_t *MemHeadPtr (void *mem) {
    4f40:	b082      	sub	sp, #8
    4f42:	9001      	str	r0, [sp, #4]
  //lint -e{9079} -e{9087} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
  return ((mem_head_t *)mem);
    4f44:	9b01      	ldr	r3, [sp, #4]
}
    4f46:	4618      	mov	r0, r3
    4f48:	b002      	add	sp, #8
    4f4a:	4770      	bx	lr

00004f4c <MemBlockPtr>:

//  Memory Block Pointer
__STATIC_INLINE mem_block_t *MemBlockPtr (void *mem, uint32_t offset) {
    4f4c:	b084      	sub	sp, #16
    4f4e:	9001      	str	r0, [sp, #4]
    4f50:	9100      	str	r1, [sp, #0]
  uint32_t     addr;
  mem_block_t *ptr;

  //lint --e{923} --e{9078} "cast between pointer and unsigned int" [MISRA Note 8]
  addr = (uint32_t)mem + offset;
    4f52:	9a01      	ldr	r2, [sp, #4]
    4f54:	9b00      	ldr	r3, [sp, #0]
    4f56:	4413      	add	r3, r2
    4f58:	9303      	str	r3, [sp, #12]
  ptr  = (mem_block_t *)addr;
    4f5a:	9b03      	ldr	r3, [sp, #12]
    4f5c:	9302      	str	r3, [sp, #8]

  return ptr;
    4f5e:	9b02      	ldr	r3, [sp, #8]
}
    4f60:	4618      	mov	r0, r3
    4f62:	b004      	add	sp, #16
    4f64:	4770      	bx	lr

00004f66 <osRtxMemoryInit>:

/// Initialize Memory Pool with variable block size.
/// \param[in]  mem             pointer to memory pool.
/// \param[in]  size            size of a memory pool in bytes.
/// \return 1 - success, 0 - failure.
__WEAK uint32_t osRtxMemoryInit (void *mem, uint32_t size) {
    4f66:	b500      	push	{lr}
    4f68:	b085      	sub	sp, #20
    4f6a:	9001      	str	r0, [sp, #4]
    4f6c:	9100      	str	r1, [sp, #0]
  mem_head_t  *head;
  mem_block_t *ptr;

  // Check parameters
  //lint -e{923} "cast from pointer to unsigned int" [MISRA Note 7]
  if ((mem == NULL) || (((uint32_t)mem & 7U) != 0U) || ((size & 7U) != 0U) ||
    4f6e:	9b01      	ldr	r3, [sp, #4]
    4f70:	2b00      	cmp	r3, #0
    4f72:	d00c      	beq.n	4f8e <osRtxMemoryInit+0x28>
    4f74:	9b01      	ldr	r3, [sp, #4]
    4f76:	f003 0307 	and.w	r3, r3, #7
    4f7a:	2b00      	cmp	r3, #0
    4f7c:	d107      	bne.n	4f8e <osRtxMemoryInit+0x28>
    4f7e:	9b00      	ldr	r3, [sp, #0]
    4f80:	f003 0307 	and.w	r3, r3, #7
    4f84:	2b00      	cmp	r3, #0
    4f86:	d102      	bne.n	4f8e <osRtxMemoryInit+0x28>
    4f88:	9b00      	ldr	r3, [sp, #0]
    4f8a:	2b17      	cmp	r3, #23
    4f8c:	d806      	bhi.n	4f9c <osRtxMemoryInit+0x36>
      (size < (sizeof(mem_head_t) + (2U*sizeof(mem_block_t))))) {
    EvrRtxMemoryInit(mem, size, 0U);
    4f8e:	2200      	movs	r2, #0
    4f90:	9900      	ldr	r1, [sp, #0]
    4f92:	9801      	ldr	r0, [sp, #4]
    4f94:	f7ff fb3c 	bl	4610 <EvrRtxMemoryInit>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    4f98:	2300      	movs	r3, #0
    4f9a:	e028      	b.n	4fee <osRtxMemoryInit+0x88>
  }

  // Initialize memory pool header
  head = MemHeadPtr(mem);
    4f9c:	9801      	ldr	r0, [sp, #4]
    4f9e:	f7ff ffcf 	bl	4f40 <MemHeadPtr>
    4fa2:	9003      	str	r0, [sp, #12]
  head->size = size;
    4fa4:	9b03      	ldr	r3, [sp, #12]
    4fa6:	9a00      	ldr	r2, [sp, #0]
    4fa8:	601a      	str	r2, [r3, #0]
  head->used = sizeof(mem_head_t) + sizeof(mem_block_t);
    4faa:	9b03      	ldr	r3, [sp, #12]
    4fac:	2210      	movs	r2, #16
    4fae:	605a      	str	r2, [r3, #4]

  // Initialize first and last block header
  ptr = MemBlockPtr(mem, sizeof(mem_head_t));
    4fb0:	2108      	movs	r1, #8
    4fb2:	9801      	ldr	r0, [sp, #4]
    4fb4:	f7ff ffca 	bl	4f4c <MemBlockPtr>
    4fb8:	9002      	str	r0, [sp, #8]
  ptr->next = MemBlockPtr(mem, size - sizeof(mem_block_t));
    4fba:	9b00      	ldr	r3, [sp, #0]
    4fbc:	3b08      	subs	r3, #8
    4fbe:	4619      	mov	r1, r3
    4fc0:	9801      	ldr	r0, [sp, #4]
    4fc2:	f7ff ffc3 	bl	4f4c <MemBlockPtr>
    4fc6:	4602      	mov	r2, r0
    4fc8:	9b02      	ldr	r3, [sp, #8]
    4fca:	601a      	str	r2, [r3, #0]
  ptr->next->next = NULL;
    4fcc:	9b02      	ldr	r3, [sp, #8]
    4fce:	681b      	ldr	r3, [r3, #0]
    4fd0:	2200      	movs	r2, #0
    4fd2:	601a      	str	r2, [r3, #0]
  ptr->next->info = sizeof(mem_head_t) + sizeof(mem_block_t);
    4fd4:	9b02      	ldr	r3, [sp, #8]
    4fd6:	681b      	ldr	r3, [r3, #0]
    4fd8:	2210      	movs	r2, #16
    4fda:	605a      	str	r2, [r3, #4]
  ptr->info = 0U;
    4fdc:	9b02      	ldr	r3, [sp, #8]
    4fde:	2200      	movs	r2, #0
    4fe0:	605a      	str	r2, [r3, #4]

  EvrRtxMemoryInit(mem, size, 1U);
    4fe2:	2201      	movs	r2, #1
    4fe4:	9900      	ldr	r1, [sp, #0]
    4fe6:	9801      	ldr	r0, [sp, #4]
    4fe8:	f7ff fb12 	bl	4610 <EvrRtxMemoryInit>

  return 1U;
    4fec:	2301      	movs	r3, #1
}
    4fee:	4618      	mov	r0, r3
    4ff0:	b005      	add	sp, #20
    4ff2:	f85d fb04 	ldr.w	pc, [sp], #4

00004ff6 <osRtxMemoryAlloc>:
/// Allocate a memory block from a Memory Pool.
/// \param[in]  mem             pointer to memory pool.
/// \param[in]  size            size of a memory block in bytes.
/// \param[in]  type            memory block type: 0 - generic, 1 - control block
/// \return allocated memory block or NULL in case of no memory is available.
__WEAK void *osRtxMemoryAlloc (void *mem, uint32_t size, uint32_t type) {
    4ff6:	b510      	push	{r4, lr}
    4ff8:	b08a      	sub	sp, #40	; 0x28
    4ffa:	9003      	str	r0, [sp, #12]
    4ffc:	9102      	str	r1, [sp, #8]
    4ffe:	9201      	str	r2, [sp, #4]
  mem_block_t *p, *p_new;
  uint32_t     block_size;
  uint32_t     hole_size;

  // Check parameters
  if ((mem == NULL) || (size == 0U) || ((type & ~MB_INFO_TYPE_MASK) != 0U)) {
    5000:	9b03      	ldr	r3, [sp, #12]
    5002:	2b00      	cmp	r3, #0
    5004:	d007      	beq.n	5016 <osRtxMemoryAlloc+0x20>
    5006:	9b02      	ldr	r3, [sp, #8]
    5008:	2b00      	cmp	r3, #0
    500a:	d004      	beq.n	5016 <osRtxMemoryAlloc+0x20>
    500c:	9b01      	ldr	r3, [sp, #4]
    500e:	f023 0303 	bic.w	r3, r3, #3
    5012:	2b00      	cmp	r3, #0
    5014:	d007      	beq.n	5026 <osRtxMemoryAlloc+0x30>
    EvrRtxMemoryAlloc(mem, size, type, NULL);
    5016:	2300      	movs	r3, #0
    5018:	9a01      	ldr	r2, [sp, #4]
    501a:	9902      	ldr	r1, [sp, #8]
    501c:	9803      	ldr	r0, [sp, #12]
    501e:	f7ff fafe 	bl	461e <EvrRtxMemoryAlloc>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return NULL;
    5022:	2300      	movs	r3, #0
    5024:	e080      	b.n	5128 <osRtxMemoryAlloc+0x132>
  }

  // Add block header to size
  block_size = size + sizeof(mem_block_t);
    5026:	9b02      	ldr	r3, [sp, #8]
    5028:	3308      	adds	r3, #8
    502a:	9307      	str	r3, [sp, #28]
  // Make sure that block is 8-byte aligned
  block_size = (block_size + 7U) & ~((uint32_t)7U);
    502c:	9b07      	ldr	r3, [sp, #28]
    502e:	3307      	adds	r3, #7
    5030:	f023 0307 	bic.w	r3, r3, #7
    5034:	9307      	str	r3, [sp, #28]

  // Search for hole big enough
  p = MemBlockPtr(mem, sizeof(mem_head_t));
    5036:	2108      	movs	r1, #8
    5038:	9803      	ldr	r0, [sp, #12]
    503a:	f7ff ff87 	bl	4f4c <MemBlockPtr>
    503e:	9008      	str	r0, [sp, #32]
  for (;;) {
    //lint -e{923} -e{9078} "cast from pointer to unsigned int"
    hole_size  = (uint32_t)p->next - (uint32_t)p;
    5040:	9b08      	ldr	r3, [sp, #32]
    5042:	681b      	ldr	r3, [r3, #0]
    5044:	461a      	mov	r2, r3
    5046:	9b08      	ldr	r3, [sp, #32]
    5048:	1ad3      	subs	r3, r2, r3
    504a:	9306      	str	r3, [sp, #24]
    hole_size -= p->info & MB_INFO_LEN_MASK;
    504c:	9b08      	ldr	r3, [sp, #32]
    504e:	685b      	ldr	r3, [r3, #4]
    5050:	f023 0303 	bic.w	r3, r3, #3
    5054:	9a06      	ldr	r2, [sp, #24]
    5056:	1ad3      	subs	r3, r2, r3
    5058:	9306      	str	r3, [sp, #24]
    if (hole_size >= block_size) {
    505a:	9a06      	ldr	r2, [sp, #24]
    505c:	9b07      	ldr	r3, [sp, #28]
    505e:	429a      	cmp	r2, r3
    5060:	d20e      	bcs.n	5080 <osRtxMemoryAlloc+0x8a>
      // Hole found
      break;
    }
    p = p->next;
    5062:	9b08      	ldr	r3, [sp, #32]
    5064:	681b      	ldr	r3, [r3, #0]
    5066:	9308      	str	r3, [sp, #32]
    if (p->next == NULL) {
    5068:	9b08      	ldr	r3, [sp, #32]
    506a:	681b      	ldr	r3, [r3, #0]
    506c:	2b00      	cmp	r3, #0
    506e:	d1e7      	bne.n	5040 <osRtxMemoryAlloc+0x4a>
      // Failed (end of list)
      EvrRtxMemoryAlloc(mem, size, type, NULL);
    5070:	2300      	movs	r3, #0
    5072:	9a01      	ldr	r2, [sp, #4]
    5074:	9902      	ldr	r1, [sp, #8]
    5076:	9803      	ldr	r0, [sp, #12]
    5078:	f7ff fad1 	bl	461e <EvrRtxMemoryAlloc>
      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
      return NULL;
    507c:	2300      	movs	r3, #0
    507e:	e053      	b.n	5128 <osRtxMemoryAlloc+0x132>
      break;
    5080:	bf00      	nop
    }
  }

  // Update used memory
  (MemHeadPtr(mem))->used += block_size;
    5082:	9803      	ldr	r0, [sp, #12]
    5084:	f7ff ff5c 	bl	4f40 <MemHeadPtr>
    5088:	4603      	mov	r3, r0
    508a:	6859      	ldr	r1, [r3, #4]
    508c:	9a07      	ldr	r2, [sp, #28]
    508e:	440a      	add	r2, r1
    5090:	605a      	str	r2, [r3, #4]

  // Update max used memory
  p_new = MemBlockPtr(mem, (MemHeadPtr(mem))->size - sizeof(mem_block_t));
    5092:	9803      	ldr	r0, [sp, #12]
    5094:	f7ff ff54 	bl	4f40 <MemHeadPtr>
    5098:	4603      	mov	r3, r0
    509a:	681b      	ldr	r3, [r3, #0]
    509c:	3b08      	subs	r3, #8
    509e:	4619      	mov	r1, r3
    50a0:	9803      	ldr	r0, [sp, #12]
    50a2:	f7ff ff53 	bl	4f4c <MemBlockPtr>
    50a6:	9005      	str	r0, [sp, #20]
  if (p_new->info < (MemHeadPtr(mem))->used) {
    50a8:	9b05      	ldr	r3, [sp, #20]
    50aa:	685c      	ldr	r4, [r3, #4]
    50ac:	9803      	ldr	r0, [sp, #12]
    50ae:	f7ff ff47 	bl	4f40 <MemHeadPtr>
    50b2:	4603      	mov	r3, r0
    50b4:	685b      	ldr	r3, [r3, #4]
    50b6:	429c      	cmp	r4, r3
    50b8:	d206      	bcs.n	50c8 <osRtxMemoryAlloc+0xd2>
    p_new->info = (MemHeadPtr(mem))->used;
    50ba:	9803      	ldr	r0, [sp, #12]
    50bc:	f7ff ff40 	bl	4f40 <MemHeadPtr>
    50c0:	4603      	mov	r3, r0
    50c2:	685a      	ldr	r2, [r3, #4]
    50c4:	9b05      	ldr	r3, [sp, #20]
    50c6:	605a      	str	r2, [r3, #4]
  }

  // Allocate block
  if (p->info == 0U) {
    50c8:	9b08      	ldr	r3, [sp, #32]
    50ca:	685b      	ldr	r3, [r3, #4]
    50cc:	2b00      	cmp	r3, #0
    50ce:	d10a      	bne.n	50e6 <osRtxMemoryAlloc+0xf0>
    // No block allocated, set info of first element
    p->info = block_size | type;
    50d0:	9a07      	ldr	r2, [sp, #28]
    50d2:	9b01      	ldr	r3, [sp, #4]
    50d4:	431a      	orrs	r2, r3
    50d6:	9b08      	ldr	r3, [sp, #32]
    50d8:	605a      	str	r2, [r3, #4]
    ptr = MemBlockPtr(p, sizeof(mem_block_t));
    50da:	2108      	movs	r1, #8
    50dc:	9808      	ldr	r0, [sp, #32]
    50de:	f7ff ff35 	bl	4f4c <MemBlockPtr>
    50e2:	9009      	str	r0, [sp, #36]	; 0x24
    50e4:	e019      	b.n	511a <osRtxMemoryAlloc+0x124>
  } else {
    // Insert new element into the list
    p_new = MemBlockPtr(p, p->info & MB_INFO_LEN_MASK);
    50e6:	9b08      	ldr	r3, [sp, #32]
    50e8:	685b      	ldr	r3, [r3, #4]
    50ea:	f023 0303 	bic.w	r3, r3, #3
    50ee:	4619      	mov	r1, r3
    50f0:	9808      	ldr	r0, [sp, #32]
    50f2:	f7ff ff2b 	bl	4f4c <MemBlockPtr>
    50f6:	9005      	str	r0, [sp, #20]
    p_new->next = p->next;
    50f8:	9b08      	ldr	r3, [sp, #32]
    50fa:	681a      	ldr	r2, [r3, #0]
    50fc:	9b05      	ldr	r3, [sp, #20]
    50fe:	601a      	str	r2, [r3, #0]
    p_new->info = block_size | type;
    5100:	9a07      	ldr	r2, [sp, #28]
    5102:	9b01      	ldr	r3, [sp, #4]
    5104:	431a      	orrs	r2, r3
    5106:	9b05      	ldr	r3, [sp, #20]
    5108:	605a      	str	r2, [r3, #4]
    p->next = p_new;
    510a:	9b08      	ldr	r3, [sp, #32]
    510c:	9a05      	ldr	r2, [sp, #20]
    510e:	601a      	str	r2, [r3, #0]
    ptr = MemBlockPtr(p_new, sizeof(mem_block_t));
    5110:	2108      	movs	r1, #8
    5112:	9805      	ldr	r0, [sp, #20]
    5114:	f7ff ff1a 	bl	4f4c <MemBlockPtr>
    5118:	9009      	str	r0, [sp, #36]	; 0x24
  }

  EvrRtxMemoryAlloc(mem, size, type, ptr);
    511a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    511c:	9a01      	ldr	r2, [sp, #4]
    511e:	9902      	ldr	r1, [sp, #8]
    5120:	9803      	ldr	r0, [sp, #12]
    5122:	f7ff fa7c 	bl	461e <EvrRtxMemoryAlloc>

  return ptr;
    5126:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    5128:	4618      	mov	r0, r3
    512a:	b00a      	add	sp, #40	; 0x28
    512c:	bd10      	pop	{r4, pc}

0000512e <osRtxMemoryFree>:

/// Return an allocated memory block back to a Memory Pool.
/// \param[in]  mem             pointer to memory pool.
/// \param[in]  block           memory block to be returned to the memory pool.
/// \return 1 - success, 0 - failure.
__WEAK uint32_t osRtxMemoryFree (void *mem, void *block) {
    512e:	b500      	push	{lr}
    5130:	b087      	sub	sp, #28
    5132:	9001      	str	r0, [sp, #4]
    5134:	9100      	str	r1, [sp, #0]
  const mem_block_t *ptr;
        mem_block_t *p, *p_prev;

  // Check parameters
  if ((mem == NULL) || (block == NULL)) {
    5136:	9b01      	ldr	r3, [sp, #4]
    5138:	2b00      	cmp	r3, #0
    513a:	d002      	beq.n	5142 <osRtxMemoryFree+0x14>
    513c:	9b00      	ldr	r3, [sp, #0]
    513e:	2b00      	cmp	r3, #0
    5140:	d106      	bne.n	5150 <osRtxMemoryFree+0x22>
    EvrRtxMemoryFree(mem, block, 0U);
    5142:	2200      	movs	r2, #0
    5144:	9900      	ldr	r1, [sp, #0]
    5146:	9801      	ldr	r0, [sp, #4]
    5148:	f7ff fa71 	bl	462e <EvrRtxMemoryFree>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    514c:	2300      	movs	r3, #0
    514e:	e03e      	b.n	51ce <osRtxMemoryFree+0xa0>
  }

  // Memory block header
  ptr = MemBlockPtr(block, 0U);
    5150:	2100      	movs	r1, #0
    5152:	9800      	ldr	r0, [sp, #0]
    5154:	f7ff fefa 	bl	4f4c <MemBlockPtr>
    5158:	9003      	str	r0, [sp, #12]
  ptr--;
    515a:	9b03      	ldr	r3, [sp, #12]
    515c:	3b08      	subs	r3, #8
    515e:	9303      	str	r3, [sp, #12]

  // Search for block header
  p_prev = NULL;
    5160:	2300      	movs	r3, #0
    5162:	9304      	str	r3, [sp, #16]
  p = MemBlockPtr(mem, sizeof(mem_head_t));
    5164:	2108      	movs	r1, #8
    5166:	9801      	ldr	r0, [sp, #4]
    5168:	f7ff fef0 	bl	4f4c <MemBlockPtr>
    516c:	9005      	str	r0, [sp, #20]
  while (p != ptr) {
    516e:	e00e      	b.n	518e <osRtxMemoryFree+0x60>
    p_prev = p;
    5170:	9b05      	ldr	r3, [sp, #20]
    5172:	9304      	str	r3, [sp, #16]
    p = p->next;
    5174:	9b05      	ldr	r3, [sp, #20]
    5176:	681b      	ldr	r3, [r3, #0]
    5178:	9305      	str	r3, [sp, #20]
    if (p == NULL) {
    517a:	9b05      	ldr	r3, [sp, #20]
    517c:	2b00      	cmp	r3, #0
    517e:	d106      	bne.n	518e <osRtxMemoryFree+0x60>
      // Not found
      EvrRtxMemoryFree(mem, block, 0U);
    5180:	2200      	movs	r2, #0
    5182:	9900      	ldr	r1, [sp, #0]
    5184:	9801      	ldr	r0, [sp, #4]
    5186:	f7ff fa52 	bl	462e <EvrRtxMemoryFree>
      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
      return 0U;
    518a:	2300      	movs	r3, #0
    518c:	e01f      	b.n	51ce <osRtxMemoryFree+0xa0>
  while (p != ptr) {
    518e:	9a05      	ldr	r2, [sp, #20]
    5190:	9b03      	ldr	r3, [sp, #12]
    5192:	429a      	cmp	r2, r3
    5194:	d1ec      	bne.n	5170 <osRtxMemoryFree+0x42>
    }
  }

  // Update used memory
  (MemHeadPtr(mem))->used -= p->info & MB_INFO_LEN_MASK;
    5196:	9801      	ldr	r0, [sp, #4]
    5198:	f7ff fed2 	bl	4f40 <MemHeadPtr>
    519c:	4603      	mov	r3, r0
    519e:	6859      	ldr	r1, [r3, #4]
    51a0:	9a05      	ldr	r2, [sp, #20]
    51a2:	6852      	ldr	r2, [r2, #4]
    51a4:	f022 0203 	bic.w	r2, r2, #3
    51a8:	1a8a      	subs	r2, r1, r2
    51aa:	605a      	str	r2, [r3, #4]

  // Free block
  if (p_prev == NULL) {
    51ac:	9b04      	ldr	r3, [sp, #16]
    51ae:	2b00      	cmp	r3, #0
    51b0:	d103      	bne.n	51ba <osRtxMemoryFree+0x8c>
    // Release first block, only set info to 0
    p->info = 0U;
    51b2:	9b05      	ldr	r3, [sp, #20]
    51b4:	2200      	movs	r2, #0
    51b6:	605a      	str	r2, [r3, #4]
    51b8:	e003      	b.n	51c2 <osRtxMemoryFree+0x94>
  } else {
    // Discard block from chained list
    p_prev->next = p->next;
    51ba:	9b05      	ldr	r3, [sp, #20]
    51bc:	681a      	ldr	r2, [r3, #0]
    51be:	9b04      	ldr	r3, [sp, #16]
    51c0:	601a      	str	r2, [r3, #0]
  }

  EvrRtxMemoryFree(mem, block, 1U);
    51c2:	2201      	movs	r2, #1
    51c4:	9900      	ldr	r1, [sp, #0]
    51c6:	9801      	ldr	r0, [sp, #4]
    51c8:	f7ff fa31 	bl	462e <EvrRtxMemoryFree>

  return 1U;
    51cc:	2301      	movs	r3, #1
}
    51ce:	4618      	mov	r0, r3
    51d0:	b007      	add	sp, #28
    51d2:	f85d fb04 	ldr.w	pc, [sp], #4

000051d6 <atomic_inc32_lt>:
  b     %B1
3
  pop   {r4,pc}
}
#else
__STATIC_INLINE uint32_t atomic_inc32_lt (uint32_t *mem, uint32_t max) {
    51d6:	b410      	push	{r4}
    51d8:	b083      	sub	sp, #12
    51da:	9001      	str	r0, [sp, #4]
    51dc:	9100      	str	r1, [sp, #0]
#ifdef  __ICCARM__
#pragma diag_default=Pe550
#endif
  register uint32_t ret;

  __ASM volatile (
    51de:	9b01      	ldr	r3, [sp, #4]
    51e0:	9a00      	ldr	r2, [sp, #0]
    51e2:	e853 1f00 	ldrex	r1, [r3]
    51e6:	428a      	cmp	r2, r1
    51e8:	d802      	bhi.n	51f0 <atomic_inc32_lt+0x1a>
    51ea:	f3bf 8f2f 	clrex
    51ee:	e004      	b.n	51fa <atomic_inc32_lt+0x24>
    51f0:	1c48      	adds	r0, r1, #1
    51f2:	e843 0400 	strex	r4, r0, [r3]
    51f6:	b104      	cbz	r4, 51fa <atomic_inc32_lt+0x24>
    51f8:	e7f3      	b.n	51e2 <atomic_inc32_lt+0xc>
    51fa:	460c      	mov	r4, r1
  : [mem] "l"   (mem),
    [max] "l"   (max)
  : "cc", "memory"
  );

  return ret;
    51fc:	4623      	mov	r3, r4
}
    51fe:	4618      	mov	r0, r3
    5200:	b003      	add	sp, #12
    5202:	f85d 4b04 	ldr.w	r4, [sp], #4
    5206:	4770      	bx	lr

00005208 <atomic_dec32_nz>:
  b     %B1
3
  bx     lr
}
#else
__STATIC_INLINE uint32_t atomic_dec32_nz (uint32_t *mem) {
    5208:	b410      	push	{r4}
    520a:	b083      	sub	sp, #12
    520c:	9001      	str	r0, [sp, #4]
#ifdef  __ICCARM__
#pragma diag_default=Pe550
#endif
  register uint32_t ret;

  __ASM volatile (
    520e:	9b01      	ldr	r3, [sp, #4]
    5210:	e853 2f00 	ldrex	r2, [r3]
    5214:	b912      	cbnz	r2, 521c <atomic_dec32_nz+0x14>
    5216:	f3bf 8f2f 	clrex
    521a:	e004      	b.n	5226 <atomic_dec32_nz+0x1e>
    521c:	1e51      	subs	r1, r2, #1
    521e:	e843 1000 	strex	r0, r1, [r3]
    5222:	b100      	cbz	r0, 5226 <atomic_dec32_nz+0x1e>
    5224:	e7f4      	b.n	5210 <atomic_dec32_nz+0x8>
    5226:	4614      	mov	r4, r2
    [res] "=&l" (res)
  : [mem] "l"   (mem)
  : "cc", "memory"
  );

  return ret;
    5228:	4623      	mov	r3, r4
}
    522a:	4618      	mov	r0, r3
    522c:	b003      	add	sp, #12
    522e:	f85d 4b04 	ldr.w	r4, [sp], #4
    5232:	4770      	bx	lr

00005234 <atomic_link_get>:
  b     %B1
3
  bx     lr
}
#else
__STATIC_INLINE void *atomic_link_get (void **root) {
    5234:	b410      	push	{r4}
    5236:	b083      	sub	sp, #12
    5238:	9001      	str	r0, [sp, #4]
#ifdef  __ICCARM__
#pragma diag_default=Pe550
#endif
  register void    *ret;

  __ASM volatile (
    523a:	9b01      	ldr	r3, [sp, #4]
    523c:	e853 2f00 	ldrex	r2, [r3]
    5240:	b912      	cbnz	r2, 5248 <atomic_link_get+0x14>
    5242:	f3bf 8f2f 	clrex
    5246:	e004      	b.n	5252 <atomic_link_get+0x1e>
    5248:	6811      	ldr	r1, [r2, #0]
    524a:	e843 1000 	strex	r0, r1, [r3]
    524e:	b100      	cbz	r0, 5252 <atomic_link_get+0x1e>
    5250:	e7f4      	b.n	523c <atomic_link_get+0x8>
    5252:	4614      	mov	r4, r2
    [res]  "=&l" (res)
  : [root] "l"   (root)
  : "cc", "memory"
  );

  return ret;
    5254:	4623      	mov	r3, r4
}
    5256:	4618      	mov	r0, r3
    5258:	b003      	add	sp, #12
    525a:	f85d 4b04 	ldr.w	r4, [sp], #4
    525e:	4770      	bx	lr

00005260 <atomic_link_put>:
  b     %B1
2
  bx    lr
}
#else
__STATIC_INLINE void atomic_link_put (void **root, void *link) {
    5260:	b410      	push	{r4}
    5262:	b083      	sub	sp, #12
    5264:	9001      	str	r0, [sp, #4]
    5266:	9100      	str	r1, [sp, #0]
  register uint32_t val1, val2, res;
#ifdef  __ICCARM__
#pragma diag_default=Pe550
#endif

  __ASM volatile (
    5268:	9b01      	ldr	r3, [sp, #4]
    526a:	9a00      	ldr	r2, [sp, #0]
    526c:	6819      	ldr	r1, [r3, #0]
    526e:	6011      	str	r1, [r2, #0]
    5270:	f3bf 8f5f 	dmb	sy
    5274:	e853 1f00 	ldrex	r1, [r3]
    5278:	6810      	ldr	r0, [r2, #0]
    527a:	4288      	cmp	r0, r1
    527c:	d1f6      	bne.n	526c <atomic_link_put+0xc>
    527e:	e843 2400 	strex	r4, r2, [r3]
    5282:	b104      	cbz	r4, 5286 <atomic_link_put+0x26>
    5284:	e7f2      	b.n	526c <atomic_link_put+0xc>
    [res]  "=&l" (res)
  : [root] "l"   (root),
    [link] "l"   (link)
  : "cc", "memory"
  );
}
    5286:	bf00      	nop
    5288:	b003      	add	sp, #12
    528a:	f85d 4b04 	ldr.w	r4, [sp], #4
    528e:	4770      	bx	lr

00005290 <osRtxMemoryPoolInit>:
/// \param[in]  mp_info         memory pool info.
/// \param[in]  block_count     maximum number of memory blocks in memory pool.
/// \param[in]  block_size      size of a memory block in bytes.
/// \param[in]  block_mem       pointer to memory for block storage.
/// \return 1 - success, 0 - failure.
uint32_t osRtxMemoryPoolInit (os_mp_info_t *mp_info, uint32_t block_count, uint32_t block_size, void *block_mem) {
    5290:	b500      	push	{lr}
    5292:	b087      	sub	sp, #28
    5294:	9003      	str	r0, [sp, #12]
    5296:	9102      	str	r1, [sp, #8]
    5298:	9201      	str	r2, [sp, #4]
    529a:	9300      	str	r3, [sp, #0]
  //lint --e{9079} --e{9087} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
  void *mem;
  void *block;

  // Check parameters
  if ((mp_info == NULL) || (block_count == 0U) || (block_size  == 0U) || (block_mem  == NULL)) {
    529c:	9b03      	ldr	r3, [sp, #12]
    529e:	2b00      	cmp	r3, #0
    52a0:	d008      	beq.n	52b4 <osRtxMemoryPoolInit+0x24>
    52a2:	9b02      	ldr	r3, [sp, #8]
    52a4:	2b00      	cmp	r3, #0
    52a6:	d005      	beq.n	52b4 <osRtxMemoryPoolInit+0x24>
    52a8:	9b01      	ldr	r3, [sp, #4]
    52aa:	2b00      	cmp	r3, #0
    52ac:	d002      	beq.n	52b4 <osRtxMemoryPoolInit+0x24>
    52ae:	9b00      	ldr	r3, [sp, #0]
    52b0:	2b00      	cmp	r3, #0
    52b2:	d101      	bne.n	52b8 <osRtxMemoryPoolInit+0x28>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    52b4:	2300      	movs	r3, #0
    52b6:	e032      	b.n	531e <osRtxMemoryPoolInit+0x8e>
  }

  // Initialize information structure
  mp_info->max_blocks  = block_count;
    52b8:	9b03      	ldr	r3, [sp, #12]
    52ba:	9a02      	ldr	r2, [sp, #8]
    52bc:	601a      	str	r2, [r3, #0]
  mp_info->used_blocks = 0U;
    52be:	9b03      	ldr	r3, [sp, #12]
    52c0:	2200      	movs	r2, #0
    52c2:	605a      	str	r2, [r3, #4]
  mp_info->block_size  = block_size;
    52c4:	9b03      	ldr	r3, [sp, #12]
    52c6:	9a01      	ldr	r2, [sp, #4]
    52c8:	609a      	str	r2, [r3, #8]
  mp_info->block_base  = block_mem;
    52ca:	9b03      	ldr	r3, [sp, #12]
    52cc:	9a00      	ldr	r2, [sp, #0]
    52ce:	60da      	str	r2, [r3, #12]
  mp_info->block_free  = block_mem;
    52d0:	9b03      	ldr	r3, [sp, #12]
    52d2:	9a00      	ldr	r2, [sp, #0]
    52d4:	615a      	str	r2, [r3, #20]
  mp_info->block_lim   = &(((uint8_t *)block_mem)[block_count * block_size]);
    52d6:	9b02      	ldr	r3, [sp, #8]
    52d8:	9a01      	ldr	r2, [sp, #4]
    52da:	fb02 f303 	mul.w	r3, r2, r3
    52de:	9a00      	ldr	r2, [sp, #0]
    52e0:	441a      	add	r2, r3
    52e2:	9b03      	ldr	r3, [sp, #12]
    52e4:	611a      	str	r2, [r3, #16]

  EvrRtxMemoryBlockInit(mp_info, block_count, block_size, block_mem);
    52e6:	9b00      	ldr	r3, [sp, #0]
    52e8:	9a01      	ldr	r2, [sp, #4]
    52ea:	9902      	ldr	r1, [sp, #8]
    52ec:	9803      	ldr	r0, [sp, #12]
    52ee:	f7ff f9a5 	bl	463c <EvrRtxMemoryBlockInit>

  // Link all free blocks
  mem = block_mem;
    52f2:	9b00      	ldr	r3, [sp, #0]
    52f4:	9305      	str	r3, [sp, #20]
  while (--block_count != 0U) {
    52f6:	e008      	b.n	530a <osRtxMemoryPoolInit+0x7a>
    block = &((uint8_t *)mem)[block_size];
    52f8:	9a05      	ldr	r2, [sp, #20]
    52fa:	9b01      	ldr	r3, [sp, #4]
    52fc:	4413      	add	r3, r2
    52fe:	9304      	str	r3, [sp, #16]
    *((void **)mem) = block;
    5300:	9b05      	ldr	r3, [sp, #20]
    5302:	9a04      	ldr	r2, [sp, #16]
    5304:	601a      	str	r2, [r3, #0]
    mem = block;
    5306:	9b04      	ldr	r3, [sp, #16]
    5308:	9305      	str	r3, [sp, #20]
  while (--block_count != 0U) {
    530a:	9b02      	ldr	r3, [sp, #8]
    530c:	3b01      	subs	r3, #1
    530e:	9302      	str	r3, [sp, #8]
    5310:	9b02      	ldr	r3, [sp, #8]
    5312:	2b00      	cmp	r3, #0
    5314:	d1f0      	bne.n	52f8 <osRtxMemoryPoolInit+0x68>
  }
  *((void **)mem) = NULL;
    5316:	9b05      	ldr	r3, [sp, #20]
    5318:	2200      	movs	r2, #0
    531a:	601a      	str	r2, [r3, #0]

  return 1U;
    531c:	2301      	movs	r3, #1
}
    531e:	4618      	mov	r0, r3
    5320:	b007      	add	sp, #28
    5322:	f85d fb04 	ldr.w	pc, [sp], #4

00005326 <osRtxMemoryPoolAlloc>:

/// Allocate a memory block from a Memory Pool.
/// \param[in]  mp_info         memory pool info.
/// \return address of the allocated memory block or NULL in case of no memory is available.
void *osRtxMemoryPoolAlloc (os_mp_info_t *mp_info) {
    5326:	b500      	push	{lr}
    5328:	b085      	sub	sp, #20
    532a:	9001      	str	r0, [sp, #4]
#if (EXCLUSIVE_ACCESS == 0)
  uint32_t primask = __get_PRIMASK();
#endif
  void *block;

  if (mp_info == NULL) {
    532c:	9b01      	ldr	r3, [sp, #4]
    532e:	2b00      	cmp	r3, #0
    5330:	d105      	bne.n	533e <osRtxMemoryPoolAlloc+0x18>
    EvrRtxMemoryBlockAlloc(NULL, NULL);
    5332:	2100      	movs	r1, #0
    5334:	2000      	movs	r0, #0
    5336:	f7ff f989 	bl	464c <EvrRtxMemoryBlockAlloc>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return NULL;
    533a:	2300      	movs	r3, #0
    533c:	e01a      	b.n	5374 <osRtxMemoryPoolAlloc+0x4e>

  if (primask == 0U) {
    __enable_irq();
  }
#else
  if (atomic_inc32_lt(&mp_info->used_blocks, mp_info->max_blocks) < mp_info->max_blocks) {
    533e:	9b01      	ldr	r3, [sp, #4]
    5340:	1d1a      	adds	r2, r3, #4
    5342:	9b01      	ldr	r3, [sp, #4]
    5344:	681b      	ldr	r3, [r3, #0]
    5346:	4619      	mov	r1, r3
    5348:	4610      	mov	r0, r2
    534a:	f7ff ff44 	bl	51d6 <atomic_inc32_lt>
    534e:	4602      	mov	r2, r0
    5350:	9b01      	ldr	r3, [sp, #4]
    5352:	681b      	ldr	r3, [r3, #0]
    5354:	429a      	cmp	r2, r3
    5356:	d206      	bcs.n	5366 <osRtxMemoryPoolAlloc+0x40>
    block = atomic_link_get(&mp_info->block_free);
    5358:	9b01      	ldr	r3, [sp, #4]
    535a:	3314      	adds	r3, #20
    535c:	4618      	mov	r0, r3
    535e:	f7ff ff69 	bl	5234 <atomic_link_get>
    5362:	9003      	str	r0, [sp, #12]
    5364:	e001      	b.n	536a <osRtxMemoryPoolAlloc+0x44>
  } else {
    block = NULL;
    5366:	2300      	movs	r3, #0
    5368:	9303      	str	r3, [sp, #12]
  }
#endif

  EvrRtxMemoryBlockAlloc(mp_info, block);
    536a:	9903      	ldr	r1, [sp, #12]
    536c:	9801      	ldr	r0, [sp, #4]
    536e:	f7ff f96d 	bl	464c <EvrRtxMemoryBlockAlloc>

  return block;
    5372:	9b03      	ldr	r3, [sp, #12]
}
    5374:	4618      	mov	r0, r3
    5376:	b005      	add	sp, #20
    5378:	f85d fb04 	ldr.w	pc, [sp], #4

0000537c <osRtxMemoryPoolFree>:

/// Return an allocated memory block back to a Memory Pool.
/// \param[in]  mp_info         memory pool info.
/// \param[in]  block           address of the allocated memory block to be returned to the memory pool.
/// \return status code that indicates the execution status of the function.
osStatus_t osRtxMemoryPoolFree (os_mp_info_t *mp_info, void *block) {
    537c:	b500      	push	{lr}
    537e:	b085      	sub	sp, #20
    5380:	9001      	str	r0, [sp, #4]
    5382:	9100      	str	r1, [sp, #0]
  uint32_t primask = __get_PRIMASK();
#endif
  osStatus_t status;

  //lint -e{946} "Relational operator applied to pointers"
  if ((mp_info == NULL) || (block < mp_info->block_base) || (block >= mp_info->block_lim)) {
    5384:	9b01      	ldr	r3, [sp, #4]
    5386:	2b00      	cmp	r3, #0
    5388:	d009      	beq.n	539e <osRtxMemoryPoolFree+0x22>
    538a:	9b01      	ldr	r3, [sp, #4]
    538c:	68da      	ldr	r2, [r3, #12]
    538e:	9b00      	ldr	r3, [sp, #0]
    5390:	429a      	cmp	r2, r3
    5392:	d804      	bhi.n	539e <osRtxMemoryPoolFree+0x22>
    5394:	9b01      	ldr	r3, [sp, #4]
    5396:	691a      	ldr	r2, [r3, #16]
    5398:	9b00      	ldr	r3, [sp, #0]
    539a:	429a      	cmp	r2, r3
    539c:	d808      	bhi.n	53b0 <osRtxMemoryPoolFree+0x34>
    EvrRtxMemoryBlockFree(mp_info, block, (int32_t)osErrorParameter);
    539e:	f06f 0203 	mvn.w	r2, #3
    53a2:	9900      	ldr	r1, [sp, #0]
    53a4:	9801      	ldr	r0, [sp, #4]
    53a6:	f7ff f957 	bl	4658 <EvrRtxMemoryBlockFree>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorParameter;
    53aa:	f06f 0303 	mvn.w	r3, #3
    53ae:	e019      	b.n	53e4 <osRtxMemoryPoolFree+0x68>

  if (primask == 0U) {
    __enable_irq();
  }
#else
  if (atomic_dec32_nz(&mp_info->used_blocks) != 0U) {
    53b0:	9b01      	ldr	r3, [sp, #4]
    53b2:	3304      	adds	r3, #4
    53b4:	4618      	mov	r0, r3
    53b6:	f7ff ff27 	bl	5208 <atomic_dec32_nz>
    53ba:	4603      	mov	r3, r0
    53bc:	2b00      	cmp	r3, #0
    53be:	d008      	beq.n	53d2 <osRtxMemoryPoolFree+0x56>
    atomic_link_put(&mp_info->block_free, block);
    53c0:	9b01      	ldr	r3, [sp, #4]
    53c2:	3314      	adds	r3, #20
    53c4:	9900      	ldr	r1, [sp, #0]
    53c6:	4618      	mov	r0, r3
    53c8:	f7ff ff4a 	bl	5260 <atomic_link_put>
    status = osOK;
    53cc:	2300      	movs	r3, #0
    53ce:	9303      	str	r3, [sp, #12]
    53d0:	e002      	b.n	53d8 <osRtxMemoryPoolFree+0x5c>
  } else {
    status = osErrorResource;
    53d2:	f06f 0302 	mvn.w	r3, #2
    53d6:	9303      	str	r3, [sp, #12]
  }
#endif

  EvrRtxMemoryBlockFree(mp_info, block, (int32_t)status);
    53d8:	9a03      	ldr	r2, [sp, #12]
    53da:	9900      	ldr	r1, [sp, #0]
    53dc:	9801      	ldr	r0, [sp, #4]
    53de:	f7ff f93b 	bl	4658 <EvrRtxMemoryBlockFree>

  return status;
    53e2:	9b03      	ldr	r3, [sp, #12]
}
    53e4:	4618      	mov	r0, r3
    53e6:	b005      	add	sp, #20
    53e8:	f85d fb04 	ldr.w	pc, [sp], #4

000053ec <IsIrqMode>:
__STATIC_INLINE bool_t IsIrqMode (void) {
    53ec:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    53ee:	f3ef 8305 	mrs	r3, IPSR
    53f2:	9301      	str	r3, [sp, #4]
  return(result);
    53f4:	9b01      	ldr	r3, [sp, #4]
  return (__get_IPSR() != 0U);
    53f6:	2b00      	cmp	r3, #0
    53f8:	bf14      	ite	ne
    53fa:	2301      	movne	r3, #1
    53fc:	2300      	moveq	r3, #0
    53fe:	b2db      	uxtb	r3, r3
}
    5400:	4618      	mov	r0, r3
    5402:	b002      	add	sp, #8
    5404:	4770      	bx	lr

00005406 <IsIrqMasked>:
__STATIC_INLINE bool_t IsIrqMasked (void) {
    5406:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    5408:	f3ef 8310 	mrs	r3, PRIMASK
    540c:	9301      	str	r3, [sp, #4]
  return(result);
    540e:	9b01      	ldr	r3, [sp, #4]
  return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
    5410:	2b00      	cmp	r3, #0
    5412:	d105      	bne.n	5420 <IsIrqMasked+0x1a>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
    5414:	f3ef 8311 	mrs	r3, BASEPRI
    5418:	9300      	str	r3, [sp, #0]
  return(result);
    541a:	9b00      	ldr	r3, [sp, #0]
    541c:	2b00      	cmp	r3, #0
    541e:	d001      	beq.n	5424 <IsIrqMasked+0x1e>
    5420:	2301      	movs	r3, #1
    5422:	e000      	b.n	5426 <IsIrqMasked+0x20>
    5424:	2300      	movs	r3, #0
    5426:	f003 0301 	and.w	r3, r3, #1
    542a:	b2db      	uxtb	r3, r3
}
    542c:	4618      	mov	r0, r3
    542e:	b002      	add	sp, #8
    5430:	4770      	bx	lr

00005432 <atomic_wr8>:
__STATIC_INLINE uint8_t atomic_wr8 (uint8_t *mem, uint8_t val) {
    5432:	b410      	push	{r4}
    5434:	b083      	sub	sp, #12
    5436:	9001      	str	r0, [sp, #4]
    5438:	460b      	mov	r3, r1
    543a:	f88d 3003 	strb.w	r3, [sp, #3]
  __ASM volatile (
    543e:	9b01      	ldr	r3, [sp, #4]
    5440:	f89d 2003 	ldrb.w	r2, [sp, #3]
    5444:	e8d3 1f4f 	ldrexb	r1, [r3]
    5448:	e8c3 2f40 	strexb	r0, r2, [r3]
    544c:	b100      	cbz	r0, 5450 <atomic_wr8+0x1e>
    544e:	e7f9      	b.n	5444 <atomic_wr8+0x12>
    5450:	b2cc      	uxtb	r4, r1
  return ret;
    5452:	4623      	mov	r3, r4
}
    5454:	4618      	mov	r0, r3
    5456:	b003      	add	sp, #12
    5458:	f85d 4b04 	ldr.w	r4, [sp], #4
    545c:	4770      	bx	lr

0000545e <atomic_inc32>:
__STATIC_INLINE uint32_t atomic_inc32 (uint32_t *mem) {
    545e:	b410      	push	{r4}
    5460:	b083      	sub	sp, #12
    5462:	9001      	str	r0, [sp, #4]
  __ASM volatile (
    5464:	9b01      	ldr	r3, [sp, #4]
    5466:	e853 2f00 	ldrex	r2, [r3]
    546a:	1c51      	adds	r1, r2, #1
    546c:	e843 1000 	strex	r0, r1, [r3]
    5470:	b100      	cbz	r0, 5474 <atomic_inc32+0x16>
    5472:	e7f8      	b.n	5466 <atomic_inc32+0x8>
    5474:	4614      	mov	r4, r2
  return ret;
    5476:	4623      	mov	r3, r4
}
    5478:	4618      	mov	r0, r3
    547a:	b003      	add	sp, #12
    547c:	f85d 4b04 	ldr.w	r4, [sp], #4
    5480:	4770      	bx	lr

00005482 <atomic_dec32_nz>:
__STATIC_INLINE uint32_t atomic_dec32_nz (uint32_t *mem) {
    5482:	b410      	push	{r4}
    5484:	b083      	sub	sp, #12
    5486:	9001      	str	r0, [sp, #4]
  __ASM volatile (
    5488:	9b01      	ldr	r3, [sp, #4]
    548a:	e853 2f00 	ldrex	r2, [r3]
    548e:	b912      	cbnz	r2, 5496 <atomic_dec32_nz+0x14>
    5490:	f3bf 8f2f 	clrex
    5494:	e004      	b.n	54a0 <atomic_dec32_nz+0x1e>
    5496:	1e51      	subs	r1, r2, #1
    5498:	e843 1000 	strex	r0, r1, [r3]
    549c:	b100      	cbz	r0, 54a0 <atomic_dec32_nz+0x1e>
    549e:	e7f4      	b.n	548a <atomic_dec32_nz+0x8>
    54a0:	4614      	mov	r4, r2
  return ret;
    54a2:	4623      	mov	r3, r4
}
    54a4:	4618      	mov	r0, r3
    54a6:	b003      	add	sp, #12
    54a8:	f85d 4b04 	ldr.w	r4, [sp], #4
    54ac:	4770      	bx	lr

000054ae <osRtxMessageQueueId>:
__STATIC_INLINE os_message_queue_t *osRtxMessageQueueId (osMessageQueueId_t mq_id) {
    54ae:	b082      	sub	sp, #8
    54b0:	9001      	str	r0, [sp, #4]
  return ((os_message_queue_t *)mq_id);
    54b2:	9b01      	ldr	r3, [sp, #4]
}
    54b4:	4618      	mov	r0, r3
    54b6:	b002      	add	sp, #8
    54b8:	4770      	bx	lr

000054ba <osRtxObject>:
__STATIC_INLINE os_object_t *osRtxObject (void *object) {
    54ba:	b082      	sub	sp, #8
    54bc:	9001      	str	r0, [sp, #4]
  return ((os_object_t *)object);
    54be:	9b01      	ldr	r3, [sp, #4]
}
    54c0:	4618      	mov	r0, r3
    54c2:	b002      	add	sp, #8
    54c4:	4770      	bx	lr
	...

000054c8 <osRtxThreadGetRunning>:
  return osRtxInfo.kernel.state;
}

// Thread Get/Set Running
__STATIC_INLINE os_thread_t *osRtxThreadGetRunning (void) {
  return osRtxInfo.thread.run.curr;
    54c8:	4b01      	ldr	r3, [pc, #4]	; (54d0 <osRtxThreadGetRunning+0x8>)
    54ca:	695b      	ldr	r3, [r3, #20]
}
    54cc:	4618      	mov	r0, r3
    54ce:	4770      	bx	lr
    54d0:	20000110 	.word	0x20000110

000054d4 <MessageQueuePut>:
//  ==== Helper functions ====

/// Put a Message into Queue sorted by Priority (Highest at Head).
/// \param[in]  mq              message queue object.
/// \param[in]  msg             message object.
static void MessageQueuePut (os_message_queue_t *mq, os_message_t *msg) {
    54d4:	b500      	push	{lr}
    54d6:	b085      	sub	sp, #20
    54d8:	9001      	str	r0, [sp, #4]
    54da:	9100      	str	r1, [sp, #0]
#if (EXCLUSIVE_ACCESS == 0)
  uint32_t      primask = __get_PRIMASK();
#endif
  os_message_t *prev, *next;

  if (mq->msg_last != NULL) {
    54dc:	9b01      	ldr	r3, [sp, #4]
    54de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    54e0:	2b00      	cmp	r3, #0
    54e2:	d02e      	beq.n	5542 <MessageQueuePut+0x6e>
    prev = mq->msg_last;
    54e4:	9b01      	ldr	r3, [sp, #4]
    54e6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    54e8:	9303      	str	r3, [sp, #12]
    next = NULL;
    54ea:	2300      	movs	r3, #0
    54ec:	9302      	str	r3, [sp, #8]
    while ((prev != NULL) && (prev->priority < msg->priority)) {
    54ee:	e004      	b.n	54fa <MessageQueuePut+0x26>
      next = prev;
    54f0:	9b03      	ldr	r3, [sp, #12]
    54f2:	9302      	str	r3, [sp, #8]
      prev = prev->prev;
    54f4:	9b03      	ldr	r3, [sp, #12]
    54f6:	685b      	ldr	r3, [r3, #4]
    54f8:	9303      	str	r3, [sp, #12]
    while ((prev != NULL) && (prev->priority < msg->priority)) {
    54fa:	9b03      	ldr	r3, [sp, #12]
    54fc:	2b00      	cmp	r3, #0
    54fe:	d005      	beq.n	550c <MessageQueuePut+0x38>
    5500:	9b03      	ldr	r3, [sp, #12]
    5502:	78da      	ldrb	r2, [r3, #3]
    5504:	9b00      	ldr	r3, [sp, #0]
    5506:	78db      	ldrb	r3, [r3, #3]
    5508:	429a      	cmp	r2, r3
    550a:	d3f1      	bcc.n	54f0 <MessageQueuePut+0x1c>
    }
    msg->prev = prev;
    550c:	9b00      	ldr	r3, [sp, #0]
    550e:	9a03      	ldr	r2, [sp, #12]
    5510:	605a      	str	r2, [r3, #4]
    msg->next = next;
    5512:	9b00      	ldr	r3, [sp, #0]
    5514:	9a02      	ldr	r2, [sp, #8]
    5516:	609a      	str	r2, [r3, #8]
    if (prev != NULL) {
    5518:	9b03      	ldr	r3, [sp, #12]
    551a:	2b00      	cmp	r3, #0
    551c:	d003      	beq.n	5526 <MessageQueuePut+0x52>
      prev->next = msg;
    551e:	9b03      	ldr	r3, [sp, #12]
    5520:	9a00      	ldr	r2, [sp, #0]
    5522:	609a      	str	r2, [r3, #8]
    5524:	e002      	b.n	552c <MessageQueuePut+0x58>
    } else {
      mq->msg_first = msg;
    5526:	9b01      	ldr	r3, [sp, #4]
    5528:	9a00      	ldr	r2, [sp, #0]
    552a:	62da      	str	r2, [r3, #44]	; 0x2c
    }
    if (next != NULL) {
    552c:	9b02      	ldr	r3, [sp, #8]
    552e:	2b00      	cmp	r3, #0
    5530:	d003      	beq.n	553a <MessageQueuePut+0x66>
      next->prev = msg;
    5532:	9b02      	ldr	r3, [sp, #8]
    5534:	9a00      	ldr	r2, [sp, #0]
    5536:	605a      	str	r2, [r3, #4]
    5538:	e00f      	b.n	555a <MessageQueuePut+0x86>
    } else {
      mq->msg_last = msg;
    553a:	9b01      	ldr	r3, [sp, #4]
    553c:	9a00      	ldr	r2, [sp, #0]
    553e:	631a      	str	r2, [r3, #48]	; 0x30
    5540:	e00b      	b.n	555a <MessageQueuePut+0x86>
    }
  } else {
    msg->prev = NULL;
    5542:	9b00      	ldr	r3, [sp, #0]
    5544:	2200      	movs	r2, #0
    5546:	605a      	str	r2, [r3, #4]
    msg->next = NULL;
    5548:	9b00      	ldr	r3, [sp, #0]
    554a:	2200      	movs	r2, #0
    554c:	609a      	str	r2, [r3, #8]
    mq->msg_first= msg;
    554e:	9b01      	ldr	r3, [sp, #4]
    5550:	9a00      	ldr	r2, [sp, #0]
    5552:	62da      	str	r2, [r3, #44]	; 0x2c
    mq->msg_last = msg;
    5554:	9b01      	ldr	r3, [sp, #4]
    5556:	9a00      	ldr	r2, [sp, #0]
    5558:	631a      	str	r2, [r3, #48]	; 0x30

  if (primask == 0U) {
    __enable_irq();
  }
#else
  (void)atomic_inc32(&mq->msg_count);
    555a:	9b01      	ldr	r3, [sp, #4]
    555c:	3328      	adds	r3, #40	; 0x28
    555e:	4618      	mov	r0, r3
    5560:	f7ff ff7d 	bl	545e <atomic_inc32>
#endif
}
    5564:	bf00      	nop
    5566:	b005      	add	sp, #20
    5568:	f85d fb04 	ldr.w	pc, [sp], #4

0000556c <MessageQueueGet>:

/// Get a Message from Queue with Highest Priority.
/// \param[in]  mq              message queue object.
/// \return message object or NULL.
static os_message_t *MessageQueueGet (os_message_queue_t *mq) {
    556c:	b500      	push	{lr}
    556e:	b087      	sub	sp, #28
    5570:	9001      	str	r0, [sp, #4]

  if (primask == 0U) {
    __enable_irq();
  }
#else
  count = atomic_dec32_nz(&mq->msg_count);
    5572:	9b01      	ldr	r3, [sp, #4]
    5574:	3328      	adds	r3, #40	; 0x28
    5576:	4618      	mov	r0, r3
    5578:	f7ff ff83 	bl	5482 <atomic_dec32_nz>
    557c:	9004      	str	r0, [sp, #16]
#endif

  if (count != 0U) {
    557e:	9b04      	ldr	r3, [sp, #16]
    5580:	2b00      	cmp	r3, #0
    5582:	d017      	beq.n	55b4 <MessageQueueGet+0x48>
    msg = mq->msg_first;
    5584:	9b01      	ldr	r3, [sp, #4]
    5586:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    5588:	9305      	str	r3, [sp, #20]

    while (msg != NULL) {
    558a:	e00f      	b.n	55ac <MessageQueueGet+0x40>

      if (primask == 0U) {
        __enable_irq();
      }
#else
      flags = atomic_wr8(&msg->flags, 1U);
    558c:	9b05      	ldr	r3, [sp, #20]
    558e:	3302      	adds	r3, #2
    5590:	2101      	movs	r1, #1
    5592:	4618      	mov	r0, r3
    5594:	f7ff ff4d 	bl	5432 <atomic_wr8>
    5598:	4603      	mov	r3, r0
    559a:	f88d 300f 	strb.w	r3, [sp, #15]
#endif
      if (flags == 0U) {
    559e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    55a2:	2b00      	cmp	r3, #0
    55a4:	d009      	beq.n	55ba <MessageQueueGet+0x4e>
        break;
      }
      msg = msg->next;
    55a6:	9b05      	ldr	r3, [sp, #20]
    55a8:	689b      	ldr	r3, [r3, #8]
    55aa:	9305      	str	r3, [sp, #20]
    while (msg != NULL) {
    55ac:	9b05      	ldr	r3, [sp, #20]
    55ae:	2b00      	cmp	r3, #0
    55b0:	d1ec      	bne.n	558c <MessageQueueGet+0x20>
    55b2:	e003      	b.n	55bc <MessageQueueGet+0x50>
    }
  } else {
    msg = NULL;
    55b4:	2300      	movs	r3, #0
    55b6:	9305      	str	r3, [sp, #20]
    55b8:	e000      	b.n	55bc <MessageQueueGet+0x50>
        break;
    55ba:	bf00      	nop
  }

  return msg;
    55bc:	9b05      	ldr	r3, [sp, #20]
}
    55be:	4618      	mov	r0, r3
    55c0:	b007      	add	sp, #28
    55c2:	f85d fb04 	ldr.w	pc, [sp], #4

000055c6 <MessageQueueRemove>:

/// Remove a Message from Queue
/// \param[in]  mq              message queue object.
/// \param[in]  msg             message object.
static void MessageQueueRemove (os_message_queue_t *mq, const os_message_t *msg) {
    55c6:	b082      	sub	sp, #8
    55c8:	9001      	str	r0, [sp, #4]
    55ca:	9100      	str	r1, [sp, #0]

  if (msg->prev != NULL) {
    55cc:	9b00      	ldr	r3, [sp, #0]
    55ce:	685b      	ldr	r3, [r3, #4]
    55d0:	2b00      	cmp	r3, #0
    55d2:	d005      	beq.n	55e0 <MessageQueueRemove+0x1a>
    msg->prev->next = msg->next;
    55d4:	9b00      	ldr	r3, [sp, #0]
    55d6:	685b      	ldr	r3, [r3, #4]
    55d8:	9a00      	ldr	r2, [sp, #0]
    55da:	6892      	ldr	r2, [r2, #8]
    55dc:	609a      	str	r2, [r3, #8]
    55de:	e003      	b.n	55e8 <MessageQueueRemove+0x22>
  } else {
    mq->msg_first = msg->next;
    55e0:	9b00      	ldr	r3, [sp, #0]
    55e2:	689a      	ldr	r2, [r3, #8]
    55e4:	9b01      	ldr	r3, [sp, #4]
    55e6:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  if (msg->next != NULL) {
    55e8:	9b00      	ldr	r3, [sp, #0]
    55ea:	689b      	ldr	r3, [r3, #8]
    55ec:	2b00      	cmp	r3, #0
    55ee:	d005      	beq.n	55fc <MessageQueueRemove+0x36>
    msg->next->prev = msg->prev;
    55f0:	9b00      	ldr	r3, [sp, #0]
    55f2:	689b      	ldr	r3, [r3, #8]
    55f4:	9a00      	ldr	r2, [sp, #0]
    55f6:	6852      	ldr	r2, [r2, #4]
    55f8:	605a      	str	r2, [r3, #4]
  } else {
    mq->msg_last = msg->prev;
  }
}
    55fa:	e003      	b.n	5604 <MessageQueueRemove+0x3e>
    mq->msg_last = msg->prev;
    55fc:	9b00      	ldr	r3, [sp, #0]
    55fe:	685a      	ldr	r2, [r3, #4]
    5600:	9b01      	ldr	r3, [sp, #4]
    5602:	631a      	str	r2, [r3, #48]	; 0x30
}
    5604:	bf00      	nop
    5606:	b002      	add	sp, #8
    5608:	4770      	bx	lr

0000560a <osRtxMessageQueuePostProcess>:

//  ==== Post ISR processing ====

/// Message Queue post ISR processing.
/// \param[in]  msg             message object.
static void osRtxMessageQueuePostProcess (os_message_t *msg) {
    560a:	b500      	push	{lr}
    560c:	b089      	sub	sp, #36	; 0x24
    560e:	9001      	str	r0, [sp, #4]
  os_thread_t        *thread;
  const uint32_t     *reg;
  const void         *ptr_src;
        void         *ptr_dst;

  if (msg->state == osRtxObjectInactive) {
    5610:	9b01      	ldr	r3, [sp, #4]
    5612:	785b      	ldrb	r3, [r3, #1]
    5614:	2b00      	cmp	r3, #0
    5616:	f000 80bc 	beq.w	5792 <osRtxMessageQueuePostProcess+0x188>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }

  if (msg->flags != 0U) {
    561a:	9b01      	ldr	r3, [sp, #4]
    561c:	789b      	ldrb	r3, [r3, #2]
    561e:	2b00      	cmp	r3, #0
    5620:	d05f      	beq.n	56e2 <osRtxMessageQueuePostProcess+0xd8>
    // Remove Message
    //lint -e{9079} -e{9087} "cast between pointers to different object types"
    mq = *((os_message_queue_t **)(void *)&msg[1]);
    5622:	9b01      	ldr	r3, [sp, #4]
    5624:	68db      	ldr	r3, [r3, #12]
    5626:	9307      	str	r3, [sp, #28]
    if (mq->state == osRtxObjectInactive) {
    5628:	9b07      	ldr	r3, [sp, #28]
    562a:	785b      	ldrb	r3, [r3, #1]
    562c:	2b00      	cmp	r3, #0
    562e:	f000 80b2 	beq.w	5796 <osRtxMessageQueuePostProcess+0x18c>
      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
      return;
    }
    MessageQueueRemove(mq, msg);
    5632:	9901      	ldr	r1, [sp, #4]
    5634:	9807      	ldr	r0, [sp, #28]
    5636:	f7ff ffc6 	bl	55c6 <MessageQueueRemove>
    // Free memory
    msg->state = osRtxObjectInactive;
    563a:	9b01      	ldr	r3, [sp, #4]
    563c:	2200      	movs	r2, #0
    563e:	705a      	strb	r2, [r3, #1]
    (void)osRtxMemoryPoolFree(&mq->mp_info, msg);
    5640:	9b07      	ldr	r3, [sp, #28]
    5642:	330c      	adds	r3, #12
    5644:	9901      	ldr	r1, [sp, #4]
    5646:	4618      	mov	r0, r3
    5648:	f7ff fe98 	bl	537c <osRtxMemoryPoolFree>
    // Check if Thread is waiting to send a Message
    if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessagePut)) {
    564c:	9b07      	ldr	r3, [sp, #28]
    564e:	689b      	ldr	r3, [r3, #8]
    5650:	2b00      	cmp	r3, #0
    5652:	f000 80a3 	beq.w	579c <osRtxMessageQueuePostProcess+0x192>
    5656:	9b07      	ldr	r3, [sp, #28]
    5658:	689b      	ldr	r3, [r3, #8]
    565a:	785b      	ldrb	r3, [r3, #1]
    565c:	2b93      	cmp	r3, #147	; 0x93
    565e:	f040 809d 	bne.w	579c <osRtxMessageQueuePostProcess+0x192>
      // Try to allocate memory
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      msg0 = osRtxMemoryPoolAlloc(&mq->mp_info);
    5662:	9b07      	ldr	r3, [sp, #28]
    5664:	330c      	adds	r3, #12
    5666:	4618      	mov	r0, r3
    5668:	f7ff fe5d 	bl	5326 <osRtxMemoryPoolAlloc>
    566c:	9006      	str	r0, [sp, #24]
      if (msg0 != NULL) {
    566e:	9b06      	ldr	r3, [sp, #24]
    5670:	2b00      	cmp	r3, #0
    5672:	f000 8093 	beq.w	579c <osRtxMessageQueuePostProcess+0x192>
        // Wakeup waiting Thread with highest Priority
        thread = osRtxThreadListGet(osRtxObject(mq));
    5676:	9807      	ldr	r0, [sp, #28]
    5678:	f7ff ff1f 	bl	54ba <osRtxObject>
    567c:	4603      	mov	r3, r0
    567e:	4618      	mov	r0, r3
    5680:	f001 fa9e 	bl	6bc0 <osRtxThreadListGet>
    5684:	9005      	str	r0, [sp, #20]
        osRtxThreadWaitExit(thread, (uint32_t)osOK, FALSE);
    5686:	2200      	movs	r2, #0
    5688:	2100      	movs	r1, #0
    568a:	9805      	ldr	r0, [sp, #20]
    568c:	f001 fd38 	bl	7100 <osRtxThreadWaitExit>
        // Copy Message (R2: const void *msg_ptr, R3: uint8_t msg_prio)
        reg = osRtxThreadRegPtr(thread);
    5690:	9805      	ldr	r0, [sp, #20]
    5692:	f001 fc5f 	bl	6f54 <osRtxThreadRegPtr>
    5696:	9004      	str	r0, [sp, #16]
        //lint -e{923} "cast from unsigned int to pointer"
        ptr_src = (const void *)reg[2];
    5698:	9b04      	ldr	r3, [sp, #16]
    569a:	3308      	adds	r3, #8
    569c:	681b      	ldr	r3, [r3, #0]
    569e:	9303      	str	r3, [sp, #12]
        memcpy(&msg0[1], ptr_src, mq->msg_size);
    56a0:	9b06      	ldr	r3, [sp, #24]
    56a2:	f103 000c 	add.w	r0, r3, #12
    56a6:	9b07      	ldr	r3, [sp, #28]
    56a8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    56aa:	461a      	mov	r2, r3
    56ac:	9903      	ldr	r1, [sp, #12]
    56ae:	f7fb f937 	bl	920 <memcpy>
        // Store Message into Queue
        msg0->id       = osRtxIdMessage;
    56b2:	9b06      	ldr	r3, [sp, #24]
    56b4:	2207      	movs	r2, #7
    56b6:	701a      	strb	r2, [r3, #0]
        msg0->state    = osRtxObjectActive;
    56b8:	9b06      	ldr	r3, [sp, #24]
    56ba:	2201      	movs	r2, #1
    56bc:	705a      	strb	r2, [r3, #1]
        msg0->flags    = 0U;
    56be:	9b06      	ldr	r3, [sp, #24]
    56c0:	2200      	movs	r2, #0
    56c2:	709a      	strb	r2, [r3, #2]
        msg0->priority = (uint8_t)reg[3];
    56c4:	9b04      	ldr	r3, [sp, #16]
    56c6:	330c      	adds	r3, #12
    56c8:	681b      	ldr	r3, [r3, #0]
    56ca:	b2da      	uxtb	r2, r3
    56cc:	9b06      	ldr	r3, [sp, #24]
    56ce:	70da      	strb	r2, [r3, #3]
        MessageQueuePut(mq, msg0);
    56d0:	9906      	ldr	r1, [sp, #24]
    56d2:	9807      	ldr	r0, [sp, #28]
    56d4:	f7ff fefe 	bl	54d4 <MessageQueuePut>
        EvrRtxMessageQueueInserted(mq, ptr_src);
    56d8:	9903      	ldr	r1, [sp, #12]
    56da:	9807      	ldr	r0, [sp, #28]
    56dc:	f7ff f8a8 	bl	4830 <EvrRtxMessageQueueInserted>
    56e0:	e05c      	b.n	579c <osRtxMessageQueuePostProcess+0x192>
      }
    }
  } else {
    // New Message
    //lint -e{9079} -e{9087} "cast between pointers to different object types"
    mq = (void *)msg->next;
    56e2:	9b01      	ldr	r3, [sp, #4]
    56e4:	689b      	ldr	r3, [r3, #8]
    56e6:	9307      	str	r3, [sp, #28]
    if (mq->state == osRtxObjectInactive) {
    56e8:	9b07      	ldr	r3, [sp, #28]
    56ea:	785b      	ldrb	r3, [r3, #1]
    56ec:	2b00      	cmp	r3, #0
    56ee:	d054      	beq.n	579a <osRtxMessageQueuePostProcess+0x190>
      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
      return;
    }
    //lint -e{9087} "cast between pointers to different object types"
    ptr_src = (const void *)msg->prev;
    56f0:	9b01      	ldr	r3, [sp, #4]
    56f2:	685b      	ldr	r3, [r3, #4]
    56f4:	9303      	str	r3, [sp, #12]
    // Check if Thread is waiting to receive a Message
    if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessageGet)) {
    56f6:	9b07      	ldr	r3, [sp, #28]
    56f8:	689b      	ldr	r3, [r3, #8]
    56fa:	2b00      	cmp	r3, #0
    56fc:	d040      	beq.n	5780 <osRtxMessageQueuePostProcess+0x176>
    56fe:	9b07      	ldr	r3, [sp, #28]
    5700:	689b      	ldr	r3, [r3, #8]
    5702:	785b      	ldrb	r3, [r3, #1]
    5704:	2b83      	cmp	r3, #131	; 0x83
    5706:	d13b      	bne.n	5780 <osRtxMessageQueuePostProcess+0x176>
      EvrRtxMessageQueueInserted(mq, ptr_src);
    5708:	9903      	ldr	r1, [sp, #12]
    570a:	9807      	ldr	r0, [sp, #28]
    570c:	f7ff f890 	bl	4830 <EvrRtxMessageQueueInserted>
      // Wakeup waiting Thread with highest Priority
      thread = osRtxThreadListGet(osRtxObject(mq));
    5710:	9807      	ldr	r0, [sp, #28]
    5712:	f7ff fed2 	bl	54ba <osRtxObject>
    5716:	4603      	mov	r3, r0
    5718:	4618      	mov	r0, r3
    571a:	f001 fa51 	bl	6bc0 <osRtxThreadListGet>
    571e:	9005      	str	r0, [sp, #20]
      osRtxThreadWaitExit(thread, (uint32_t)osOK, FALSE);
    5720:	2200      	movs	r2, #0
    5722:	2100      	movs	r1, #0
    5724:	9805      	ldr	r0, [sp, #20]
    5726:	f001 fceb 	bl	7100 <osRtxThreadWaitExit>
      // Copy Message (R2: void *msg_ptr, R3: uint8_t *msg_prio)
      reg = osRtxThreadRegPtr(thread);
    572a:	9805      	ldr	r0, [sp, #20]
    572c:	f001 fc12 	bl	6f54 <osRtxThreadRegPtr>
    5730:	9004      	str	r0, [sp, #16]
      //lint -e{923} "cast from unsigned int to pointer"
      ptr_dst = (void *)reg[2];
    5732:	9b04      	ldr	r3, [sp, #16]
    5734:	3308      	adds	r3, #8
    5736:	681b      	ldr	r3, [r3, #0]
    5738:	9302      	str	r3, [sp, #8]
      memcpy(ptr_dst, &msg[1], mq->msg_size);
    573a:	9b01      	ldr	r3, [sp, #4]
    573c:	f103 010c 	add.w	r1, r3, #12
    5740:	9b07      	ldr	r3, [sp, #28]
    5742:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5744:	461a      	mov	r2, r3
    5746:	9802      	ldr	r0, [sp, #8]
    5748:	f7fb f8ea 	bl	920 <memcpy>
      if (reg[3] != 0U) {
    574c:	9b04      	ldr	r3, [sp, #16]
    574e:	330c      	adds	r3, #12
    5750:	681b      	ldr	r3, [r3, #0]
    5752:	2b00      	cmp	r3, #0
    5754:	d006      	beq.n	5764 <osRtxMessageQueuePostProcess+0x15a>
        //lint -e{923} -e{9078} "cast from unsigned int to pointer"
        *((uint8_t *)reg[3]) = msg->priority;
    5756:	9b04      	ldr	r3, [sp, #16]
    5758:	330c      	adds	r3, #12
    575a:	681b      	ldr	r3, [r3, #0]
    575c:	461a      	mov	r2, r3
    575e:	9b01      	ldr	r3, [sp, #4]
    5760:	78db      	ldrb	r3, [r3, #3]
    5762:	7013      	strb	r3, [r2, #0]
      }
      EvrRtxMessageQueueRetrieved(mq, ptr_dst);
    5764:	9902      	ldr	r1, [sp, #8]
    5766:	9807      	ldr	r0, [sp, #28]
    5768:	f7ff f882 	bl	4870 <EvrRtxMessageQueueRetrieved>
      // Free memory
      msg->state = osRtxObjectInactive;
    576c:	9b01      	ldr	r3, [sp, #4]
    576e:	2200      	movs	r2, #0
    5770:	705a      	strb	r2, [r3, #1]
      (void)osRtxMemoryPoolFree(&mq->mp_info, msg);
    5772:	9b07      	ldr	r3, [sp, #28]
    5774:	330c      	adds	r3, #12
    5776:	9901      	ldr	r1, [sp, #4]
    5778:	4618      	mov	r0, r3
    577a:	f7ff fdff 	bl	537c <osRtxMemoryPoolFree>
    577e:	e00d      	b.n	579c <osRtxMessageQueuePostProcess+0x192>
    } else {
      EvrRtxMessageQueueInserted(mq, ptr_src);
    5780:	9903      	ldr	r1, [sp, #12]
    5782:	9807      	ldr	r0, [sp, #28]
    5784:	f7ff f854 	bl	4830 <EvrRtxMessageQueueInserted>
      MessageQueuePut(mq, msg);
    5788:	9901      	ldr	r1, [sp, #4]
    578a:	9807      	ldr	r0, [sp, #28]
    578c:	f7ff fea2 	bl	54d4 <MessageQueuePut>
    5790:	e004      	b.n	579c <osRtxMessageQueuePostProcess+0x192>
    return;
    5792:	bf00      	nop
    5794:	e002      	b.n	579c <osRtxMessageQueuePostProcess+0x192>
      return;
    5796:	bf00      	nop
    5798:	e000      	b.n	579c <osRtxMessageQueuePostProcess+0x192>
      return;
    579a:	bf00      	nop
    }
  }
}
    579c:	b009      	add	sp, #36	; 0x24
    579e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000057a4 <svcRtxMessageQueueNew>:

//  ==== Service Calls ====

/// Create and Initialize a Message Queue object.
/// \note API identical to osMessageQueueNew
static osMessageQueueId_t svcRtxMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
    57a4:	b500      	push	{lr}
    57a6:	b08d      	sub	sp, #52	; 0x34
    57a8:	9003      	str	r0, [sp, #12]
    57aa:	9102      	str	r1, [sp, #8]
    57ac:	9201      	str	r2, [sp, #4]
  uint32_t            size;
  uint8_t             flags;
  const char         *name;

  // Check parameters
  if ((msg_count == 0U) || (msg_size  == 0U)) {
    57ae:	9b03      	ldr	r3, [sp, #12]
    57b0:	2b00      	cmp	r3, #0
    57b2:	d002      	beq.n	57ba <svcRtxMessageQueueNew+0x16>
    57b4:	9b02      	ldr	r3, [sp, #8]
    57b6:	2b00      	cmp	r3, #0
    57b8:	d106      	bne.n	57c8 <svcRtxMessageQueueNew+0x24>
    EvrRtxMessageQueueError(NULL, (int32_t)osErrorParameter);
    57ba:	f06f 0103 	mvn.w	r1, #3
    57be:	2000      	movs	r0, #0
    57c0:	f7fe fe88 	bl	44d4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return NULL;
    57c4:	2300      	movs	r3, #0
    57c6:	e0fd      	b.n	59c4 <svcRtxMessageQueueNew+0x220>
  }
  block_size = ((msg_size + 3U) & ~3UL) + sizeof(os_message_t);
    57c8:	9b02      	ldr	r3, [sp, #8]
    57ca:	3303      	adds	r3, #3
    57cc:	f023 0303 	bic.w	r3, r3, #3
    57d0:	330c      	adds	r3, #12
    57d2:	9307      	str	r3, [sp, #28]
  if ((__CLZ(msg_count) + __CLZ(block_size)) < 32U) {
    57d4:	9b03      	ldr	r3, [sp, #12]
    57d6:	fab3 f383 	clz	r3, r3
    57da:	b2db      	uxtb	r3, r3
    57dc:	461a      	mov	r2, r3
    57de:	9b07      	ldr	r3, [sp, #28]
    57e0:	fab3 f383 	clz	r3, r3
    57e4:	b2db      	uxtb	r3, r3
    57e6:	4413      	add	r3, r2
    57e8:	2b1f      	cmp	r3, #31
    57ea:	d806      	bhi.n	57fa <svcRtxMessageQueueNew+0x56>
    EvrRtxMessageQueueError(NULL, (int32_t)osErrorParameter);
    57ec:	f06f 0103 	mvn.w	r1, #3
    57f0:	2000      	movs	r0, #0
    57f2:	f7fe fe6f 	bl	44d4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return NULL;
    57f6:	2300      	movs	r3, #0
    57f8:	e0e4      	b.n	59c4 <svcRtxMessageQueueNew+0x220>
  }

  size = msg_count * block_size;
    57fa:	9b03      	ldr	r3, [sp, #12]
    57fc:	9a07      	ldr	r2, [sp, #28]
    57fe:	fb02 f303 	mul.w	r3, r2, r3
    5802:	9306      	str	r3, [sp, #24]

  // Process attributes
  if (attr != NULL) {
    5804:	9b01      	ldr	r3, [sp, #4]
    5806:	2b00      	cmp	r3, #0
    5808:	d046      	beq.n	5898 <svcRtxMessageQueueNew+0xf4>
    name    = attr->name;
    580a:	9b01      	ldr	r3, [sp, #4]
    580c:	681b      	ldr	r3, [r3, #0]
    580e:	9308      	str	r3, [sp, #32]
    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
    mq      = attr->cb_mem;
    5810:	9b01      	ldr	r3, [sp, #4]
    5812:	689b      	ldr	r3, [r3, #8]
    5814:	930b      	str	r3, [sp, #44]	; 0x2c
    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
    mq_mem  = attr->mq_mem;
    5816:	9b01      	ldr	r3, [sp, #4]
    5818:	691b      	ldr	r3, [r3, #16]
    581a:	930a      	str	r3, [sp, #40]	; 0x28
    mq_size = attr->mq_size;
    581c:	9b01      	ldr	r3, [sp, #4]
    581e:	695b      	ldr	r3, [r3, #20]
    5820:	9305      	str	r3, [sp, #20]
    if (mq != NULL) {
    5822:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5824:	2b00      	cmp	r3, #0
    5826:	d00f      	beq.n	5848 <svcRtxMessageQueueNew+0xa4>
      //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
      if ((((uint32_t)mq & 3U) != 0U) || (attr->cb_size < sizeof(os_message_queue_t))) {
    5828:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    582a:	f003 0303 	and.w	r3, r3, #3
    582e:	2b00      	cmp	r3, #0
    5830:	d103      	bne.n	583a <svcRtxMessageQueueNew+0x96>
    5832:	9b01      	ldr	r3, [sp, #4]
    5834:	68db      	ldr	r3, [r3, #12]
    5836:	2b33      	cmp	r3, #51	; 0x33
    5838:	d811      	bhi.n	585e <svcRtxMessageQueueNew+0xba>
        EvrRtxMessageQueueError(NULL, osRtxErrorInvalidControlBlock);
    583a:	f06f 0108 	mvn.w	r1, #8
    583e:	2000      	movs	r0, #0
    5840:	f7fe fe48 	bl	44d4 <EvrRtxMessageQueueError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    5844:	2300      	movs	r3, #0
    5846:	e0bd      	b.n	59c4 <svcRtxMessageQueueNew+0x220>
      }
    } else {
      if (attr->cb_size != 0U) {
    5848:	9b01      	ldr	r3, [sp, #4]
    584a:	68db      	ldr	r3, [r3, #12]
    584c:	2b00      	cmp	r3, #0
    584e:	d006      	beq.n	585e <svcRtxMessageQueueNew+0xba>
        EvrRtxMessageQueueError(NULL, osRtxErrorInvalidControlBlock);
    5850:	f06f 0108 	mvn.w	r1, #8
    5854:	2000      	movs	r0, #0
    5856:	f7fe fe3d 	bl	44d4 <EvrRtxMessageQueueError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    585a:	2300      	movs	r3, #0
    585c:	e0b2      	b.n	59c4 <svcRtxMessageQueueNew+0x220>
      }
    }
    if (mq_mem != NULL) {
    585e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5860:	2b00      	cmp	r3, #0
    5862:	d00f      	beq.n	5884 <svcRtxMessageQueueNew+0xe0>
      //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
      if ((((uint32_t)mq_mem & 3U) != 0U) || (mq_size < size)) {
    5864:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5866:	f003 0303 	and.w	r3, r3, #3
    586a:	2b00      	cmp	r3, #0
    586c:	d103      	bne.n	5876 <svcRtxMessageQueueNew+0xd2>
    586e:	9a05      	ldr	r2, [sp, #20]
    5870:	9b06      	ldr	r3, [sp, #24]
    5872:	429a      	cmp	r2, r3
    5874:	d216      	bcs.n	58a4 <svcRtxMessageQueueNew+0x100>
        EvrRtxMessageQueueError(NULL, osRtxErrorInvalidDataMemory);
    5876:	f06f 0109 	mvn.w	r1, #9
    587a:	2000      	movs	r0, #0
    587c:	f7fe fe2a 	bl	44d4 <EvrRtxMessageQueueError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    5880:	2300      	movs	r3, #0
    5882:	e09f      	b.n	59c4 <svcRtxMessageQueueNew+0x220>
      }
    } else {
      if (mq_size != 0U) {
    5884:	9b05      	ldr	r3, [sp, #20]
    5886:	2b00      	cmp	r3, #0
    5888:	d00c      	beq.n	58a4 <svcRtxMessageQueueNew+0x100>
        EvrRtxMessageQueueError(NULL, osRtxErrorInvalidDataMemory);
    588a:	f06f 0109 	mvn.w	r1, #9
    588e:	2000      	movs	r0, #0
    5890:	f7fe fe20 	bl	44d4 <EvrRtxMessageQueueError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    5894:	2300      	movs	r3, #0
    5896:	e095      	b.n	59c4 <svcRtxMessageQueueNew+0x220>
      }
    }
  } else {
    name   = NULL;
    5898:	2300      	movs	r3, #0
    589a:	9308      	str	r3, [sp, #32]
    mq     = NULL;
    589c:	2300      	movs	r3, #0
    589e:	930b      	str	r3, [sp, #44]	; 0x2c
    mq_mem = NULL;
    58a0:	2300      	movs	r3, #0
    58a2:	930a      	str	r3, [sp, #40]	; 0x28
  }

  // Allocate object memory if not provided
  if (mq == NULL) {
    58a4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    58a6:	2b00      	cmp	r3, #0
    58a8:	d119      	bne.n	58de <svcRtxMessageQueueNew+0x13a>
    if (osRtxInfo.mpi.message_queue != NULL) {
    58aa:	4b48      	ldr	r3, [pc, #288]	; (59cc <svcRtxMessageQueueNew+0x228>)
    58ac:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    58b0:	2b00      	cmp	r3, #0
    58b2:	d007      	beq.n	58c4 <svcRtxMessageQueueNew+0x120>
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      mq = osRtxMemoryPoolAlloc(osRtxInfo.mpi.message_queue);
    58b4:	4b45      	ldr	r3, [pc, #276]	; (59cc <svcRtxMessageQueueNew+0x228>)
    58b6:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    58ba:	4618      	mov	r0, r3
    58bc:	f7ff fd33 	bl	5326 <osRtxMemoryPoolAlloc>
    58c0:	900b      	str	r0, [sp, #44]	; 0x2c
    58c2:	e008      	b.n	58d6 <svcRtxMessageQueueNew+0x132>
    } else {
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      mq = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_message_queue_t), 1U);
    58c4:	4b41      	ldr	r3, [pc, #260]	; (59cc <svcRtxMessageQueueNew+0x228>)
    58c6:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    58ca:	2201      	movs	r2, #1
    58cc:	2134      	movs	r1, #52	; 0x34
    58ce:	4618      	mov	r0, r3
    58d0:	f7ff fb91 	bl	4ff6 <osRtxMemoryAlloc>
    58d4:	900b      	str	r0, [sp, #44]	; 0x2c
      if (osRtxMessageQueueMemUsage.max_used < used) {
        osRtxMessageQueueMemUsage.max_used = used;
      }
    }
#endif
    flags = osRtxFlagSystemObject;
    58d6:	2301      	movs	r3, #1
    58d8:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    58dc:	e002      	b.n	58e4 <svcRtxMessageQueueNew+0x140>
  } else {
    flags = 0U;
    58de:	2300      	movs	r3, #0
    58e0:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
  }

  // Allocate data memory if not provided
  if ((mq != NULL) && (mq_mem == NULL)) {
    58e4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    58e6:	2b00      	cmp	r3, #0
    58e8:	d035      	beq.n	5956 <svcRtxMessageQueueNew+0x1b2>
    58ea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    58ec:	2b00      	cmp	r3, #0
    58ee:	d132      	bne.n	5956 <svcRtxMessageQueueNew+0x1b2>
    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
    mq_mem = osRtxMemoryAlloc(osRtxInfo.mem.mq_data, size, 0U);
    58f0:	4b36      	ldr	r3, [pc, #216]	; (59cc <svcRtxMessageQueueNew+0x228>)
    58f2:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    58f4:	2200      	movs	r2, #0
    58f6:	9906      	ldr	r1, [sp, #24]
    58f8:	4618      	mov	r0, r3
    58fa:	f7ff fb7c 	bl	4ff6 <osRtxMemoryAlloc>
    58fe:	900a      	str	r0, [sp, #40]	; 0x28
    if (mq_mem == NULL) {
    5900:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5902:	2b00      	cmp	r3, #0
    5904:	d11c      	bne.n	5940 <svcRtxMessageQueueNew+0x19c>
      if ((flags & osRtxFlagSystemObject) != 0U) {
    5906:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    590a:	f003 0301 	and.w	r3, r3, #1
    590e:	2b00      	cmp	r3, #0
    5910:	d013      	beq.n	593a <svcRtxMessageQueueNew+0x196>
        if (osRtxInfo.mpi.message_queue != NULL) {
    5912:	4b2e      	ldr	r3, [pc, #184]	; (59cc <svcRtxMessageQueueNew+0x228>)
    5914:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    5918:	2b00      	cmp	r3, #0
    591a:	d007      	beq.n	592c <svcRtxMessageQueueNew+0x188>
          (void)osRtxMemoryPoolFree(osRtxInfo.mpi.message_queue, mq);
    591c:	4b2b      	ldr	r3, [pc, #172]	; (59cc <svcRtxMessageQueueNew+0x228>)
    591e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    5922:	990b      	ldr	r1, [sp, #44]	; 0x2c
    5924:	4618      	mov	r0, r3
    5926:	f7ff fd29 	bl	537c <osRtxMemoryPoolFree>
    592a:	e006      	b.n	593a <svcRtxMessageQueueNew+0x196>
        } else {
          (void)osRtxMemoryFree(osRtxInfo.mem.common, mq);
    592c:	4b27      	ldr	r3, [pc, #156]	; (59cc <svcRtxMessageQueueNew+0x228>)
    592e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    5932:	990b      	ldr	r1, [sp, #44]	; 0x2c
    5934:	4618      	mov	r0, r3
    5936:	f7ff fbfa 	bl	512e <osRtxMemoryFree>
        }
#if (defined(OS_OBJ_MEM_USAGE) && (OS_OBJ_MEM_USAGE != 0))
        osRtxMessageQueueMemUsage.cnt_free++;
#endif
      }
      mq = NULL;
    593a:	2300      	movs	r3, #0
    593c:	930b      	str	r3, [sp, #44]	; 0x2c
    593e:	e004      	b.n	594a <svcRtxMessageQueueNew+0x1a6>
    } else {
      memset(mq_mem, 0, size);
    5940:	9a06      	ldr	r2, [sp, #24]
    5942:	2100      	movs	r1, #0
    5944:	980a      	ldr	r0, [sp, #40]	; 0x28
    5946:	f005 fd9d 	bl	b484 <memset>
    }
    flags |= osRtxFlagSystemMemory;
    594a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    594e:	f043 0302 	orr.w	r3, r3, #2
    5952:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
  }

  if (mq != NULL) {
    5956:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5958:	2b00      	cmp	r3, #0
    595a:	d02d      	beq.n	59b8 <svcRtxMessageQueueNew+0x214>
    // Initialize control block
    mq->id          = osRtxIdMessageQueue;
    595c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    595e:	2208      	movs	r2, #8
    5960:	701a      	strb	r2, [r3, #0]
    mq->state       = osRtxObjectActive;
    5962:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5964:	2201      	movs	r2, #1
    5966:	705a      	strb	r2, [r3, #1]
    mq->flags       = flags;
    5968:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    596a:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
    596e:	709a      	strb	r2, [r3, #2]
    mq->name        = name;
    5970:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5972:	9a08      	ldr	r2, [sp, #32]
    5974:	605a      	str	r2, [r3, #4]
    mq->thread_list = NULL;
    5976:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5978:	2200      	movs	r2, #0
    597a:	609a      	str	r2, [r3, #8]
    mq->msg_size    = msg_size;
    597c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    597e:	9a02      	ldr	r2, [sp, #8]
    5980:	625a      	str	r2, [r3, #36]	; 0x24
    mq->msg_count   = 0U;
    5982:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5984:	2200      	movs	r2, #0
    5986:	629a      	str	r2, [r3, #40]	; 0x28
    mq->msg_first   = NULL;
    5988:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    598a:	2200      	movs	r2, #0
    598c:	62da      	str	r2, [r3, #44]	; 0x2c
    mq->msg_last    = NULL;
    598e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5990:	2200      	movs	r2, #0
    5992:	631a      	str	r2, [r3, #48]	; 0x30
    (void)osRtxMemoryPoolInit(&mq->mp_info, msg_count, block_size, mq_mem);
    5994:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5996:	f103 000c 	add.w	r0, r3, #12
    599a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    599c:	9a07      	ldr	r2, [sp, #28]
    599e:	9903      	ldr	r1, [sp, #12]
    59a0:	f7ff fc76 	bl	5290 <osRtxMemoryPoolInit>

    // Register post ISR processing function
    osRtxInfo.post_process.message = osRtxMessageQueuePostProcess;
    59a4:	4b09      	ldr	r3, [pc, #36]	; (59cc <svcRtxMessageQueueNew+0x228>)
    59a6:	4a0a      	ldr	r2, [pc, #40]	; (59d0 <svcRtxMessageQueueNew+0x22c>)
    59a8:	671a      	str	r2, [r3, #112]	; 0x70

    EvrRtxMessageQueueCreated(mq, mq->name);
    59aa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    59ac:	685b      	ldr	r3, [r3, #4]
    59ae:	4619      	mov	r1, r3
    59b0:	980b      	ldr	r0, [sp, #44]	; 0x2c
    59b2:	f7fe ff1b 	bl	47ec <EvrRtxMessageQueueCreated>
    59b6:	e004      	b.n	59c2 <svcRtxMessageQueueNew+0x21e>
  } else {
    EvrRtxMessageQueueError(NULL, (int32_t)osErrorNoMemory);
    59b8:	f06f 0104 	mvn.w	r1, #4
    59bc:	2000      	movs	r0, #0
    59be:	f7fe fd89 	bl	44d4 <EvrRtxMessageQueueError>
  }

  return mq;
    59c2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
}
    59c4:	4618      	mov	r0, r3
    59c6:	b00d      	add	sp, #52	; 0x34
    59c8:	f85d fb04 	ldr.w	pc, [sp], #4
    59cc:	20000110 	.word	0x20000110
    59d0:	0000560b 	.word	0x0000560b

000059d4 <svcRtxMessageQueuePut>:
  return mq->name;
}

/// Put a Message into a Queue or timeout if Queue is full.
/// \note API identical to osMessageQueuePut
static osStatus_t svcRtxMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
    59d4:	b510      	push	{r4, lr}
    59d6:	b08a      	sub	sp, #40	; 0x28
    59d8:	9003      	str	r0, [sp, #12]
    59da:	9102      	str	r1, [sp, #8]
    59dc:	9300      	str	r3, [sp, #0]
    59de:	4613      	mov	r3, r2
    59e0:	f88d 3007 	strb.w	r3, [sp, #7]
  os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
    59e4:	9803      	ldr	r0, [sp, #12]
    59e6:	f7ff fd62 	bl	54ae <osRtxMessageQueueId>
    59ea:	9008      	str	r0, [sp, #32]
  uint32_t           *reg;
  void               *ptr;
  osStatus_t          status;

  // Check parameters
  if ((mq == NULL) || (mq->id != osRtxIdMessageQueue) || (msg_ptr == NULL)) {
    59ec:	9b08      	ldr	r3, [sp, #32]
    59ee:	2b00      	cmp	r3, #0
    59f0:	d006      	beq.n	5a00 <svcRtxMessageQueuePut+0x2c>
    59f2:	9b08      	ldr	r3, [sp, #32]
    59f4:	781b      	ldrb	r3, [r3, #0]
    59f6:	2b08      	cmp	r3, #8
    59f8:	d102      	bne.n	5a00 <svcRtxMessageQueuePut+0x2c>
    59fa:	9b02      	ldr	r3, [sp, #8]
    59fc:	2b00      	cmp	r3, #0
    59fe:	d107      	bne.n	5a10 <svcRtxMessageQueuePut+0x3c>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorParameter);
    5a00:	f06f 0103 	mvn.w	r1, #3
    5a04:	9808      	ldr	r0, [sp, #32]
    5a06:	f7fe fd65 	bl	44d4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorParameter;
    5a0a:	f06f 0303 	mvn.w	r3, #3
    5a0e:	e0a9      	b.n	5b64 <svcRtxMessageQueuePut+0x190>
  }

  // Check object state
  if (mq->state == osRtxObjectInactive) {
    5a10:	9b08      	ldr	r3, [sp, #32]
    5a12:	785b      	ldrb	r3, [r3, #1]
    5a14:	2b00      	cmp	r3, #0
    5a16:	d107      	bne.n	5a28 <svcRtxMessageQueuePut+0x54>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorResource);
    5a18:	f06f 0102 	mvn.w	r1, #2
    5a1c:	9808      	ldr	r0, [sp, #32]
    5a1e:	f7fe fd59 	bl	44d4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    5a22:	f06f 0302 	mvn.w	r3, #2
    5a26:	e09d      	b.n	5b64 <svcRtxMessageQueuePut+0x190>
  }

  // Check if Thread is waiting to receive a Message
  if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessageGet)) {
    5a28:	9b08      	ldr	r3, [sp, #32]
    5a2a:	689b      	ldr	r3, [r3, #8]
    5a2c:	2b00      	cmp	r3, #0
    5a2e:	d037      	beq.n	5aa0 <svcRtxMessageQueuePut+0xcc>
    5a30:	9b08      	ldr	r3, [sp, #32]
    5a32:	689b      	ldr	r3, [r3, #8]
    5a34:	785b      	ldrb	r3, [r3, #1]
    5a36:	2b83      	cmp	r3, #131	; 0x83
    5a38:	d132      	bne.n	5aa0 <svcRtxMessageQueuePut+0xcc>
    EvrRtxMessageQueueInserted(mq, msg_ptr);
    5a3a:	9902      	ldr	r1, [sp, #8]
    5a3c:	9808      	ldr	r0, [sp, #32]
    5a3e:	f7fe fef7 	bl	4830 <EvrRtxMessageQueueInserted>
    // Wakeup waiting Thread with highest Priority
    thread = osRtxThreadListGet(osRtxObject(mq));
    5a42:	9808      	ldr	r0, [sp, #32]
    5a44:	f7ff fd39 	bl	54ba <osRtxObject>
    5a48:	4603      	mov	r3, r0
    5a4a:	4618      	mov	r0, r3
    5a4c:	f001 f8b8 	bl	6bc0 <osRtxThreadListGet>
    5a50:	9007      	str	r0, [sp, #28]
    osRtxThreadWaitExit(thread, (uint32_t)osOK, TRUE);
    5a52:	2201      	movs	r2, #1
    5a54:	2100      	movs	r1, #0
    5a56:	9807      	ldr	r0, [sp, #28]
    5a58:	f001 fb52 	bl	7100 <osRtxThreadWaitExit>
    // Copy Message (R2: void *msg_ptr, R3: uint8_t *msg_prio)
    reg = osRtxThreadRegPtr(thread);
    5a5c:	9807      	ldr	r0, [sp, #28]
    5a5e:	f001 fa79 	bl	6f54 <osRtxThreadRegPtr>
    5a62:	9006      	str	r0, [sp, #24]
    //lint -e{923} "cast from unsigned int to pointer"
    ptr = (void *)reg[2];
    5a64:	9b06      	ldr	r3, [sp, #24]
    5a66:	3308      	adds	r3, #8
    5a68:	681b      	ldr	r3, [r3, #0]
    5a6a:	9305      	str	r3, [sp, #20]
    memcpy(ptr, msg_ptr, mq->msg_size);
    5a6c:	9b08      	ldr	r3, [sp, #32]
    5a6e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5a70:	461a      	mov	r2, r3
    5a72:	9902      	ldr	r1, [sp, #8]
    5a74:	9805      	ldr	r0, [sp, #20]
    5a76:	f7fa ff53 	bl	920 <memcpy>
    if (reg[3] != 0U) {
    5a7a:	9b06      	ldr	r3, [sp, #24]
    5a7c:	330c      	adds	r3, #12
    5a7e:	681b      	ldr	r3, [r3, #0]
    5a80:	2b00      	cmp	r3, #0
    5a82:	d006      	beq.n	5a92 <svcRtxMessageQueuePut+0xbe>
      //lint -e{923} -e{9078} "cast from unsigned int to pointer"
      *((uint8_t *)reg[3]) = msg_prio;
    5a84:	9b06      	ldr	r3, [sp, #24]
    5a86:	330c      	adds	r3, #12
    5a88:	681b      	ldr	r3, [r3, #0]
    5a8a:	461a      	mov	r2, r3
    5a8c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5a90:	7013      	strb	r3, [r2, #0]
    }
    EvrRtxMessageQueueRetrieved(mq, ptr);
    5a92:	9905      	ldr	r1, [sp, #20]
    5a94:	9808      	ldr	r0, [sp, #32]
    5a96:	f7fe feeb 	bl	4870 <EvrRtxMessageQueueRetrieved>
    status = osOK;
    5a9a:	2300      	movs	r3, #0
    5a9c:	9309      	str	r3, [sp, #36]	; 0x24
    5a9e:	e060      	b.n	5b62 <svcRtxMessageQueuePut+0x18e>
  } else {
    // Try to allocate memory
    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
    msg = osRtxMemoryPoolAlloc(&mq->mp_info);
    5aa0:	9b08      	ldr	r3, [sp, #32]
    5aa2:	330c      	adds	r3, #12
    5aa4:	4618      	mov	r0, r3
    5aa6:	f7ff fc3e 	bl	5326 <osRtxMemoryPoolAlloc>
    5aaa:	9004      	str	r0, [sp, #16]
    if (msg != NULL) {
    5aac:	9b04      	ldr	r3, [sp, #16]
    5aae:	2b00      	cmp	r3, #0
    5ab0:	d020      	beq.n	5af4 <svcRtxMessageQueuePut+0x120>
      // Copy Message
      memcpy(&msg[1], msg_ptr, mq->msg_size);
    5ab2:	9b04      	ldr	r3, [sp, #16]
    5ab4:	f103 000c 	add.w	r0, r3, #12
    5ab8:	9b08      	ldr	r3, [sp, #32]
    5aba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5abc:	461a      	mov	r2, r3
    5abe:	9902      	ldr	r1, [sp, #8]
    5ac0:	f7fa ff2e 	bl	920 <memcpy>
      // Put Message into Queue
      msg->id       = osRtxIdMessage;
    5ac4:	9b04      	ldr	r3, [sp, #16]
    5ac6:	2207      	movs	r2, #7
    5ac8:	701a      	strb	r2, [r3, #0]
      msg->state    = osRtxObjectActive;
    5aca:	9b04      	ldr	r3, [sp, #16]
    5acc:	2201      	movs	r2, #1
    5ace:	705a      	strb	r2, [r3, #1]
      msg->flags    = 0U;
    5ad0:	9b04      	ldr	r3, [sp, #16]
    5ad2:	2200      	movs	r2, #0
    5ad4:	709a      	strb	r2, [r3, #2]
      msg->priority = msg_prio;
    5ad6:	9b04      	ldr	r3, [sp, #16]
    5ad8:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5adc:	70da      	strb	r2, [r3, #3]
      MessageQueuePut(mq, msg);
    5ade:	9904      	ldr	r1, [sp, #16]
    5ae0:	9808      	ldr	r0, [sp, #32]
    5ae2:	f7ff fcf7 	bl	54d4 <MessageQueuePut>
      EvrRtxMessageQueueInserted(mq, msg_ptr);
    5ae6:	9902      	ldr	r1, [sp, #8]
    5ae8:	9808      	ldr	r0, [sp, #32]
    5aea:	f7fe fea1 	bl	4830 <EvrRtxMessageQueueInserted>
      status = osOK;
    5aee:	2300      	movs	r3, #0
    5af0:	9309      	str	r3, [sp, #36]	; 0x24
    5af2:	e036      	b.n	5b62 <svcRtxMessageQueuePut+0x18e>
    } else {
      // No memory available
      if (timeout != 0U) {
    5af4:	9b00      	ldr	r3, [sp, #0]
    5af6:	2b00      	cmp	r3, #0
    5af8:	d02c      	beq.n	5b54 <svcRtxMessageQueuePut+0x180>
        EvrRtxMessageQueuePutPending(mq, msg_ptr, timeout);
    5afa:	9a00      	ldr	r2, [sp, #0]
    5afc:	9902      	ldr	r1, [sp, #8]
    5afe:	9808      	ldr	r0, [sp, #32]
    5b00:	f7fe fe84 	bl	480c <EvrRtxMessageQueuePutPending>
        // Suspend current Thread
        if (osRtxThreadWaitEnter(osRtxThreadWaitingMessagePut, timeout)) {
    5b04:	9900      	ldr	r1, [sp, #0]
    5b06:	2093      	movs	r0, #147	; 0x93
    5b08:	f001 fb1e 	bl	7148 <osRtxThreadWaitEnter>
    5b0c:	4603      	mov	r3, r0
    5b0e:	2b00      	cmp	r3, #0
    5b10:	d019      	beq.n	5b46 <svcRtxMessageQueuePut+0x172>
          osRtxThreadListPut(osRtxObject(mq), osRtxThreadGetRunning());
    5b12:	9808      	ldr	r0, [sp, #32]
    5b14:	f7ff fcd1 	bl	54ba <osRtxObject>
    5b18:	4604      	mov	r4, r0
    5b1a:	f7ff fcd5 	bl	54c8 <osRtxThreadGetRunning>
    5b1e:	4603      	mov	r3, r0
    5b20:	4619      	mov	r1, r3
    5b22:	4620      	mov	r0, r4
    5b24:	f001 f816 	bl	6b54 <osRtxThreadListPut>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
    5b28:	f3ef 8309 	mrs	r3, PSP
    5b2c:	461c      	mov	r4, r3
  return(result);
    5b2e:	4623      	mov	r3, r4
          // Save arguments (R2: const void *msg_ptr, R3: uint8_t msg_prio)
          //lint -e{923} -e{9078} "cast from unsigned int to pointer"
          reg = (uint32_t *)(__get_PSP());
    5b30:	9306      	str	r3, [sp, #24]
          //lint -e{923} -e{9078} "cast from pointer to unsigned int"
          reg[2] = (uint32_t)msg_ptr;
    5b32:	9b06      	ldr	r3, [sp, #24]
    5b34:	3308      	adds	r3, #8
    5b36:	9a02      	ldr	r2, [sp, #8]
    5b38:	601a      	str	r2, [r3, #0]
          //lint -e{923} -e{9078} "cast from pointer to unsigned int"
          reg[3] = (uint32_t)msg_prio;
    5b3a:	9b06      	ldr	r3, [sp, #24]
    5b3c:	330c      	adds	r3, #12
    5b3e:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5b42:	601a      	str	r2, [r3, #0]
    5b44:	e002      	b.n	5b4c <svcRtxMessageQueuePut+0x178>
        } else {
          EvrRtxMessageQueuePutTimeout(mq);
    5b46:	9808      	ldr	r0, [sp, #32]
    5b48:	f7fe fe67 	bl	481a <EvrRtxMessageQueuePutTimeout>
        }
        status = osErrorTimeout;
    5b4c:	f06f 0301 	mvn.w	r3, #1
    5b50:	9309      	str	r3, [sp, #36]	; 0x24
    5b52:	e006      	b.n	5b62 <svcRtxMessageQueuePut+0x18e>
      } else {
        EvrRtxMessageQueueNotInserted(mq, msg_ptr);
    5b54:	9902      	ldr	r1, [sp, #8]
    5b56:	9808      	ldr	r0, [sp, #32]
    5b58:	f7fe fe70 	bl	483c <EvrRtxMessageQueueNotInserted>
        status = osErrorResource;
    5b5c:	f06f 0302 	mvn.w	r3, #2
    5b60:	9309      	str	r3, [sp, #36]	; 0x24
      }
    }
  }

  return status;
    5b62:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    5b64:	4618      	mov	r0, r3
    5b66:	b00a      	add	sp, #40	; 0x28
    5b68:	bd10      	pop	{r4, pc}

00005b6a <svcRtxMessageQueueGet>:

/// Get a Message from a Queue or timeout if Queue is empty.
/// \note API identical to osMessageQueueGet
static osStatus_t svcRtxMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
    5b6a:	b510      	push	{r4, lr}
    5b6c:	b08a      	sub	sp, #40	; 0x28
    5b6e:	9003      	str	r0, [sp, #12]
    5b70:	9102      	str	r1, [sp, #8]
    5b72:	9201      	str	r2, [sp, #4]
    5b74:	9300      	str	r3, [sp, #0]
  os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
    5b76:	9803      	ldr	r0, [sp, #12]
    5b78:	f7ff fc99 	bl	54ae <osRtxMessageQueueId>
    5b7c:	9008      	str	r0, [sp, #32]
  uint32_t           *reg;
  const void         *ptr;
  osStatus_t          status;

  // Check parameters
  if ((mq == NULL) || (mq->id != osRtxIdMessageQueue) || (msg_ptr == NULL)) {
    5b7e:	9b08      	ldr	r3, [sp, #32]
    5b80:	2b00      	cmp	r3, #0
    5b82:	d006      	beq.n	5b92 <svcRtxMessageQueueGet+0x28>
    5b84:	9b08      	ldr	r3, [sp, #32]
    5b86:	781b      	ldrb	r3, [r3, #0]
    5b88:	2b08      	cmp	r3, #8
    5b8a:	d102      	bne.n	5b92 <svcRtxMessageQueueGet+0x28>
    5b8c:	9b02      	ldr	r3, [sp, #8]
    5b8e:	2b00      	cmp	r3, #0
    5b90:	d107      	bne.n	5ba2 <svcRtxMessageQueueGet+0x38>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorParameter);
    5b92:	f06f 0103 	mvn.w	r1, #3
    5b96:	9808      	ldr	r0, [sp, #32]
    5b98:	f7fe fc9c 	bl	44d4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorParameter;
    5b9c:	f06f 0303 	mvn.w	r3, #3
    5ba0:	e0b4      	b.n	5d0c <svcRtxMessageQueueGet+0x1a2>
  }

  // Check object state
  if (mq->state == osRtxObjectInactive) {
    5ba2:	9b08      	ldr	r3, [sp, #32]
    5ba4:	785b      	ldrb	r3, [r3, #1]
    5ba6:	2b00      	cmp	r3, #0
    5ba8:	d107      	bne.n	5bba <svcRtxMessageQueueGet+0x50>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorResource);
    5baa:	f06f 0102 	mvn.w	r1, #2
    5bae:	9808      	ldr	r0, [sp, #32]
    5bb0:	f7fe fc90 	bl	44d4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    5bb4:	f06f 0302 	mvn.w	r3, #2
    5bb8:	e0a8      	b.n	5d0c <svcRtxMessageQueueGet+0x1a2>
  }

  // Get Message from Queue
  msg = MessageQueueGet(mq);
    5bba:	9808      	ldr	r0, [sp, #32]
    5bbc:	f7ff fcd6 	bl	556c <MessageQueueGet>
    5bc0:	9007      	str	r0, [sp, #28]
  if (msg != NULL) {
    5bc2:	9b07      	ldr	r3, [sp, #28]
    5bc4:	2b00      	cmp	r3, #0
    5bc6:	d06a      	beq.n	5c9e <svcRtxMessageQueueGet+0x134>
    MessageQueueRemove(mq, msg);
    5bc8:	9907      	ldr	r1, [sp, #28]
    5bca:	9808      	ldr	r0, [sp, #32]
    5bcc:	f7ff fcfb 	bl	55c6 <MessageQueueRemove>
    // Copy Message
    memcpy(msg_ptr, &msg[1], mq->msg_size);
    5bd0:	9b07      	ldr	r3, [sp, #28]
    5bd2:	f103 010c 	add.w	r1, r3, #12
    5bd6:	9b08      	ldr	r3, [sp, #32]
    5bd8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5bda:	461a      	mov	r2, r3
    5bdc:	9802      	ldr	r0, [sp, #8]
    5bde:	f7fa fe9f 	bl	920 <memcpy>
    if (msg_prio != NULL) {
    5be2:	9b01      	ldr	r3, [sp, #4]
    5be4:	2b00      	cmp	r3, #0
    5be6:	d003      	beq.n	5bf0 <svcRtxMessageQueueGet+0x86>
      *msg_prio = msg->priority;
    5be8:	9b07      	ldr	r3, [sp, #28]
    5bea:	78da      	ldrb	r2, [r3, #3]
    5bec:	9b01      	ldr	r3, [sp, #4]
    5bee:	701a      	strb	r2, [r3, #0]
    }
    EvrRtxMessageQueueRetrieved(mq, msg_ptr);
    5bf0:	9902      	ldr	r1, [sp, #8]
    5bf2:	9808      	ldr	r0, [sp, #32]
    5bf4:	f7fe fe3c 	bl	4870 <EvrRtxMessageQueueRetrieved>
    // Free memory
    msg->state = osRtxObjectInactive;
    5bf8:	9b07      	ldr	r3, [sp, #28]
    5bfa:	2200      	movs	r2, #0
    5bfc:	705a      	strb	r2, [r3, #1]
    (void)osRtxMemoryPoolFree(&mq->mp_info, msg);
    5bfe:	9b08      	ldr	r3, [sp, #32]
    5c00:	330c      	adds	r3, #12
    5c02:	9907      	ldr	r1, [sp, #28]
    5c04:	4618      	mov	r0, r3
    5c06:	f7ff fbb9 	bl	537c <osRtxMemoryPoolFree>
    // Check if Thread is waiting to send a Message
    if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessagePut)) {
    5c0a:	9b08      	ldr	r3, [sp, #32]
    5c0c:	689b      	ldr	r3, [r3, #8]
    5c0e:	2b00      	cmp	r3, #0
    5c10:	d042      	beq.n	5c98 <svcRtxMessageQueueGet+0x12e>
    5c12:	9b08      	ldr	r3, [sp, #32]
    5c14:	689b      	ldr	r3, [r3, #8]
    5c16:	785b      	ldrb	r3, [r3, #1]
    5c18:	2b93      	cmp	r3, #147	; 0x93
    5c1a:	d13d      	bne.n	5c98 <svcRtxMessageQueueGet+0x12e>
      // Try to allocate memory
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      msg = osRtxMemoryPoolAlloc(&mq->mp_info);
    5c1c:	9b08      	ldr	r3, [sp, #32]
    5c1e:	330c      	adds	r3, #12
    5c20:	4618      	mov	r0, r3
    5c22:	f7ff fb80 	bl	5326 <osRtxMemoryPoolAlloc>
    5c26:	9007      	str	r0, [sp, #28]
      if (msg != NULL) {
    5c28:	9b07      	ldr	r3, [sp, #28]
    5c2a:	2b00      	cmp	r3, #0
    5c2c:	d034      	beq.n	5c98 <svcRtxMessageQueueGet+0x12e>
        // Wakeup waiting Thread with highest Priority
        thread = osRtxThreadListGet(osRtxObject(mq));
    5c2e:	9808      	ldr	r0, [sp, #32]
    5c30:	f7ff fc43 	bl	54ba <osRtxObject>
    5c34:	4603      	mov	r3, r0
    5c36:	4618      	mov	r0, r3
    5c38:	f000 ffc2 	bl	6bc0 <osRtxThreadListGet>
    5c3c:	9006      	str	r0, [sp, #24]
        osRtxThreadWaitExit(thread, (uint32_t)osOK, TRUE);
    5c3e:	2201      	movs	r2, #1
    5c40:	2100      	movs	r1, #0
    5c42:	9806      	ldr	r0, [sp, #24]
    5c44:	f001 fa5c 	bl	7100 <osRtxThreadWaitExit>
        // Copy Message (R2: const void *msg_ptr, R3: uint8_t msg_prio)
        reg = osRtxThreadRegPtr(thread);
    5c48:	9806      	ldr	r0, [sp, #24]
    5c4a:	f001 f983 	bl	6f54 <osRtxThreadRegPtr>
    5c4e:	9005      	str	r0, [sp, #20]
        //lint -e{923} "cast from unsigned int to pointer"
        ptr = (const void *)reg[2];
    5c50:	9b05      	ldr	r3, [sp, #20]
    5c52:	3308      	adds	r3, #8
    5c54:	681b      	ldr	r3, [r3, #0]
    5c56:	9304      	str	r3, [sp, #16]
        memcpy(&msg[1], ptr, mq->msg_size);
    5c58:	9b07      	ldr	r3, [sp, #28]
    5c5a:	f103 000c 	add.w	r0, r3, #12
    5c5e:	9b08      	ldr	r3, [sp, #32]
    5c60:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5c62:	461a      	mov	r2, r3
    5c64:	9904      	ldr	r1, [sp, #16]
    5c66:	f7fa fe5b 	bl	920 <memcpy>
        // Store Message into Queue
        msg->id       = osRtxIdMessage;
    5c6a:	9b07      	ldr	r3, [sp, #28]
    5c6c:	2207      	movs	r2, #7
    5c6e:	701a      	strb	r2, [r3, #0]
        msg->state    = osRtxObjectActive;
    5c70:	9b07      	ldr	r3, [sp, #28]
    5c72:	2201      	movs	r2, #1
    5c74:	705a      	strb	r2, [r3, #1]
        msg->flags    = 0U;
    5c76:	9b07      	ldr	r3, [sp, #28]
    5c78:	2200      	movs	r2, #0
    5c7a:	709a      	strb	r2, [r3, #2]
        msg->priority = (uint8_t)reg[3];
    5c7c:	9b05      	ldr	r3, [sp, #20]
    5c7e:	330c      	adds	r3, #12
    5c80:	681b      	ldr	r3, [r3, #0]
    5c82:	b2da      	uxtb	r2, r3
    5c84:	9b07      	ldr	r3, [sp, #28]
    5c86:	70da      	strb	r2, [r3, #3]
        MessageQueuePut(mq, msg);
    5c88:	9907      	ldr	r1, [sp, #28]
    5c8a:	9808      	ldr	r0, [sp, #32]
    5c8c:	f7ff fc22 	bl	54d4 <MessageQueuePut>
        EvrRtxMessageQueueInserted(mq, ptr);
    5c90:	9904      	ldr	r1, [sp, #16]
    5c92:	9808      	ldr	r0, [sp, #32]
    5c94:	f7fe fdcc 	bl	4830 <EvrRtxMessageQueueInserted>
      }
    }
    status = osOK;
    5c98:	2300      	movs	r3, #0
    5c9a:	9309      	str	r3, [sp, #36]	; 0x24
    5c9c:	e035      	b.n	5d0a <svcRtxMessageQueueGet+0x1a0>
  } else {
    // No Message available
    if (timeout != 0U) {
    5c9e:	9b00      	ldr	r3, [sp, #0]
    5ca0:	2b00      	cmp	r3, #0
    5ca2:	d02b      	beq.n	5cfc <svcRtxMessageQueueGet+0x192>
      EvrRtxMessageQueueGetPending(mq, msg_ptr, timeout);
    5ca4:	9a00      	ldr	r2, [sp, #0]
    5ca6:	9902      	ldr	r1, [sp, #8]
    5ca8:	9808      	ldr	r0, [sp, #32]
    5caa:	f7fe fdd5 	bl	4858 <EvrRtxMessageQueueGetPending>
      // Suspend current Thread
      if (osRtxThreadWaitEnter(osRtxThreadWaitingMessageGet, timeout)) {
    5cae:	9900      	ldr	r1, [sp, #0]
    5cb0:	2083      	movs	r0, #131	; 0x83
    5cb2:	f001 fa49 	bl	7148 <osRtxThreadWaitEnter>
    5cb6:	4603      	mov	r3, r0
    5cb8:	2b00      	cmp	r3, #0
    5cba:	d018      	beq.n	5cee <svcRtxMessageQueueGet+0x184>
        osRtxThreadListPut(osRtxObject(mq), osRtxThreadGetRunning());
    5cbc:	9808      	ldr	r0, [sp, #32]
    5cbe:	f7ff fbfc 	bl	54ba <osRtxObject>
    5cc2:	4604      	mov	r4, r0
    5cc4:	f7ff fc00 	bl	54c8 <osRtxThreadGetRunning>
    5cc8:	4603      	mov	r3, r0
    5cca:	4619      	mov	r1, r3
    5ccc:	4620      	mov	r0, r4
    5cce:	f000 ff41 	bl	6b54 <osRtxThreadListPut>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
    5cd2:	f3ef 8309 	mrs	r3, PSP
    5cd6:	461c      	mov	r4, r3
  return(result);
    5cd8:	4623      	mov	r3, r4
        // Save arguments (R2: void *msg_ptr, R3: uint8_t *msg_prio)
        //lint -e{923} -e{9078} "cast from unsigned int to pointer"
        reg = (uint32_t *)(__get_PSP());
    5cda:	9305      	str	r3, [sp, #20]
        //lint -e{923} -e{9078} "cast from pointer to unsigned int"
        reg[2] = (uint32_t)msg_ptr;
    5cdc:	9b05      	ldr	r3, [sp, #20]
    5cde:	3308      	adds	r3, #8
    5ce0:	9a02      	ldr	r2, [sp, #8]
    5ce2:	601a      	str	r2, [r3, #0]
        //lint -e{923} -e{9078} "cast from pointer to unsigned int"
        reg[3] = (uint32_t)msg_prio;
    5ce4:	9b05      	ldr	r3, [sp, #20]
    5ce6:	330c      	adds	r3, #12
    5ce8:	9a01      	ldr	r2, [sp, #4]
    5cea:	601a      	str	r2, [r3, #0]
    5cec:	e002      	b.n	5cf4 <svcRtxMessageQueueGet+0x18a>
      } else {
        EvrRtxMessageQueueGetTimeout(mq);
    5cee:	9808      	ldr	r0, [sp, #32]
    5cf0:	f7fe fdb9 	bl	4866 <EvrRtxMessageQueueGetTimeout>
      }
      status = osErrorTimeout;
    5cf4:	f06f 0301 	mvn.w	r3, #1
    5cf8:	9309      	str	r3, [sp, #36]	; 0x24
    5cfa:	e006      	b.n	5d0a <svcRtxMessageQueueGet+0x1a0>
    } else {
      EvrRtxMessageQueueNotRetrieved(mq, msg_ptr);
    5cfc:	9902      	ldr	r1, [sp, #8]
    5cfe:	9808      	ldr	r0, [sp, #32]
    5d00:	f7fe fdbc 	bl	487c <EvrRtxMessageQueueNotRetrieved>
      status = osErrorResource;
    5d04:	f06f 0302 	mvn.w	r3, #2
    5d08:	9309      	str	r3, [sp, #36]	; 0x24
    }
  }

  return status;
    5d0a:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    5d0c:	4618      	mov	r0, r3
    5d0e:	b00a      	add	sp, #40	; 0x28
    5d10:	bd10      	pop	{r4, pc}

00005d12 <isrRtxMessageQueuePut>:
//  ==== ISR Calls ====

/// Put a Message into a Queue or timeout if Queue is full.
/// \note API identical to osMessageQueuePut
__STATIC_INLINE
osStatus_t isrRtxMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
    5d12:	b500      	push	{lr}
    5d14:	b089      	sub	sp, #36	; 0x24
    5d16:	9003      	str	r0, [sp, #12]
    5d18:	9102      	str	r1, [sp, #8]
    5d1a:	9300      	str	r3, [sp, #0]
    5d1c:	4613      	mov	r3, r2
    5d1e:	f88d 3007 	strb.w	r3, [sp, #7]
  os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
    5d22:	9803      	ldr	r0, [sp, #12]
    5d24:	f7ff fbc3 	bl	54ae <osRtxMessageQueueId>
    5d28:	9006      	str	r0, [sp, #24]
  os_message_t       *msg;
  osStatus_t          status;

  // Check parameters
  if ((mq == NULL) || (mq->id != osRtxIdMessageQueue) || (msg_ptr == NULL) || (timeout != 0U)) {
    5d2a:	9b06      	ldr	r3, [sp, #24]
    5d2c:	2b00      	cmp	r3, #0
    5d2e:	d009      	beq.n	5d44 <isrRtxMessageQueuePut+0x32>
    5d30:	9b06      	ldr	r3, [sp, #24]
    5d32:	781b      	ldrb	r3, [r3, #0]
    5d34:	2b08      	cmp	r3, #8
    5d36:	d105      	bne.n	5d44 <isrRtxMessageQueuePut+0x32>
    5d38:	9b02      	ldr	r3, [sp, #8]
    5d3a:	2b00      	cmp	r3, #0
    5d3c:	d002      	beq.n	5d44 <isrRtxMessageQueuePut+0x32>
    5d3e:	9b00      	ldr	r3, [sp, #0]
    5d40:	2b00      	cmp	r3, #0
    5d42:	d007      	beq.n	5d54 <isrRtxMessageQueuePut+0x42>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorParameter);
    5d44:	f06f 0103 	mvn.w	r1, #3
    5d48:	9806      	ldr	r0, [sp, #24]
    5d4a:	f7fe fbc3 	bl	44d4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorParameter;
    5d4e:	f06f 0303 	mvn.w	r3, #3
    5d52:	e048      	b.n	5de6 <isrRtxMessageQueuePut+0xd4>
  }

  // Check object state
  if (mq->state == osRtxObjectInactive) {
    5d54:	9b06      	ldr	r3, [sp, #24]
    5d56:	785b      	ldrb	r3, [r3, #1]
    5d58:	2b00      	cmp	r3, #0
    5d5a:	d107      	bne.n	5d6c <isrRtxMessageQueuePut+0x5a>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorResource);
    5d5c:	f06f 0102 	mvn.w	r1, #2
    5d60:	9806      	ldr	r0, [sp, #24]
    5d62:	f7fe fbb7 	bl	44d4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    5d66:	f06f 0302 	mvn.w	r3, #2
    5d6a:	e03c      	b.n	5de6 <isrRtxMessageQueuePut+0xd4>
  }

  // Try to allocate memory
  //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
  msg = osRtxMemoryPoolAlloc(&mq->mp_info);
    5d6c:	9b06      	ldr	r3, [sp, #24]
    5d6e:	330c      	adds	r3, #12
    5d70:	4618      	mov	r0, r3
    5d72:	f7ff fad8 	bl	5326 <osRtxMemoryPoolAlloc>
    5d76:	9005      	str	r0, [sp, #20]
  if (msg != NULL) {
    5d78:	9b05      	ldr	r3, [sp, #20]
    5d7a:	2b00      	cmp	r3, #0
    5d7c:	d02b      	beq.n	5dd6 <isrRtxMessageQueuePut+0xc4>
    // Copy Message
    memcpy(&msg[1], msg_ptr, mq->msg_size);
    5d7e:	9b05      	ldr	r3, [sp, #20]
    5d80:	f103 000c 	add.w	r0, r3, #12
    5d84:	9b06      	ldr	r3, [sp, #24]
    5d86:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5d88:	461a      	mov	r2, r3
    5d8a:	9902      	ldr	r1, [sp, #8]
    5d8c:	f7fa fdc8 	bl	920 <memcpy>
    msg->id       = osRtxIdMessage;
    5d90:	9b05      	ldr	r3, [sp, #20]
    5d92:	2207      	movs	r2, #7
    5d94:	701a      	strb	r2, [r3, #0]
    msg->state    = osRtxObjectActive;
    5d96:	9b05      	ldr	r3, [sp, #20]
    5d98:	2201      	movs	r2, #1
    5d9a:	705a      	strb	r2, [r3, #1]
    msg->flags    = 0U;
    5d9c:	9b05      	ldr	r3, [sp, #20]
    5d9e:	2200      	movs	r2, #0
    5da0:	709a      	strb	r2, [r3, #2]
    msg->priority = msg_prio;
    5da2:	9b05      	ldr	r3, [sp, #20]
    5da4:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5da8:	70da      	strb	r2, [r3, #3]
    // Register post ISR processing
    //lint -e{9079} -e{9087} "cast between pointers to different object types"
    *((const void **)(void *)&msg->prev) = msg_ptr;
    5daa:	9b05      	ldr	r3, [sp, #20]
    5dac:	3304      	adds	r3, #4
    5dae:	9a02      	ldr	r2, [sp, #8]
    5db0:	601a      	str	r2, [r3, #0]
    //lint -e{9079} -e{9087} "cast between pointers to different object types"
    *(      (void **)        &msg->next) = mq;
    5db2:	9b05      	ldr	r3, [sp, #20]
    5db4:	3308      	adds	r3, #8
    5db6:	9a06      	ldr	r2, [sp, #24]
    5db8:	601a      	str	r2, [r3, #0]
    osRtxPostProcess(osRtxObject(msg));
    5dba:	9805      	ldr	r0, [sp, #20]
    5dbc:	f7ff fb7d 	bl	54ba <osRtxObject>
    5dc0:	4603      	mov	r3, r0
    5dc2:	4618      	mov	r0, r3
    5dc4:	f000 fdc8 	bl	6958 <osRtxPostProcess>
    EvrRtxMessageQueueInsertPending(mq, msg_ptr);
    5dc8:	9902      	ldr	r1, [sp, #8]
    5dca:	9806      	ldr	r0, [sp, #24]
    5dcc:	f7fe fd2a 	bl	4824 <EvrRtxMessageQueueInsertPending>
    status = osOK;
    5dd0:	2300      	movs	r3, #0
    5dd2:	9307      	str	r3, [sp, #28]
    5dd4:	e006      	b.n	5de4 <isrRtxMessageQueuePut+0xd2>
  } else {
    // No memory available
    EvrRtxMessageQueueNotInserted(mq, msg_ptr);
    5dd6:	9902      	ldr	r1, [sp, #8]
    5dd8:	9806      	ldr	r0, [sp, #24]
    5dda:	f7fe fd2f 	bl	483c <EvrRtxMessageQueueNotInserted>
    status = osErrorResource;
    5dde:	f06f 0302 	mvn.w	r3, #2
    5de2:	9307      	str	r3, [sp, #28]
  }

  return status;
    5de4:	9b07      	ldr	r3, [sp, #28]
}
    5de6:	4618      	mov	r0, r3
    5de8:	b009      	add	sp, #36	; 0x24
    5dea:	f85d fb04 	ldr.w	pc, [sp], #4

00005dee <isrRtxMessageQueueGet>:

/// Get a Message from a Queue or timeout if Queue is empty.
/// \note API identical to osMessageQueueGet
__STATIC_INLINE
osStatus_t isrRtxMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
    5dee:	b500      	push	{lr}
    5df0:	b089      	sub	sp, #36	; 0x24
    5df2:	9003      	str	r0, [sp, #12]
    5df4:	9102      	str	r1, [sp, #8]
    5df6:	9201      	str	r2, [sp, #4]
    5df8:	9300      	str	r3, [sp, #0]
  os_message_queue_t *mq = osRtxMessageQueueId(mq_id);
    5dfa:	9803      	ldr	r0, [sp, #12]
    5dfc:	f7ff fb57 	bl	54ae <osRtxMessageQueueId>
    5e00:	9006      	str	r0, [sp, #24]
  os_message_t       *msg;
  osStatus_t          status;

  // Check parameters
  if ((mq == NULL) || (mq->id != osRtxIdMessageQueue) || (msg_ptr == NULL) || (timeout != 0U)) {
    5e02:	9b06      	ldr	r3, [sp, #24]
    5e04:	2b00      	cmp	r3, #0
    5e06:	d009      	beq.n	5e1c <isrRtxMessageQueueGet+0x2e>
    5e08:	9b06      	ldr	r3, [sp, #24]
    5e0a:	781b      	ldrb	r3, [r3, #0]
    5e0c:	2b08      	cmp	r3, #8
    5e0e:	d105      	bne.n	5e1c <isrRtxMessageQueueGet+0x2e>
    5e10:	9b02      	ldr	r3, [sp, #8]
    5e12:	2b00      	cmp	r3, #0
    5e14:	d002      	beq.n	5e1c <isrRtxMessageQueueGet+0x2e>
    5e16:	9b00      	ldr	r3, [sp, #0]
    5e18:	2b00      	cmp	r3, #0
    5e1a:	d007      	beq.n	5e2c <isrRtxMessageQueueGet+0x3e>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorParameter);
    5e1c:	f06f 0103 	mvn.w	r1, #3
    5e20:	9806      	ldr	r0, [sp, #24]
    5e22:	f7fe fb57 	bl	44d4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorParameter;
    5e26:	f06f 0303 	mvn.w	r3, #3
    5e2a:	e03c      	b.n	5ea6 <isrRtxMessageQueueGet+0xb8>
  }

  // Check object state
  if (mq->state == osRtxObjectInactive) {
    5e2c:	9b06      	ldr	r3, [sp, #24]
    5e2e:	785b      	ldrb	r3, [r3, #1]
    5e30:	2b00      	cmp	r3, #0
    5e32:	d107      	bne.n	5e44 <isrRtxMessageQueueGet+0x56>
    EvrRtxMessageQueueError(mq, (int32_t)osErrorResource);
    5e34:	f06f 0102 	mvn.w	r1, #2
    5e38:	9806      	ldr	r0, [sp, #24]
    5e3a:	f7fe fb4b 	bl	44d4 <EvrRtxMessageQueueError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    5e3e:	f06f 0302 	mvn.w	r3, #2
    5e42:	e030      	b.n	5ea6 <isrRtxMessageQueueGet+0xb8>
  }

  // Get Message from Queue
  msg = MessageQueueGet(mq);
    5e44:	9806      	ldr	r0, [sp, #24]
    5e46:	f7ff fb91 	bl	556c <MessageQueueGet>
    5e4a:	9005      	str	r0, [sp, #20]
  if (msg != NULL) {
    5e4c:	9b05      	ldr	r3, [sp, #20]
    5e4e:	2b00      	cmp	r3, #0
    5e50:	d021      	beq.n	5e96 <isrRtxMessageQueueGet+0xa8>
    // Copy Message
    memcpy(msg_ptr, &msg[1], mq->msg_size);
    5e52:	9b05      	ldr	r3, [sp, #20]
    5e54:	f103 010c 	add.w	r1, r3, #12
    5e58:	9b06      	ldr	r3, [sp, #24]
    5e5a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5e5c:	461a      	mov	r2, r3
    5e5e:	9802      	ldr	r0, [sp, #8]
    5e60:	f7fa fd5e 	bl	920 <memcpy>
    if (msg_prio != NULL) {
    5e64:	9b01      	ldr	r3, [sp, #4]
    5e66:	2b00      	cmp	r3, #0
    5e68:	d003      	beq.n	5e72 <isrRtxMessageQueueGet+0x84>
      *msg_prio = msg->priority;
    5e6a:	9b05      	ldr	r3, [sp, #20]
    5e6c:	78da      	ldrb	r2, [r3, #3]
    5e6e:	9b01      	ldr	r3, [sp, #4]
    5e70:	701a      	strb	r2, [r3, #0]
    }
    // Register post ISR processing
    //lint -e{9079} -e{9087} "cast between pointers to different object types"
    *((os_message_queue_t **)(void *)&msg[1]) = mq;
    5e72:	9b05      	ldr	r3, [sp, #20]
    5e74:	330c      	adds	r3, #12
    5e76:	9a06      	ldr	r2, [sp, #24]
    5e78:	601a      	str	r2, [r3, #0]
    osRtxPostProcess(osRtxObject(msg));
    5e7a:	9805      	ldr	r0, [sp, #20]
    5e7c:	f7ff fb1d 	bl	54ba <osRtxObject>
    5e80:	4603      	mov	r3, r0
    5e82:	4618      	mov	r0, r3
    5e84:	f000 fd68 	bl	6958 <osRtxPostProcess>
    EvrRtxMessageQueueRetrieved(mq, msg_ptr);
    5e88:	9902      	ldr	r1, [sp, #8]
    5e8a:	9806      	ldr	r0, [sp, #24]
    5e8c:	f7fe fcf0 	bl	4870 <EvrRtxMessageQueueRetrieved>
    status = osOK;
    5e90:	2300      	movs	r3, #0
    5e92:	9307      	str	r3, [sp, #28]
    5e94:	e006      	b.n	5ea4 <isrRtxMessageQueueGet+0xb6>
  } else {
    // No Message available
    EvrRtxMessageQueueNotRetrieved(mq, msg_ptr);
    5e96:	9902      	ldr	r1, [sp, #8]
    5e98:	9806      	ldr	r0, [sp, #24]
    5e9a:	f7fe fcef 	bl	487c <EvrRtxMessageQueueNotRetrieved>
    status = osErrorResource;
    5e9e:	f06f 0302 	mvn.w	r3, #2
    5ea2:	9307      	str	r3, [sp, #28]
  }

  return status;
    5ea4:	9b07      	ldr	r3, [sp, #28]
}
    5ea6:	4618      	mov	r0, r3
    5ea8:	b009      	add	sp, #36	; 0x24
    5eaa:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00005eb0 <osMessageQueueNew>:


//  ==== Public API ====

/// Create and Initialize a Message Queue object.
osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
    5eb0:	b500      	push	{lr}
    5eb2:	b089      	sub	sp, #36	; 0x24
    5eb4:	9003      	str	r0, [sp, #12]
    5eb6:	9102      	str	r1, [sp, #8]
    5eb8:	9201      	str	r2, [sp, #4]
  osMessageQueueId_t mq_id;

  EvrRtxMessageQueueNew(msg_count, msg_size, attr);
    5eba:	9a01      	ldr	r2, [sp, #4]
    5ebc:	9902      	ldr	r1, [sp, #8]
    5ebe:	9803      	ldr	r0, [sp, #12]
    5ec0:	f7fe fc8d 	bl	47de <EvrRtxMessageQueueNew>
  if (IsIrqMode() || IsIrqMasked()) {
    5ec4:	f7ff fa92 	bl	53ec <IsIrqMode>
    5ec8:	4603      	mov	r3, r0
    5eca:	2b00      	cmp	r3, #0
    5ecc:	d104      	bne.n	5ed8 <osMessageQueueNew+0x28>
    5ece:	f7ff fa9a 	bl	5406 <IsIrqMasked>
    5ed2:	4603      	mov	r3, r0
    5ed4:	2b00      	cmp	r3, #0
    5ed6:	d007      	beq.n	5ee8 <osMessageQueueNew+0x38>
    EvrRtxMessageQueueError(NULL, (int32_t)osErrorISR);
    5ed8:	f06f 0105 	mvn.w	r1, #5
    5edc:	2000      	movs	r0, #0
    5ede:	f7fe faf9 	bl	44d4 <EvrRtxMessageQueueError>
    mq_id = NULL;
    5ee2:	2300      	movs	r3, #0
    5ee4:	9307      	str	r3, [sp, #28]
    5ee6:	e00e      	b.n	5f06 <osMessageQueueNew+0x56>
    5ee8:	9b03      	ldr	r3, [sp, #12]
    5eea:	9306      	str	r3, [sp, #24]
    5eec:	9b02      	ldr	r3, [sp, #8]
    5eee:	9305      	str	r3, [sp, #20]
    5ef0:	9b01      	ldr	r3, [sp, #4]
    5ef2:	9304      	str	r3, [sp, #16]
SVC0_3(MessageQueueNew,         osMessageQueueId_t, uint32_t, uint32_t, const osMessageQueueAttr_t *)
    5ef4:	9806      	ldr	r0, [sp, #24]
    5ef6:	9905      	ldr	r1, [sp, #20]
    5ef8:	9b04      	ldr	r3, [sp, #16]
    5efa:	461a      	mov	r2, r3
    5efc:	4b04      	ldr	r3, [pc, #16]	; (5f10 <osMessageQueueNew+0x60>)
    5efe:	469c      	mov	ip, r3
    5f00:	df00      	svc	0
    5f02:	4603      	mov	r3, r0
  } else {
    mq_id = __svcMessageQueueNew(msg_count, msg_size, attr);
    5f04:	9307      	str	r3, [sp, #28]
  }
  return mq_id;
    5f06:	9b07      	ldr	r3, [sp, #28]
}
    5f08:	4618      	mov	r0, r3
    5f0a:	b009      	add	sp, #36	; 0x24
    5f0c:	f85d fb04 	ldr.w	pc, [sp], #4
    5f10:	000057a5 	.word	0x000057a5

00005f14 <osMessageQueuePut>:
  }
  return name;
}

/// Put a Message into a Queue or timeout if Queue is full.
osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
    5f14:	b510      	push	{r4, lr}
    5f16:	b08a      	sub	sp, #40	; 0x28
    5f18:	9003      	str	r0, [sp, #12]
    5f1a:	9102      	str	r1, [sp, #8]
    5f1c:	9300      	str	r3, [sp, #0]
    5f1e:	4613      	mov	r3, r2
    5f20:	f88d 3007 	strb.w	r3, [sp, #7]
  osStatus_t status;

  EvrRtxMessageQueuePut(mq_id, msg_ptr, msg_prio, timeout);
    5f24:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5f28:	9b00      	ldr	r3, [sp, #0]
    5f2a:	9902      	ldr	r1, [sp, #8]
    5f2c:	9803      	ldr	r0, [sp, #12]
    5f2e:	f7fe fc63 	bl	47f8 <EvrRtxMessageQueuePut>
  if (IsIrqMode() || IsIrqMasked()) {
    5f32:	f7ff fa5b 	bl	53ec <IsIrqMode>
    5f36:	4603      	mov	r3, r0
    5f38:	2b00      	cmp	r3, #0
    5f3a:	d104      	bne.n	5f46 <osMessageQueuePut+0x32>
    5f3c:	f7ff fa63 	bl	5406 <IsIrqMasked>
    5f40:	4603      	mov	r3, r0
    5f42:	2b00      	cmp	r3, #0
    5f44:	d008      	beq.n	5f58 <osMessageQueuePut+0x44>
    status = isrRtxMessageQueuePut(mq_id, msg_ptr, msg_prio, timeout);
    5f46:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5f4a:	9b00      	ldr	r3, [sp, #0]
    5f4c:	9902      	ldr	r1, [sp, #8]
    5f4e:	9803      	ldr	r0, [sp, #12]
    5f50:	f7ff fedf 	bl	5d12 <isrRtxMessageQueuePut>
    5f54:	9009      	str	r0, [sp, #36]	; 0x24
    5f56:	e016      	b.n	5f86 <osMessageQueuePut+0x72>
    5f58:	9b03      	ldr	r3, [sp, #12]
    5f5a:	9308      	str	r3, [sp, #32]
    5f5c:	9b02      	ldr	r3, [sp, #8]
    5f5e:	9307      	str	r3, [sp, #28]
    5f60:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5f64:	f88d 301b 	strb.w	r3, [sp, #27]
    5f68:	9b00      	ldr	r3, [sp, #0]
    5f6a:	9305      	str	r3, [sp, #20]
SVC0_4(MessageQueuePut,         osStatus_t,         osMessageQueueId_t, const void *, uint8_t,   uint32_t)
    5f6c:	9b08      	ldr	r3, [sp, #32]
    5f6e:	4618      	mov	r0, r3
    5f70:	9b07      	ldr	r3, [sp, #28]
    5f72:	4619      	mov	r1, r3
    5f74:	f89d 301b 	ldrb.w	r3, [sp, #27]
    5f78:	461a      	mov	r2, r3
    5f7a:	9b05      	ldr	r3, [sp, #20]
    5f7c:	4c04      	ldr	r4, [pc, #16]	; (5f90 <osMessageQueuePut+0x7c>)
    5f7e:	46a4      	mov	ip, r4
    5f80:	df00      	svc	0
    5f82:	4603      	mov	r3, r0
  } else {
    status =  __svcMessageQueuePut(mq_id, msg_ptr, msg_prio, timeout);
    5f84:	9309      	str	r3, [sp, #36]	; 0x24
  }
  return status;
    5f86:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    5f88:	4618      	mov	r0, r3
    5f8a:	b00a      	add	sp, #40	; 0x28
    5f8c:	bd10      	pop	{r4, pc}
    5f8e:	bf00      	nop
    5f90:	000059d5 	.word	0x000059d5

00005f94 <osMessageQueueGet>:

/// Get a Message from a Queue or timeout if Queue is empty.
osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
    5f94:	b510      	push	{r4, lr}
    5f96:	b08a      	sub	sp, #40	; 0x28
    5f98:	9003      	str	r0, [sp, #12]
    5f9a:	9102      	str	r1, [sp, #8]
    5f9c:	9201      	str	r2, [sp, #4]
    5f9e:	9300      	str	r3, [sp, #0]
  osStatus_t status;

  EvrRtxMessageQueueGet(mq_id, msg_ptr, msg_prio, timeout);
    5fa0:	9b00      	ldr	r3, [sp, #0]
    5fa2:	9a01      	ldr	r2, [sp, #4]
    5fa4:	9902      	ldr	r1, [sp, #8]
    5fa6:	9803      	ldr	r0, [sp, #12]
    5fa8:	f7fe fc4e 	bl	4848 <EvrRtxMessageQueueGet>
  if (IsIrqMode() || IsIrqMasked()) {
    5fac:	f7ff fa1e 	bl	53ec <IsIrqMode>
    5fb0:	4603      	mov	r3, r0
    5fb2:	2b00      	cmp	r3, #0
    5fb4:	d104      	bne.n	5fc0 <osMessageQueueGet+0x2c>
    5fb6:	f7ff fa26 	bl	5406 <IsIrqMasked>
    5fba:	4603      	mov	r3, r0
    5fbc:	2b00      	cmp	r3, #0
    5fbe:	d007      	beq.n	5fd0 <osMessageQueueGet+0x3c>
    status = isrRtxMessageQueueGet(mq_id, msg_ptr, msg_prio, timeout);
    5fc0:	9b00      	ldr	r3, [sp, #0]
    5fc2:	9a01      	ldr	r2, [sp, #4]
    5fc4:	9902      	ldr	r1, [sp, #8]
    5fc6:	9803      	ldr	r0, [sp, #12]
    5fc8:	f7ff ff11 	bl	5dee <isrRtxMessageQueueGet>
    5fcc:	9009      	str	r0, [sp, #36]	; 0x24
    5fce:	e013      	b.n	5ff8 <osMessageQueueGet+0x64>
    5fd0:	9b03      	ldr	r3, [sp, #12]
    5fd2:	9308      	str	r3, [sp, #32]
    5fd4:	9b02      	ldr	r3, [sp, #8]
    5fd6:	9307      	str	r3, [sp, #28]
    5fd8:	9b01      	ldr	r3, [sp, #4]
    5fda:	9306      	str	r3, [sp, #24]
    5fdc:	9b00      	ldr	r3, [sp, #0]
    5fde:	9305      	str	r3, [sp, #20]
SVC0_4(MessageQueueGet,         osStatus_t,         osMessageQueueId_t,       void *, uint8_t *, uint32_t)
    5fe0:	9b08      	ldr	r3, [sp, #32]
    5fe2:	4618      	mov	r0, r3
    5fe4:	9b07      	ldr	r3, [sp, #28]
    5fe6:	4619      	mov	r1, r3
    5fe8:	9b06      	ldr	r3, [sp, #24]
    5fea:	461a      	mov	r2, r3
    5fec:	9b05      	ldr	r3, [sp, #20]
    5fee:	4c04      	ldr	r4, [pc, #16]	; (6000 <HEAP_SIZE>)
    5ff0:	46a4      	mov	ip, r4
    5ff2:	df00      	svc	0
    5ff4:	4603      	mov	r3, r0
  } else {
    status =  __svcMessageQueueGet(mq_id, msg_ptr, msg_prio, timeout);
    5ff6:	9309      	str	r3, [sp, #36]	; 0x24
  }
  return status;
    5ff8:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    5ffa:	4618      	mov	r0, r3
    5ffc:	b00a      	add	sp, #40	; 0x28
    5ffe:	bd10      	pop	{r4, pc}
    6000:	00005b6b 	.word	0x00005b6b

00006004 <IsIrqMode>:
__STATIC_INLINE bool_t IsIrqMode (void) {
    6004:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    6006:	f3ef 8305 	mrs	r3, IPSR
    600a:	9301      	str	r3, [sp, #4]
  return(result);
    600c:	9b01      	ldr	r3, [sp, #4]
  return (__get_IPSR() != 0U);
    600e:	2b00      	cmp	r3, #0
    6010:	bf14      	ite	ne
    6012:	2301      	movne	r3, #1
    6014:	2300      	moveq	r3, #0
    6016:	b2db      	uxtb	r3, r3
}
    6018:	4618      	mov	r0, r3
    601a:	b002      	add	sp, #8
    601c:	4770      	bx	lr

0000601e <IsIrqMasked>:
__STATIC_INLINE bool_t IsIrqMasked (void) {
    601e:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    6020:	f3ef 8310 	mrs	r3, PRIMASK
    6024:	9301      	str	r3, [sp, #4]
  return(result);
    6026:	9b01      	ldr	r3, [sp, #4]
  return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
    6028:	2b00      	cmp	r3, #0
    602a:	d105      	bne.n	6038 <IsIrqMasked+0x1a>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
    602c:	f3ef 8311 	mrs	r3, BASEPRI
    6030:	9300      	str	r3, [sp, #0]
  return(result);
    6032:	9b00      	ldr	r3, [sp, #0]
    6034:	2b00      	cmp	r3, #0
    6036:	d001      	beq.n	603c <IsIrqMasked+0x1e>
    6038:	2301      	movs	r3, #1
    603a:	e000      	b.n	603e <IsIrqMasked+0x20>
    603c:	2300      	movs	r3, #0
    603e:	f003 0301 	and.w	r3, r3, #1
    6042:	b2db      	uxtb	r3, r3
}
    6044:	4618      	mov	r0, r3
    6046:	b002      	add	sp, #8
    6048:	4770      	bx	lr

0000604a <osRtxMutexId>:
__STATIC_INLINE os_mutex_t *osRtxMutexId (osMutexId_t mutex_id) {
    604a:	b082      	sub	sp, #8
    604c:	9001      	str	r0, [sp, #4]
  return ((os_mutex_t *)mutex_id);
    604e:	9b01      	ldr	r3, [sp, #4]
}
    6050:	4618      	mov	r0, r3
    6052:	b002      	add	sp, #8
    6054:	4770      	bx	lr

00006056 <osRtxObject>:
__STATIC_INLINE os_object_t *osRtxObject (void *object) {
    6056:	b082      	sub	sp, #8
    6058:	9001      	str	r0, [sp, #4]
  return ((os_object_t *)object);
    605a:	9b01      	ldr	r3, [sp, #4]
}
    605c:	4618      	mov	r0, r3
    605e:	b002      	add	sp, #8
    6060:	4770      	bx	lr
	...

00006064 <osRtxThreadGetRunning>:
  return osRtxInfo.thread.run.curr;
    6064:	4b01      	ldr	r3, [pc, #4]	; (606c <osRtxThreadGetRunning+0x8>)
    6066:	695b      	ldr	r3, [r3, #20]
}
    6068:	4618      	mov	r0, r3
    606a:	4770      	bx	lr
    606c:	20000110 	.word	0x20000110

00006070 <osRtxMutexOwnerRelease>:
//  ==== Library functions ====

/// Release Mutex list when owner Thread terminates.
/// \param[in]  mutex           mutex object.
/// \return 1 - success, 0 - failure.
void osRtxMutexOwnerRelease (os_mutex_t *mutex_list) {
    6070:	b500      	push	{lr}
    6072:	b087      	sub	sp, #28
    6074:	9001      	str	r0, [sp, #4]
  os_mutex_t  *mutex;
  os_mutex_t  *mutex_next;
  os_thread_t *thread;

  mutex = mutex_list;
    6076:	9b01      	ldr	r3, [sp, #4]
    6078:	9305      	str	r3, [sp, #20]
  while (mutex != NULL) {
    607a:	e036      	b.n	60ea <osRtxMutexOwnerRelease+0x7a>
    mutex_next = mutex->owner_next;
    607c:	9b05      	ldr	r3, [sp, #20]
    607e:	695b      	ldr	r3, [r3, #20]
    6080:	9304      	str	r3, [sp, #16]
    // Check if Mutex is Robust
    if ((mutex->attr & osMutexRobust) != 0U) {
    6082:	9b05      	ldr	r3, [sp, #20]
    6084:	78db      	ldrb	r3, [r3, #3]
    6086:	f003 0308 	and.w	r3, r3, #8
    608a:	2b00      	cmp	r3, #0
    608c:	d02b      	beq.n	60e6 <osRtxMutexOwnerRelease+0x76>
      // Clear Lock counter
      mutex->lock = 0U;
    608e:	9b05      	ldr	r3, [sp, #20]
    6090:	2200      	movs	r2, #0
    6092:	761a      	strb	r2, [r3, #24]
      EvrRtxMutexReleased(mutex, 0U);
    6094:	2100      	movs	r1, #0
    6096:	9805      	ldr	r0, [sp, #20]
    6098:	f7fe fb91 	bl	47be <EvrRtxMutexReleased>
      // Check if Thread is waiting for a Mutex
      if (mutex->thread_list != NULL) {
    609c:	9b05      	ldr	r3, [sp, #20]
    609e:	689b      	ldr	r3, [r3, #8]
    60a0:	2b00      	cmp	r3, #0
    60a2:	d020      	beq.n	60e6 <osRtxMutexOwnerRelease+0x76>
        // Wakeup waiting Thread with highest Priority
        thread = osRtxThreadListGet(osRtxObject(mutex));
    60a4:	9805      	ldr	r0, [sp, #20]
    60a6:	f7ff ffd6 	bl	6056 <osRtxObject>
    60aa:	4603      	mov	r3, r0
    60ac:	4618      	mov	r0, r3
    60ae:	f000 fd87 	bl	6bc0 <osRtxThreadListGet>
    60b2:	9003      	str	r0, [sp, #12]
        osRtxThreadWaitExit(thread, (uint32_t)osOK, FALSE);
    60b4:	2200      	movs	r2, #0
    60b6:	2100      	movs	r1, #0
    60b8:	9803      	ldr	r0, [sp, #12]
    60ba:	f001 f821 	bl	7100 <osRtxThreadWaitExit>
        // Thread is the new Mutex owner
        mutex->owner_thread = thread;
    60be:	9b05      	ldr	r3, [sp, #20]
    60c0:	9a03      	ldr	r2, [sp, #12]
    60c2:	60da      	str	r2, [r3, #12]
        mutex->owner_next   = thread->mutex_list;
    60c4:	9b03      	ldr	r3, [sp, #12]
    60c6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    60c8:	9b05      	ldr	r3, [sp, #20]
    60ca:	615a      	str	r2, [r3, #20]
        mutex->owner_prev   = NULL;
    60cc:	9b05      	ldr	r3, [sp, #20]
    60ce:	2200      	movs	r2, #0
    60d0:	611a      	str	r2, [r3, #16]
        thread->mutex_list  = mutex;
    60d2:	9b03      	ldr	r3, [sp, #12]
    60d4:	9a05      	ldr	r2, [sp, #20]
    60d6:	62da      	str	r2, [r3, #44]	; 0x2c
        mutex->lock = 1U;
    60d8:	9b05      	ldr	r3, [sp, #20]
    60da:	2201      	movs	r2, #1
    60dc:	761a      	strb	r2, [r3, #24]
        EvrRtxMutexAcquired(mutex, 1U);
    60de:	2101      	movs	r1, #1
    60e0:	9805      	ldr	r0, [sp, #20]
    60e2:	f7fe fb5c 	bl	479e <EvrRtxMutexAcquired>
      }
    }
    mutex = mutex_next;
    60e6:	9b04      	ldr	r3, [sp, #16]
    60e8:	9305      	str	r3, [sp, #20]
  while (mutex != NULL) {
    60ea:	9b05      	ldr	r3, [sp, #20]
    60ec:	2b00      	cmp	r3, #0
    60ee:	d1c5      	bne.n	607c <osRtxMutexOwnerRelease+0xc>
  }
}
    60f0:	bf00      	nop
    60f2:	b007      	add	sp, #28
    60f4:	f85d fb04 	ldr.w	pc, [sp], #4

000060f8 <svcRtxMutexNew>:

//  ==== Service Calls ====

/// Create and Initialize a Mutex object.
/// \note API identical to osMutexNew
static osMutexId_t svcRtxMutexNew (const osMutexAttr_t *attr) {
    60f8:	b500      	push	{lr}
    60fa:	b087      	sub	sp, #28
    60fc:	9001      	str	r0, [sp, #4]
  uint32_t    attr_bits;
  uint8_t     flags;
  const char *name;

  // Process attributes
  if (attr != NULL) {
    60fe:	9b01      	ldr	r3, [sp, #4]
    6100:	2b00      	cmp	r3, #0
    6102:	d026      	beq.n	6152 <svcRtxMutexNew+0x5a>
    name      = attr->name;
    6104:	9b01      	ldr	r3, [sp, #4]
    6106:	681b      	ldr	r3, [r3, #0]
    6108:	9302      	str	r3, [sp, #8]
    attr_bits = attr->attr_bits;
    610a:	9b01      	ldr	r3, [sp, #4]
    610c:	685b      	ldr	r3, [r3, #4]
    610e:	9304      	str	r3, [sp, #16]
    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
    mutex     = attr->cb_mem;
    6110:	9b01      	ldr	r3, [sp, #4]
    6112:	689b      	ldr	r3, [r3, #8]
    6114:	9305      	str	r3, [sp, #20]
    if (mutex != NULL) {
    6116:	9b05      	ldr	r3, [sp, #20]
    6118:	2b00      	cmp	r3, #0
    611a:	d00f      	beq.n	613c <svcRtxMutexNew+0x44>
      //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
      if ((((uint32_t)mutex & 3U) != 0U) || (attr->cb_size < sizeof(os_mutex_t))) {
    611c:	9b05      	ldr	r3, [sp, #20]
    611e:	f003 0303 	and.w	r3, r3, #3
    6122:	2b00      	cmp	r3, #0
    6124:	d103      	bne.n	612e <svcRtxMutexNew+0x36>
    6126:	9b01      	ldr	r3, [sp, #4]
    6128:	68db      	ldr	r3, [r3, #12]
    612a:	2b1b      	cmp	r3, #27
    612c:	d817      	bhi.n	615e <svcRtxMutexNew+0x66>
        EvrRtxMutexError(NULL, osRtxErrorInvalidControlBlock);
    612e:	f06f 0108 	mvn.w	r1, #8
    6132:	2000      	movs	r0, #0
    6134:	f7fe f9b8 	bl	44a8 <EvrRtxMutexError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    6138:	2300      	movs	r3, #0
    613a:	e060      	b.n	61fe <svcRtxMutexNew+0x106>
      }
    } else {
      if (attr->cb_size != 0U) {
    613c:	9b01      	ldr	r3, [sp, #4]
    613e:	68db      	ldr	r3, [r3, #12]
    6140:	2b00      	cmp	r3, #0
    6142:	d00c      	beq.n	615e <svcRtxMutexNew+0x66>
        EvrRtxMutexError(NULL, osRtxErrorInvalidControlBlock);
    6144:	f06f 0108 	mvn.w	r1, #8
    6148:	2000      	movs	r0, #0
    614a:	f7fe f9ad 	bl	44a8 <EvrRtxMutexError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    614e:	2300      	movs	r3, #0
    6150:	e055      	b.n	61fe <svcRtxMutexNew+0x106>
      }
    }
  } else {
    name      = NULL;
    6152:	2300      	movs	r3, #0
    6154:	9302      	str	r3, [sp, #8]
    attr_bits = 0U;
    6156:	2300      	movs	r3, #0
    6158:	9304      	str	r3, [sp, #16]
    mutex     = NULL;
    615a:	2300      	movs	r3, #0
    615c:	9305      	str	r3, [sp, #20]
  }

  // Allocate object memory if not provided
  if (mutex == NULL) {
    615e:	9b05      	ldr	r3, [sp, #20]
    6160:	2b00      	cmp	r3, #0
    6162:	d119      	bne.n	6198 <svcRtxMutexNew+0xa0>
    if (osRtxInfo.mpi.mutex != NULL) {
    6164:	4b28      	ldr	r3, [pc, #160]	; (6208 <svcRtxMutexNew+0x110>)
    6166:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    616a:	2b00      	cmp	r3, #0
    616c:	d007      	beq.n	617e <svcRtxMutexNew+0x86>
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      mutex = osRtxMemoryPoolAlloc(osRtxInfo.mpi.mutex);
    616e:	4b26      	ldr	r3, [pc, #152]	; (6208 <svcRtxMutexNew+0x110>)
    6170:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    6174:	4618      	mov	r0, r3
    6176:	f7ff f8d6 	bl	5326 <osRtxMemoryPoolAlloc>
    617a:	9005      	str	r0, [sp, #20]
    617c:	e008      	b.n	6190 <svcRtxMutexNew+0x98>
    } else {
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      mutex = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_mutex_t), 1U);
    617e:	4b22      	ldr	r3, [pc, #136]	; (6208 <svcRtxMutexNew+0x110>)
    6180:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    6184:	2201      	movs	r2, #1
    6186:	211c      	movs	r1, #28
    6188:	4618      	mov	r0, r3
    618a:	f7fe ff34 	bl	4ff6 <osRtxMemoryAlloc>
    618e:	9005      	str	r0, [sp, #20]
      if (osRtxMutexMemUsage.max_used < used) {
        osRtxMutexMemUsage.max_used = used;
      }
    }
#endif
    flags = osRtxFlagSystemObject;
    6190:	2301      	movs	r3, #1
    6192:	f88d 300f 	strb.w	r3, [sp, #15]
    6196:	e002      	b.n	619e <svcRtxMutexNew+0xa6>
  } else {
    flags = 0U;
    6198:	2300      	movs	r3, #0
    619a:	f88d 300f 	strb.w	r3, [sp, #15]
  }

  if (mutex != NULL) {
    619e:	9b05      	ldr	r3, [sp, #20]
    61a0:	2b00      	cmp	r3, #0
    61a2:	d026      	beq.n	61f2 <svcRtxMutexNew+0xfa>
    // Initialize control block
    mutex->id           = osRtxIdMutex;
    61a4:	9b05      	ldr	r3, [sp, #20]
    61a6:	2204      	movs	r2, #4
    61a8:	701a      	strb	r2, [r3, #0]
    mutex->state        = osRtxObjectActive;
    61aa:	9b05      	ldr	r3, [sp, #20]
    61ac:	2201      	movs	r2, #1
    61ae:	705a      	strb	r2, [r3, #1]
    mutex->flags        = flags;
    61b0:	9b05      	ldr	r3, [sp, #20]
    61b2:	f89d 200f 	ldrb.w	r2, [sp, #15]
    61b6:	709a      	strb	r2, [r3, #2]
    mutex->attr         = (uint8_t)attr_bits;
    61b8:	9b04      	ldr	r3, [sp, #16]
    61ba:	b2da      	uxtb	r2, r3
    61bc:	9b05      	ldr	r3, [sp, #20]
    61be:	70da      	strb	r2, [r3, #3]
    mutex->name         = name;
    61c0:	9b05      	ldr	r3, [sp, #20]
    61c2:	9a02      	ldr	r2, [sp, #8]
    61c4:	605a      	str	r2, [r3, #4]
    mutex->thread_list  = NULL;
    61c6:	9b05      	ldr	r3, [sp, #20]
    61c8:	2200      	movs	r2, #0
    61ca:	609a      	str	r2, [r3, #8]
    mutex->owner_thread = NULL;
    61cc:	9b05      	ldr	r3, [sp, #20]
    61ce:	2200      	movs	r2, #0
    61d0:	60da      	str	r2, [r3, #12]
    mutex->owner_prev   = NULL;
    61d2:	9b05      	ldr	r3, [sp, #20]
    61d4:	2200      	movs	r2, #0
    61d6:	611a      	str	r2, [r3, #16]
    mutex->owner_next   = NULL;
    61d8:	9b05      	ldr	r3, [sp, #20]
    61da:	2200      	movs	r2, #0
    61dc:	615a      	str	r2, [r3, #20]
    mutex->lock         = 0U;
    61de:	9b05      	ldr	r3, [sp, #20]
    61e0:	2200      	movs	r2, #0
    61e2:	761a      	strb	r2, [r3, #24]

    EvrRtxMutexCreated(mutex, mutex->name);
    61e4:	9b05      	ldr	r3, [sp, #20]
    61e6:	685b      	ldr	r3, [r3, #4]
    61e8:	4619      	mov	r1, r3
    61ea:	9805      	ldr	r0, [sp, #20]
    61ec:	f7fe fac0 	bl	4770 <EvrRtxMutexCreated>
    61f0:	e004      	b.n	61fc <svcRtxMutexNew+0x104>
  } else {
    EvrRtxMutexError(NULL, (int32_t)osErrorNoMemory);
    61f2:	f06f 0104 	mvn.w	r1, #4
    61f6:	2000      	movs	r0, #0
    61f8:	f7fe f956 	bl	44a8 <EvrRtxMutexError>
  }

  return mutex;
    61fc:	9b05      	ldr	r3, [sp, #20]
}
    61fe:	4618      	mov	r0, r3
    6200:	b007      	add	sp, #28
    6202:	f85d fb04 	ldr.w	pc, [sp], #4
    6206:	bf00      	nop
    6208:	20000110 	.word	0x20000110

0000620c <svcRtxMutexAcquire>:
  return mutex->name;
}

/// Acquire a Mutex or timeout if it is locked.
/// \note API identical to osMutexAcquire
static osStatus_t svcRtxMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
    620c:	b500      	push	{lr}
    620e:	b087      	sub	sp, #28
    6210:	9001      	str	r0, [sp, #4]
    6212:	9100      	str	r1, [sp, #0]
  os_mutex_t  *mutex = osRtxMutexId(mutex_id);
    6214:	9801      	ldr	r0, [sp, #4]
    6216:	f7ff ff18 	bl	604a <osRtxMutexId>
    621a:	9004      	str	r0, [sp, #16]
  os_thread_t *runnig_thread;
  osStatus_t   status;

  // Check running thread
  runnig_thread = osRtxThreadGetRunning();
    621c:	f7ff ff22 	bl	6064 <osRtxThreadGetRunning>
    6220:	9003      	str	r0, [sp, #12]
  if (runnig_thread == NULL) {
    6222:	9b03      	ldr	r3, [sp, #12]
    6224:	2b00      	cmp	r3, #0
    6226:	d107      	bne.n	6238 <svcRtxMutexAcquire+0x2c>
    EvrRtxMutexError(mutex, osRtxErrorKernelNotRunning);
    6228:	f06f 0107 	mvn.w	r1, #7
    622c:	9804      	ldr	r0, [sp, #16]
    622e:	f7fe f93b 	bl	44a8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    6232:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    6236:	e0a6      	b.n	6386 <svcRtxMutexAcquire+0x17a>
  }

  // Check parameters
  if ((mutex == NULL) || (mutex->id != osRtxIdMutex)) {
    6238:	9b04      	ldr	r3, [sp, #16]
    623a:	2b00      	cmp	r3, #0
    623c:	d003      	beq.n	6246 <svcRtxMutexAcquire+0x3a>
    623e:	9b04      	ldr	r3, [sp, #16]
    6240:	781b      	ldrb	r3, [r3, #0]
    6242:	2b04      	cmp	r3, #4
    6244:	d007      	beq.n	6256 <svcRtxMutexAcquire+0x4a>
    EvrRtxMutexError(mutex, (int32_t)osErrorParameter);
    6246:	f06f 0103 	mvn.w	r1, #3
    624a:	9804      	ldr	r0, [sp, #16]
    624c:	f7fe f92c 	bl	44a8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorParameter;
    6250:	f06f 0303 	mvn.w	r3, #3
    6254:	e097      	b.n	6386 <svcRtxMutexAcquire+0x17a>
  }

  // Check object state
  if (mutex->state == osRtxObjectInactive) {
    6256:	9b04      	ldr	r3, [sp, #16]
    6258:	785b      	ldrb	r3, [r3, #1]
    625a:	2b00      	cmp	r3, #0
    625c:	d107      	bne.n	626e <svcRtxMutexAcquire+0x62>
    EvrRtxMutexError(mutex, (int32_t)osErrorResource);
    625e:	f06f 0102 	mvn.w	r1, #2
    6262:	9804      	ldr	r0, [sp, #16]
    6264:	f7fe f920 	bl	44a8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    6268:	f06f 0302 	mvn.w	r3, #2
    626c:	e08b      	b.n	6386 <svcRtxMutexAcquire+0x17a>
  }

  // Check if Mutex is not locked
  if (mutex->lock == 0U) {
    626e:	9b04      	ldr	r3, [sp, #16]
    6270:	7e1b      	ldrb	r3, [r3, #24]
    6272:	2b00      	cmp	r3, #0
    6274:	d120      	bne.n	62b8 <svcRtxMutexAcquire+0xac>
    // Acquire Mutex
    mutex->owner_thread = runnig_thread;
    6276:	9b04      	ldr	r3, [sp, #16]
    6278:	9a03      	ldr	r2, [sp, #12]
    627a:	60da      	str	r2, [r3, #12]
    mutex->owner_next   = runnig_thread->mutex_list;
    627c:	9b03      	ldr	r3, [sp, #12]
    627e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    6280:	9b04      	ldr	r3, [sp, #16]
    6282:	615a      	str	r2, [r3, #20]
    mutex->owner_prev   = NULL;
    6284:	9b04      	ldr	r3, [sp, #16]
    6286:	2200      	movs	r2, #0
    6288:	611a      	str	r2, [r3, #16]
    if (runnig_thread->mutex_list != NULL) {
    628a:	9b03      	ldr	r3, [sp, #12]
    628c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    628e:	2b00      	cmp	r3, #0
    6290:	d003      	beq.n	629a <svcRtxMutexAcquire+0x8e>
        runnig_thread->mutex_list->owner_prev = mutex;
    6292:	9b03      	ldr	r3, [sp, #12]
    6294:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6296:	9a04      	ldr	r2, [sp, #16]
    6298:	611a      	str	r2, [r3, #16]
    }
    runnig_thread->mutex_list = mutex;
    629a:	9b03      	ldr	r3, [sp, #12]
    629c:	9a04      	ldr	r2, [sp, #16]
    629e:	62da      	str	r2, [r3, #44]	; 0x2c
    mutex->lock = 1U;
    62a0:	9b04      	ldr	r3, [sp, #16]
    62a2:	2201      	movs	r2, #1
    62a4:	761a      	strb	r2, [r3, #24]
    EvrRtxMutexAcquired(mutex, mutex->lock);
    62a6:	9b04      	ldr	r3, [sp, #16]
    62a8:	7e1b      	ldrb	r3, [r3, #24]
    62aa:	4619      	mov	r1, r3
    62ac:	9804      	ldr	r0, [sp, #16]
    62ae:	f7fe fa76 	bl	479e <EvrRtxMutexAcquired>
    status = osOK;
    62b2:	2300      	movs	r3, #0
    62b4:	9305      	str	r3, [sp, #20]
    62b6:	e065      	b.n	6384 <svcRtxMutexAcquire+0x178>
  } else {
    // Check if Mutex is recursive and running Thread is the owner
    if (((mutex->attr & osMutexRecursive) != 0U) && (mutex->owner_thread == runnig_thread)) {
    62b8:	9b04      	ldr	r3, [sp, #16]
    62ba:	78db      	ldrb	r3, [r3, #3]
    62bc:	f003 0301 	and.w	r3, r3, #1
    62c0:	2b00      	cmp	r3, #0
    62c2:	d020      	beq.n	6306 <svcRtxMutexAcquire+0xfa>
    62c4:	9b04      	ldr	r3, [sp, #16]
    62c6:	68da      	ldr	r2, [r3, #12]
    62c8:	9b03      	ldr	r3, [sp, #12]
    62ca:	429a      	cmp	r2, r3
    62cc:	d11b      	bne.n	6306 <svcRtxMutexAcquire+0xfa>
      // Try to increment lock counter
      if (mutex->lock == osRtxMutexLockLimit) {
    62ce:	9b04      	ldr	r3, [sp, #16]
    62d0:	7e1b      	ldrb	r3, [r3, #24]
    62d2:	2bff      	cmp	r3, #255	; 0xff
    62d4:	d108      	bne.n	62e8 <svcRtxMutexAcquire+0xdc>
        EvrRtxMutexError(mutex, osRtxErrorMutexLockLimit);
    62d6:	f06f 010f 	mvn.w	r1, #15
    62da:	9804      	ldr	r0, [sp, #16]
    62dc:	f7fe f8e4 	bl	44a8 <EvrRtxMutexError>
        status = osErrorResource;
    62e0:	f06f 0302 	mvn.w	r3, #2
    62e4:	9305      	str	r3, [sp, #20]
      if (mutex->lock == osRtxMutexLockLimit) {
    62e6:	e04d      	b.n	6384 <svcRtxMutexAcquire+0x178>
      } else {
        mutex->lock++;
    62e8:	9b04      	ldr	r3, [sp, #16]
    62ea:	7e1b      	ldrb	r3, [r3, #24]
    62ec:	3301      	adds	r3, #1
    62ee:	b2da      	uxtb	r2, r3
    62f0:	9b04      	ldr	r3, [sp, #16]
    62f2:	761a      	strb	r2, [r3, #24]
        EvrRtxMutexAcquired(mutex, mutex->lock);
    62f4:	9b04      	ldr	r3, [sp, #16]
    62f6:	7e1b      	ldrb	r3, [r3, #24]
    62f8:	4619      	mov	r1, r3
    62fa:	9804      	ldr	r0, [sp, #16]
    62fc:	f7fe fa4f 	bl	479e <EvrRtxMutexAcquired>
        status = osOK;
    6300:	2300      	movs	r3, #0
    6302:	9305      	str	r3, [sp, #20]
      if (mutex->lock == osRtxMutexLockLimit) {
    6304:	e03e      	b.n	6384 <svcRtxMutexAcquire+0x178>
      }
    } else {
      // Check if timeout is specified
      if (timeout != 0U) {
    6306:	9b00      	ldr	r3, [sp, #0]
    6308:	2b00      	cmp	r3, #0
    630a:	d035      	beq.n	6378 <svcRtxMutexAcquire+0x16c>
        // Check if Priority inheritance protocol is enabled
        if ((mutex->attr & osMutexPrioInherit) != 0U) {
    630c:	9b04      	ldr	r3, [sp, #16]
    630e:	78db      	ldrb	r3, [r3, #3]
    6310:	f003 0302 	and.w	r3, r3, #2
    6314:	2b00      	cmp	r3, #0
    6316:	d014      	beq.n	6342 <svcRtxMutexAcquire+0x136>
          // Raise priority of owner Thread if lower than priority of running Thread
          if (mutex->owner_thread->priority < runnig_thread->priority) {
    6318:	9b04      	ldr	r3, [sp, #16]
    631a:	68db      	ldr	r3, [r3, #12]
    631c:	f993 2020 	ldrsb.w	r2, [r3, #32]
    6320:	9b03      	ldr	r3, [sp, #12]
    6322:	f993 3020 	ldrsb.w	r3, [r3, #32]
    6326:	429a      	cmp	r2, r3
    6328:	da0b      	bge.n	6342 <svcRtxMutexAcquire+0x136>
            mutex->owner_thread->priority = runnig_thread->priority;
    632a:	9b04      	ldr	r3, [sp, #16]
    632c:	68db      	ldr	r3, [r3, #12]
    632e:	9a03      	ldr	r2, [sp, #12]
    6330:	f992 2020 	ldrsb.w	r2, [r2, #32]
    6334:	f883 2020 	strb.w	r2, [r3, #32]
            osRtxThreadListSort(mutex->owner_thread);
    6338:	9b04      	ldr	r3, [sp, #16]
    633a:	68db      	ldr	r3, [r3, #12]
    633c:	4618      	mov	r0, r3
    633e:	f000 fc71 	bl	6c24 <osRtxThreadListSort>
          }
        }
        EvrRtxMutexAcquirePending(mutex, timeout);
    6342:	9900      	ldr	r1, [sp, #0]
    6344:	9804      	ldr	r0, [sp, #16]
    6346:	f7fe fa1f 	bl	4788 <EvrRtxMutexAcquirePending>
        // Suspend current Thread
        if (osRtxThreadWaitEnter(osRtxThreadWaitingMutex, timeout)) {
    634a:	9900      	ldr	r1, [sp, #0]
    634c:	2053      	movs	r0, #83	; 0x53
    634e:	f000 fefb 	bl	7148 <osRtxThreadWaitEnter>
    6352:	4603      	mov	r3, r0
    6354:	2b00      	cmp	r3, #0
    6356:	d008      	beq.n	636a <svcRtxMutexAcquire+0x15e>
          osRtxThreadListPut(osRtxObject(mutex), runnig_thread);
    6358:	9804      	ldr	r0, [sp, #16]
    635a:	f7ff fe7c 	bl	6056 <osRtxObject>
    635e:	4603      	mov	r3, r0
    6360:	9903      	ldr	r1, [sp, #12]
    6362:	4618      	mov	r0, r3
    6364:	f000 fbf6 	bl	6b54 <osRtxThreadListPut>
    6368:	e002      	b.n	6370 <svcRtxMutexAcquire+0x164>
        } else {
          EvrRtxMutexAcquireTimeout(mutex);
    636a:	9804      	ldr	r0, [sp, #16]
    636c:	f7fe fa12 	bl	4794 <EvrRtxMutexAcquireTimeout>
        }
        status = osErrorTimeout;
    6370:	f06f 0301 	mvn.w	r3, #1
    6374:	9305      	str	r3, [sp, #20]
    6376:	e005      	b.n	6384 <svcRtxMutexAcquire+0x178>
      } else {
        EvrRtxMutexNotAcquired(mutex);
    6378:	9804      	ldr	r0, [sp, #16]
    637a:	f7fe fa16 	bl	47aa <EvrRtxMutexNotAcquired>
        status = osErrorResource;
    637e:	f06f 0302 	mvn.w	r3, #2
    6382:	9305      	str	r3, [sp, #20]
      }
    }
  }

  return status;
    6384:	9b05      	ldr	r3, [sp, #20]
}
    6386:	4618      	mov	r0, r3
    6388:	b007      	add	sp, #28
    638a:	f85d fb04 	ldr.w	pc, [sp], #4

0000638e <svcRtxMutexRelease>:

/// Release a Mutex that was acquired by osMutexAcquire.
/// \note API identical to osMutexRelease
static osStatus_t svcRtxMutexRelease (osMutexId_t mutex_id) {
    638e:	b500      	push	{lr}
    6390:	b089      	sub	sp, #36	; 0x24
    6392:	9001      	str	r0, [sp, #4]
        os_mutex_t  *mutex = osRtxMutexId(mutex_id);
    6394:	9801      	ldr	r0, [sp, #4]
    6396:	f7ff fe58 	bl	604a <osRtxMutexId>
    639a:	9005      	str	r0, [sp, #20]
        os_thread_t *thread;
        os_thread_t *runnig_thread;
        int8_t       priority;

  // Check running thread
  runnig_thread = osRtxThreadGetRunning();
    639c:	f7ff fe62 	bl	6064 <osRtxThreadGetRunning>
    63a0:	9004      	str	r0, [sp, #16]
  if (runnig_thread == NULL) {
    63a2:	9b04      	ldr	r3, [sp, #16]
    63a4:	2b00      	cmp	r3, #0
    63a6:	d107      	bne.n	63b8 <svcRtxMutexRelease+0x2a>
    EvrRtxMutexError(mutex, osRtxErrorKernelNotRunning);
    63a8:	f06f 0107 	mvn.w	r1, #7
    63ac:	9805      	ldr	r0, [sp, #20]
    63ae:	f7fe f87b 	bl	44a8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osError;
    63b2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    63b6:	e0af      	b.n	6518 <svcRtxMutexRelease+0x18a>
  }

  // Check parameters
  if ((mutex == NULL) || (mutex->id != osRtxIdMutex)) {
    63b8:	9b05      	ldr	r3, [sp, #20]
    63ba:	2b00      	cmp	r3, #0
    63bc:	d003      	beq.n	63c6 <svcRtxMutexRelease+0x38>
    63be:	9b05      	ldr	r3, [sp, #20]
    63c0:	781b      	ldrb	r3, [r3, #0]
    63c2:	2b04      	cmp	r3, #4
    63c4:	d007      	beq.n	63d6 <svcRtxMutexRelease+0x48>
    EvrRtxMutexError(mutex, (int32_t)osErrorParameter);
    63c6:	f06f 0103 	mvn.w	r1, #3
    63ca:	9805      	ldr	r0, [sp, #20]
    63cc:	f7fe f86c 	bl	44a8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorParameter;
    63d0:	f06f 0303 	mvn.w	r3, #3
    63d4:	e0a0      	b.n	6518 <svcRtxMutexRelease+0x18a>
  }

  // Check object state
  if (mutex->state == osRtxObjectInactive) {
    63d6:	9b05      	ldr	r3, [sp, #20]
    63d8:	785b      	ldrb	r3, [r3, #1]
    63da:	2b00      	cmp	r3, #0
    63dc:	d107      	bne.n	63ee <svcRtxMutexRelease+0x60>
    EvrRtxMutexError(mutex, (int32_t)osErrorResource);
    63de:	f06f 0102 	mvn.w	r1, #2
    63e2:	9805      	ldr	r0, [sp, #20]
    63e4:	f7fe f860 	bl	44a8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    63e8:	f06f 0302 	mvn.w	r3, #2
    63ec:	e094      	b.n	6518 <svcRtxMutexRelease+0x18a>
  }

  // Check if running Thread is not the owner
  if (mutex->owner_thread != runnig_thread) {
    63ee:	9b05      	ldr	r3, [sp, #20]
    63f0:	68da      	ldr	r2, [r3, #12]
    63f2:	9b04      	ldr	r3, [sp, #16]
    63f4:	429a      	cmp	r2, r3
    63f6:	d007      	beq.n	6408 <svcRtxMutexRelease+0x7a>
    EvrRtxMutexError(mutex, osRtxErrorMutexNotOwned);
    63f8:	f06f 010d 	mvn.w	r1, #13
    63fc:	9805      	ldr	r0, [sp, #20]
    63fe:	f7fe f853 	bl	44a8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    6402:	f06f 0302 	mvn.w	r3, #2
    6406:	e087      	b.n	6518 <svcRtxMutexRelease+0x18a>
  }

  // Check if Mutex is not locked
  if (mutex->lock == 0U) {
    6408:	9b05      	ldr	r3, [sp, #20]
    640a:	7e1b      	ldrb	r3, [r3, #24]
    640c:	2b00      	cmp	r3, #0
    640e:	d107      	bne.n	6420 <svcRtxMutexRelease+0x92>
    EvrRtxMutexError(mutex, osRtxErrorMutexNotLocked);
    6410:	f06f 010e 	mvn.w	r1, #14
    6414:	9805      	ldr	r0, [sp, #20]
    6416:	f7fe f847 	bl	44a8 <EvrRtxMutexError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return osErrorResource;
    641a:	f06f 0302 	mvn.w	r3, #2
    641e:	e07b      	b.n	6518 <svcRtxMutexRelease+0x18a>
  }

  // Decrement Lock counter
  mutex->lock--;
    6420:	9b05      	ldr	r3, [sp, #20]
    6422:	7e1b      	ldrb	r3, [r3, #24]
    6424:	3b01      	subs	r3, #1
    6426:	b2da      	uxtb	r2, r3
    6428:	9b05      	ldr	r3, [sp, #20]
    642a:	761a      	strb	r2, [r3, #24]
  EvrRtxMutexReleased(mutex, mutex->lock);
    642c:	9b05      	ldr	r3, [sp, #20]
    642e:	7e1b      	ldrb	r3, [r3, #24]
    6430:	4619      	mov	r1, r3
    6432:	9805      	ldr	r0, [sp, #20]
    6434:	f7fe f9c3 	bl	47be <EvrRtxMutexReleased>

  // Check Lock counter
  if (mutex->lock == 0U) {
    6438:	9b05      	ldr	r3, [sp, #20]
    643a:	7e1b      	ldrb	r3, [r3, #24]
    643c:	2b00      	cmp	r3, #0
    643e:	d16a      	bne.n	6516 <svcRtxMutexRelease+0x188>

    // Remove Mutex from Thread owner list
    if (mutex->owner_next != NULL) {
    6440:	9b05      	ldr	r3, [sp, #20]
    6442:	695b      	ldr	r3, [r3, #20]
    6444:	2b00      	cmp	r3, #0
    6446:	d004      	beq.n	6452 <svcRtxMutexRelease+0xc4>
      mutex->owner_next->owner_prev = mutex->owner_prev;
    6448:	9b05      	ldr	r3, [sp, #20]
    644a:	695b      	ldr	r3, [r3, #20]
    644c:	9a05      	ldr	r2, [sp, #20]
    644e:	6912      	ldr	r2, [r2, #16]
    6450:	611a      	str	r2, [r3, #16]
    }
    if (mutex->owner_prev != NULL) {
    6452:	9b05      	ldr	r3, [sp, #20]
    6454:	691b      	ldr	r3, [r3, #16]
    6456:	2b00      	cmp	r3, #0
    6458:	d005      	beq.n	6466 <svcRtxMutexRelease+0xd8>
      mutex->owner_prev->owner_next = mutex->owner_next;
    645a:	9b05      	ldr	r3, [sp, #20]
    645c:	691b      	ldr	r3, [r3, #16]
    645e:	9a05      	ldr	r2, [sp, #20]
    6460:	6952      	ldr	r2, [r2, #20]
    6462:	615a      	str	r2, [r3, #20]
    6464:	e003      	b.n	646e <svcRtxMutexRelease+0xe0>
    } else {
      runnig_thread->mutex_list = mutex->owner_next;
    6466:	9b05      	ldr	r3, [sp, #20]
    6468:	695a      	ldr	r2, [r3, #20]
    646a:	9b04      	ldr	r3, [sp, #16]
    646c:	62da      	str	r2, [r3, #44]	; 0x2c
    }

    // Restore running Thread priority
    if ((mutex->attr & osMutexPrioInherit) != 0U) {
    646e:	9b05      	ldr	r3, [sp, #20]
    6470:	78db      	ldrb	r3, [r3, #3]
    6472:	f003 0302 	and.w	r3, r3, #2
    6476:	2b00      	cmp	r3, #0
    6478:	d025      	beq.n	64c6 <svcRtxMutexRelease+0x138>
      priority = runnig_thread->priority_base;
    647a:	9b04      	ldr	r3, [sp, #16]
    647c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
    6480:	f88d 301b 	strb.w	r3, [sp, #27]
      mutex0   = runnig_thread->mutex_list;
    6484:	9b04      	ldr	r3, [sp, #16]
    6486:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6488:	9307      	str	r3, [sp, #28]
      while (mutex0 != NULL) {
    648a:	e014      	b.n	64b6 <svcRtxMutexRelease+0x128>
        // Mutexes owned by running Thread
        if ((mutex0->thread_list != NULL) && (mutex0->thread_list->priority > priority)) {
    648c:	9b07      	ldr	r3, [sp, #28]
    648e:	689b      	ldr	r3, [r3, #8]
    6490:	2b00      	cmp	r3, #0
    6492:	d00d      	beq.n	64b0 <svcRtxMutexRelease+0x122>
    6494:	9b07      	ldr	r3, [sp, #28]
    6496:	689b      	ldr	r3, [r3, #8]
    6498:	f993 3020 	ldrsb.w	r3, [r3, #32]
    649c:	f99d 201b 	ldrsb.w	r2, [sp, #27]
    64a0:	429a      	cmp	r2, r3
    64a2:	da05      	bge.n	64b0 <svcRtxMutexRelease+0x122>
          // Higher priority Thread is waiting for Mutex
          priority = mutex0->thread_list->priority;
    64a4:	9b07      	ldr	r3, [sp, #28]
    64a6:	689b      	ldr	r3, [r3, #8]
    64a8:	f893 3020 	ldrb.w	r3, [r3, #32]
    64ac:	f88d 301b 	strb.w	r3, [sp, #27]
        }
        mutex0 = mutex0->owner_next;
    64b0:	9b07      	ldr	r3, [sp, #28]
    64b2:	695b      	ldr	r3, [r3, #20]
    64b4:	9307      	str	r3, [sp, #28]
      while (mutex0 != NULL) {
    64b6:	9b07      	ldr	r3, [sp, #28]
    64b8:	2b00      	cmp	r3, #0
    64ba:	d1e7      	bne.n	648c <svcRtxMutexRelease+0xfe>
      }
      runnig_thread->priority = priority;
    64bc:	9b04      	ldr	r3, [sp, #16]
    64be:	f89d 201b 	ldrb.w	r2, [sp, #27]
    64c2:	f883 2020 	strb.w	r2, [r3, #32]
    }

    // Check if Thread is waiting for a Mutex
    if (mutex->thread_list != NULL) {
    64c6:	9b05      	ldr	r3, [sp, #20]
    64c8:	689b      	ldr	r3, [r3, #8]
    64ca:	2b00      	cmp	r3, #0
    64cc:	d020      	beq.n	6510 <svcRtxMutexRelease+0x182>
      // Wakeup waiting Thread with highest Priority
      thread = osRtxThreadListGet(osRtxObject(mutex));
    64ce:	9805      	ldr	r0, [sp, #20]
    64d0:	f7ff fdc1 	bl	6056 <osRtxObject>
    64d4:	4603      	mov	r3, r0
    64d6:	4618      	mov	r0, r3
    64d8:	f000 fb72 	bl	6bc0 <osRtxThreadListGet>
    64dc:	9003      	str	r0, [sp, #12]
      osRtxThreadWaitExit(thread, (uint32_t)osOK, FALSE);
    64de:	2200      	movs	r2, #0
    64e0:	2100      	movs	r1, #0
    64e2:	9803      	ldr	r0, [sp, #12]
    64e4:	f000 fe0c 	bl	7100 <osRtxThreadWaitExit>
      // Thread is the new Mutex owner
      mutex->owner_thread = thread;
    64e8:	9b05      	ldr	r3, [sp, #20]
    64ea:	9a03      	ldr	r2, [sp, #12]
    64ec:	60da      	str	r2, [r3, #12]
      mutex->owner_next   = thread->mutex_list;
    64ee:	9b03      	ldr	r3, [sp, #12]
    64f0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    64f2:	9b05      	ldr	r3, [sp, #20]
    64f4:	615a      	str	r2, [r3, #20]
      mutex->owner_prev   = NULL;
    64f6:	9b05      	ldr	r3, [sp, #20]
    64f8:	2200      	movs	r2, #0
    64fa:	611a      	str	r2, [r3, #16]
      thread->mutex_list  = mutex;
    64fc:	9b03      	ldr	r3, [sp, #12]
    64fe:	9a05      	ldr	r2, [sp, #20]
    6500:	62da      	str	r2, [r3, #44]	; 0x2c
      mutex->lock = 1U;
    6502:	9b05      	ldr	r3, [sp, #20]
    6504:	2201      	movs	r2, #1
    6506:	761a      	strb	r2, [r3, #24]
      EvrRtxMutexAcquired(mutex, 1U);
    6508:	2101      	movs	r1, #1
    650a:	9805      	ldr	r0, [sp, #20]
    650c:	f7fe f947 	bl	479e <EvrRtxMutexAcquired>
    }

    osRtxThreadDispatch(NULL);
    6510:	2000      	movs	r0, #0
    6512:	f000 fda9 	bl	7068 <osRtxThreadDispatch>
  }

  return osOK;
    6516:	2300      	movs	r3, #0
}
    6518:	4618      	mov	r0, r3
    651a:	b009      	add	sp, #36	; 0x24
    651c:	f85d fb04 	ldr.w	pc, [sp], #4

00006520 <osMutexNew>:


//  ==== Public API ====

/// Create and Initialize a Mutex object.
osMutexId_t osMutexNew (const osMutexAttr_t *attr) {
    6520:	b500      	push	{lr}
    6522:	b085      	sub	sp, #20
    6524:	9001      	str	r0, [sp, #4]
  osMutexId_t mutex_id;

  EvrRtxMutexNew(attr);
    6526:	9801      	ldr	r0, [sp, #4]
    6528:	f7fe f91d 	bl	4766 <EvrRtxMutexNew>
  if (IsIrqMode() || IsIrqMasked()) {
    652c:	f7ff fd6a 	bl	6004 <IsIrqMode>
    6530:	4603      	mov	r3, r0
    6532:	2b00      	cmp	r3, #0
    6534:	d104      	bne.n	6540 <osMutexNew+0x20>
    6536:	f7ff fd72 	bl	601e <IsIrqMasked>
    653a:	4603      	mov	r3, r0
    653c:	2b00      	cmp	r3, #0
    653e:	d007      	beq.n	6550 <osMutexNew+0x30>
    EvrRtxMutexError(NULL, (int32_t)osErrorISR);
    6540:	f06f 0105 	mvn.w	r1, #5
    6544:	2000      	movs	r0, #0
    6546:	f7fd ffaf 	bl	44a8 <EvrRtxMutexError>
    mutex_id = NULL;
    654a:	2300      	movs	r3, #0
    654c:	9303      	str	r3, [sp, #12]
    654e:	e008      	b.n	6562 <osMutexNew+0x42>
    6550:	9b01      	ldr	r3, [sp, #4]
    6552:	9302      	str	r3, [sp, #8]
SVC0_1(MutexNew,      osMutexId_t,  const osMutexAttr_t *)
    6554:	9b02      	ldr	r3, [sp, #8]
    6556:	4618      	mov	r0, r3
    6558:	4b04      	ldr	r3, [pc, #16]	; (656c <osMutexNew+0x4c>)
    655a:	469c      	mov	ip, r3
    655c:	df00      	svc	0
    655e:	4603      	mov	r3, r0
  } else {
    mutex_id = __svcMutexNew(attr);
    6560:	9303      	str	r3, [sp, #12]
  }
  return mutex_id;
    6562:	9b03      	ldr	r3, [sp, #12]
}
    6564:	4618      	mov	r0, r3
    6566:	b005      	add	sp, #20
    6568:	f85d fb04 	ldr.w	pc, [sp], #4
    656c:	000060f9 	.word	0x000060f9

00006570 <osMutexAcquire>:
  }
  return name;
}

/// Acquire a Mutex or timeout if it is locked.
osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
    6570:	b500      	push	{lr}
    6572:	b087      	sub	sp, #28
    6574:	9001      	str	r0, [sp, #4]
    6576:	9100      	str	r1, [sp, #0]
  osStatus_t status;

  EvrRtxMutexAcquire(mutex_id, timeout);
    6578:	9900      	ldr	r1, [sp, #0]
    657a:	9801      	ldr	r0, [sp, #4]
    657c:	f7fe f8fe 	bl	477c <EvrRtxMutexAcquire>
  if (IsIrqMode() || IsIrqMasked()) {
    6580:	f7ff fd40 	bl	6004 <IsIrqMode>
    6584:	4603      	mov	r3, r0
    6586:	2b00      	cmp	r3, #0
    6588:	d104      	bne.n	6594 <osMutexAcquire+0x24>
    658a:	f7ff fd48 	bl	601e <IsIrqMasked>
    658e:	4603      	mov	r3, r0
    6590:	2b00      	cmp	r3, #0
    6592:	d008      	beq.n	65a6 <osMutexAcquire+0x36>
    EvrRtxMutexError(mutex_id, (int32_t)osErrorISR);
    6594:	f06f 0105 	mvn.w	r1, #5
    6598:	9801      	ldr	r0, [sp, #4]
    659a:	f7fd ff85 	bl	44a8 <EvrRtxMutexError>
    status = osErrorISR;
    659e:	f06f 0305 	mvn.w	r3, #5
    65a2:	9305      	str	r3, [sp, #20]
    65a4:	e00b      	b.n	65be <osMutexAcquire+0x4e>
    65a6:	9b01      	ldr	r3, [sp, #4]
    65a8:	9304      	str	r3, [sp, #16]
    65aa:	9b00      	ldr	r3, [sp, #0]
    65ac:	9303      	str	r3, [sp, #12]
SVC0_2(MutexAcquire,  osStatus_t,   osMutexId_t, uint32_t)
    65ae:	9b04      	ldr	r3, [sp, #16]
    65b0:	4618      	mov	r0, r3
    65b2:	9903      	ldr	r1, [sp, #12]
    65b4:	4b04      	ldr	r3, [pc, #16]	; (65c8 <osMutexAcquire+0x58>)
    65b6:	469c      	mov	ip, r3
    65b8:	df00      	svc	0
    65ba:	4603      	mov	r3, r0
  } else {
    status = __svcMutexAcquire(mutex_id, timeout);
    65bc:	9305      	str	r3, [sp, #20]
  }
  return status;
    65be:	9b05      	ldr	r3, [sp, #20]
}
    65c0:	4618      	mov	r0, r3
    65c2:	b007      	add	sp, #28
    65c4:	f85d fb04 	ldr.w	pc, [sp], #4
    65c8:	0000620d 	.word	0x0000620d

000065cc <osMutexRelease>:

/// Release a Mutex that was acquired by \ref osMutexAcquire.
osStatus_t osMutexRelease (osMutexId_t mutex_id) {
    65cc:	b500      	push	{lr}
    65ce:	b085      	sub	sp, #20
    65d0:	9001      	str	r0, [sp, #4]
  osStatus_t status;

  EvrRtxMutexRelease(mutex_id);
    65d2:	9801      	ldr	r0, [sp, #4]
    65d4:	f7fe f8ee 	bl	47b4 <EvrRtxMutexRelease>
  if (IsIrqMode() || IsIrqMasked()) {
    65d8:	f7ff fd14 	bl	6004 <IsIrqMode>
    65dc:	4603      	mov	r3, r0
    65de:	2b00      	cmp	r3, #0
    65e0:	d104      	bne.n	65ec <osMutexRelease+0x20>
    65e2:	f7ff fd1c 	bl	601e <IsIrqMasked>
    65e6:	4603      	mov	r3, r0
    65e8:	2b00      	cmp	r3, #0
    65ea:	d008      	beq.n	65fe <osMutexRelease+0x32>
    EvrRtxMutexError(mutex_id, (int32_t)osErrorISR);
    65ec:	f06f 0105 	mvn.w	r1, #5
    65f0:	9801      	ldr	r0, [sp, #4]
    65f2:	f7fd ff59 	bl	44a8 <EvrRtxMutexError>
    status = osErrorISR;
    65f6:	f06f 0305 	mvn.w	r3, #5
    65fa:	9303      	str	r3, [sp, #12]
    65fc:	e008      	b.n	6610 <osMutexRelease+0x44>
    65fe:	9b01      	ldr	r3, [sp, #4]
    6600:	9302      	str	r3, [sp, #8]
SVC0_1(MutexRelease,  osStatus_t,   osMutexId_t)
    6602:	9b02      	ldr	r3, [sp, #8]
    6604:	4618      	mov	r0, r3
    6606:	4b05      	ldr	r3, [pc, #20]	; (661c <osMutexRelease+0x50>)
    6608:	469c      	mov	ip, r3
    660a:	df00      	svc	0
    660c:	4603      	mov	r3, r0
  } else {
    status = __svcMutexRelease(mutex_id);
    660e:	9303      	str	r3, [sp, #12]
  }
  return status;
    6610:	9b03      	ldr	r3, [sp, #12]
}
    6612:	4618      	mov	r0, r3
    6614:	b005      	add	sp, #20
    6616:	f85d fb04 	ldr.w	pc, [sp], #4
    661a:	bf00      	nop
    661c:	0000638f 	.word	0x0000638f

00006620 <SetPendSV>:
  SCB->ICSR = SCB_ICSR_PENDSVSET_Msk;
    6620:	4b02      	ldr	r3, [pc, #8]	; (662c <SetPendSV+0xc>)
    6622:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    6626:	605a      	str	r2, [r3, #4]
}
    6628:	bf00      	nop
    662a:	4770      	bx	lr
    662c:	e000ed00 	.word	0xe000ed00

00006630 <atomic_inc16_lt>:
__STATIC_INLINE uint16_t atomic_inc16_lt (uint16_t *mem, uint16_t max) {
    6630:	b410      	push	{r4}
    6632:	b083      	sub	sp, #12
    6634:	9001      	str	r0, [sp, #4]
    6636:	460b      	mov	r3, r1
    6638:	f8ad 3002 	strh.w	r3, [sp, #2]
  __ASM volatile (
    663c:	9b01      	ldr	r3, [sp, #4]
    663e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    6642:	e8d3 1f5f 	ldrexh	r1, [r3]
    6646:	428a      	cmp	r2, r1
    6648:	d802      	bhi.n	6650 <atomic_inc16_lt+0x20>
    664a:	f3bf 8f2f 	clrex
    664e:	e004      	b.n	665a <atomic_inc16_lt+0x2a>
    6650:	1c48      	adds	r0, r1, #1
    6652:	e8c3 0f54 	strexh	r4, r0, [r3]
    6656:	b104      	cbz	r4, 665a <atomic_inc16_lt+0x2a>
    6658:	e7f3      	b.n	6642 <atomic_inc16_lt+0x12>
    665a:	b28c      	uxth	r4, r1
  return ret;
    665c:	4623      	mov	r3, r4
}
    665e:	4618      	mov	r0, r3
    6660:	b003      	add	sp, #12
    6662:	f85d 4b04 	ldr.w	r4, [sp], #4
    6666:	4770      	bx	lr

00006668 <atomic_inc16_lim>:
__STATIC_INLINE uint16_t atomic_inc16_lim (uint16_t *mem, uint16_t lim) {
    6668:	b410      	push	{r4}
    666a:	b083      	sub	sp, #12
    666c:	9001      	str	r0, [sp, #4]
    666e:	460b      	mov	r3, r1
    6670:	f8ad 3002 	strh.w	r3, [sp, #2]
  __ASM volatile (
    6674:	9b01      	ldr	r3, [sp, #4]
    6676:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    667a:	e8d3 1f5f 	ldrexh	r1, [r3]
    667e:	1c48      	adds	r0, r1, #1
    6680:	4282      	cmp	r2, r0
    6682:	d800      	bhi.n	6686 <atomic_inc16_lim+0x1e>
    6684:	2000      	movs	r0, #0
    6686:	e8c3 0f54 	strexh	r4, r0, [r3]
    668a:	b104      	cbz	r4, 668e <atomic_inc16_lim+0x26>
    668c:	e7f5      	b.n	667a <atomic_inc16_lim+0x12>
    668e:	b28c      	uxth	r4, r1
  return ret;
    6690:	4623      	mov	r3, r4
}
    6692:	4618      	mov	r0, r3
    6694:	b003      	add	sp, #12
    6696:	f85d 4b04 	ldr.w	r4, [sp], #4
    669a:	4770      	bx	lr

0000669c <atomic_dec16_nz>:
__STATIC_INLINE uint16_t atomic_dec16_nz (uint16_t *mem) {
    669c:	b410      	push	{r4}
    669e:	b083      	sub	sp, #12
    66a0:	9001      	str	r0, [sp, #4]
  __ASM volatile (
    66a2:	9b01      	ldr	r3, [sp, #4]
    66a4:	e8d3 2f5f 	ldrexh	r2, [r3]
    66a8:	b912      	cbnz	r2, 66b0 <atomic_dec16_nz+0x14>
    66aa:	f3bf 8f2f 	clrex
    66ae:	e004      	b.n	66ba <atomic_dec16_nz+0x1e>
    66b0:	1e51      	subs	r1, r2, #1
    66b2:	e8c3 1f50 	strexh	r0, r1, [r3]
    66b6:	b100      	cbz	r0, 66ba <atomic_dec16_nz+0x1e>
    66b8:	e7f4      	b.n	66a4 <atomic_dec16_nz+0x8>
    66ba:	b294      	uxth	r4, r2
  return ret;
    66bc:	4623      	mov	r3, r4
}
    66be:	4618      	mov	r0, r3
    66c0:	b003      	add	sp, #12
    66c2:	f85d 4b04 	ldr.w	r4, [sp], #4
    66c6:	4770      	bx	lr

000066c8 <osRtxObject>:
__STATIC_INLINE os_object_t *osRtxObject (void *object) {
    66c8:	b082      	sub	sp, #8
    66ca:	9001      	str	r0, [sp, #4]
  return ((os_object_t *)object);
    66cc:	9b01      	ldr	r3, [sp, #4]
}
    66ce:	4618      	mov	r0, r3
    66d0:	b002      	add	sp, #8
    66d2:	4770      	bx	lr

000066d4 <osRtxThreadObject>:
__STATIC_INLINE os_thread_t *osRtxThreadObject (os_object_t *object) {
    66d4:	b082      	sub	sp, #8
    66d6:	9001      	str	r0, [sp, #4]
  return ((os_thread_t *)object);
    66d8:	9b01      	ldr	r3, [sp, #4]
}
    66da:	4618      	mov	r0, r3
    66dc:	b002      	add	sp, #8
    66de:	4770      	bx	lr

000066e0 <osRtxEventFlagsObject>:
__STATIC_INLINE os_event_flags_t *osRtxEventFlagsObject (os_object_t *object) {
    66e0:	b082      	sub	sp, #8
    66e2:	9001      	str	r0, [sp, #4]
  return ((os_event_flags_t *)object);
    66e4:	9b01      	ldr	r3, [sp, #4]
}
    66e6:	4618      	mov	r0, r3
    66e8:	b002      	add	sp, #8
    66ea:	4770      	bx	lr

000066ec <osRtxSemaphoreObject>:
__STATIC_INLINE os_semaphore_t *osRtxSemaphoreObject (os_object_t *object) {
    66ec:	b082      	sub	sp, #8
    66ee:	9001      	str	r0, [sp, #4]
  return ((os_semaphore_t *)object);
    66f0:	9b01      	ldr	r3, [sp, #4]
}
    66f2:	4618      	mov	r0, r3
    66f4:	b002      	add	sp, #8
    66f6:	4770      	bx	lr

000066f8 <osRtxMemoryPoolObject>:
__STATIC_INLINE os_memory_pool_t *osRtxMemoryPoolObject (os_object_t *object) {
    66f8:	b082      	sub	sp, #8
    66fa:	9001      	str	r0, [sp, #4]
  return ((os_memory_pool_t *)object);
    66fc:	9b01      	ldr	r3, [sp, #4]
}
    66fe:	4618      	mov	r0, r3
    6700:	b002      	add	sp, #8
    6702:	4770      	bx	lr

00006704 <osRtxMessageObject>:
__STATIC_INLINE os_message_t *osRtxMessageObject (os_object_t *object) {
    6704:	b082      	sub	sp, #8
    6706:	9001      	str	r0, [sp, #4]
  return ((os_message_t *)object);
    6708:	9b01      	ldr	r3, [sp, #4]
}
    670a:	4618      	mov	r0, r3
    670c:	b002      	add	sp, #8
    670e:	4770      	bx	lr

00006710 <osRtxKernelGetState>:
  return osRtxInfo.kernel.state;
    6710:	4b01      	ldr	r3, [pc, #4]	; (6718 <osRtxKernelGetState+0x8>)
    6712:	7a1b      	ldrb	r3, [r3, #8]
}
    6714:	4618      	mov	r0, r3
    6716:	4770      	bx	lr
    6718:	20000110 	.word	0x20000110

0000671c <isr_queue_put>:
//  ==== Helper functions ====

/// Put Object into ISR Queue.
/// \param[in]  object          object.
/// \return 1 - success, 0 - failure.
static uint32_t isr_queue_put (os_object_t *object) {
    671c:	b500      	push	{lr}
    671e:	b087      	sub	sp, #28
    6720:	9001      	str	r0, [sp, #4]
  uint32_t n;
#endif
  uint16_t max;
  uint32_t ret;

  max = osRtxInfo.isr_queue.max;
    6722:	4b15      	ldr	r3, [pc, #84]	; (6778 <isr_queue_put+0x5c>)
    6724:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
    6728:	f8ad 3012 	strh.w	r3, [sp, #18]

  if (primask == 0U) {
    __enable_irq();
  }
#else
  if (atomic_inc16_lt(&osRtxInfo.isr_queue.cnt, max) < max) {
    672c:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    6730:	4619      	mov	r1, r3
    6732:	4812      	ldr	r0, [pc, #72]	; (677c <isr_queue_put+0x60>)
    6734:	f7ff ff7c 	bl	6630 <atomic_inc16_lt>
    6738:	4603      	mov	r3, r0
    673a:	461a      	mov	r2, r3
    673c:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    6740:	4293      	cmp	r3, r2
    6742:	d911      	bls.n	6768 <isr_queue_put+0x4c>
    n = atomic_inc16_lim(&osRtxInfo.isr_queue.in, max);
    6744:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    6748:	4619      	mov	r1, r3
    674a:	480d      	ldr	r0, [pc, #52]	; (6780 <isr_queue_put+0x64>)
    674c:	f7ff ff8c 	bl	6668 <atomic_inc16_lim>
    6750:	4603      	mov	r3, r0
    6752:	9303      	str	r3, [sp, #12]
    osRtxInfo.isr_queue.data[n] = object;
    6754:	4b08      	ldr	r3, [pc, #32]	; (6778 <isr_queue_put+0x5c>)
    6756:	6dda      	ldr	r2, [r3, #92]	; 0x5c
    6758:	9b03      	ldr	r3, [sp, #12]
    675a:	009b      	lsls	r3, r3, #2
    675c:	4413      	add	r3, r2
    675e:	9a01      	ldr	r2, [sp, #4]
    6760:	601a      	str	r2, [r3, #0]
    ret = 1U;
    6762:	2301      	movs	r3, #1
    6764:	9305      	str	r3, [sp, #20]
    6766:	e001      	b.n	676c <isr_queue_put+0x50>
  } else {
    ret = 0U;
    6768:	2300      	movs	r3, #0
    676a:	9305      	str	r3, [sp, #20]
  }
#endif

  return ret;
    676c:	9b05      	ldr	r3, [sp, #20]
}
    676e:	4618      	mov	r0, r3
    6770:	b007      	add	sp, #28
    6772:	f85d fb04 	ldr.w	pc, [sp], #4
    6776:	bf00      	nop
    6778:	20000110 	.word	0x20000110
    677c:	20000166 	.word	0x20000166
    6780:	20000168 	.word	0x20000168

00006784 <isr_queue_get>:

/// Get Object from ISR Queue.
/// \return object or NULL.
static os_object_t *isr_queue_get (void) {
    6784:	b500      	push	{lr}
    6786:	b085      	sub	sp, #20
  uint32_t     n;
#endif
  uint16_t     max;
  os_object_t *ret;

  max = osRtxInfo.isr_queue.max;
    6788:	4b12      	ldr	r3, [pc, #72]	; (67d4 <isr_queue_get+0x50>)
    678a:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
    678e:	f8ad 300a 	strh.w	r3, [sp, #10]

  if (primask == 0U) {
    __enable_irq();
  }
#else
  if (atomic_dec16_nz(&osRtxInfo.isr_queue.cnt) != 0U) {
    6792:	4811      	ldr	r0, [pc, #68]	; (67d8 <isr_queue_get+0x54>)
    6794:	f7ff ff82 	bl	669c <atomic_dec16_nz>
    6798:	4603      	mov	r3, r0
    679a:	2b00      	cmp	r3, #0
    679c:	d012      	beq.n	67c4 <isr_queue_get+0x40>
    n = atomic_inc16_lim(&osRtxInfo.isr_queue.out, max);
    679e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    67a2:	4619      	mov	r1, r3
    67a4:	480d      	ldr	r0, [pc, #52]	; (67dc <isr_queue_get+0x58>)
    67a6:	f7ff ff5f 	bl	6668 <atomic_inc16_lim>
    67aa:	4603      	mov	r3, r0
    67ac:	9301      	str	r3, [sp, #4]
    ret = osRtxObject(osRtxInfo.isr_queue.data[n]);
    67ae:	4b09      	ldr	r3, [pc, #36]	; (67d4 <isr_queue_get+0x50>)
    67b0:	6dda      	ldr	r2, [r3, #92]	; 0x5c
    67b2:	9b01      	ldr	r3, [sp, #4]
    67b4:	009b      	lsls	r3, r3, #2
    67b6:	4413      	add	r3, r2
    67b8:	681b      	ldr	r3, [r3, #0]
    67ba:	4618      	mov	r0, r3
    67bc:	f7ff ff84 	bl	66c8 <osRtxObject>
    67c0:	9003      	str	r0, [sp, #12]
    67c2:	e001      	b.n	67c8 <isr_queue_get+0x44>
  } else {
    ret = NULL;
    67c4:	2300      	movs	r3, #0
    67c6:	9303      	str	r3, [sp, #12]
  }
#endif

  return ret;
    67c8:	9b03      	ldr	r3, [sp, #12]
}
    67ca:	4618      	mov	r0, r3
    67cc:	b005      	add	sp, #20
    67ce:	f85d fb04 	ldr.w	pc, [sp], #4
    67d2:	bf00      	nop
    67d4:	20000110 	.word	0x20000110
    67d8:	20000166 	.word	0x20000166
    67dc:	2000016a 	.word	0x2000016a

000067e0 <osRtxTick_Handler>:

/// Tick Handler.
//lint -esym(714,osRtxTick_Handler) "Referenced by Exception handlers"
//lint -esym(759,osRtxTick_Handler) "Prototype in header"
//lint -esym(765,osRtxTick_Handler) "Global scope"
void osRtxTick_Handler (void) {
    67e0:	b500      	push	{lr}
    67e2:	b083      	sub	sp, #12
  os_thread_t *thread;

  OS_Tick_AcknowledgeIRQ();
    67e4:	f001 fb6c 	bl	7ec0 <OS_Tick_AcknowledgeIRQ>
  osRtxInfo.kernel.tick++;
    67e8:	4b2f      	ldr	r3, [pc, #188]	; (68a8 <osRtxTick_Handler+0xc8>)
    67ea:	68db      	ldr	r3, [r3, #12]
    67ec:	3301      	adds	r3, #1
    67ee:	4a2e      	ldr	r2, [pc, #184]	; (68a8 <osRtxTick_Handler+0xc8>)
    67f0:	60d3      	str	r3, [r2, #12]

  // Process Timers
  if (osRtxInfo.timer.tick != NULL) {
    67f2:	4b2d      	ldr	r3, [pc, #180]	; (68a8 <osRtxTick_Handler+0xc8>)
    67f4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    67f6:	2b00      	cmp	r3, #0
    67f8:	d002      	beq.n	6800 <osRtxTick_Handler+0x20>
    osRtxInfo.timer.tick();
    67fa:	4b2b      	ldr	r3, [pc, #172]	; (68a8 <osRtxTick_Handler+0xc8>)
    67fc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    67fe:	4798      	blx	r3
  }

  // Process Thread Delays
  osRtxThreadDelayTick();
    6800:	f000 fb1e 	bl	6e40 <osRtxThreadDelayTick>

  osRtxThreadDispatch(NULL);
    6804:	2000      	movs	r0, #0
    6806:	f000 fc2f 	bl	7068 <osRtxThreadDispatch>

  // Check Round Robin timeout
  if (osRtxInfo.thread.robin.timeout != 0U) {
    680a:	4b27      	ldr	r3, [pc, #156]	; (68a8 <osRtxTick_Handler+0xc8>)
    680c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    680e:	2b00      	cmp	r3, #0
    6810:	d046      	beq.n	68a0 <osRtxTick_Handler+0xc0>
    if (osRtxInfo.thread.robin.thread != osRtxInfo.thread.run.next) {
    6812:	4b25      	ldr	r3, [pc, #148]	; (68a8 <osRtxTick_Handler+0xc8>)
    6814:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    6816:	4b24      	ldr	r3, [pc, #144]	; (68a8 <osRtxTick_Handler+0xc8>)
    6818:	699b      	ldr	r3, [r3, #24]
    681a:	429a      	cmp	r2, r3
    681c:	d008      	beq.n	6830 <osRtxTick_Handler+0x50>
      // Reset Round Robin
      osRtxInfo.thread.robin.thread = osRtxInfo.thread.run.next;
    681e:	4b22      	ldr	r3, [pc, #136]	; (68a8 <osRtxTick_Handler+0xc8>)
    6820:	699b      	ldr	r3, [r3, #24]
    6822:	4a21      	ldr	r2, [pc, #132]	; (68a8 <osRtxTick_Handler+0xc8>)
    6824:	6393      	str	r3, [r2, #56]	; 0x38
      osRtxInfo.thread.robin.tick   = osRtxInfo.thread.robin.timeout;
    6826:	4b20      	ldr	r3, [pc, #128]	; (68a8 <osRtxTick_Handler+0xc8>)
    6828:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    682a:	4a1f      	ldr	r2, [pc, #124]	; (68a8 <osRtxTick_Handler+0xc8>)
    682c:	63d3      	str	r3, [r2, #60]	; 0x3c
          }
        }
      }
    }
  }
}
    682e:	e037      	b.n	68a0 <osRtxTick_Handler+0xc0>
      if (osRtxInfo.thread.robin.tick != 0U) {
    6830:	4b1d      	ldr	r3, [pc, #116]	; (68a8 <osRtxTick_Handler+0xc8>)
    6832:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    6834:	2b00      	cmp	r3, #0
    6836:	d004      	beq.n	6842 <osRtxTick_Handler+0x62>
        osRtxInfo.thread.robin.tick--;
    6838:	4b1b      	ldr	r3, [pc, #108]	; (68a8 <osRtxTick_Handler+0xc8>)
    683a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    683c:	3b01      	subs	r3, #1
    683e:	4a1a      	ldr	r2, [pc, #104]	; (68a8 <osRtxTick_Handler+0xc8>)
    6840:	63d3      	str	r3, [r2, #60]	; 0x3c
      if (osRtxInfo.thread.robin.tick == 0U) {
    6842:	4b19      	ldr	r3, [pc, #100]	; (68a8 <osRtxTick_Handler+0xc8>)
    6844:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    6846:	2b00      	cmp	r3, #0
    6848:	d12a      	bne.n	68a0 <osRtxTick_Handler+0xc0>
        if (osRtxKernelGetState() == osRtxKernelRunning) {
    684a:	f7ff ff61 	bl	6710 <osRtxKernelGetState>
    684e:	4603      	mov	r3, r0
    6850:	2b02      	cmp	r3, #2
    6852:	d125      	bne.n	68a0 <osRtxTick_Handler+0xc0>
          thread = osRtxInfo.thread.ready.thread_list;
    6854:	4b14      	ldr	r3, [pc, #80]	; (68a8 <osRtxTick_Handler+0xc8>)
    6856:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6858:	9301      	str	r3, [sp, #4]
          if ((thread != NULL) && (thread->priority == osRtxInfo.thread.robin.thread->priority)) {
    685a:	9b01      	ldr	r3, [sp, #4]
    685c:	2b00      	cmp	r3, #0
    685e:	d01f      	beq.n	68a0 <osRtxTick_Handler+0xc0>
    6860:	9b01      	ldr	r3, [sp, #4]
    6862:	f993 2020 	ldrsb.w	r2, [r3, #32]
    6866:	4b10      	ldr	r3, [pc, #64]	; (68a8 <osRtxTick_Handler+0xc8>)
    6868:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    686a:	f993 3020 	ldrsb.w	r3, [r3, #32]
    686e:	429a      	cmp	r2, r3
    6870:	d116      	bne.n	68a0 <osRtxTick_Handler+0xc0>
            osRtxThreadListRemove(thread);
    6872:	9801      	ldr	r0, [sp, #4]
    6874:	f000 f9f8 	bl	6c68 <osRtxThreadListRemove>
            osRtxThreadReadyPut(osRtxInfo.thread.robin.thread);
    6878:	4b0b      	ldr	r3, [pc, #44]	; (68a8 <osRtxTick_Handler+0xc8>)
    687a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    687c:	4618      	mov	r0, r3
    687e:	f000 fa0d 	bl	6c9c <osRtxThreadReadyPut>
            EvrRtxThreadPreempted(osRtxInfo.thread.robin.thread);
    6882:	4b09      	ldr	r3, [pc, #36]	; (68a8 <osRtxTick_Handler+0xc8>)
    6884:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    6886:	4618      	mov	r0, r3
    6888:	f7fd ff37 	bl	46fa <EvrRtxThreadPreempted>
            osRtxThreadSwitch(thread);
    688c:	9801      	ldr	r0, [sp, #4]
    688e:	f000 fbad 	bl	6fec <osRtxThreadSwitch>
            osRtxInfo.thread.robin.thread = thread;
    6892:	4a05      	ldr	r2, [pc, #20]	; (68a8 <osRtxTick_Handler+0xc8>)
    6894:	9b01      	ldr	r3, [sp, #4]
    6896:	6393      	str	r3, [r2, #56]	; 0x38
            osRtxInfo.thread.robin.tick   = osRtxInfo.thread.robin.timeout;
    6898:	4b03      	ldr	r3, [pc, #12]	; (68a8 <osRtxTick_Handler+0xc8>)
    689a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    689c:	4a02      	ldr	r2, [pc, #8]	; (68a8 <osRtxTick_Handler+0xc8>)
    689e:	63d3      	str	r3, [r2, #60]	; 0x3c
}
    68a0:	bf00      	nop
    68a2:	b003      	add	sp, #12
    68a4:	f85d fb04 	ldr.w	pc, [sp], #4
    68a8:	20000110 	.word	0x20000110

000068ac <osRtxPendSV_Handler>:

/// Pending Service Call Handler.
//lint -esym(714,osRtxPendSV_Handler) "Referenced by Exception handlers"
//lint -esym(759,osRtxPendSV_Handler) "Prototype in header"
//lint -esym(765,osRtxPendSV_Handler) "Global scope"
void osRtxPendSV_Handler (void) {
    68ac:	b510      	push	{r4, lr}
    68ae:	b082      	sub	sp, #8
  os_object_t *object;

  for (;;) {
    object = isr_queue_get();
    68b0:	f7ff ff68 	bl	6784 <isr_queue_get>
    68b4:	9001      	str	r0, [sp, #4]
    if (object == NULL) {
    68b6:	9b01      	ldr	r3, [sp, #4]
    68b8:	2b00      	cmp	r3, #0
    68ba:	d044      	beq.n	6946 <osRtxPendSV_Handler+0x9a>
      break;
    }
    switch (object->id) {
    68bc:	9b01      	ldr	r3, [sp, #4]
    68be:	781b      	ldrb	r3, [r3, #0]
    68c0:	3b01      	subs	r3, #1
    68c2:	2b06      	cmp	r3, #6
    68c4:	d83d      	bhi.n	6942 <osRtxPendSV_Handler+0x96>
    68c6:	a201      	add	r2, pc, #4	; (adr r2, 68cc <osRtxPendSV_Handler+0x20>)
    68c8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    68cc:	000068e9 	.word	0x000068e9
    68d0:	00006943 	.word	0x00006943
    68d4:	000068fb 	.word	0x000068fb
    68d8:	00006943 	.word	0x00006943
    68dc:	0000690d 	.word	0x0000690d
    68e0:	0000691f 	.word	0x0000691f
    68e4:	00006931 	.word	0x00006931
      case osRtxIdThread:
        osRtxInfo.post_process.thread(osRtxThreadObject(object));
    68e8:	4b1a      	ldr	r3, [pc, #104]	; (6954 <osRtxPendSV_Handler+0xa8>)
    68ea:	6e1c      	ldr	r4, [r3, #96]	; 0x60
    68ec:	9801      	ldr	r0, [sp, #4]
    68ee:	f7ff fef1 	bl	66d4 <osRtxThreadObject>
    68f2:	4603      	mov	r3, r0
    68f4:	4618      	mov	r0, r3
    68f6:	47a0      	blx	r4
        break;
    68f8:	e024      	b.n	6944 <osRtxPendSV_Handler+0x98>
      case osRtxIdEventFlags:
        osRtxInfo.post_process.event_flags(osRtxEventFlagsObject(object));
    68fa:	4b16      	ldr	r3, [pc, #88]	; (6954 <osRtxPendSV_Handler+0xa8>)
    68fc:	6e5c      	ldr	r4, [r3, #100]	; 0x64
    68fe:	9801      	ldr	r0, [sp, #4]
    6900:	f7ff feee 	bl	66e0 <osRtxEventFlagsObject>
    6904:	4603      	mov	r3, r0
    6906:	4618      	mov	r0, r3
    6908:	47a0      	blx	r4
        break;
    690a:	e01b      	b.n	6944 <osRtxPendSV_Handler+0x98>
      case osRtxIdSemaphore:
        osRtxInfo.post_process.semaphore(osRtxSemaphoreObject(object));
    690c:	4b11      	ldr	r3, [pc, #68]	; (6954 <osRtxPendSV_Handler+0xa8>)
    690e:	6e9c      	ldr	r4, [r3, #104]	; 0x68
    6910:	9801      	ldr	r0, [sp, #4]
    6912:	f7ff feeb 	bl	66ec <osRtxSemaphoreObject>
    6916:	4603      	mov	r3, r0
    6918:	4618      	mov	r0, r3
    691a:	47a0      	blx	r4
        break;
    691c:	e012      	b.n	6944 <osRtxPendSV_Handler+0x98>
      case osRtxIdMemoryPool:
        osRtxInfo.post_process.memory_pool(osRtxMemoryPoolObject(object));
    691e:	4b0d      	ldr	r3, [pc, #52]	; (6954 <osRtxPendSV_Handler+0xa8>)
    6920:	6edc      	ldr	r4, [r3, #108]	; 0x6c
    6922:	9801      	ldr	r0, [sp, #4]
    6924:	f7ff fee8 	bl	66f8 <osRtxMemoryPoolObject>
    6928:	4603      	mov	r3, r0
    692a:	4618      	mov	r0, r3
    692c:	47a0      	blx	r4
        break;
    692e:	e009      	b.n	6944 <osRtxPendSV_Handler+0x98>
      case osRtxIdMessage:
        osRtxInfo.post_process.message(osRtxMessageObject(object));
    6930:	4b08      	ldr	r3, [pc, #32]	; (6954 <osRtxPendSV_Handler+0xa8>)
    6932:	6f1c      	ldr	r4, [r3, #112]	; 0x70
    6934:	9801      	ldr	r0, [sp, #4]
    6936:	f7ff fee5 	bl	6704 <osRtxMessageObject>
    693a:	4603      	mov	r3, r0
    693c:	4618      	mov	r0, r3
    693e:	47a0      	blx	r4
        break;
    6940:	e000      	b.n	6944 <osRtxPendSV_Handler+0x98>
      default:
        // Should never come here
        break;
    6942:	bf00      	nop
    object = isr_queue_get();
    6944:	e7b4      	b.n	68b0 <osRtxPendSV_Handler+0x4>
      break;
    6946:	bf00      	nop
    }
  }

  osRtxThreadDispatch(NULL);
    6948:	2000      	movs	r0, #0
    694a:	f000 fb8d 	bl	7068 <osRtxThreadDispatch>
}
    694e:	bf00      	nop
    6950:	b002      	add	sp, #8
    6952:	bd10      	pop	{r4, pc}
    6954:	20000110 	.word	0x20000110

00006958 <osRtxPostProcess>:

/// Register post ISR processing.
/// \param[in]  object          generic object.
void osRtxPostProcess (os_object_t *object) {
    6958:	b500      	push	{lr}
    695a:	b083      	sub	sp, #12
    695c:	9001      	str	r0, [sp, #4]

  if (isr_queue_put(object) != 0U) {
    695e:	9801      	ldr	r0, [sp, #4]
    6960:	f7ff fedc 	bl	671c <isr_queue_put>
    6964:	4603      	mov	r3, r0
    6966:	2b00      	cmp	r3, #0
    6968:	d00b      	beq.n	6982 <osRtxPostProcess+0x2a>
    if (osRtxInfo.kernel.blocked == 0U) {
    696a:	4b0a      	ldr	r3, [pc, #40]	; (6994 <osRtxPostProcess+0x3c>)
    696c:	7a5b      	ldrb	r3, [r3, #9]
    696e:	b2db      	uxtb	r3, r3
    6970:	2b00      	cmp	r3, #0
    6972:	d102      	bne.n	697a <osRtxPostProcess+0x22>
      SetPendSV();
    6974:	f7ff fe54 	bl	6620 <SetPendSV>
      osRtxInfo.kernel.pendSV = 1U;
    }
  } else {
    (void)osRtxErrorNotify(osRtxErrorISRQueueOverflow, object);
  }
}
    6978:	e007      	b.n	698a <osRtxPostProcess+0x32>
      osRtxInfo.kernel.pendSV = 1U;
    697a:	4b06      	ldr	r3, [pc, #24]	; (6994 <osRtxPostProcess+0x3c>)
    697c:	2201      	movs	r2, #1
    697e:	729a      	strb	r2, [r3, #10]
}
    6980:	e003      	b.n	698a <osRtxPostProcess+0x32>
    (void)osRtxErrorNotify(osRtxErrorISRQueueOverflow, object);
    6982:	9901      	ldr	r1, [sp, #4]
    6984:	2002      	movs	r0, #2
    6986:	f7fd fcc9 	bl	431c <osRtxErrorNotify>
}
    698a:	bf00      	nop
    698c:	b003      	add	sp, #12
    698e:	f85d fb04 	ldr.w	pc, [sp], #4
    6992:	bf00      	nop
    6994:	20000110 	.word	0x20000110

00006998 <xPSR_InitVal>:
__STATIC_INLINE uint32_t xPSR_InitVal (bool_t privileged, bool_t thumb) {
    6998:	b082      	sub	sp, #8
    699a:	4603      	mov	r3, r0
    699c:	460a      	mov	r2, r1
    699e:	f88d 3007 	strb.w	r3, [sp, #7]
    69a2:	4613      	mov	r3, r2
    69a4:	f88d 3006 	strb.w	r3, [sp, #6]
  return (0x01000000U);
    69a8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
}
    69ac:	4618      	mov	r0, r3
    69ae:	b002      	add	sp, #8
    69b0:	4770      	bx	lr

000069b2 <StackOffsetR0>:
__STATIC_INLINE uint32_t StackOffsetR0 (uint8_t stack_frame) {
    69b2:	b082      	sub	sp, #8
    69b4:	4603      	mov	r3, r0
    69b6:	f88d 3007 	strb.w	r3, [sp, #7]
  return (((stack_frame & 0x10U) == 0U) ? ((16U+8U)*4U) : (8U*4U));
    69ba:	f89d 3007 	ldrb.w	r3, [sp, #7]
    69be:	f003 0310 	and.w	r3, r3, #16
    69c2:	2b00      	cmp	r3, #0
    69c4:	d101      	bne.n	69ca <StackOffsetR0+0x18>
    69c6:	2360      	movs	r3, #96	; 0x60
    69c8:	e000      	b.n	69cc <StackOffsetR0+0x1a>
    69ca:	2320      	movs	r3, #32
}
    69cc:	4618      	mov	r0, r3
    69ce:	b002      	add	sp, #8
    69d0:	4770      	bx	lr

000069d2 <IsIrqMode>:
__STATIC_INLINE bool_t IsIrqMode (void) {
    69d2:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    69d4:	f3ef 8305 	mrs	r3, IPSR
    69d8:	9301      	str	r3, [sp, #4]
  return(result);
    69da:	9b01      	ldr	r3, [sp, #4]
  return (__get_IPSR() != 0U);
    69dc:	2b00      	cmp	r3, #0
    69de:	bf14      	ite	ne
    69e0:	2301      	movne	r3, #1
    69e2:	2300      	moveq	r3, #0
    69e4:	b2db      	uxtb	r3, r3
}
    69e6:	4618      	mov	r0, r3
    69e8:	b002      	add	sp, #8
    69ea:	4770      	bx	lr

000069ec <IsIrqMasked>:
__STATIC_INLINE bool_t IsIrqMasked (void) {
    69ec:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    69ee:	f3ef 8310 	mrs	r3, PRIMASK
    69f2:	9301      	str	r3, [sp, #4]
  return(result);
    69f4:	9b01      	ldr	r3, [sp, #4]
  return ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U));
    69f6:	2b00      	cmp	r3, #0
    69f8:	d105      	bne.n	6a06 <IsIrqMasked+0x1a>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
    69fa:	f3ef 8311 	mrs	r3, BASEPRI
    69fe:	9300      	str	r3, [sp, #0]
  return(result);
    6a00:	9b00      	ldr	r3, [sp, #0]
    6a02:	2b00      	cmp	r3, #0
    6a04:	d001      	beq.n	6a0a <IsIrqMasked+0x1e>
    6a06:	2301      	movs	r3, #1
    6a08:	e000      	b.n	6a0c <IsIrqMasked+0x20>
    6a0a:	2300      	movs	r3, #0
    6a0c:	f003 0301 	and.w	r3, r3, #1
    6a10:	b2db      	uxtb	r3, r3
}
    6a12:	4618      	mov	r0, r3
    6a14:	b002      	add	sp, #8
    6a16:	4770      	bx	lr

00006a18 <atomic_chk32_all>:
__STATIC_INLINE uint32_t atomic_chk32_all (uint32_t *mem, uint32_t bits) {
    6a18:	b410      	push	{r4}
    6a1a:	b083      	sub	sp, #12
    6a1c:	9001      	str	r0, [sp, #4]
    6a1e:	9100      	str	r1, [sp, #0]
  __ASM volatile (
    6a20:	9b01      	ldr	r3, [sp, #4]
    6a22:	9a00      	ldr	r2, [sp, #0]
    6a24:	e853 1f00 	ldrex	r1, [r3]
    6a28:	ea01 0002 	and.w	r0, r1, r2
    6a2c:	4290      	cmp	r0, r2
    6a2e:	d003      	beq.n	6a38 <atomic_chk32_all+0x20>
    6a30:	f3bf 8f2f 	clrex
    6a34:	2100      	movs	r1, #0
    6a36:	e005      	b.n	6a44 <atomic_chk32_all+0x2c>
    6a38:	ea21 0002 	bic.w	r0, r1, r2
    6a3c:	e843 0400 	strex	r4, r0, [r3]
    6a40:	b104      	cbz	r4, 6a44 <atomic_chk32_all+0x2c>
    6a42:	e7ef      	b.n	6a24 <atomic_chk32_all+0xc>
    6a44:	460c      	mov	r4, r1
  return ret;
    6a46:	4623      	mov	r3, r4
}
    6a48:	4618      	mov	r0, r3
    6a4a:	b003      	add	sp, #12
    6a4c:	f85d 4b04 	ldr.w	r4, [sp], #4
    6a50:	4770      	bx	lr

00006a52 <atomic_chk32_any>:
__STATIC_INLINE uint32_t atomic_chk32_any (uint32_t *mem, uint32_t bits) {
    6a52:	b410      	push	{r4}
    6a54:	b083      	sub	sp, #12
    6a56:	9001      	str	r0, [sp, #4]
    6a58:	9100      	str	r1, [sp, #0]
  __ASM volatile (
    6a5a:	9b01      	ldr	r3, [sp, #4]
    6a5c:	9a00      	ldr	r2, [sp, #0]
    6a5e:	e853 1f00 	ldrex	r1, [r3]
    6a62:	4211      	tst	r1, r2
    6a64:	d103      	bne.n	6a6e <atomic_chk32_any+0x1c>
    6a66:	f3bf 8f2f 	clrex
    6a6a:	2100      	movs	r1, #0
    6a6c:	e005      	b.n	6a7a <atomic_chk32_any+0x28>
    6a6e:	ea21 0002 	bic.w	r0, r1, r2
    6a72:	e843 0400 	strex	r4, r0, [r3]
    6a76:	b104      	cbz	r4, 6a7a <atomic_chk32_any+0x28>
    6a78:	e7f1      	b.n	6a5e <atomic_chk32_any+0xc>
    6a7a:	460c      	mov	r4, r1
  return ret;
    6a7c:	4623      	mov	r3, r4
}
    6a7e:	4618      	mov	r0, r3
    6a80:	b003      	add	sp, #12
    6a82:	f85d 4b04 	ldr.w	r4, [sp], #4
    6a86:	4770      	bx	lr

00006a88 <osRtxThreadId>:
__STATIC_INLINE os_thread_t *osRtxThreadId (osThreadId_t thread_id) {
    6a88:	b082      	sub	sp, #8
    6a8a:	9001      	str	r0, [sp, #4]
  return ((os_thread_t *)thread_id);
    6a8c:	9b01      	ldr	r3, [sp, #4]
}
    6a8e:	4618      	mov	r0, r3
    6a90:	b002      	add	sp, #8
    6a92:	4770      	bx	lr

00006a94 <osRtxObject>:
__STATIC_INLINE os_object_t *osRtxObject (void *object) {
    6a94:	b082      	sub	sp, #8
    6a96:	9001      	str	r0, [sp, #4]
  return ((os_object_t *)object);
    6a98:	9b01      	ldr	r3, [sp, #4]
}
    6a9a:	4618      	mov	r0, r3
    6a9c:	b002      	add	sp, #8
    6a9e:	4770      	bx	lr

00006aa0 <osRtxThreadObject>:
__STATIC_INLINE os_thread_t *osRtxThreadObject (os_object_t *object) {
    6aa0:	b082      	sub	sp, #8
    6aa2:	9001      	str	r0, [sp, #4]
  return ((os_thread_t *)object);
    6aa4:	9b01      	ldr	r3, [sp, #4]
}
    6aa6:	4618      	mov	r0, r3
    6aa8:	b002      	add	sp, #8
    6aaa:	4770      	bx	lr

00006aac <osRtxKernelGetState>:
  return osRtxInfo.kernel.state;
    6aac:	4b01      	ldr	r3, [pc, #4]	; (6ab4 <osRtxKernelGetState+0x8>)
    6aae:	7a1b      	ldrb	r3, [r3, #8]
}
    6ab0:	4618      	mov	r0, r3
    6ab2:	4770      	bx	lr
    6ab4:	20000110 	.word	0x20000110

00006ab8 <osRtxThreadGetRunning>:
  return osRtxInfo.thread.run.curr;
    6ab8:	4b01      	ldr	r3, [pc, #4]	; (6ac0 <osRtxThreadGetRunning+0x8>)
    6aba:	695b      	ldr	r3, [r3, #20]
}
    6abc:	4618      	mov	r0, r3
    6abe:	4770      	bx	lr
    6ac0:	20000110 	.word	0x20000110

00006ac4 <osRtxThreadSetRunning>:
__STATIC_INLINE void osRtxThreadSetRunning (os_thread_t *thread) {
    6ac4:	b082      	sub	sp, #8
    6ac6:	9001      	str	r0, [sp, #4]
  osRtxInfo.thread.run.curr = thread;
    6ac8:	4a02      	ldr	r2, [pc, #8]	; (6ad4 <osRtxThreadSetRunning+0x10>)
    6aca:	9b01      	ldr	r3, [sp, #4]
    6acc:	6153      	str	r3, [r2, #20]
}
    6ace:	bf00      	nop
    6ad0:	b002      	add	sp, #8
    6ad2:	4770      	bx	lr
    6ad4:	20000110 	.word	0x20000110

00006ad8 <ThreadFlagsCheck>:
/// Check Thread Flags.
/// \param[in]  thread          thread object.
/// \param[in]  flags           specifies the flags to check.
/// \param[in]  options         specifies flags options (osFlagsXxxx).
/// \return thread flags before clearing or 0 if specified flags have not been set.
static uint32_t ThreadFlagsCheck (os_thread_t *thread, uint32_t flags, uint32_t options) {
    6ad8:	b500      	push	{lr}
    6ada:	b087      	sub	sp, #28
    6adc:	9003      	str	r0, [sp, #12]
    6ade:	9102      	str	r1, [sp, #8]
    6ae0:	9201      	str	r2, [sp, #4]
#if (EXCLUSIVE_ACCESS == 0)
  uint32_t primask;
#endif
  uint32_t thread_flags;

  if ((options & osFlagsNoClear) == 0U) {
    6ae2:	9b01      	ldr	r3, [sp, #4]
    6ae4:	f003 0302 	and.w	r3, r3, #2
    6ae8:	2b00      	cmp	r3, #0
    6aea:	d114      	bne.n	6b16 <ThreadFlagsCheck+0x3e>

    if (primask == 0U) {
      __enable_irq();
    }
#else
    if ((options & osFlagsWaitAll) != 0U) {
    6aec:	9b01      	ldr	r3, [sp, #4]
    6aee:	f003 0301 	and.w	r3, r3, #1
    6af2:	2b00      	cmp	r3, #0
    6af4:	d007      	beq.n	6b06 <ThreadFlagsCheck+0x2e>
      thread_flags = atomic_chk32_all(&thread->thread_flags, flags);
    6af6:	9b03      	ldr	r3, [sp, #12]
    6af8:	3328      	adds	r3, #40	; 0x28
    6afa:	9902      	ldr	r1, [sp, #8]
    6afc:	4618      	mov	r0, r3
    6afe:	f7ff ff8b 	bl	6a18 <atomic_chk32_all>
    6b02:	9005      	str	r0, [sp, #20]
    6b04:	e021      	b.n	6b4a <ThreadFlagsCheck+0x72>
    } else {
      thread_flags = atomic_chk32_any(&thread->thread_flags, flags);
    6b06:	9b03      	ldr	r3, [sp, #12]
    6b08:	3328      	adds	r3, #40	; 0x28
    6b0a:	9902      	ldr	r1, [sp, #8]
    6b0c:	4618      	mov	r0, r3
    6b0e:	f7ff ffa0 	bl	6a52 <atomic_chk32_any>
    6b12:	9005      	str	r0, [sp, #20]
    6b14:	e019      	b.n	6b4a <ThreadFlagsCheck+0x72>
    }
#endif
  } else {
    thread_flags = thread->thread_flags;
    6b16:	9b03      	ldr	r3, [sp, #12]
    6b18:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6b1a:	9305      	str	r3, [sp, #20]
    if ((((options & osFlagsWaitAll) != 0U) && ((thread_flags & flags) != flags)) ||
    6b1c:	9b01      	ldr	r3, [sp, #4]
    6b1e:	f003 0301 	and.w	r3, r3, #1
    6b22:	2b00      	cmp	r3, #0
    6b24:	d005      	beq.n	6b32 <ThreadFlagsCheck+0x5a>
    6b26:	9a05      	ldr	r2, [sp, #20]
    6b28:	9b02      	ldr	r3, [sp, #8]
    6b2a:	401a      	ands	r2, r3
    6b2c:	9b02      	ldr	r3, [sp, #8]
    6b2e:	429a      	cmp	r2, r3
    6b30:	d109      	bne.n	6b46 <ThreadFlagsCheck+0x6e>
        (((options & osFlagsWaitAll) == 0U) && ((thread_flags & flags) == 0U))) {
    6b32:	9b01      	ldr	r3, [sp, #4]
    6b34:	f003 0301 	and.w	r3, r3, #1
    if ((((options & osFlagsWaitAll) != 0U) && ((thread_flags & flags) != flags)) ||
    6b38:	2b00      	cmp	r3, #0
    6b3a:	d106      	bne.n	6b4a <ThreadFlagsCheck+0x72>
        (((options & osFlagsWaitAll) == 0U) && ((thread_flags & flags) == 0U))) {
    6b3c:	9a05      	ldr	r2, [sp, #20]
    6b3e:	9b02      	ldr	r3, [sp, #8]
    6b40:	4013      	ands	r3, r2
    6b42:	2b00      	cmp	r3, #0
    6b44:	d101      	bne.n	6b4a <ThreadFlagsCheck+0x72>
      thread_flags = 0U;
    6b46:	2300      	movs	r3, #0
    6b48:	9305      	str	r3, [sp, #20]
    }
  }

  return thread_flags;
    6b4a:	9b05      	ldr	r3, [sp, #20]
}
    6b4c:	4618      	mov	r0, r3
    6b4e:	b007      	add	sp, #28
    6b50:	f85d fb04 	ldr.w	pc, [sp], #4

00006b54 <osRtxThreadListPut>:
//  ==== Library functions ====

/// Put a Thread into specified Object list sorted by Priority (Highest at Head).
/// \param[in]  object          generic object.
/// \param[in]  thread          thread object.
void osRtxThreadListPut (os_object_t *object, os_thread_t *thread) {
    6b54:	b500      	push	{lr}
    6b56:	b087      	sub	sp, #28
    6b58:	9001      	str	r0, [sp, #4]
    6b5a:	9100      	str	r1, [sp, #0]
  os_thread_t *prev, *next;
  int32_t      priority;

  if (thread == NULL) {
    6b5c:	9b00      	ldr	r3, [sp, #0]
    6b5e:	2b00      	cmp	r3, #0
    6b60:	d02a      	beq.n	6bb8 <osRtxThreadListPut+0x64>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }

  priority = thread->priority;
    6b62:	9b00      	ldr	r3, [sp, #0]
    6b64:	f993 3020 	ldrsb.w	r3, [r3, #32]
    6b68:	9303      	str	r3, [sp, #12]

  prev = osRtxThreadObject(object);
    6b6a:	9801      	ldr	r0, [sp, #4]
    6b6c:	f7ff ff98 	bl	6aa0 <osRtxThreadObject>
    6b70:	9005      	str	r0, [sp, #20]
  next = object->thread_list;
    6b72:	9b01      	ldr	r3, [sp, #4]
    6b74:	689b      	ldr	r3, [r3, #8]
    6b76:	9304      	str	r3, [sp, #16]
  while ((next != NULL) && (next->priority >= priority)) {
    6b78:	e004      	b.n	6b84 <osRtxThreadListPut+0x30>
    prev = next;
    6b7a:	9b04      	ldr	r3, [sp, #16]
    6b7c:	9305      	str	r3, [sp, #20]
    next = next->thread_next;
    6b7e:	9b04      	ldr	r3, [sp, #16]
    6b80:	689b      	ldr	r3, [r3, #8]
    6b82:	9304      	str	r3, [sp, #16]
  while ((next != NULL) && (next->priority >= priority)) {
    6b84:	9b04      	ldr	r3, [sp, #16]
    6b86:	2b00      	cmp	r3, #0
    6b88:	d006      	beq.n	6b98 <osRtxThreadListPut+0x44>
    6b8a:	9b04      	ldr	r3, [sp, #16]
    6b8c:	f993 3020 	ldrsb.w	r3, [r3, #32]
    6b90:	461a      	mov	r2, r3
    6b92:	9b03      	ldr	r3, [sp, #12]
    6b94:	429a      	cmp	r2, r3
    6b96:	daf0      	bge.n	6b7a <osRtxThreadListPut+0x26>
  }
  thread->thread_prev = prev;
    6b98:	9b00      	ldr	r3, [sp, #0]
    6b9a:	9a05      	ldr	r2, [sp, #20]
    6b9c:	60da      	str	r2, [r3, #12]
  thread->thread_next = next;
    6b9e:	9b00      	ldr	r3, [sp, #0]
    6ba0:	9a04      	ldr	r2, [sp, #16]
    6ba2:	609a      	str	r2, [r3, #8]
  prev->thread_next = thread;
    6ba4:	9b05      	ldr	r3, [sp, #20]
    6ba6:	9a00      	ldr	r2, [sp, #0]
    6ba8:	609a      	str	r2, [r3, #8]
  if (next != NULL) {
    6baa:	9b04      	ldr	r3, [sp, #16]
    6bac:	2b00      	cmp	r3, #0
    6bae:	d004      	beq.n	6bba <osRtxThreadListPut+0x66>
    next->thread_prev = thread;
    6bb0:	9b04      	ldr	r3, [sp, #16]
    6bb2:	9a00      	ldr	r2, [sp, #0]
    6bb4:	60da      	str	r2, [r3, #12]
    6bb6:	e000      	b.n	6bba <osRtxThreadListPut+0x66>
    return;
    6bb8:	bf00      	nop
  }
}
    6bba:	b007      	add	sp, #28
    6bbc:	f85d fb04 	ldr.w	pc, [sp], #4

00006bc0 <osRtxThreadListGet>:

/// Get a Thread with Highest Priority from specified Object list and remove it.
/// \param[in]  object          generic object.
/// \return thread object.
os_thread_t *osRtxThreadListGet (os_object_t *object) {
    6bc0:	b510      	push	{r4, lr}
    6bc2:	b084      	sub	sp, #16
    6bc4:	9001      	str	r0, [sp, #4]
  os_thread_t *thread;

  thread = object->thread_list;
    6bc6:	9b01      	ldr	r3, [sp, #4]
    6bc8:	689b      	ldr	r3, [r3, #8]
    6bca:	9303      	str	r3, [sp, #12]
  if (thread != NULL) {
    6bcc:	9b03      	ldr	r3, [sp, #12]
    6bce:	2b00      	cmp	r3, #0
    6bd0:	d011      	beq.n	6bf6 <osRtxThreadListGet+0x36>
    object->thread_list = thread->thread_next;
    6bd2:	9b03      	ldr	r3, [sp, #12]
    6bd4:	689a      	ldr	r2, [r3, #8]
    6bd6:	9b01      	ldr	r3, [sp, #4]
    6bd8:	609a      	str	r2, [r3, #8]
    if (thread->thread_next != NULL) {
    6bda:	9b03      	ldr	r3, [sp, #12]
    6bdc:	689b      	ldr	r3, [r3, #8]
    6bde:	2b00      	cmp	r3, #0
    6be0:	d006      	beq.n	6bf0 <osRtxThreadListGet+0x30>
      thread->thread_next->thread_prev = osRtxThreadObject(object);
    6be2:	9b03      	ldr	r3, [sp, #12]
    6be4:	689c      	ldr	r4, [r3, #8]
    6be6:	9801      	ldr	r0, [sp, #4]
    6be8:	f7ff ff5a 	bl	6aa0 <osRtxThreadObject>
    6bec:	4603      	mov	r3, r0
    6bee:	60e3      	str	r3, [r4, #12]
    }
    thread->thread_prev = NULL;
    6bf0:	9b03      	ldr	r3, [sp, #12]
    6bf2:	2200      	movs	r2, #0
    6bf4:	60da      	str	r2, [r3, #12]
  }

  return thread;
    6bf6:	9b03      	ldr	r3, [sp, #12]
}
    6bf8:	4618      	mov	r0, r3
    6bfa:	b004      	add	sp, #16
    6bfc:	bd10      	pop	{r4, pc}

00006bfe <osRtxThreadListRoot>:

/// Retrieve Thread list root.
/// \param[in]  thread          thread object.
#ifndef EVR_RTX_DISABLE
static void *osRtxThreadListRoot (os_thread_t *thread) {
    6bfe:	b084      	sub	sp, #16
    6c00:	9001      	str	r0, [sp, #4]
  os_thread_t *thread0;

  thread0 = thread;
    6c02:	9b01      	ldr	r3, [sp, #4]
    6c04:	9303      	str	r3, [sp, #12]
  while ((thread0 != NULL) && (thread0->id == osRtxIdThread)) {
    6c06:	e002      	b.n	6c0e <osRtxThreadListRoot+0x10>
    thread0 = thread0->thread_prev;
    6c08:	9b03      	ldr	r3, [sp, #12]
    6c0a:	68db      	ldr	r3, [r3, #12]
    6c0c:	9303      	str	r3, [sp, #12]
  while ((thread0 != NULL) && (thread0->id == osRtxIdThread)) {
    6c0e:	9b03      	ldr	r3, [sp, #12]
    6c10:	2b00      	cmp	r3, #0
    6c12:	d003      	beq.n	6c1c <osRtxThreadListRoot+0x1e>
    6c14:	9b03      	ldr	r3, [sp, #12]
    6c16:	781b      	ldrb	r3, [r3, #0]
    6c18:	2b01      	cmp	r3, #1
    6c1a:	d0f5      	beq.n	6c08 <osRtxThreadListRoot+0xa>
  }
  return thread0;
    6c1c:	9b03      	ldr	r3, [sp, #12]
}
    6c1e:	4618      	mov	r0, r3
    6c20:	b004      	add	sp, #16
    6c22:	4770      	bx	lr

00006c24 <osRtxThreadListSort>:
#endif

/// Re-sort a Thread in linked Object list by Priority (Highest at Head).
/// \param[in]  thread          thread object.
void osRtxThreadListSort (os_thread_t *thread) {
    6c24:	b500      	push	{lr}
    6c26:	b085      	sub	sp, #20
    6c28:	9001      	str	r0, [sp, #4]
  os_object_t *object;
  os_thread_t *thread0;

  // Search for object
  thread0 = thread;
    6c2a:	9b01      	ldr	r3, [sp, #4]
    6c2c:	9303      	str	r3, [sp, #12]
  while ((thread0 != NULL) && (thread0->id == osRtxIdThread)) {
    6c2e:	e002      	b.n	6c36 <osRtxThreadListSort+0x12>
    thread0 = thread0->thread_prev;
    6c30:	9b03      	ldr	r3, [sp, #12]
    6c32:	68db      	ldr	r3, [r3, #12]
    6c34:	9303      	str	r3, [sp, #12]
  while ((thread0 != NULL) && (thread0->id == osRtxIdThread)) {
    6c36:	9b03      	ldr	r3, [sp, #12]
    6c38:	2b00      	cmp	r3, #0
    6c3a:	d003      	beq.n	6c44 <osRtxThreadListSort+0x20>
    6c3c:	9b03      	ldr	r3, [sp, #12]
    6c3e:	781b      	ldrb	r3, [r3, #0]
    6c40:	2b01      	cmp	r3, #1
    6c42:	d0f5      	beq.n	6c30 <osRtxThreadListSort+0xc>
  }
  object = osRtxObject(thread0);
    6c44:	9803      	ldr	r0, [sp, #12]
    6c46:	f7ff ff25 	bl	6a94 <osRtxObject>
    6c4a:	9002      	str	r0, [sp, #8]

  if (object != NULL) {
    6c4c:	9b02      	ldr	r3, [sp, #8]
    6c4e:	2b00      	cmp	r3, #0
    6c50:	d006      	beq.n	6c60 <osRtxThreadListSort+0x3c>
    osRtxThreadListRemove(thread);
    6c52:	9801      	ldr	r0, [sp, #4]
    6c54:	f000 f808 	bl	6c68 <osRtxThreadListRemove>
    osRtxThreadListPut(object, thread);
    6c58:	9901      	ldr	r1, [sp, #4]
    6c5a:	9802      	ldr	r0, [sp, #8]
    6c5c:	f7ff ff7a 	bl	6b54 <osRtxThreadListPut>
  }
}
    6c60:	bf00      	nop
    6c62:	b005      	add	sp, #20
    6c64:	f85d fb04 	ldr.w	pc, [sp], #4

00006c68 <osRtxThreadListRemove>:

/// Remove a Thread from linked Object list.
/// \param[in]  thread          thread object.
void osRtxThreadListRemove (os_thread_t *thread) {
    6c68:	b082      	sub	sp, #8
    6c6a:	9001      	str	r0, [sp, #4]

  if (thread->thread_prev != NULL) {
    6c6c:	9b01      	ldr	r3, [sp, #4]
    6c6e:	68db      	ldr	r3, [r3, #12]
    6c70:	2b00      	cmp	r3, #0
    6c72:	d010      	beq.n	6c96 <osRtxThreadListRemove+0x2e>
    thread->thread_prev->thread_next = thread->thread_next;
    6c74:	9b01      	ldr	r3, [sp, #4]
    6c76:	68db      	ldr	r3, [r3, #12]
    6c78:	9a01      	ldr	r2, [sp, #4]
    6c7a:	6892      	ldr	r2, [r2, #8]
    6c7c:	609a      	str	r2, [r3, #8]
    if (thread->thread_next != NULL) {
    6c7e:	9b01      	ldr	r3, [sp, #4]
    6c80:	689b      	ldr	r3, [r3, #8]
    6c82:	2b00      	cmp	r3, #0
    6c84:	d004      	beq.n	6c90 <osRtxThreadListRemove+0x28>
      thread->thread_next->thread_prev = thread->thread_prev;
    6c86:	9b01      	ldr	r3, [sp, #4]
    6c88:	689b      	ldr	r3, [r3, #8]
    6c8a:	9a01      	ldr	r2, [sp, #4]
    6c8c:	68d2      	ldr	r2, [r2, #12]
    6c8e:	60da      	str	r2, [r3, #12]
    }
    thread->thread_prev = NULL;
    6c90:	9b01      	ldr	r3, [sp, #4]
    6c92:	2200      	movs	r2, #0
    6c94:	60da      	str	r2, [r3, #12]
  }
}
    6c96:	bf00      	nop
    6c98:	b002      	add	sp, #8
    6c9a:	4770      	bx	lr

00006c9c <osRtxThreadReadyPut>:
  }
}

/// Mark a Thread as Ready and put it into Ready list (sorted by Priority).
/// \param[in]  thread          thread object.
void osRtxThreadReadyPut (os_thread_t *thread) {
    6c9c:	b500      	push	{lr}
    6c9e:	b083      	sub	sp, #12
    6ca0:	9001      	str	r0, [sp, #4]

  thread->state = osRtxThreadReady;
    6ca2:	9b01      	ldr	r3, [sp, #4]
    6ca4:	2201      	movs	r2, #1
    6ca6:	705a      	strb	r2, [r3, #1]
  osRtxThreadListPut(&osRtxInfo.thread.ready, thread);
    6ca8:	9901      	ldr	r1, [sp, #4]
    6caa:	4803      	ldr	r0, [pc, #12]	; (6cb8 <osRtxThreadReadyPut+0x1c>)
    6cac:	f7ff ff52 	bl	6b54 <osRtxThreadListPut>
}
    6cb0:	bf00      	nop
    6cb2:	b003      	add	sp, #12
    6cb4:	f85d fb04 	ldr.w	pc, [sp], #4
    6cb8:	2000012c 	.word	0x2000012c

00006cbc <osRtxThreadDelayInsert>:

/// Insert a Thread into the Delay list sorted by Delay (Lowest at Head).
/// \param[in]  thread          thread object.
/// \param[in]  delay           delay value.
static void osRtxThreadDelayInsert (os_thread_t *thread, uint32_t delay) {
    6cbc:	b084      	sub	sp, #16
    6cbe:	9001      	str	r0, [sp, #4]
    6cc0:	9100      	str	r1, [sp, #0]
  os_thread_t *prev, *next;

  if (delay == osWaitForever) {
    6cc2:	9b00      	ldr	r3, [sp, #0]
    6cc4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    6cc8:	d121      	bne.n	6d0e <osRtxThreadDelayInsert+0x52>
    prev = NULL;
    6cca:	2300      	movs	r3, #0
    6ccc:	9303      	str	r3, [sp, #12]
    next = osRtxInfo.thread.wait_list;
    6cce:	4b2d      	ldr	r3, [pc, #180]	; (6d84 <osRtxThreadDelayInsert+0xc8>)
    6cd0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    6cd2:	9302      	str	r3, [sp, #8]
    while (next != NULL)  {
    6cd4:	e004      	b.n	6ce0 <osRtxThreadDelayInsert+0x24>
      prev = next;
    6cd6:	9b02      	ldr	r3, [sp, #8]
    6cd8:	9303      	str	r3, [sp, #12]
      next = next->delay_next;
    6cda:	9b02      	ldr	r3, [sp, #8]
    6cdc:	691b      	ldr	r3, [r3, #16]
    6cde:	9302      	str	r3, [sp, #8]
    while (next != NULL)  {
    6ce0:	9b02      	ldr	r3, [sp, #8]
    6ce2:	2b00      	cmp	r3, #0
    6ce4:	d1f7      	bne.n	6cd6 <osRtxThreadDelayInsert+0x1a>
    }
    thread->delay = delay;
    6ce6:	9b01      	ldr	r3, [sp, #4]
    6ce8:	9a00      	ldr	r2, [sp, #0]
    6cea:	61da      	str	r2, [r3, #28]
    thread->delay_prev = prev;
    6cec:	9b01      	ldr	r3, [sp, #4]
    6cee:	9a03      	ldr	r2, [sp, #12]
    6cf0:	615a      	str	r2, [r3, #20]
    thread->delay_next = NULL;
    6cf2:	9b01      	ldr	r3, [sp, #4]
    6cf4:	2200      	movs	r2, #0
    6cf6:	611a      	str	r2, [r3, #16]
    if (prev != NULL) {
    6cf8:	9b03      	ldr	r3, [sp, #12]
    6cfa:	2b00      	cmp	r3, #0
    6cfc:	d003      	beq.n	6d06 <osRtxThreadDelayInsert+0x4a>
      prev->delay_next = thread;
    6cfe:	9b03      	ldr	r3, [sp, #12]
    6d00:	9a01      	ldr	r2, [sp, #4]
    6d02:	611a      	str	r2, [r3, #16]
    if (next != NULL) {
      next->delay -= delay;
      next->delay_prev = thread;
    }
  }
}
    6d04:	e03a      	b.n	6d7c <osRtxThreadDelayInsert+0xc0>
      osRtxInfo.thread.wait_list = thread;
    6d06:	4a1f      	ldr	r2, [pc, #124]	; (6d84 <osRtxThreadDelayInsert+0xc8>)
    6d08:	9b01      	ldr	r3, [sp, #4]
    6d0a:	6313      	str	r3, [r2, #48]	; 0x30
}
    6d0c:	e036      	b.n	6d7c <osRtxThreadDelayInsert+0xc0>
    prev = NULL;
    6d0e:	2300      	movs	r3, #0
    6d10:	9303      	str	r3, [sp, #12]
    next = osRtxInfo.thread.delay_list;
    6d12:	4b1c      	ldr	r3, [pc, #112]	; (6d84 <osRtxThreadDelayInsert+0xc8>)
    6d14:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6d16:	9302      	str	r3, [sp, #8]
    while ((next != NULL) && (next->delay <= delay)) {
    6d18:	e009      	b.n	6d2e <osRtxThreadDelayInsert+0x72>
      delay -= next->delay;
    6d1a:	9b02      	ldr	r3, [sp, #8]
    6d1c:	69db      	ldr	r3, [r3, #28]
    6d1e:	9a00      	ldr	r2, [sp, #0]
    6d20:	1ad3      	subs	r3, r2, r3
    6d22:	9300      	str	r3, [sp, #0]
      prev = next;
    6d24:	9b02      	ldr	r3, [sp, #8]
    6d26:	9303      	str	r3, [sp, #12]
      next = next->delay_next;
    6d28:	9b02      	ldr	r3, [sp, #8]
    6d2a:	691b      	ldr	r3, [r3, #16]
    6d2c:	9302      	str	r3, [sp, #8]
    while ((next != NULL) && (next->delay <= delay)) {
    6d2e:	9b02      	ldr	r3, [sp, #8]
    6d30:	2b00      	cmp	r3, #0
    6d32:	d004      	beq.n	6d3e <osRtxThreadDelayInsert+0x82>
    6d34:	9b02      	ldr	r3, [sp, #8]
    6d36:	69da      	ldr	r2, [r3, #28]
    6d38:	9b00      	ldr	r3, [sp, #0]
    6d3a:	429a      	cmp	r2, r3
    6d3c:	d9ed      	bls.n	6d1a <osRtxThreadDelayInsert+0x5e>
    thread->delay = delay;
    6d3e:	9b01      	ldr	r3, [sp, #4]
    6d40:	9a00      	ldr	r2, [sp, #0]
    6d42:	61da      	str	r2, [r3, #28]
    thread->delay_prev = prev;
    6d44:	9b01      	ldr	r3, [sp, #4]
    6d46:	9a03      	ldr	r2, [sp, #12]
    6d48:	615a      	str	r2, [r3, #20]
    thread->delay_next = next;
    6d4a:	9b01      	ldr	r3, [sp, #4]
    6d4c:	9a02      	ldr	r2, [sp, #8]
    6d4e:	611a      	str	r2, [r3, #16]
    if (prev != NULL) {
    6d50:	9b03      	ldr	r3, [sp, #12]
    6d52:	2b00      	cmp	r3, #0
    6d54:	d003      	beq.n	6d5e <osRtxThreadDelayInsert+0xa2>
      prev->delay_next = thread;
    6d56:	9b03      	ldr	r3, [sp, #12]
    6d58:	9a01      	ldr	r2, [sp, #4]
    6d5a:	611a      	str	r2, [r3, #16]
    6d5c:	e002      	b.n	6d64 <osRtxThreadDelayInsert+0xa8>
      osRtxInfo.thread.delay_list = thread;
    6d5e:	4a09      	ldr	r2, [pc, #36]	; (6d84 <osRtxThreadDelayInsert+0xc8>)
    6d60:	9b01      	ldr	r3, [sp, #4]
    6d62:	62d3      	str	r3, [r2, #44]	; 0x2c
    if (next != NULL) {
    6d64:	9b02      	ldr	r3, [sp, #8]
    6d66:	2b00      	cmp	r3, #0
    6d68:	d008      	beq.n	6d7c <osRtxThreadDelayInsert+0xc0>
      next->delay -= delay;
    6d6a:	9b02      	ldr	r3, [sp, #8]
    6d6c:	69da      	ldr	r2, [r3, #28]
    6d6e:	9b00      	ldr	r3, [sp, #0]
    6d70:	1ad2      	subs	r2, r2, r3
    6d72:	9b02      	ldr	r3, [sp, #8]
    6d74:	61da      	str	r2, [r3, #28]
      next->delay_prev = thread;
    6d76:	9b02      	ldr	r3, [sp, #8]
    6d78:	9a01      	ldr	r2, [sp, #4]
    6d7a:	615a      	str	r2, [r3, #20]
}
    6d7c:	bf00      	nop
    6d7e:	b004      	add	sp, #16
    6d80:	4770      	bx	lr
    6d82:	bf00      	nop
    6d84:	20000110 	.word	0x20000110

00006d88 <osRtxThreadDelayRemove>:

/// Remove a Thread from the Delay list.
/// \param[in]  thread          thread object.
static void osRtxThreadDelayRemove (os_thread_t *thread) {
    6d88:	b082      	sub	sp, #8
    6d8a:	9001      	str	r0, [sp, #4]

  if (thread->delay == osWaitForever) {
    6d8c:	9b01      	ldr	r3, [sp, #4]
    6d8e:	69db      	ldr	r3, [r3, #28]
    6d90:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    6d94:	d123      	bne.n	6dde <osRtxThreadDelayRemove+0x56>
    if ((thread->delay_prev != NULL) || (osRtxInfo.thread.wait_list == thread)) {
    6d96:	9b01      	ldr	r3, [sp, #4]
    6d98:	695b      	ldr	r3, [r3, #20]
    6d9a:	2b00      	cmp	r3, #0
    6d9c:	d104      	bne.n	6da8 <osRtxThreadDelayRemove+0x20>
    6d9e:	4b27      	ldr	r3, [pc, #156]	; (6e3c <osRtxThreadDelayRemove+0xb4>)
    6da0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    6da2:	9b01      	ldr	r3, [sp, #4]
    6da4:	429a      	cmp	r2, r3
    6da6:	d146      	bne.n	6e36 <osRtxThreadDelayRemove+0xae>
      if (thread->delay_next != NULL) {
    6da8:	9b01      	ldr	r3, [sp, #4]
    6daa:	691b      	ldr	r3, [r3, #16]
    6dac:	2b00      	cmp	r3, #0
    6dae:	d004      	beq.n	6dba <osRtxThreadDelayRemove+0x32>
        thread->delay_next->delay_prev = thread->delay_prev;
    6db0:	9b01      	ldr	r3, [sp, #4]
    6db2:	691b      	ldr	r3, [r3, #16]
    6db4:	9a01      	ldr	r2, [sp, #4]
    6db6:	6952      	ldr	r2, [r2, #20]
    6db8:	615a      	str	r2, [r3, #20]
      }
      if (thread->delay_prev != NULL) {
    6dba:	9b01      	ldr	r3, [sp, #4]
    6dbc:	695b      	ldr	r3, [r3, #20]
    6dbe:	2b00      	cmp	r3, #0
    6dc0:	d008      	beq.n	6dd4 <osRtxThreadDelayRemove+0x4c>
        thread->delay_prev->delay_next = thread->delay_next;
    6dc2:	9b01      	ldr	r3, [sp, #4]
    6dc4:	695b      	ldr	r3, [r3, #20]
    6dc6:	9a01      	ldr	r2, [sp, #4]
    6dc8:	6912      	ldr	r2, [r2, #16]
    6dca:	611a      	str	r2, [r3, #16]
        thread->delay_prev = NULL;
    6dcc:	9b01      	ldr	r3, [sp, #4]
    6dce:	2200      	movs	r2, #0
    6dd0:	615a      	str	r2, [r3, #20]
      } else {
        osRtxInfo.thread.delay_list = thread->delay_next;
      }
    }
  }
}
    6dd2:	e030      	b.n	6e36 <osRtxThreadDelayRemove+0xae>
        osRtxInfo.thread.wait_list = thread->delay_next;
    6dd4:	9b01      	ldr	r3, [sp, #4]
    6dd6:	691b      	ldr	r3, [r3, #16]
    6dd8:	4a18      	ldr	r2, [pc, #96]	; (6e3c <osRtxThreadDelayRemove+0xb4>)
    6dda:	6313      	str	r3, [r2, #48]	; 0x30
}
    6ddc:	e02b      	b.n	6e36 <osRtxThreadDelayRemove+0xae>
    if ((thread->delay_prev != NULL) || (osRtxInfo.thread.delay_list == thread)) {
    6dde:	9b01      	ldr	r3, [sp, #4]
    6de0:	695b      	ldr	r3, [r3, #20]
    6de2:	2b00      	cmp	r3, #0
    6de4:	d104      	bne.n	6df0 <osRtxThreadDelayRemove+0x68>
    6de6:	4b15      	ldr	r3, [pc, #84]	; (6e3c <osRtxThreadDelayRemove+0xb4>)
    6de8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    6dea:	9b01      	ldr	r3, [sp, #4]
    6dec:	429a      	cmp	r2, r3
    6dee:	d122      	bne.n	6e36 <osRtxThreadDelayRemove+0xae>
      if (thread->delay_next != NULL) {
    6df0:	9b01      	ldr	r3, [sp, #4]
    6df2:	691b      	ldr	r3, [r3, #16]
    6df4:	2b00      	cmp	r3, #0
    6df6:	d00d      	beq.n	6e14 <osRtxThreadDelayRemove+0x8c>
        thread->delay_next->delay += thread->delay;
    6df8:	9b01      	ldr	r3, [sp, #4]
    6dfa:	691b      	ldr	r3, [r3, #16]
    6dfc:	9a01      	ldr	r2, [sp, #4]
    6dfe:	6912      	ldr	r2, [r2, #16]
    6e00:	69d1      	ldr	r1, [r2, #28]
    6e02:	9a01      	ldr	r2, [sp, #4]
    6e04:	69d2      	ldr	r2, [r2, #28]
    6e06:	440a      	add	r2, r1
    6e08:	61da      	str	r2, [r3, #28]
        thread->delay_next->delay_prev = thread->delay_prev;
    6e0a:	9b01      	ldr	r3, [sp, #4]
    6e0c:	691b      	ldr	r3, [r3, #16]
    6e0e:	9a01      	ldr	r2, [sp, #4]
    6e10:	6952      	ldr	r2, [r2, #20]
    6e12:	615a      	str	r2, [r3, #20]
      if (thread->delay_prev != NULL) {
    6e14:	9b01      	ldr	r3, [sp, #4]
    6e16:	695b      	ldr	r3, [r3, #20]
    6e18:	2b00      	cmp	r3, #0
    6e1a:	d008      	beq.n	6e2e <osRtxThreadDelayRemove+0xa6>
        thread->delay_prev->delay_next = thread->delay_next;
    6e1c:	9b01      	ldr	r3, [sp, #4]
    6e1e:	695b      	ldr	r3, [r3, #20]
    6e20:	9a01      	ldr	r2, [sp, #4]
    6e22:	6912      	ldr	r2, [r2, #16]
    6e24:	611a      	str	r2, [r3, #16]
        thread->delay_prev = NULL;
    6e26:	9b01      	ldr	r3, [sp, #4]
    6e28:	2200      	movs	r2, #0
    6e2a:	615a      	str	r2, [r3, #20]
}
    6e2c:	e003      	b.n	6e36 <osRtxThreadDelayRemove+0xae>
        osRtxInfo.thread.delay_list = thread->delay_next;
    6e2e:	9b01      	ldr	r3, [sp, #4]
    6e30:	691b      	ldr	r3, [r3, #16]
    6e32:	4a02      	ldr	r2, [pc, #8]	; (6e3c <osRtxThreadDelayRemove+0xb4>)
    6e34:	62d3      	str	r3, [r2, #44]	; 0x2c
}
    6e36:	bf00      	nop
    6e38:	b002      	add	sp, #8
    6e3a:	4770      	bx	lr
    6e3c:	20000110 	.word	0x20000110

00006e40 <osRtxThreadDelayTick>:

/// Process Thread Delay Tick (executed each System Tick).
void osRtxThreadDelayTick (void) {
    6e40:	b500      	push	{lr}
    6e42:	b083      	sub	sp, #12
  os_thread_t *thread;

  thread = osRtxInfo.thread.delay_list;
    6e44:	4b42      	ldr	r3, [pc, #264]	; (6f50 <osRtxThreadDelayTick+0x110>)
    6e46:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    6e48:	9301      	str	r3, [sp, #4]
  if (thread == NULL) {
    6e4a:	9b01      	ldr	r3, [sp, #4]
    6e4c:	2b00      	cmp	r3, #0
    6e4e:	d07a      	beq.n	6f46 <osRtxThreadDelayTick+0x106>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }

  thread->delay--;
    6e50:	9b01      	ldr	r3, [sp, #4]
    6e52:	69db      	ldr	r3, [r3, #28]
    6e54:	1e5a      	subs	r2, r3, #1
    6e56:	9b01      	ldr	r3, [sp, #4]
    6e58:	61da      	str	r2, [r3, #28]

  if (thread->delay == 0U) {
    6e5a:	9b01      	ldr	r3, [sp, #4]
    6e5c:	69db      	ldr	r3, [r3, #28]
    6e5e:	2b00      	cmp	r3, #0
    6e60:	d172      	bne.n	6f48 <osRtxThreadDelayTick+0x108>
    do {
      switch (thread->state) {
    6e62:	9b01      	ldr	r3, [sp, #4]
    6e64:	785b      	ldrb	r3, [r3, #1]
    6e66:	2b53      	cmp	r3, #83	; 0x53
    6e68:	d022      	beq.n	6eb0 <osRtxThreadDelayTick+0x70>
    6e6a:	2b53      	cmp	r3, #83	; 0x53
    6e6c:	dc06      	bgt.n	6e7c <osRtxThreadDelayTick+0x3c>
    6e6e:	2b33      	cmp	r3, #51	; 0x33
    6e70:	d013      	beq.n	6e9a <osRtxThreadDelayTick+0x5a>
    6e72:	2b43      	cmp	r3, #67	; 0x43
    6e74:	d014      	beq.n	6ea0 <osRtxThreadDelayTick+0x60>
    6e76:	2b13      	cmp	r3, #19
    6e78:	d00c      	beq.n	6e94 <osRtxThreadDelayTick+0x54>
        case osRtxThreadWaitingMessagePut:
          EvrRtxMessageQueuePutTimeout((osMessageQueueId_t)osRtxThreadListRoot(thread));
          break;
        default:
          // Invalid
          break;
    6e7a:	e041      	b.n	6f00 <osRtxThreadDelayTick+0xc0>
      switch (thread->state) {
    6e7c:	2b73      	cmp	r3, #115	; 0x73
    6e7e:	d027      	beq.n	6ed0 <osRtxThreadDelayTick+0x90>
    6e80:	2b73      	cmp	r3, #115	; 0x73
    6e82:	dc02      	bgt.n	6e8a <osRtxThreadDelayTick+0x4a>
    6e84:	2b63      	cmp	r3, #99	; 0x63
    6e86:	d01b      	beq.n	6ec0 <osRtxThreadDelayTick+0x80>
          break;
    6e88:	e03a      	b.n	6f00 <osRtxThreadDelayTick+0xc0>
      switch (thread->state) {
    6e8a:	2b83      	cmp	r3, #131	; 0x83
    6e8c:	d028      	beq.n	6ee0 <osRtxThreadDelayTick+0xa0>
    6e8e:	2b93      	cmp	r3, #147	; 0x93
    6e90:	d02e      	beq.n	6ef0 <osRtxThreadDelayTick+0xb0>
          break;
    6e92:	e035      	b.n	6f00 <osRtxThreadDelayTick+0xc0>
          EvrRtxThreadDelayCompleted();
    6e94:	f7fd fc5a 	bl	474c <EvrRtxThreadDelayCompleted>
          break;
    6e98:	e032      	b.n	6f00 <osRtxThreadDelayTick+0xc0>
          EvrRtxThreadFlagsWaitTimeout();
    6e9a:	f7fd fc49 	bl	4730 <EvrRtxThreadFlagsWaitTimeout>
          break;
    6e9e:	e02f      	b.n	6f00 <osRtxThreadDelayTick+0xc0>
          EvrRtxEventFlagsWaitTimeout((osEventFlagsId_t)osRtxThreadListRoot(thread));
    6ea0:	9801      	ldr	r0, [sp, #4]
    6ea2:	f7ff feac 	bl	6bfe <osRtxThreadListRoot>
    6ea6:	4603      	mov	r3, r0
    6ea8:	4618      	mov	r0, r3
    6eaa:	f7fd fc57 	bl	475c <EvrRtxEventFlagsWaitTimeout>
          break;
    6eae:	e027      	b.n	6f00 <osRtxThreadDelayTick+0xc0>
          EvrRtxMutexAcquireTimeout((osMutexId_t)osRtxThreadListRoot(thread));
    6eb0:	9801      	ldr	r0, [sp, #4]
    6eb2:	f7ff fea4 	bl	6bfe <osRtxThreadListRoot>
    6eb6:	4603      	mov	r3, r0
    6eb8:	4618      	mov	r0, r3
    6eba:	f7fd fc6b 	bl	4794 <EvrRtxMutexAcquireTimeout>
          break;
    6ebe:	e01f      	b.n	6f00 <osRtxThreadDelayTick+0xc0>
          EvrRtxSemaphoreAcquireTimeout((osSemaphoreId_t)osRtxThreadListRoot(thread));
    6ec0:	9801      	ldr	r0, [sp, #4]
    6ec2:	f7ff fe9c 	bl	6bfe <osRtxThreadListRoot>
    6ec6:	4603      	mov	r3, r0
    6ec8:	4618      	mov	r0, r3
    6eca:	f7fd fc7e 	bl	47ca <EvrRtxSemaphoreAcquireTimeout>
          break;
    6ece:	e017      	b.n	6f00 <osRtxThreadDelayTick+0xc0>
          EvrRtxMemoryPoolAllocTimeout((osMemoryPoolId_t)osRtxThreadListRoot(thread));
    6ed0:	9801      	ldr	r0, [sp, #4]
    6ed2:	f7ff fe94 	bl	6bfe <osRtxThreadListRoot>
    6ed6:	4603      	mov	r3, r0
    6ed8:	4618      	mov	r0, r3
    6eda:	f7fd fc7b 	bl	47d4 <EvrRtxMemoryPoolAllocTimeout>
          break;
    6ede:	e00f      	b.n	6f00 <osRtxThreadDelayTick+0xc0>
          EvrRtxMessageQueueGetTimeout((osMessageQueueId_t)osRtxThreadListRoot(thread));
    6ee0:	9801      	ldr	r0, [sp, #4]
    6ee2:	f7ff fe8c 	bl	6bfe <osRtxThreadListRoot>
    6ee6:	4603      	mov	r3, r0
    6ee8:	4618      	mov	r0, r3
    6eea:	f7fd fcbc 	bl	4866 <EvrRtxMessageQueueGetTimeout>
          break;
    6eee:	e007      	b.n	6f00 <osRtxThreadDelayTick+0xc0>
          EvrRtxMessageQueuePutTimeout((osMessageQueueId_t)osRtxThreadListRoot(thread));
    6ef0:	9801      	ldr	r0, [sp, #4]
    6ef2:	f7ff fe84 	bl	6bfe <osRtxThreadListRoot>
    6ef6:	4603      	mov	r3, r0
    6ef8:	4618      	mov	r0, r3
    6efa:	f7fd fc8e 	bl	481a <EvrRtxMessageQueuePutTimeout>
          break;
    6efe:	bf00      	nop
      }
      EvrRtxThreadUnblocked(thread, (osRtxThreadRegPtr(thread))[0]);
    6f00:	9801      	ldr	r0, [sp, #4]
    6f02:	f000 f827 	bl	6f54 <osRtxThreadRegPtr>
    6f06:	4603      	mov	r3, r0
    6f08:	681b      	ldr	r3, [r3, #0]
    6f0a:	4619      	mov	r1, r3
    6f0c:	9801      	ldr	r0, [sp, #4]
    6f0e:	f7fd fbee 	bl	46ee <EvrRtxThreadUnblocked>
      osRtxThreadListRemove(thread);
    6f12:	9801      	ldr	r0, [sp, #4]
    6f14:	f7ff fea8 	bl	6c68 <osRtxThreadListRemove>
      osRtxThreadReadyPut(thread);
    6f18:	9801      	ldr	r0, [sp, #4]
    6f1a:	f7ff febf 	bl	6c9c <osRtxThreadReadyPut>
      thread = thread->delay_next;
    6f1e:	9b01      	ldr	r3, [sp, #4]
    6f20:	691b      	ldr	r3, [r3, #16]
    6f22:	9301      	str	r3, [sp, #4]
    } while ((thread != NULL) && (thread->delay == 0U));
    6f24:	9b01      	ldr	r3, [sp, #4]
    6f26:	2b00      	cmp	r3, #0
    6f28:	d003      	beq.n	6f32 <osRtxThreadDelayTick+0xf2>
    6f2a:	9b01      	ldr	r3, [sp, #4]
    6f2c:	69db      	ldr	r3, [r3, #28]
    6f2e:	2b00      	cmp	r3, #0
    6f30:	d097      	beq.n	6e62 <osRtxThreadDelayTick+0x22>
    if (thread != NULL) {
    6f32:	9b01      	ldr	r3, [sp, #4]
    6f34:	2b00      	cmp	r3, #0
    6f36:	d002      	beq.n	6f3e <osRtxThreadDelayTick+0xfe>
      thread->delay_prev = NULL;
    6f38:	9b01      	ldr	r3, [sp, #4]
    6f3a:	2200      	movs	r2, #0
    6f3c:	615a      	str	r2, [r3, #20]
    }
    osRtxInfo.thread.delay_list = thread;
    6f3e:	4a04      	ldr	r2, [pc, #16]	; (6f50 <osRtxThreadDelayTick+0x110>)
    6f40:	9b01      	ldr	r3, [sp, #4]
    6f42:	62d3      	str	r3, [r2, #44]	; 0x2c
    6f44:	e000      	b.n	6f48 <osRtxThreadDelayTick+0x108>
    return;
    6f46:	bf00      	nop
  }
}
    6f48:	b003      	add	sp, #12
    6f4a:	f85d fb04 	ldr.w	pc, [sp], #4
    6f4e:	bf00      	nop
    6f50:	20000110 	.word	0x20000110

00006f54 <osRtxThreadRegPtr>:

/// Get pointer to Thread registers (R0..R3)
/// \param[in]  thread          thread object.
/// \return pointer to registers R0-R3.
uint32_t *osRtxThreadRegPtr (const os_thread_t *thread) {
    6f54:	b510      	push	{r4, lr}
    6f56:	b084      	sub	sp, #16
    6f58:	9001      	str	r0, [sp, #4]
  uint32_t addr = thread->sp + StackOffsetR0(thread->stack_frame);
    6f5a:	9b01      	ldr	r3, [sp, #4]
    6f5c:	6b9c      	ldr	r4, [r3, #56]	; 0x38
    6f5e:	9b01      	ldr	r3, [sp, #4]
    6f60:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
    6f64:	4618      	mov	r0, r3
    6f66:	f7ff fd24 	bl	69b2 <StackOffsetR0>
    6f6a:	4603      	mov	r3, r0
    6f6c:	4423      	add	r3, r4
    6f6e:	9303      	str	r3, [sp, #12]
  //lint -e{923} -e{9078} "cast from unsigned int to pointer"
  return ((uint32_t *)addr);
    6f70:	9b03      	ldr	r3, [sp, #12]
}
    6f72:	4618      	mov	r0, r3
    6f74:	b004      	add	sp, #16
    6f76:	bd10      	pop	{r4, pc}

00006f78 <osRtxThreadBlock>:

/// Block running Thread execution and register it as Ready to Run.
/// \param[in]  thread          running thread object.
static void osRtxThreadBlock (os_thread_t *thread) {
    6f78:	b500      	push	{lr}
    6f7a:	b087      	sub	sp, #28
    6f7c:	9001      	str	r0, [sp, #4]
  os_thread_t *prev, *next;
  int32_t      priority;

  thread->state = osRtxThreadReady;
    6f7e:	9b01      	ldr	r3, [sp, #4]
    6f80:	2201      	movs	r2, #1
    6f82:	705a      	strb	r2, [r3, #1]

  priority = thread->priority;
    6f84:	9b01      	ldr	r3, [sp, #4]
    6f86:	f993 3020 	ldrsb.w	r3, [r3, #32]
    6f8a:	9303      	str	r3, [sp, #12]

  prev = osRtxThreadObject(&osRtxInfo.thread.ready);
    6f8c:	4816      	ldr	r0, [pc, #88]	; (6fe8 <osRtxThreadBlock+0x70>)
    6f8e:	f7ff fd87 	bl	6aa0 <osRtxThreadObject>
    6f92:	9005      	str	r0, [sp, #20]
  next = prev->thread_next;
    6f94:	9b05      	ldr	r3, [sp, #20]
    6f96:	689b      	ldr	r3, [r3, #8]
    6f98:	9304      	str	r3, [sp, #16]

  while ((next != NULL) && (next->priority > priority)) {
    6f9a:	e004      	b.n	6fa6 <osRtxThreadBlock+0x2e>
    prev = next;
    6f9c:	9b04      	ldr	r3, [sp, #16]
    6f9e:	9305      	str	r3, [sp, #20]
    next = next->thread_next;
    6fa0:	9b04      	ldr	r3, [sp, #16]
    6fa2:	689b      	ldr	r3, [r3, #8]
    6fa4:	9304      	str	r3, [sp, #16]
  while ((next != NULL) && (next->priority > priority)) {
    6fa6:	9b04      	ldr	r3, [sp, #16]
    6fa8:	2b00      	cmp	r3, #0
    6faa:	d006      	beq.n	6fba <osRtxThreadBlock+0x42>
    6fac:	9b04      	ldr	r3, [sp, #16]
    6fae:	f993 3020 	ldrsb.w	r3, [r3, #32]
    6fb2:	461a      	mov	r2, r3
    6fb4:	9b03      	ldr	r3, [sp, #12]
    6fb6:	429a      	cmp	r2, r3
    6fb8:	dcf0      	bgt.n	6f9c <osRtxThreadBlock+0x24>
  }
  thread->thread_prev = prev;
    6fba:	9b01      	ldr	r3, [sp, #4]
    6fbc:	9a05      	ldr	r2, [sp, #20]
    6fbe:	60da      	str	r2, [r3, #12]
  thread->thread_next = next;
    6fc0:	9b01      	ldr	r3, [sp, #4]
    6fc2:	9a04      	ldr	r2, [sp, #16]
    6fc4:	609a      	str	r2, [r3, #8]
  prev->thread_next = thread;
    6fc6:	9b05      	ldr	r3, [sp, #20]
    6fc8:	9a01      	ldr	r2, [sp, #4]
    6fca:	609a      	str	r2, [r3, #8]
  if (next != NULL) {
    6fcc:	9b04      	ldr	r3, [sp, #16]
    6fce:	2b00      	cmp	r3, #0
    6fd0:	d002      	beq.n	6fd8 <osRtxThreadBlock+0x60>
    next->thread_prev = thread;
    6fd2:	9b04      	ldr	r3, [sp, #16]
    6fd4:	9a01      	ldr	r2, [sp, #4]
    6fd6:	60da      	str	r2, [r3, #12]
  }

  EvrRtxThreadPreempted(thread);
    6fd8:	9801      	ldr	r0, [sp, #4]
    6fda:	f7fd fb8e 	bl	46fa <EvrRtxThreadPreempted>
}
    6fde:	bf00      	nop
    6fe0:	b007      	add	sp, #28
    6fe2:	f85d fb04 	ldr.w	pc, [sp], #4
    6fe6:	bf00      	nop
    6fe8:	2000012c 	.word	0x2000012c

00006fec <osRtxThreadSwitch>:

/// Switch to specified Thread.
/// \param[in]  thread          thread object.
void osRtxThreadSwitch (os_thread_t *thread) {
    6fec:	b500      	push	{lr}
    6fee:	b083      	sub	sp, #12
    6ff0:	9001      	str	r0, [sp, #4]

  thread->state = osRtxThreadRunning;
    6ff2:	9b01      	ldr	r3, [sp, #4]
    6ff4:	2202      	movs	r2, #2
    6ff6:	705a      	strb	r2, [r3, #1]
  osRtxInfo.thread.run.next = thread;
    6ff8:	4a0d      	ldr	r2, [pc, #52]	; (7030 <osRtxThreadSwitch+0x44>)
    6ffa:	9b01      	ldr	r3, [sp, #4]
    6ffc:	6193      	str	r3, [r2, #24]
  osRtxThreadStackCheck();
    6ffe:	f000 f8db 	bl	71b8 <osRtxThreadStackCheck>
  EvrRtxThreadSwitched(thread);
    7002:	9801      	ldr	r0, [sp, #4]
    7004:	f7fd fb7e 	bl	4704 <EvrRtxThreadSwitched>

  if (osEventObs && osEventObs->thread_switch) {
    7008:	4b0a      	ldr	r3, [pc, #40]	; (7034 <osRtxThreadSwitch+0x48>)
    700a:	681b      	ldr	r3, [r3, #0]
    700c:	2b00      	cmp	r3, #0
    700e:	d00b      	beq.n	7028 <osRtxThreadSwitch+0x3c>
    7010:	4b08      	ldr	r3, [pc, #32]	; (7034 <osRtxThreadSwitch+0x48>)
    7012:	681b      	ldr	r3, [r3, #0]
    7014:	691b      	ldr	r3, [r3, #16]
    7016:	2b00      	cmp	r3, #0
    7018:	d006      	beq.n	7028 <osRtxThreadSwitch+0x3c>
    osEventObs->thread_switch(thread->context);
    701a:	4b06      	ldr	r3, [pc, #24]	; (7034 <osRtxThreadSwitch+0x48>)
    701c:	681b      	ldr	r3, [r3, #0]
    701e:	691b      	ldr	r3, [r3, #16]
    7020:	9a01      	ldr	r2, [sp, #4]
    7022:	6c52      	ldr	r2, [r2, #68]	; 0x44
    7024:	4610      	mov	r0, r2
    7026:	4798      	blx	r3
  }
}
    7028:	bf00      	nop
    702a:	b003      	add	sp, #12
    702c:	f85d fb04 	ldr.w	pc, [sp], #4
    7030:	20000110 	.word	0x20000110
    7034:	20002f58 	.word	0x20002f58

00007038 <thread_switch_helper>:

/// Notify the OS event observer of an imminent thread switch.
void thread_switch_helper(void) {
    7038:	b508      	push	{r3, lr}
  if (osEventObs && osEventObs->thread_switch) {
    703a:	4b09      	ldr	r3, [pc, #36]	; (7060 <thread_switch_helper+0x28>)
    703c:	681b      	ldr	r3, [r3, #0]
    703e:	2b00      	cmp	r3, #0
    7040:	d00c      	beq.n	705c <thread_switch_helper+0x24>
    7042:	4b07      	ldr	r3, [pc, #28]	; (7060 <thread_switch_helper+0x28>)
    7044:	681b      	ldr	r3, [r3, #0]
    7046:	691b      	ldr	r3, [r3, #16]
    7048:	2b00      	cmp	r3, #0
    704a:	d007      	beq.n	705c <thread_switch_helper+0x24>
    osEventObs->thread_switch(osRtxInfo.thread.run.next->context);
    704c:	4b04      	ldr	r3, [pc, #16]	; (7060 <thread_switch_helper+0x28>)
    704e:	681b      	ldr	r3, [r3, #0]
    7050:	691b      	ldr	r3, [r3, #16]
    7052:	4a04      	ldr	r2, [pc, #16]	; (7064 <thread_switch_helper+0x2c>)
    7054:	6992      	ldr	r2, [r2, #24]
    7056:	6c52      	ldr	r2, [r2, #68]	; 0x44
    7058:	4610      	mov	r0, r2
    705a:	4798      	blx	r3
  }
}
    705c:	bf00      	nop
    705e:	bd08      	pop	{r3, pc}
    7060:	20002f58 	.word	0x20002f58
    7064:	20000110 	.word	0x20000110

00007068 <osRtxThreadDispatch>:

/// Dispatch specified Thread or Ready Thread with Highest Priority.
/// \param[in]  thread          thread object or NULL.
void osRtxThreadDispatch (os_thread_t *thread) {
    7068:	b500      	push	{lr}
    706a:	b087      	sub	sp, #28
    706c:	9001      	str	r0, [sp, #4]
  uint8_t      kernel_state;
  os_thread_t *thread_running;
  os_thread_t *thread_ready;

  kernel_state   = osRtxKernelGetState();
    706e:	f7ff fd1d 	bl	6aac <osRtxKernelGetState>
    7072:	4603      	mov	r3, r0
    7074:	f88d 3017 	strb.w	r3, [sp, #23]
  thread_running = osRtxThreadGetRunning();
    7078:	f7ff fd1e 	bl	6ab8 <osRtxThreadGetRunning>
    707c:	9004      	str	r0, [sp, #16]

  if (thread == NULL) {
    707e:	9b01      	ldr	r3, [sp, #4]
    7080:	2b00      	cmp	r3, #0
    7082:	d11e      	bne.n	70c2 <osRtxThreadDispatch+0x5a>
    thread_ready = osRtxInfo.thread.ready.thread_list;
    7084:	4b1d      	ldr	r3, [pc, #116]	; (70fc <osRtxThreadDispatch+0x94>)
    7086:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7088:	9303      	str	r3, [sp, #12]
    if ((kernel_state == osRtxKernelRunning) &&
    708a:	f89d 3017 	ldrb.w	r3, [sp, #23]
    708e:	2b02      	cmp	r3, #2
    7090:	d130      	bne.n	70f4 <osRtxThreadDispatch+0x8c>
    7092:	9b04      	ldr	r3, [sp, #16]
    7094:	2b00      	cmp	r3, #0
    7096:	d02d      	beq.n	70f4 <osRtxThreadDispatch+0x8c>
        (thread_running != NULL) && (thread_ready != NULL) &&
    7098:	9b03      	ldr	r3, [sp, #12]
    709a:	2b00      	cmp	r3, #0
    709c:	d02a      	beq.n	70f4 <osRtxThreadDispatch+0x8c>
        (thread_ready->priority > thread_running->priority)) {
    709e:	9b03      	ldr	r3, [sp, #12]
    70a0:	f993 2020 	ldrsb.w	r2, [r3, #32]
    70a4:	9b04      	ldr	r3, [sp, #16]
    70a6:	f993 3020 	ldrsb.w	r3, [r3, #32]
        (thread_running != NULL) && (thread_ready != NULL) &&
    70aa:	429a      	cmp	r2, r3
    70ac:	dd22      	ble.n	70f4 <osRtxThreadDispatch+0x8c>
      // Preempt running Thread
      osRtxThreadListRemove(thread_ready);
    70ae:	9803      	ldr	r0, [sp, #12]
    70b0:	f7ff fdda 	bl	6c68 <osRtxThreadListRemove>
      osRtxThreadBlock(thread_running);
    70b4:	9804      	ldr	r0, [sp, #16]
    70b6:	f7ff ff5f 	bl	6f78 <osRtxThreadBlock>
      osRtxThreadSwitch(thread_ready);
    70ba:	9803      	ldr	r0, [sp, #12]
    70bc:	f7ff ff96 	bl	6fec <osRtxThreadSwitch>
    } else {
      // Put Thread into Ready list
      osRtxThreadReadyPut(thread);
    }
  }
}
    70c0:	e018      	b.n	70f4 <osRtxThreadDispatch+0x8c>
    if ((kernel_state == osRtxKernelRunning) &&
    70c2:	f89d 3017 	ldrb.w	r3, [sp, #23]
    70c6:	2b02      	cmp	r3, #2
    70c8:	d111      	bne.n	70ee <osRtxThreadDispatch+0x86>
    70ca:	9b04      	ldr	r3, [sp, #16]
    70cc:	2b00      	cmp	r3, #0
    70ce:	d00e      	beq.n	70ee <osRtxThreadDispatch+0x86>
        (thread->priority > thread_running->priority)) {
    70d0:	9b01      	ldr	r3, [sp, #4]
    70d2:	f993 2020 	ldrsb.w	r2, [r3, #32]
    70d6:	9b04      	ldr	r3, [sp, #16]
    70d8:	f993 3020 	ldrsb.w	r3, [r3, #32]
        (thread_running != NULL) &&
    70dc:	429a      	cmp	r2, r3
    70de:	dd06      	ble.n	70ee <osRtxThreadDispatch+0x86>
      osRtxThreadBlock(thread_running);
    70e0:	9804      	ldr	r0, [sp, #16]
    70e2:	f7ff ff49 	bl	6f78 <osRtxThreadBlock>
      osRtxThreadSwitch(thread);
    70e6:	9801      	ldr	r0, [sp, #4]
    70e8:	f7ff ff80 	bl	6fec <osRtxThreadSwitch>
}
    70ec:	e002      	b.n	70f4 <osRtxThreadDispatch+0x8c>
      osRtxThreadReadyPut(thread);
    70ee:	9801      	ldr	r0, [sp, #4]
    70f0:	f7ff fdd4 	bl	6c9c <osRtxThreadReadyPut>
}
    70f4:	bf00      	nop
    70f6:	b007      	add	sp, #28
    70f8:	f85d fb04 	ldr.w	pc, [sp], #4
    70fc:	20000110 	.word	0x20000110

00007100 <osRtxThreadWaitExit>:

/// Exit Thread wait state.
/// \param[in]  thread          thread object.
/// \param[in]  ret_val         return value.
/// \param[in]  dispatch        dispatch flag.
void osRtxThreadWaitExit (os_thread_t *thread, uint32_t ret_val, bool_t dispatch) {
    7100:	b500      	push	{lr}
    7102:	b087      	sub	sp, #28
    7104:	9003      	str	r0, [sp, #12]
    7106:	9102      	str	r1, [sp, #8]
    7108:	4613      	mov	r3, r2
    710a:	f88d 3007 	strb.w	r3, [sp, #7]
  uint32_t *reg;

  EvrRtxThreadUnblocked(thread, ret_val);
    710e:	9902      	ldr	r1, [sp, #8]
    7110:	9803      	ldr	r0, [sp, #12]
    7112:	f7fd faec 	bl	46ee <EvrRtxThreadUnblocked>

  reg = osRtxThreadRegPtr(thread);
    7116:	9803      	ldr	r0, [sp, #12]
    7118:	f7ff ff1c 	bl	6f54 <osRtxThreadRegPtr>
    711c:	9005      	str	r0, [sp, #20]
  reg[0] = ret_val;
    711e:	9b05      	ldr	r3, [sp, #20]
    7120:	9a02      	ldr	r2, [sp, #8]
    7122:	601a      	str	r2, [r3, #0]

  osRtxThreadDelayRemove(thread);
    7124:	9803      	ldr	r0, [sp, #12]
    7126:	f7ff fe2f 	bl	6d88 <osRtxThreadDelayRemove>
  if (dispatch) {
    712a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    712e:	2b00      	cmp	r3, #0
    7130:	d003      	beq.n	713a <osRtxThreadWaitExit+0x3a>
    osRtxThreadDispatch(thread);
    7132:	9803      	ldr	r0, [sp, #12]
    7134:	f7ff ff98 	bl	7068 <osRtxThreadDispatch>
  } else {
    osRtxThreadReadyPut(thread);
  }
}
    7138:	e002      	b.n	7140 <osRtxThreadWaitExit+0x40>
    osRtxThreadReadyPut(thread);
    713a:	9803      	ldr	r0, [sp, #12]
    713c:	f7ff fdae 	bl	6c9c <osRtxThreadReadyPut>
}
    7140:	bf00      	nop
    7142:	b007      	add	sp, #28
    7144:	f85d fb04 	ldr.w	pc, [sp], #4

00007148 <osRtxThreadWaitEnter>:

/// Enter Thread wait state.
/// \param[in]  state           new thread state.
/// \param[in]  timeout         timeout.
/// \return true - success, false - failure.
bool_t osRtxThreadWaitEnter (uint8_t state, uint32_t timeout) {
    7148:	b500      	push	{lr}
    714a:	b085      	sub	sp, #20
    714c:	4603      	mov	r3, r0
    714e:	9100      	str	r1, [sp, #0]
    7150:	f88d 3007 	strb.w	r3, [sp, #7]
  os_thread_t *thread;

  // Check if Kernel is running
  if (osRtxKernelGetState() != osRtxKernelRunning) {
    7154:	f7ff fcaa 	bl	6aac <osRtxKernelGetState>
    7158:	4603      	mov	r3, r0
    715a:	2b02      	cmp	r3, #2
    715c:	d001      	beq.n	7162 <osRtxThreadWaitEnter+0x1a>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return FALSE;
    715e:	2300      	movs	r3, #0
    7160:	e021      	b.n	71a6 <osRtxThreadWaitEnter+0x5e>
  }

  // Check running thread
  thread = osRtxThreadGetRunning();
    7162:	f7ff fca9 	bl	6ab8 <osRtxThreadGetRunning>
    7166:	9003      	str	r0, [sp, #12]
  if (thread == NULL) {
    7168:	9b03      	ldr	r3, [sp, #12]
    716a:	2b00      	cmp	r3, #0
    716c:	d101      	bne.n	7172 <osRtxThreadWaitEnter+0x2a>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return FALSE;
    716e:	2300      	movs	r3, #0
    7170:	e019      	b.n	71a6 <osRtxThreadWaitEnter+0x5e>
  }

  // Check if any thread is ready
  if (osRtxInfo.thread.ready.thread_list == NULL) {
    7172:	4b0f      	ldr	r3, [pc, #60]	; (71b0 <osRtxThreadWaitEnter+0x68>)
    7174:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7176:	2b00      	cmp	r3, #0
    7178:	d101      	bne.n	717e <osRtxThreadWaitEnter+0x36>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return FALSE;
    717a:	2300      	movs	r3, #0
    717c:	e013      	b.n	71a6 <osRtxThreadWaitEnter+0x5e>
  }

  EvrRtxThreadBlocked(thread, timeout);
    717e:	9900      	ldr	r1, [sp, #0]
    7180:	9803      	ldr	r0, [sp, #12]
    7182:	f7fd faae 	bl	46e2 <EvrRtxThreadBlocked>

  thread->state = state;
    7186:	9b03      	ldr	r3, [sp, #12]
    7188:	f89d 2007 	ldrb.w	r2, [sp, #7]
    718c:	705a      	strb	r2, [r3, #1]
  osRtxThreadDelayInsert(thread, timeout);
    718e:	9900      	ldr	r1, [sp, #0]
    7190:	9803      	ldr	r0, [sp, #12]
    7192:	f7ff fd93 	bl	6cbc <osRtxThreadDelayInsert>
  thread = osRtxThreadListGet(&osRtxInfo.thread.ready);
    7196:	4807      	ldr	r0, [pc, #28]	; (71b4 <osRtxThreadWaitEnter+0x6c>)
    7198:	f7ff fd12 	bl	6bc0 <osRtxThreadListGet>
    719c:	9003      	str	r0, [sp, #12]
  osRtxThreadSwitch(thread);
    719e:	9803      	ldr	r0, [sp, #12]
    71a0:	f7ff ff24 	bl	6fec <osRtxThreadSwitch>

  return TRUE;
    71a4:	2301      	movs	r3, #1
}
    71a6:	4618      	mov	r0, r3
    71a8:	b005      	add	sp, #20
    71aa:	f85d fb04 	ldr.w	pc, [sp], #4
    71ae:	bf00      	nop
    71b0:	20000110 	.word	0x20000110
    71b4:	2000012c 	.word	0x2000012c

000071b8 <osRtxThreadStackCheck>:

/// Check current running Thread Stack.
//lint -esym(759,osRtxThreadStackCheck) "Prototype in header"
//lint -esym(765,osRtxThreadStackCheck) "Global scope (can be overridden)"
__WEAK void osRtxThreadStackCheck (void) {
    71b8:	b500      	push	{lr}
    71ba:	b083      	sub	sp, #12
  os_thread_t *thread;

  thread = osRtxThreadGetRunning();
    71bc:	f7ff fc7c 	bl	6ab8 <osRtxThreadGetRunning>
    71c0:	9001      	str	r0, [sp, #4]
  if (thread != NULL) {
    71c2:	9b01      	ldr	r3, [sp, #4]
    71c4:	2b00      	cmp	r3, #0
    71c6:	d00f      	beq.n	71e8 <osRtxThreadStackCheck+0x30>
    //lint -e{923} "cast from pointer to unsigned int"
    //lint -e{9079} -e{9087} "cast between pointers to different object types"
    if ((thread->sp <= (uint32_t)thread->stack_mem) ||
    71c8:	9b01      	ldr	r3, [sp, #4]
    71ca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    71cc:	9a01      	ldr	r2, [sp, #4]
    71ce:	6b12      	ldr	r2, [r2, #48]	; 0x30
    71d0:	4293      	cmp	r3, r2
    71d2:	d905      	bls.n	71e0 <osRtxThreadStackCheck+0x28>
        (*((uint32_t *)thread->stack_mem) != osRtxStackMagicWord)) {
    71d4:	9b01      	ldr	r3, [sp, #4]
    71d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    71d8:	681b      	ldr	r3, [r3, #0]
    if ((thread->sp <= (uint32_t)thread->stack_mem) ||
    71da:	4a05      	ldr	r2, [pc, #20]	; (71f0 <osRtxThreadStackCheck+0x38>)
    71dc:	4293      	cmp	r3, r2
    71de:	d003      	beq.n	71e8 <osRtxThreadStackCheck+0x30>
      (void)osRtxErrorNotify(osRtxErrorStackUnderflow, thread);
    71e0:	9901      	ldr	r1, [sp, #4]
    71e2:	2001      	movs	r0, #1
    71e4:	f7fd f89a 	bl	431c <osRtxErrorNotify>
    }
  }
}
    71e8:	bf00      	nop
    71ea:	b003      	add	sp, #12
    71ec:	f85d fb04 	ldr.w	pc, [sp], #4
    71f0:	e25a2ea5 	.word	0xe25a2ea5

000071f4 <osRtxThreadPostProcess>:

//  ==== Post ISR processing ====

/// Thread post ISR processing.
/// \param[in]  thread          thread object.
static void osRtxThreadPostProcess (os_thread_t *thread) {
    71f4:	b500      	push	{lr}
    71f6:	b085      	sub	sp, #20
    71f8:	9001      	str	r0, [sp, #4]
  uint32_t thread_flags;

  // Check thread state
  if ((thread->state == osRtxThreadInactive) ||
    71fa:	9b01      	ldr	r3, [sp, #4]
    71fc:	785b      	ldrb	r3, [r3, #1]
    71fe:	2b00      	cmp	r3, #0
    7200:	d023      	beq.n	724a <osRtxThreadPostProcess+0x56>
      (thread->state == osRtxThreadTerminated)) {
    7202:	9b01      	ldr	r3, [sp, #4]
    7204:	785b      	ldrb	r3, [r3, #1]
  if ((thread->state == osRtxThreadInactive) ||
    7206:	2b04      	cmp	r3, #4
    7208:	d01f      	beq.n	724a <osRtxThreadPostProcess+0x56>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }

  // Check if Thread is waiting for Thread Flags
  if (thread->state == osRtxThreadWaitingThreadFlags) {
    720a:	9b01      	ldr	r3, [sp, #4]
    720c:	785b      	ldrb	r3, [r3, #1]
    720e:	2b33      	cmp	r3, #51	; 0x33
    7210:	d11c      	bne.n	724c <osRtxThreadPostProcess+0x58>
    thread_flags = ThreadFlagsCheck(thread, thread->wait_flags, thread->flags_options);
    7212:	9b01      	ldr	r3, [sp, #4]
    7214:	6a59      	ldr	r1, [r3, #36]	; 0x24
    7216:	9b01      	ldr	r3, [sp, #4]
    7218:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
    721c:	461a      	mov	r2, r3
    721e:	9801      	ldr	r0, [sp, #4]
    7220:	f7ff fc5a 	bl	6ad8 <ThreadFlagsCheck>
    7224:	9003      	str	r0, [sp, #12]
    if (thread_flags != 0U) {
    7226:	9b03      	ldr	r3, [sp, #12]
    7228:	2b00      	cmp	r3, #0
    722a:	d00f      	beq.n	724c <osRtxThreadPostProcess+0x58>
      osRtxThreadWaitExit(thread, thread_flags, FALSE);
    722c:	2200      	movs	r2, #0
    722e:	9903      	ldr	r1, [sp, #12]
    7230:	9801      	ldr	r0, [sp, #4]
    7232:	f7ff ff65 	bl	7100 <osRtxThreadWaitExit>
      EvrRtxThreadFlagsWaitCompleted(thread->wait_flags, thread->flags_options, thread_flags);
    7236:	9b01      	ldr	r3, [sp, #4]
    7238:	6a58      	ldr	r0, [r3, #36]	; 0x24
    723a:	9b01      	ldr	r3, [sp, #4]
    723c:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
    7240:	9a03      	ldr	r2, [sp, #12]
    7242:	4619      	mov	r1, r3
    7244:	f7fd fa76 	bl	4734 <EvrRtxThreadFlagsWaitCompleted>
    7248:	e000      	b.n	724c <osRtxThreadPostProcess+0x58>
    return;
    724a:	bf00      	nop
    }
  }
}
    724c:	b005      	add	sp, #20
    724e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00007254 <svcRtxThreadNew>:

//  ==== Service Calls ====

/// Create a thread and add it to Active Threads.
/// \note API identical to osThreadContextNew
osThreadId_t svcRtxThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr, void *context) {
    7254:	b510      	push	{r4, lr}
    7256:	b08e      	sub	sp, #56	; 0x38
    7258:	9003      	str	r0, [sp, #12]
    725a:	9102      	str	r1, [sp, #8]
    725c:	9201      	str	r2, [sp, #4]
    725e:	9300      	str	r3, [sp, #0]
  TZ_ModuleId_t tz_module;
  TZ_MemoryId_t tz_memory;
#endif

  // Check parameters
  if (func == NULL) {
    7260:	9b03      	ldr	r3, [sp, #12]
    7262:	2b00      	cmp	r3, #0
    7264:	d106      	bne.n	7274 <svcRtxThreadNew+0x20>
    EvrRtxThreadError(NULL, (int32_t)osErrorParameter);
    7266:	f06f 0103 	mvn.w	r1, #3
    726a:	2000      	movs	r0, #0
    726c:	f7fd f906 	bl	447c <EvrRtxThreadError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return NULL;
    7270:	2300      	movs	r3, #0
    7272:	e1cd      	b.n	7610 <svcRtxThreadNew+0x3bc>
  }

  // Process attributes
  if (attr != NULL) {
    7274:	9b01      	ldr	r3, [sp, #4]
    7276:	2b00      	cmp	r3, #0
    7278:	d054      	beq.n	7324 <svcRtxThreadNew+0xd0>
    name       = attr->name;
    727a:	9b01      	ldr	r3, [sp, #4]
    727c:	681b      	ldr	r3, [r3, #0]
    727e:	9307      	str	r3, [sp, #28]
    attr_bits  = attr->attr_bits;
    7280:	9b01      	ldr	r3, [sp, #4]
    7282:	685b      	ldr	r3, [r3, #4]
    7284:	930c      	str	r3, [sp, #48]	; 0x30
    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
    thread     = attr->cb_mem;
    7286:	9b01      	ldr	r3, [sp, #4]
    7288:	689b      	ldr	r3, [r3, #8]
    728a:	930d      	str	r3, [sp, #52]	; 0x34
    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
    stack_mem  = attr->stack_mem;
    728c:	9b01      	ldr	r3, [sp, #4]
    728e:	691b      	ldr	r3, [r3, #16]
    7290:	930b      	str	r3, [sp, #44]	; 0x2c
    stack_size = attr->stack_size;
    7292:	9b01      	ldr	r3, [sp, #4]
    7294:	695b      	ldr	r3, [r3, #20]
    7296:	930a      	str	r3, [sp, #40]	; 0x28
    priority   = attr->priority;
    7298:	9b01      	ldr	r3, [sp, #4]
    729a:	699b      	ldr	r3, [r3, #24]
    729c:	9309      	str	r3, [sp, #36]	; 0x24
#if (DOMAIN_NS == 1)
    tz_module  = attr->tz_module;
#endif
    if (thread != NULL) {
    729e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    72a0:	2b00      	cmp	r3, #0
    72a2:	d00f      	beq.n	72c4 <svcRtxThreadNew+0x70>
      //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
      if ((((uint32_t)thread & 3U) != 0U) || (attr->cb_size < sizeof(os_thread_t))) {
    72a4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    72a6:	f003 0303 	and.w	r3, r3, #3
    72aa:	2b00      	cmp	r3, #0
    72ac:	d103      	bne.n	72b6 <svcRtxThreadNew+0x62>
    72ae:	9b01      	ldr	r3, [sp, #4]
    72b0:	68db      	ldr	r3, [r3, #12]
    72b2:	2b47      	cmp	r3, #71	; 0x47
    72b4:	d811      	bhi.n	72da <svcRtxThreadNew+0x86>
        EvrRtxThreadError(NULL, osRtxErrorInvalidControlBlock);
    72b6:	f06f 0108 	mvn.w	r1, #8
    72ba:	2000      	movs	r0, #0
    72bc:	f7fd f8de 	bl	447c <EvrRtxThreadError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    72c0:	2300      	movs	r3, #0
    72c2:	e1a5      	b.n	7610 <svcRtxThreadNew+0x3bc>
      }
    } else {
      if (attr->cb_size != 0U) {
    72c4:	9b01      	ldr	r3, [sp, #4]
    72c6:	68db      	ldr	r3, [r3, #12]
    72c8:	2b00      	cmp	r3, #0
    72ca:	d006      	beq.n	72da <svcRtxThreadNew+0x86>
        EvrRtxThreadError(NULL, osRtxErrorInvalidControlBlock);
    72cc:	f06f 0108 	mvn.w	r1, #8
    72d0:	2000      	movs	r0, #0
    72d2:	f7fd f8d3 	bl	447c <EvrRtxThreadError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    72d6:	2300      	movs	r3, #0
    72d8:	e19a      	b.n	7610 <svcRtxThreadNew+0x3bc>
      }
    }
    if (stack_mem != NULL) {
    72da:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    72dc:	2b00      	cmp	r3, #0
    72de:	d00e      	beq.n	72fe <svcRtxThreadNew+0xaa>
      //lint -e(923) -e(9078) "cast from pointer to unsigned int" [MISRA Note 7]
      if ((((uint32_t)stack_mem & 7U) != 0U) || (stack_size == 0U)) {
    72e0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    72e2:	f003 0307 	and.w	r3, r3, #7
    72e6:	2b00      	cmp	r3, #0
    72e8:	d102      	bne.n	72f0 <svcRtxThreadNew+0x9c>
    72ea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    72ec:	2b00      	cmp	r3, #0
    72ee:	d106      	bne.n	72fe <svcRtxThreadNew+0xaa>
        EvrRtxThreadError(NULL, osRtxErrorInvalidThreadStack);
    72f0:	f06f 010a 	mvn.w	r1, #10
    72f4:	2000      	movs	r0, #0
    72f6:	f7fd f8c1 	bl	447c <EvrRtxThreadError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    72fa:	2300      	movs	r3, #0
    72fc:	e188      	b.n	7610 <svcRtxThreadNew+0x3bc>
      }
    }
    if (priority == osPriorityNone) {
    72fe:	9b09      	ldr	r3, [sp, #36]	; 0x24
    7300:	2b00      	cmp	r3, #0
    7302:	d102      	bne.n	730a <svcRtxThreadNew+0xb6>
      priority = osPriorityNormal;
    7304:	2318      	movs	r3, #24
    7306:	9309      	str	r3, [sp, #36]	; 0x24
    7308:	e018      	b.n	733c <svcRtxThreadNew+0xe8>
    } else {
      if ((priority < osPriorityIdle) || (priority > osPriorityISR)) {
    730a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    730c:	2b00      	cmp	r3, #0
    730e:	dd02      	ble.n	7316 <svcRtxThreadNew+0xc2>
    7310:	9b09      	ldr	r3, [sp, #36]	; 0x24
    7312:	2b38      	cmp	r3, #56	; 0x38
    7314:	dd12      	ble.n	733c <svcRtxThreadNew+0xe8>
        EvrRtxThreadError(NULL, osRtxErrorInvalidPriority);
    7316:	f06f 010b 	mvn.w	r1, #11
    731a:	2000      	movs	r0, #0
    731c:	f7fd f8ae 	bl	447c <EvrRtxThreadError>
        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
        return NULL;
    7320:	2300      	movs	r3, #0
    7322:	e175      	b.n	7610 <svcRtxThreadNew+0x3bc>
      }
    }
  } else {
    name       = NULL;
    7324:	2300      	movs	r3, #0
    7326:	9307      	str	r3, [sp, #28]
    attr_bits  = 0U;
    7328:	2300      	movs	r3, #0
    732a:	930c      	str	r3, [sp, #48]	; 0x30
    thread     = NULL;
    732c:	2300      	movs	r3, #0
    732e:	930d      	str	r3, [sp, #52]	; 0x34
    stack_mem  = NULL;
    7330:	2300      	movs	r3, #0
    7332:	930b      	str	r3, [sp, #44]	; 0x2c
    stack_size = 0U;
    7334:	2300      	movs	r3, #0
    7336:	930a      	str	r3, [sp, #40]	; 0x28
    priority   = osPriorityNormal;
    7338:	2318      	movs	r3, #24
    733a:	9309      	str	r3, [sp, #36]	; 0x24
    tz_module  = 0U;
#endif
  }

  // Check stack size
  if ((stack_size != 0U) && (((stack_size & 7U) != 0U) || (stack_size < (64U + 8U)))) {
    733c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    733e:	2b00      	cmp	r3, #0
    7340:	d00e      	beq.n	7360 <svcRtxThreadNew+0x10c>
    7342:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    7344:	f003 0307 	and.w	r3, r3, #7
    7348:	2b00      	cmp	r3, #0
    734a:	d102      	bne.n	7352 <svcRtxThreadNew+0xfe>
    734c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    734e:	2b47      	cmp	r3, #71	; 0x47
    7350:	d806      	bhi.n	7360 <svcRtxThreadNew+0x10c>
    EvrRtxThreadError(NULL, osRtxErrorInvalidThreadStack);
    7352:	f06f 010a 	mvn.w	r1, #10
    7356:	2000      	movs	r0, #0
    7358:	f7fd f890 	bl	447c <EvrRtxThreadError>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return NULL;
    735c:	2300      	movs	r3, #0
    735e:	e157      	b.n	7610 <svcRtxThreadNew+0x3bc>
  }

  // Allocate object memory if not provided
  if (thread == NULL) {
    7360:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7362:	2b00      	cmp	r3, #0
    7364:	d119      	bne.n	739a <svcRtxThreadNew+0x146>
    if (osRtxInfo.mpi.thread != NULL) {
    7366:	4b9f      	ldr	r3, [pc, #636]	; (75e4 <svcRtxThreadNew+0x390>)
    7368:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    736c:	2b00      	cmp	r3, #0
    736e:	d007      	beq.n	7380 <svcRtxThreadNew+0x12c>
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      thread = osRtxMemoryPoolAlloc(osRtxInfo.mpi.thread);
    7370:	4b9c      	ldr	r3, [pc, #624]	; (75e4 <svcRtxThreadNew+0x390>)
    7372:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    7376:	4618      	mov	r0, r3
    7378:	f7fd ffd5 	bl	5326 <osRtxMemoryPoolAlloc>
    737c:	900d      	str	r0, [sp, #52]	; 0x34
    737e:	e008      	b.n	7392 <svcRtxThreadNew+0x13e>
    } else {
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      thread = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_thread_t), 1U);
    7380:	4b98      	ldr	r3, [pc, #608]	; (75e4 <svcRtxThreadNew+0x390>)
    7382:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    7386:	2201      	movs	r2, #1
    7388:	2148      	movs	r1, #72	; 0x48
    738a:	4618      	mov	r0, r3
    738c:	f7fd fe33 	bl	4ff6 <osRtxMemoryAlloc>
    7390:	900d      	str	r0, [sp, #52]	; 0x34
      if (osRtxThreadMemUsage.max_used < used) {
        osRtxThreadMemUsage.max_used = used;
      }
    }
#endif
    flags = osRtxFlagSystemObject;
    7392:	2301      	movs	r3, #1
    7394:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    7398:	e002      	b.n	73a0 <svcRtxThreadNew+0x14c>
  } else {
    flags = 0U;
    739a:	2300      	movs	r3, #0
    739c:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
  }

  // Allocate stack memory if not provided
  if ((thread != NULL) && (stack_mem == NULL)) {
    73a0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    73a2:	2b00      	cmp	r3, #0
    73a4:	d054      	beq.n	7450 <svcRtxThreadNew+0x1fc>
    73a6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    73a8:	2b00      	cmp	r3, #0
    73aa:	d151      	bne.n	7450 <svcRtxThreadNew+0x1fc>
    if (stack_size == 0U) {
    73ac:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    73ae:	2b00      	cmp	r3, #0
    73b0:	d121      	bne.n	73f6 <svcRtxThreadNew+0x1a2>
      stack_size = osRtxConfig.thread_stack_size;
    73b2:	4b8d      	ldr	r3, [pc, #564]	; (75e8 <svcRtxThreadNew+0x394>)
    73b4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    73b6:	930a      	str	r3, [sp, #40]	; 0x28
      if (osRtxInfo.mpi.stack != NULL) {
    73b8:	4b8a      	ldr	r3, [pc, #552]	; (75e4 <svcRtxThreadNew+0x390>)
    73ba:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
    73be:	2b00      	cmp	r3, #0
    73c0:	d010      	beq.n	73e4 <svcRtxThreadNew+0x190>
        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
        stack_mem = osRtxMemoryPoolAlloc(osRtxInfo.mpi.stack);
    73c2:	4b88      	ldr	r3, [pc, #544]	; (75e4 <svcRtxThreadNew+0x390>)
    73c4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
    73c8:	4618      	mov	r0, r3
    73ca:	f7fd ffac 	bl	5326 <osRtxMemoryPoolAlloc>
    73ce:	900b      	str	r0, [sp, #44]	; 0x2c
        if (stack_mem != NULL) {
    73d0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    73d2:	2b00      	cmp	r3, #0
    73d4:	d017      	beq.n	7406 <svcRtxThreadNew+0x1b2>
          flags |= osRtxThreadFlagDefStack;
    73d6:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    73da:	f043 0310 	orr.w	r3, r3, #16
    73de:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    73e2:	e010      	b.n	7406 <svcRtxThreadNew+0x1b2>
        }
      } else {
        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
        stack_mem = osRtxMemoryAlloc(osRtxInfo.mem.stack, stack_size, 0U);
    73e4:	4b7f      	ldr	r3, [pc, #508]	; (75e4 <svcRtxThreadNew+0x390>)
    73e6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    73e8:	2200      	movs	r2, #0
    73ea:	990a      	ldr	r1, [sp, #40]	; 0x28
    73ec:	4618      	mov	r0, r3
    73ee:	f7fd fe02 	bl	4ff6 <osRtxMemoryAlloc>
    73f2:	900b      	str	r0, [sp, #44]	; 0x2c
    73f4:	e007      	b.n	7406 <svcRtxThreadNew+0x1b2>
      }
    } else {
      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
      stack_mem = osRtxMemoryAlloc(osRtxInfo.mem.stack, stack_size, 0U);
    73f6:	4b7b      	ldr	r3, [pc, #492]	; (75e4 <svcRtxThreadNew+0x390>)
    73f8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    73fa:	2200      	movs	r2, #0
    73fc:	990a      	ldr	r1, [sp, #40]	; 0x28
    73fe:	4618      	mov	r0, r3
    7400:	f7fd fdf9 	bl	4ff6 <osRtxMemoryAlloc>
    7404:	900b      	str	r0, [sp, #44]	; 0x2c
    }
    if (stack_mem == NULL) {
    7406:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    7408:	2b00      	cmp	r3, #0
    740a:	d11b      	bne.n	7444 <svcRtxThreadNew+0x1f0>
      if ((flags & osRtxFlagSystemObject) != 0U) {
    740c:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    7410:	f003 0301 	and.w	r3, r3, #1
    7414:	2b00      	cmp	r3, #0
    7416:	d013      	beq.n	7440 <svcRtxThreadNew+0x1ec>
        if (osRtxInfo.mpi.thread != NULL) {
    7418:	4b72      	ldr	r3, [pc, #456]	; (75e4 <svcRtxThreadNew+0x390>)
    741a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    741e:	2b00      	cmp	r3, #0
    7420:	d007      	beq.n	7432 <svcRtxThreadNew+0x1de>
          (void)osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
    7422:	4b70      	ldr	r3, [pc, #448]	; (75e4 <svcRtxThreadNew+0x390>)
    7424:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    7428:	990d      	ldr	r1, [sp, #52]	; 0x34
    742a:	4618      	mov	r0, r3
    742c:	f7fd ffa6 	bl	537c <osRtxMemoryPoolFree>
    7430:	e006      	b.n	7440 <svcRtxThreadNew+0x1ec>
        } else {
          (void)osRtxMemoryFree(osRtxInfo.mem.common, thread);
    7432:	4b6c      	ldr	r3, [pc, #432]	; (75e4 <svcRtxThreadNew+0x390>)
    7434:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    7438:	990d      	ldr	r1, [sp, #52]	; 0x34
    743a:	4618      	mov	r0, r3
    743c:	f7fd fe77 	bl	512e <osRtxMemoryFree>
        }
#if (defined(OS_OBJ_MEM_USAGE) && (OS_OBJ_MEM_USAGE != 0))
        osRtxThreadMemUsage.cnt_free++;
#endif
      }
      thread = NULL;
    7440:	2300      	movs	r3, #0
    7442:	930d      	str	r3, [sp, #52]	; 0x34
    }
    flags |= osRtxFlagSystemMemory;
    7444:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    7448:	f043 0302 	orr.w	r3, r3, #2
    744c:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
  } else {
    tz_memory = 0U;
  }
#endif

  if (thread != NULL) {
    7450:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7452:	2b00      	cmp	r3, #0
    7454:	f000 80ad 	beq.w	75b2 <svcRtxThreadNew+0x35e>
    // Initialize control block
    //lint --e{923}  --e{9078} "cast between pointers and unsigned int"
    //lint --e{9079} --e{9087} "cast between pointers to different object types"
    //lint --e{9074} "conversion between a pointer to function and another type"
    thread->id            = osRtxIdThread;
    7458:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    745a:	2201      	movs	r2, #1
    745c:	701a      	strb	r2, [r3, #0]
    thread->state         = osRtxThreadReady;
    745e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7460:	2201      	movs	r2, #1
    7462:	705a      	strb	r2, [r3, #1]
    thread->flags         = flags;
    7464:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7466:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
    746a:	709a      	strb	r2, [r3, #2]
    thread->attr          = (uint8_t)attr_bits;
    746c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    746e:	b2da      	uxtb	r2, r3
    7470:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7472:	70da      	strb	r2, [r3, #3]
    thread->name          = name;
    7474:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7476:	9a07      	ldr	r2, [sp, #28]
    7478:	605a      	str	r2, [r3, #4]
    thread->thread_next   = NULL;
    747a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    747c:	2200      	movs	r2, #0
    747e:	609a      	str	r2, [r3, #8]
    thread->thread_prev   = NULL;
    7480:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7482:	2200      	movs	r2, #0
    7484:	60da      	str	r2, [r3, #12]
    thread->delay_next    = NULL;
    7486:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7488:	2200      	movs	r2, #0
    748a:	611a      	str	r2, [r3, #16]
    thread->delay_prev    = NULL;
    748c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    748e:	2200      	movs	r2, #0
    7490:	615a      	str	r2, [r3, #20]
    thread->thread_join   = NULL;
    7492:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7494:	2200      	movs	r2, #0
    7496:	619a      	str	r2, [r3, #24]
    thread->delay         = 0U;
    7498:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    749a:	2200      	movs	r2, #0
    749c:	61da      	str	r2, [r3, #28]
    thread->priority      = (int8_t)priority;
    749e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    74a0:	b25a      	sxtb	r2, r3
    74a2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74a4:	f883 2020 	strb.w	r2, [r3, #32]
    thread->priority_base = (int8_t)priority;
    74a8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    74aa:	b25a      	sxtb	r2, r3
    74ac:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74ae:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
    thread->stack_frame   = STACK_FRAME_INIT_VAL;
    74b2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74b4:	22fd      	movs	r2, #253	; 0xfd
    74b6:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    thread->flags_options = 0U;
    74ba:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74bc:	2200      	movs	r2, #0
    74be:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
    thread->wait_flags    = 0U;
    74c2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74c4:	2200      	movs	r2, #0
    74c6:	625a      	str	r2, [r3, #36]	; 0x24
    thread->thread_flags  = 0U;
    74c8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74ca:	2200      	movs	r2, #0
    74cc:	629a      	str	r2, [r3, #40]	; 0x28
    thread->mutex_list    = NULL;
    74ce:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74d0:	2200      	movs	r2, #0
    74d2:	62da      	str	r2, [r3, #44]	; 0x2c
    thread->stack_mem     = stack_mem;
    74d4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74d6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    74d8:	631a      	str	r2, [r3, #48]	; 0x30
    thread->stack_size    = stack_size;
    74da:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74dc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    74de:	635a      	str	r2, [r3, #52]	; 0x34
    thread->sp            = (uint32_t)stack_mem + stack_size - 64U;
    74e0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    74e2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    74e4:	4413      	add	r3, r2
    74e6:	f1a3 0240 	sub.w	r2, r3, #64	; 0x40
    74ea:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74ec:	639a      	str	r2, [r3, #56]	; 0x38
    thread->thread_addr   = (uint32_t)func;
    74ee:	9a03      	ldr	r2, [sp, #12]
    74f0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    74f2:	63da      	str	r2, [r3, #60]	; 0x3c
    thread->tz_memory     = tz_memory;
  #endif

    // Initialize stack
    //lint --e{613} false detection: "Possible use of null pointer"
    ptr = (uint32_t *)stack_mem;
    74f4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    74f6:	9306      	str	r3, [sp, #24]
    ptr[0] = osRtxStackMagicWord;
    74f8:	9b06      	ldr	r3, [sp, #24]
    74fa:	4a3c      	ldr	r2, [pc, #240]	; (75ec <svcRtxThreadNew+0x398>)
    74fc:	601a      	str	r2, [r3, #0]
    if ((osRtxConfig.flags & osRtxConfigStackWatermark) != 0U) {
    74fe:	4b3a      	ldr	r3, [pc, #232]	; (75e8 <svcRtxThreadNew+0x394>)
    7500:	681b      	ldr	r3, [r3, #0]
    7502:	f003 0304 	and.w	r3, r3, #4
    7506:	2b00      	cmp	r3, #0
    7508:	d011      	beq.n	752e <svcRtxThreadNew+0x2da>
      for (n = (stack_size/4U) - (16U + 1U); n != 0U; n--) {
    750a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    750c:	089b      	lsrs	r3, r3, #2
    750e:	3b11      	subs	r3, #17
    7510:	9305      	str	r3, [sp, #20]
    7512:	e009      	b.n	7528 <svcRtxThreadNew+0x2d4>
         ptr++;
    7514:	9b06      	ldr	r3, [sp, #24]
    7516:	3304      	adds	r3, #4
    7518:	9306      	str	r3, [sp, #24]
        *ptr = osRtxStackFillPattern;
    751a:	9b06      	ldr	r3, [sp, #24]
    751c:	f04f 32cc 	mov.w	r2, #3435973836	; 0xcccccccc
    7520:	601a      	str	r2, [r3, #0]
      for (n = (stack_size/4U) - (16U + 1U); n != 0U; n--) {
    7522:	9b05      	ldr	r3, [sp, #20]
    7524:	3b01      	subs	r3, #1
    7526:	9305      	str	r3, [sp, #20]
    7528:	9b05      	ldr	r3, [sp, #20]
    752a:	2b00      	cmp	r3, #0
    752c:	d1f2      	bne.n	7514 <svcRtxThreadNew+0x2c0>
      }
    }
    ptr = (uint32_t *)thread->sp;
    752e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7530:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    7532:	9306      	str	r3, [sp, #24]
    for (n = 0U; n != 13U; n++) {
    7534:	2300      	movs	r3, #0
    7536:	9305      	str	r3, [sp, #20]
    7538:	e008      	b.n	754c <svcRtxThreadNew+0x2f8>
      ptr[n] = 0U;                      // R4..R11, R0..R3, R12
    753a:	9b05      	ldr	r3, [sp, #20]
    753c:	009b      	lsls	r3, r3, #2
    753e:	9a06      	ldr	r2, [sp, #24]
    7540:	4413      	add	r3, r2
    7542:	2200      	movs	r2, #0
    7544:	601a      	str	r2, [r3, #0]
    for (n = 0U; n != 13U; n++) {
    7546:	9b05      	ldr	r3, [sp, #20]
    7548:	3301      	adds	r3, #1
    754a:	9305      	str	r3, [sp, #20]
    754c:	9b05      	ldr	r3, [sp, #20]
    754e:	2b0d      	cmp	r3, #13
    7550:	d1f3      	bne.n	753a <svcRtxThreadNew+0x2e6>
    }
    ptr[13] = (uint32_t)osThreadExit;   // LR
    7552:	9b06      	ldr	r3, [sp, #24]
    7554:	3334      	adds	r3, #52	; 0x34
    7556:	4a26      	ldr	r2, [pc, #152]	; (75f0 <svcRtxThreadNew+0x39c>)
    7558:	601a      	str	r2, [r3, #0]
    ptr[14] = (uint32_t)func;           // PC
    755a:	9b06      	ldr	r3, [sp, #24]
    755c:	3338      	adds	r3, #56	; 0x38
    755e:	9a03      	ldr	r2, [sp, #12]
    7560:	601a      	str	r2, [r3, #0]
    ptr[15] = xPSR_InitVal(
    7562:	9b06      	ldr	r3, [sp, #24]
    7564:	f103 043c 	add.w	r4, r3, #60	; 0x3c
                (bool_t)((osRtxConfig.flags & osRtxConfigPrivilegedMode) != 0U),
    7568:	4b1f      	ldr	r3, [pc, #124]	; (75e8 <svcRtxThreadNew+0x394>)
    756a:	681b      	ldr	r3, [r3, #0]
    756c:	f003 0301 	and.w	r3, r3, #1
    ptr[15] = xPSR_InitVal(
    7570:	2b00      	cmp	r3, #0
    7572:	bf14      	ite	ne
    7574:	2301      	movne	r3, #1
    7576:	2300      	moveq	r3, #0
    7578:	b2da      	uxtb	r2, r3
                (bool_t)(((uint32_t)func & 1U) != 0U)
    757a:	9b03      	ldr	r3, [sp, #12]
    757c:	f003 0301 	and.w	r3, r3, #1
    ptr[15] = xPSR_InitVal(
    7580:	2b00      	cmp	r3, #0
    7582:	bf14      	ite	ne
    7584:	2301      	movne	r3, #1
    7586:	2300      	moveq	r3, #0
    7588:	b2db      	uxtb	r3, r3
    758a:	4619      	mov	r1, r3
    758c:	4610      	mov	r0, r2
    758e:	f7ff fa03 	bl	6998 <xPSR_InitVal>
    7592:	4603      	mov	r3, r0
    7594:	6023      	str	r3, [r4, #0]
              );                        // xPSR
    ptr[8]  = (uint32_t)argument;       // R0
    7596:	9b06      	ldr	r3, [sp, #24]
    7598:	3320      	adds	r3, #32
    759a:	9a02      	ldr	r2, [sp, #8]
    759c:	601a      	str	r2, [r3, #0]

    // Register post ISR processing function
    osRtxInfo.post_process.thread = osRtxThreadPostProcess;
    759e:	4b11      	ldr	r3, [pc, #68]	; (75e4 <svcRtxThreadNew+0x390>)
    75a0:	4a14      	ldr	r2, [pc, #80]	; (75f4 <svcRtxThreadNew+0x3a0>)
    75a2:	661a      	str	r2, [r3, #96]	; 0x60

    EvrRtxThreadCreated(thread, thread->thread_addr);
    75a4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    75a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    75a8:	4619      	mov	r1, r3
    75aa:	980d      	ldr	r0, [sp, #52]	; 0x34
    75ac:	f7fd f87d 	bl	46aa <EvrRtxThreadCreated>
    75b0:	e004      	b.n	75bc <svcRtxThreadNew+0x368>
  } else {
    EvrRtxThreadError(NULL, (int32_t)osErrorNoMemory);
    75b2:	f06f 0104 	mvn.w	r1, #4
    75b6:	2000      	movs	r0, #0
    75b8:	f7fc ff60 	bl	447c <EvrRtxThreadError>
  }

  /* Notify the OS event observer of a new thread. */
  if (osEventObs && osEventObs->thread_create) {
    75bc:	4b0e      	ldr	r3, [pc, #56]	; (75f8 <svcRtxThreadNew+0x3a4>)
    75be:	681b      	ldr	r3, [r3, #0]
    75c0:	2b00      	cmp	r3, #0
    75c2:	d01b      	beq.n	75fc <svcRtxThreadNew+0x3a8>
    75c4:	4b0c      	ldr	r3, [pc, #48]	; (75f8 <svcRtxThreadNew+0x3a4>)
    75c6:	681b      	ldr	r3, [r3, #0]
    75c8:	689b      	ldr	r3, [r3, #8]
    75ca:	2b00      	cmp	r3, #0
    75cc:	d016      	beq.n	75fc <svcRtxThreadNew+0x3a8>
    thread->context = osEventObs->thread_create((int)thread, context);
    75ce:	4b0a      	ldr	r3, [pc, #40]	; (75f8 <svcRtxThreadNew+0x3a4>)
    75d0:	681b      	ldr	r3, [r3, #0]
    75d2:	689b      	ldr	r3, [r3, #8]
    75d4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    75d6:	9900      	ldr	r1, [sp, #0]
    75d8:	4610      	mov	r0, r2
    75da:	4798      	blx	r3
    75dc:	4602      	mov	r2, r0
    75de:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    75e0:	645a      	str	r2, [r3, #68]	; 0x44
    75e2:	e00e      	b.n	7602 <svcRtxThreadNew+0x3ae>
    75e4:	20000110 	.word	0x20000110
    75e8:	0001144c 	.word	0x0001144c
    75ec:	e25a2ea5 	.word	0xe25a2ea5
    75f0:	00007bcd 	.word	0x00007bcd
    75f4:	000071f5 	.word	0x000071f5
    75f8:	20002f58 	.word	0x20002f58
  } else {
    thread->context = context;
    75fc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    75fe:	9a00      	ldr	r2, [sp, #0]
    7600:	645a      	str	r2, [r3, #68]	; 0x44
  }

  if (thread != NULL) {
    7602:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7604:	2b00      	cmp	r3, #0
    7606:	d002      	beq.n	760e <svcRtxThreadNew+0x3ba>
    osRtxThreadDispatch(thread);
    7608:	980d      	ldr	r0, [sp, #52]	; 0x34
    760a:	f7ff fd2d 	bl	7068 <osRtxThreadDispatch>
  }

  return thread;
    760e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
}
    7610:	4618      	mov	r0, r3
    7612:	b00e      	add	sp, #56	; 0x38
    7614:	bd10      	pop	{r4, pc}
    7616:	bf00      	nop

00007618 <svcRtxThreadGetId>:
  return thread->name;
}

/// Return the thread ID of the current running thread.
/// \note API identical to osThreadGetId
static osThreadId_t svcRtxThreadGetId (void) {
    7618:	b500      	push	{lr}
    761a:	b083      	sub	sp, #12
  os_thread_t *thread;

  thread = osRtxThreadGetRunning();
    761c:	f7ff fa4c 	bl	6ab8 <osRtxThreadGetRunning>
    7620:	9001      	str	r0, [sp, #4]
  EvrRtxThreadGetId(thread);
    7622:	9801      	ldr	r0, [sp, #4]
    7624:	f7fd f847 	bl	46b6 <EvrRtxThreadGetId>
  return thread;
    7628:	9b01      	ldr	r3, [sp, #4]
}
    762a:	4618      	mov	r0, r3
    762c:	b003      	add	sp, #12
    762e:	f85d fb04 	ldr.w	pc, [sp], #4

00007632 <svcRtxThreadGetStackSize>:
  return state;
}

/// Get stack size of a thread.
/// \note API identical to osThreadGetStackSize
static uint32_t svcRtxThreadGetStackSize (osThreadId_t thread_id) {
    7632:	b500      	push	{lr}
    7634:	b085      	sub	sp, #20
    7636:	9001      	str	r0, [sp, #4]
  os_thread_t *thread = osRtxThreadId(thread_id);
    7638:	9801      	ldr	r0, [sp, #4]
    763a:	f7ff fa25 	bl	6a88 <osRtxThreadId>
    763e:	9003      	str	r0, [sp, #12]

  // Check parameters
  if ((thread == NULL) || (thread->id != osRtxIdThread)) {
    7640:	9b03      	ldr	r3, [sp, #12]
    7642:	2b00      	cmp	r3, #0
    7644:	d003      	beq.n	764e <svcRtxThreadGetStackSize+0x1c>
    7646:	9b03      	ldr	r3, [sp, #12]
    7648:	781b      	ldrb	r3, [r3, #0]
    764a:	2b01      	cmp	r3, #1
    764c:	d005      	beq.n	765a <svcRtxThreadGetStackSize+0x28>
    EvrRtxThreadGetStackSize(thread, 0U);
    764e:	2100      	movs	r1, #0
    7650:	9803      	ldr	r0, [sp, #12]
    7652:	f7fd f835 	bl	46c0 <EvrRtxThreadGetStackSize>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    7656:	2300      	movs	r3, #0
    7658:	e011      	b.n	767e <svcRtxThreadGetStackSize+0x4c>
  }

  // Check object state
  if (thread->state == osRtxObjectInactive) {
    765a:	9b03      	ldr	r3, [sp, #12]
    765c:	785b      	ldrb	r3, [r3, #1]
    765e:	2b00      	cmp	r3, #0
    7660:	d105      	bne.n	766e <svcRtxThreadGetStackSize+0x3c>
    EvrRtxThreadGetStackSize(thread, 0U);
    7662:	2100      	movs	r1, #0
    7664:	9803      	ldr	r0, [sp, #12]
    7666:	f7fd f82b 	bl	46c0 <EvrRtxThreadGetStackSize>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    766a:	2300      	movs	r3, #0
    766c:	e007      	b.n	767e <svcRtxThreadGetStackSize+0x4c>
  }

  EvrRtxThreadGetStackSize(thread, thread->stack_size);
    766e:	9b03      	ldr	r3, [sp, #12]
    7670:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    7672:	4619      	mov	r1, r3
    7674:	9803      	ldr	r0, [sp, #12]
    7676:	f7fd f823 	bl	46c0 <EvrRtxThreadGetStackSize>

  return thread->stack_size;
    767a:	9b03      	ldr	r3, [sp, #12]
    767c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
    767e:	4618      	mov	r0, r3
    7680:	b005      	add	sp, #20
    7682:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00007688 <svcRtxThreadGetStackSpace>:

/// Get available stack space of a thread based on stack watermark recording during execution.
/// \note API identical to osThreadGetStackSpace
static uint32_t svcRtxThreadGetStackSpace (osThreadId_t thread_id) {
    7688:	b500      	push	{lr}
    768a:	b087      	sub	sp, #28
    768c:	9001      	str	r0, [sp, #4]
  os_thread_t    *thread = osRtxThreadId(thread_id);
    768e:	9801      	ldr	r0, [sp, #4]
    7690:	f7ff f9fa 	bl	6a88 <osRtxThreadId>
    7694:	9003      	str	r0, [sp, #12]
  const uint32_t *stack;
        uint32_t  space;

  // Check parameters
  if ((thread == NULL) || (thread->id != osRtxIdThread)) {
    7696:	9b03      	ldr	r3, [sp, #12]
    7698:	2b00      	cmp	r3, #0
    769a:	d003      	beq.n	76a4 <svcRtxThreadGetStackSpace+0x1c>
    769c:	9b03      	ldr	r3, [sp, #12]
    769e:	781b      	ldrb	r3, [r3, #0]
    76a0:	2b01      	cmp	r3, #1
    76a2:	d005      	beq.n	76b0 <svcRtxThreadGetStackSpace+0x28>
    EvrRtxThreadGetStackSpace(thread, 0U);
    76a4:	2100      	movs	r1, #0
    76a6:	9803      	ldr	r0, [sp, #12]
    76a8:	f7fd f810 	bl	46cc <EvrRtxThreadGetStackSpace>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    76ac:	2300      	movs	r3, #0
    76ae:	e03b      	b.n	7728 <svcRtxThreadGetStackSpace+0xa0>
  }

  // Check object state
  if (thread->state == osRtxObjectInactive) {
    76b0:	9b03      	ldr	r3, [sp, #12]
    76b2:	785b      	ldrb	r3, [r3, #1]
    76b4:	2b00      	cmp	r3, #0
    76b6:	d105      	bne.n	76c4 <svcRtxThreadGetStackSpace+0x3c>
    EvrRtxThreadGetStackSpace(thread, 0U);
    76b8:	2100      	movs	r1, #0
    76ba:	9803      	ldr	r0, [sp, #12]
    76bc:	f7fd f806 	bl	46cc <EvrRtxThreadGetStackSpace>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    76c0:	2300      	movs	r3, #0
    76c2:	e031      	b.n	7728 <svcRtxThreadGetStackSpace+0xa0>
  }

  // Check if stack watermark is not enabled
  if ((osRtxConfig.flags & osRtxConfigStackWatermark) == 0U) {
    76c4:	4b1a      	ldr	r3, [pc, #104]	; (7730 <svcRtxThreadGetStackSpace+0xa8>)
    76c6:	681b      	ldr	r3, [r3, #0]
    76c8:	f003 0304 	and.w	r3, r3, #4
    76cc:	2b00      	cmp	r3, #0
    76ce:	d105      	bne.n	76dc <svcRtxThreadGetStackSpace+0x54>
    EvrRtxThreadGetStackSpace(thread, 0U);
    76d0:	2100      	movs	r1, #0
    76d2:	9803      	ldr	r0, [sp, #12]
    76d4:	f7fc fffa 	bl	46cc <EvrRtxThreadGetStackSpace>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    76d8:	2300      	movs	r3, #0
    76da:	e025      	b.n	7728 <svcRtxThreadGetStackSpace+0xa0>
  }

  //lint -e{9079} "conversion from pointer to void to pointer to other type"
  stack = thread->stack_mem;
    76dc:	9b03      	ldr	r3, [sp, #12]
    76de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    76e0:	9305      	str	r3, [sp, #20]
  if (*stack++ == osRtxStackMagicWord) {
    76e2:	9b05      	ldr	r3, [sp, #20]
    76e4:	1d1a      	adds	r2, r3, #4
    76e6:	9205      	str	r2, [sp, #20]
    76e8:	681b      	ldr	r3, [r3, #0]
    76ea:	4a12      	ldr	r2, [pc, #72]	; (7734 <svcRtxThreadGetStackSpace+0xac>)
    76ec:	4293      	cmp	r3, r2
    76ee:	d112      	bne.n	7716 <svcRtxThreadGetStackSpace+0x8e>
    for (space = 4U; space < thread->stack_size; space += 4U) {
    76f0:	2304      	movs	r3, #4
    76f2:	9304      	str	r3, [sp, #16]
    76f4:	e009      	b.n	770a <svcRtxThreadGetStackSpace+0x82>
      if (*stack++ != osRtxStackFillPattern) {
    76f6:	9b05      	ldr	r3, [sp, #20]
    76f8:	1d1a      	adds	r2, r3, #4
    76fa:	9205      	str	r2, [sp, #20]
    76fc:	681b      	ldr	r3, [r3, #0]
    76fe:	f1b3 3fcc 	cmp.w	r3, #3435973836	; 0xcccccccc
    7702:	d10b      	bne.n	771c <svcRtxThreadGetStackSpace+0x94>
    for (space = 4U; space < thread->stack_size; space += 4U) {
    7704:	9b04      	ldr	r3, [sp, #16]
    7706:	3304      	adds	r3, #4
    7708:	9304      	str	r3, [sp, #16]
    770a:	9b03      	ldr	r3, [sp, #12]
    770c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    770e:	9b04      	ldr	r3, [sp, #16]
    7710:	429a      	cmp	r2, r3
    7712:	d8f0      	bhi.n	76f6 <svcRtxThreadGetStackSpace+0x6e>
    7714:	e003      	b.n	771e <svcRtxThreadGetStackSpace+0x96>
        break;
      }
    }
  } else {
    space = 0U;
    7716:	2300      	movs	r3, #0
    7718:	9304      	str	r3, [sp, #16]
    771a:	e000      	b.n	771e <svcRtxThreadGetStackSpace+0x96>
        break;
    771c:	bf00      	nop
  }

  EvrRtxThreadGetStackSpace(thread, space);
    771e:	9904      	ldr	r1, [sp, #16]
    7720:	9803      	ldr	r0, [sp, #12]
    7722:	f7fc ffd3 	bl	46cc <EvrRtxThreadGetStackSpace>

  return space;
    7726:	9b04      	ldr	r3, [sp, #16]
}
    7728:	4618      	mov	r0, r3
    772a:	b007      	add	sp, #28
    772c:	f85d fb04 	ldr.w	pc, [sp], #4
    7730:	0001144c 	.word	0x0001144c
    7734:	e25a2ea5 	.word	0xe25a2ea5

00007738 <osRtxThreadFree>:
  return osOK;
}

/// Free Thread resources.
/// \param[in]  thread          thread object.
static void osRtxThreadFree (os_thread_t *thread) {
    7738:	b500      	push	{lr}
    773a:	b083      	sub	sp, #12
    773c:	9001      	str	r0, [sp, #4]

  // Mark object as inactive
  thread->state = osRtxThreadInactive;
    773e:	9b01      	ldr	r3, [sp, #4]
    7740:	2200      	movs	r2, #0
    7742:	705a      	strb	r2, [r3, #1]
    (void)TZ_FreeModuleContext_S(thread->tz_memory);
  }
#endif

  // Free stack memory
  if ((thread->flags & osRtxFlagSystemMemory) != 0U) {
    7744:	9b01      	ldr	r3, [sp, #4]
    7746:	789b      	ldrb	r3, [r3, #2]
    7748:	f003 0302 	and.w	r3, r3, #2
    774c:	2b00      	cmp	r3, #0
    774e:	d017      	beq.n	7780 <osRtxThreadFree+0x48>
    if ((thread->flags & osRtxThreadFlagDefStack) != 0U) {
    7750:	9b01      	ldr	r3, [sp, #4]
    7752:	789b      	ldrb	r3, [r3, #2]
    7754:	f003 0310 	and.w	r3, r3, #16
    7758:	2b00      	cmp	r3, #0
    775a:	d009      	beq.n	7770 <osRtxThreadFree+0x38>
      (void)osRtxMemoryPoolFree(osRtxInfo.mpi.stack, thread->stack_mem);
    775c:	4b17      	ldr	r3, [pc, #92]	; (77bc <osRtxThreadFree+0x84>)
    775e:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
    7762:	9b01      	ldr	r3, [sp, #4]
    7764:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    7766:	4619      	mov	r1, r3
    7768:	4610      	mov	r0, r2
    776a:	f7fd fe07 	bl	537c <osRtxMemoryPoolFree>
    776e:	e007      	b.n	7780 <osRtxThreadFree+0x48>
    } else {
      (void)osRtxMemoryFree(osRtxInfo.mem.stack, thread->stack_mem);
    7770:	4b12      	ldr	r3, [pc, #72]	; (77bc <osRtxThreadFree+0x84>)
    7772:	6f5a      	ldr	r2, [r3, #116]	; 0x74
    7774:	9b01      	ldr	r3, [sp, #4]
    7776:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    7778:	4619      	mov	r1, r3
    777a:	4610      	mov	r0, r2
    777c:	f7fd fcd7 	bl	512e <osRtxMemoryFree>
    }
  }

  // Free object memory
  if ((thread->flags & osRtxFlagSystemObject) != 0U) {
    7780:	9b01      	ldr	r3, [sp, #4]
    7782:	789b      	ldrb	r3, [r3, #2]
    7784:	f003 0301 	and.w	r3, r3, #1
    7788:	2b00      	cmp	r3, #0
    778a:	d013      	beq.n	77b4 <osRtxThreadFree+0x7c>
    if (osRtxInfo.mpi.thread != NULL) {
    778c:	4b0b      	ldr	r3, [pc, #44]	; (77bc <osRtxThreadFree+0x84>)
    778e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    7792:	2b00      	cmp	r3, #0
    7794:	d007      	beq.n	77a6 <osRtxThreadFree+0x6e>
      (void)osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
    7796:	4b09      	ldr	r3, [pc, #36]	; (77bc <osRtxThreadFree+0x84>)
    7798:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    779c:	9901      	ldr	r1, [sp, #4]
    779e:	4618      	mov	r0, r3
    77a0:	f7fd fdec 	bl	537c <osRtxMemoryPoolFree>
    }
#if (defined(OS_OBJ_MEM_USAGE) && (OS_OBJ_MEM_USAGE != 0))
    osRtxThreadMemUsage.cnt_free++;
#endif
  }
}
    77a4:	e006      	b.n	77b4 <osRtxThreadFree+0x7c>
      (void)osRtxMemoryFree(osRtxInfo.mem.common, thread);
    77a6:	4b05      	ldr	r3, [pc, #20]	; (77bc <osRtxThreadFree+0x84>)
    77a8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    77ac:	9901      	ldr	r1, [sp, #4]
    77ae:	4618      	mov	r0, r3
    77b0:	f7fd fcbd 	bl	512e <osRtxMemoryFree>
}
    77b4:	bf00      	nop
    77b6:	b003      	add	sp, #12
    77b8:	f85d fb04 	ldr.w	pc, [sp], #4
    77bc:	20000110 	.word	0x20000110

000077c0 <svcRtxThreadExit>:
  return status;
}

/// Terminate execution of current running thread.
/// \note API identical to osThreadExit
static void svcRtxThreadExit (void) {
    77c0:	b510      	push	{r4, lr}
    77c2:	b082      	sub	sp, #8
  os_thread_t *thread;

  // Check running thread
  thread = osRtxThreadGetRunning();
    77c4:	f7ff f978 	bl	6ab8 <osRtxThreadGetRunning>
    77c8:	9001      	str	r0, [sp, #4]
  if (thread == NULL) {
    77ca:	9b01      	ldr	r3, [sp, #4]
    77cc:	2b00      	cmp	r3, #0
    77ce:	d054      	beq.n	787a <svcRtxThreadExit+0xba>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }

  // Check if switch to next Ready Thread is possible
  if ((osRtxKernelGetState() != osRtxKernelRunning) ||
    77d0:	f7ff f96c 	bl	6aac <osRtxKernelGetState>
    77d4:	4603      	mov	r3, r0
    77d6:	2b02      	cmp	r3, #2
    77d8:	d151      	bne.n	787e <svcRtxThreadExit+0xbe>
      (osRtxInfo.thread.ready.thread_list == NULL)) {
    77da:	4b2a      	ldr	r3, [pc, #168]	; (7884 <svcRtxThreadExit+0xc4>)
    77dc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  if ((osRtxKernelGetState() != osRtxKernelRunning) ||
    77de:	2b00      	cmp	r3, #0
    77e0:	d04d      	beq.n	787e <svcRtxThreadExit+0xbe>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }

  // Release owned Mutexes
  osRtxMutexOwnerRelease(thread->mutex_list);
    77e2:	9b01      	ldr	r3, [sp, #4]
    77e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    77e6:	4618      	mov	r0, r3
    77e8:	f7fe fc42 	bl	6070 <osRtxMutexOwnerRelease>

  // Wakeup Thread waiting to Join
  if (thread->thread_join != NULL) {
    77ec:	9b01      	ldr	r3, [sp, #4]
    77ee:	699b      	ldr	r3, [r3, #24]
    77f0:	2b00      	cmp	r3, #0
    77f2:	d00b      	beq.n	780c <svcRtxThreadExit+0x4c>
    osRtxThreadWaitExit(thread->thread_join, (uint32_t)osOK, FALSE);
    77f4:	9b01      	ldr	r3, [sp, #4]
    77f6:	699b      	ldr	r3, [r3, #24]
    77f8:	2200      	movs	r2, #0
    77fa:	2100      	movs	r1, #0
    77fc:	4618      	mov	r0, r3
    77fe:	f7ff fc7f 	bl	7100 <osRtxThreadWaitExit>
    EvrRtxThreadJoined(thread->thread_join);
    7802:	9b01      	ldr	r3, [sp, #4]
    7804:	699b      	ldr	r3, [r3, #24]
    7806:	4618      	mov	r0, r3
    7808:	f7fc ff66 	bl	46d8 <EvrRtxThreadJoined>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
    780c:	f3ef 8309 	mrs	r3, PSP
    7810:	461c      	mov	r4, r3
  return(result);
    7812:	4622      	mov	r2, r4
  }

  // Switch to next Ready Thread
  thread->sp = __get_PSP();
    7814:	9b01      	ldr	r3, [sp, #4]
    7816:	639a      	str	r2, [r3, #56]	; 0x38
  osRtxThreadSwitch(osRtxThreadListGet(&osRtxInfo.thread.ready));
    7818:	481b      	ldr	r0, [pc, #108]	; (7888 <svcRtxThreadExit+0xc8>)
    781a:	f7ff f9d1 	bl	6bc0 <osRtxThreadListGet>
    781e:	4603      	mov	r3, r0
    7820:	4618      	mov	r0, r3
    7822:	f7ff fbe3 	bl	6fec <osRtxThreadSwitch>
  osRtxThreadSetRunning(NULL);
    7826:	2000      	movs	r0, #0
    7828:	f7ff f94c 	bl	6ac4 <osRtxThreadSetRunning>

  if (((thread->attr & osThreadJoinable) == 0U) || (thread->thread_join != NULL)) {
    782c:	9b01      	ldr	r3, [sp, #4]
    782e:	78db      	ldrb	r3, [r3, #3]
    7830:	f003 0301 	and.w	r3, r3, #1
    7834:	2b00      	cmp	r3, #0
    7836:	d003      	beq.n	7840 <svcRtxThreadExit+0x80>
    7838:	9b01      	ldr	r3, [sp, #4]
    783a:	699b      	ldr	r3, [r3, #24]
    783c:	2b00      	cmp	r3, #0
    783e:	d003      	beq.n	7848 <svcRtxThreadExit+0x88>
    osRtxThreadFree(thread);
    7840:	9801      	ldr	r0, [sp, #4]
    7842:	f7ff ff79 	bl	7738 <osRtxThreadFree>
    7846:	e014      	b.n	7872 <svcRtxThreadExit+0xb2>
  } else {
    // Update Thread State and put it into Terminate Thread list
    thread->state = osRtxThreadTerminated;
    7848:	9b01      	ldr	r3, [sp, #4]
    784a:	2204      	movs	r2, #4
    784c:	705a      	strb	r2, [r3, #1]
    thread->thread_prev = NULL;
    784e:	9b01      	ldr	r3, [sp, #4]
    7850:	2200      	movs	r2, #0
    7852:	60da      	str	r2, [r3, #12]
    thread->thread_next = osRtxInfo.thread.terminate_list;
    7854:	4b0b      	ldr	r3, [pc, #44]	; (7884 <svcRtxThreadExit+0xc4>)
    7856:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    7858:	9b01      	ldr	r3, [sp, #4]
    785a:	609a      	str	r2, [r3, #8]
    if (osRtxInfo.thread.terminate_list != NULL) {
    785c:	4b09      	ldr	r3, [pc, #36]	; (7884 <svcRtxThreadExit+0xc4>)
    785e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    7860:	2b00      	cmp	r3, #0
    7862:	d003      	beq.n	786c <svcRtxThreadExit+0xac>
      osRtxInfo.thread.terminate_list->thread_prev = thread;
    7864:	4b07      	ldr	r3, [pc, #28]	; (7884 <svcRtxThreadExit+0xc4>)
    7866:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    7868:	9a01      	ldr	r2, [sp, #4]
    786a:	60da      	str	r2, [r3, #12]
    }
    osRtxInfo.thread.terminate_list = thread;
    786c:	4a05      	ldr	r2, [pc, #20]	; (7884 <svcRtxThreadExit+0xc4>)
    786e:	9b01      	ldr	r3, [sp, #4]
    7870:	6353      	str	r3, [r2, #52]	; 0x34
  }

  EvrRtxThreadDestroyed(thread);
    7872:	9801      	ldr	r0, [sp, #4]
    7874:	f7fc ff4b 	bl	470e <EvrRtxThreadDestroyed>
    7878:	e002      	b.n	7880 <svcRtxThreadExit+0xc0>
    return;
    787a:	bf00      	nop
    787c:	e000      	b.n	7880 <svcRtxThreadExit+0xc0>
    return;
    787e:	bf00      	nop
}
    7880:	b002      	add	sp, #8
    7882:	bd10      	pop	{r4, pc}
    7884:	20000110 	.word	0x20000110
    7888:	2000012c 	.word	0x2000012c

0000788c <svcRtxThreadGetCount>:
  return status;
}

/// Get number of active threads.
/// \note API identical to osThreadGetCount
static uint32_t svcRtxThreadGetCount (void) {
    788c:	b500      	push	{lr}
    788e:	b083      	sub	sp, #12
  const os_thread_t *thread;
        uint32_t     count;

  // Running Thread
  count = 1U;
    7890:	2301      	movs	r3, #1
    7892:	9300      	str	r3, [sp, #0]

  // Ready List
  for (thread = osRtxInfo.thread.ready.thread_list;
    7894:	4b17      	ldr	r3, [pc, #92]	; (78f4 <svcRtxThreadGetCount+0x68>)
    7896:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7898:	9301      	str	r3, [sp, #4]
    789a:	e005      	b.n	78a8 <svcRtxThreadGetCount+0x1c>
       thread != NULL; thread = thread->thread_next) {
    count++;
    789c:	9b00      	ldr	r3, [sp, #0]
    789e:	3301      	adds	r3, #1
    78a0:	9300      	str	r3, [sp, #0]
       thread != NULL; thread = thread->thread_next) {
    78a2:	9b01      	ldr	r3, [sp, #4]
    78a4:	689b      	ldr	r3, [r3, #8]
    78a6:	9301      	str	r3, [sp, #4]
  for (thread = osRtxInfo.thread.ready.thread_list;
    78a8:	9b01      	ldr	r3, [sp, #4]
    78aa:	2b00      	cmp	r3, #0
    78ac:	d1f6      	bne.n	789c <svcRtxThreadGetCount+0x10>
  }

  // Delay List
  for (thread = osRtxInfo.thread.delay_list;
    78ae:	4b11      	ldr	r3, [pc, #68]	; (78f4 <svcRtxThreadGetCount+0x68>)
    78b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    78b2:	9301      	str	r3, [sp, #4]
    78b4:	e005      	b.n	78c2 <svcRtxThreadGetCount+0x36>
       thread != NULL; thread = thread->delay_next) {
    count++;
    78b6:	9b00      	ldr	r3, [sp, #0]
    78b8:	3301      	adds	r3, #1
    78ba:	9300      	str	r3, [sp, #0]
       thread != NULL; thread = thread->delay_next) {
    78bc:	9b01      	ldr	r3, [sp, #4]
    78be:	691b      	ldr	r3, [r3, #16]
    78c0:	9301      	str	r3, [sp, #4]
  for (thread = osRtxInfo.thread.delay_list;
    78c2:	9b01      	ldr	r3, [sp, #4]
    78c4:	2b00      	cmp	r3, #0
    78c6:	d1f6      	bne.n	78b6 <svcRtxThreadGetCount+0x2a>
  }

  // Wait List
  for (thread = osRtxInfo.thread.wait_list;
    78c8:	4b0a      	ldr	r3, [pc, #40]	; (78f4 <svcRtxThreadGetCount+0x68>)
    78ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    78cc:	9301      	str	r3, [sp, #4]
    78ce:	e005      	b.n	78dc <svcRtxThreadGetCount+0x50>
       thread != NULL; thread = thread->delay_next) {
    count++;
    78d0:	9b00      	ldr	r3, [sp, #0]
    78d2:	3301      	adds	r3, #1
    78d4:	9300      	str	r3, [sp, #0]
       thread != NULL; thread = thread->delay_next) {
    78d6:	9b01      	ldr	r3, [sp, #4]
    78d8:	691b      	ldr	r3, [r3, #16]
    78da:	9301      	str	r3, [sp, #4]
  for (thread = osRtxInfo.thread.wait_list;
    78dc:	9b01      	ldr	r3, [sp, #4]
    78de:	2b00      	cmp	r3, #0
    78e0:	d1f6      	bne.n	78d0 <svcRtxThreadGetCount+0x44>
  }

  EvrRtxThreadGetCount(count);
    78e2:	9800      	ldr	r0, [sp, #0]
    78e4:	f7fc ff18 	bl	4718 <EvrRtxThreadGetCount>

  return count;
    78e8:	9b00      	ldr	r3, [sp, #0]
}
    78ea:	4618      	mov	r0, r3
    78ec:	b003      	add	sp, #12
    78ee:	f85d fb04 	ldr.w	pc, [sp], #4
    78f2:	bf00      	nop
    78f4:	20000110 	.word	0x20000110

000078f8 <svcRtxThreadEnumerate>:

/// Enumerate active threads.
/// \note API identical to osThreadEnumerate
static uint32_t svcRtxThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items) {
    78f8:	b500      	push	{lr}
    78fa:	b085      	sub	sp, #20
    78fc:	9001      	str	r0, [sp, #4]
    78fe:	9100      	str	r1, [sp, #0]
  os_thread_t *thread;
  uint32_t     count;

  // Check parameters
  if ((thread_array == NULL) || (array_items == 0U)) {
    7900:	9b01      	ldr	r3, [sp, #4]
    7902:	2b00      	cmp	r3, #0
    7904:	d002      	beq.n	790c <svcRtxThreadEnumerate+0x14>
    7906:	9b00      	ldr	r3, [sp, #0]
    7908:	2b00      	cmp	r3, #0
    790a:	d106      	bne.n	791a <svcRtxThreadEnumerate+0x22>
    EvrRtxThreadEnumerate(thread_array, array_items, 0U);
    790c:	2200      	movs	r2, #0
    790e:	9900      	ldr	r1, [sp, #0]
    7910:	9801      	ldr	r0, [sp, #4]
    7912:	f7fc ff06 	bl	4722 <EvrRtxThreadEnumerate>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return 0U;
    7916:	2300      	movs	r3, #0
    7918:	e059      	b.n	79ce <svcRtxThreadEnumerate+0xd6>
  }

  // Running Thread
  *thread_array = osRtxThreadGetRunning();
    791a:	f7ff f8cd 	bl	6ab8 <osRtxThreadGetRunning>
    791e:	4602      	mov	r2, r0
    7920:	9b01      	ldr	r3, [sp, #4]
    7922:	601a      	str	r2, [r3, #0]
   thread_array++;
    7924:	9b01      	ldr	r3, [sp, #4]
    7926:	3304      	adds	r3, #4
    7928:	9301      	str	r3, [sp, #4]
   count = 1U;
    792a:	2301      	movs	r3, #1
    792c:	9302      	str	r3, [sp, #8]

  // Ready List
  for (thread = osRtxInfo.thread.ready.thread_list;
    792e:	4b2a      	ldr	r3, [pc, #168]	; (79d8 <svcRtxThreadEnumerate+0xe0>)
    7930:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    7932:	9303      	str	r3, [sp, #12]
    7934:	e00b      	b.n	794e <svcRtxThreadEnumerate+0x56>
       (thread != NULL) && (count < array_items); thread = thread->thread_next) {
    *thread_array = thread;
    7936:	9b01      	ldr	r3, [sp, #4]
    7938:	9a03      	ldr	r2, [sp, #12]
    793a:	601a      	str	r2, [r3, #0]
     thread_array++;
    793c:	9b01      	ldr	r3, [sp, #4]
    793e:	3304      	adds	r3, #4
    7940:	9301      	str	r3, [sp, #4]
     count++;
    7942:	9b02      	ldr	r3, [sp, #8]
    7944:	3301      	adds	r3, #1
    7946:	9302      	str	r3, [sp, #8]
       (thread != NULL) && (count < array_items); thread = thread->thread_next) {
    7948:	9b03      	ldr	r3, [sp, #12]
    794a:	689b      	ldr	r3, [r3, #8]
    794c:	9303      	str	r3, [sp, #12]
  for (thread = osRtxInfo.thread.ready.thread_list;
    794e:	9b03      	ldr	r3, [sp, #12]
    7950:	2b00      	cmp	r3, #0
    7952:	d003      	beq.n	795c <svcRtxThreadEnumerate+0x64>
       (thread != NULL) && (count < array_items); thread = thread->thread_next) {
    7954:	9a02      	ldr	r2, [sp, #8]
    7956:	9b00      	ldr	r3, [sp, #0]
    7958:	429a      	cmp	r2, r3
    795a:	d3ec      	bcc.n	7936 <svcRtxThreadEnumerate+0x3e>
  }

  // Delay List
  for (thread = osRtxInfo.thread.delay_list;
    795c:	4b1e      	ldr	r3, [pc, #120]	; (79d8 <svcRtxThreadEnumerate+0xe0>)
    795e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    7960:	9303      	str	r3, [sp, #12]
    7962:	e00b      	b.n	797c <svcRtxThreadEnumerate+0x84>
       (thread != NULL) && (count < array_items); thread = thread->delay_next) {
    *thread_array = thread;
    7964:	9b01      	ldr	r3, [sp, #4]
    7966:	9a03      	ldr	r2, [sp, #12]
    7968:	601a      	str	r2, [r3, #0]
     thread_array++;
    796a:	9b01      	ldr	r3, [sp, #4]
    796c:	3304      	adds	r3, #4
    796e:	9301      	str	r3, [sp, #4]
     count++;
    7970:	9b02      	ldr	r3, [sp, #8]
    7972:	3301      	adds	r3, #1
    7974:	9302      	str	r3, [sp, #8]
       (thread != NULL) && (count < array_items); thread = thread->delay_next) {
    7976:	9b03      	ldr	r3, [sp, #12]
    7978:	691b      	ldr	r3, [r3, #16]
    797a:	9303      	str	r3, [sp, #12]
  for (thread = osRtxInfo.thread.delay_list;
    797c:	9b03      	ldr	r3, [sp, #12]
    797e:	2b00      	cmp	r3, #0
    7980:	d003      	beq.n	798a <svcRtxThreadEnumerate+0x92>
       (thread != NULL) && (count < array_items); thread = thread->delay_next) {
    7982:	9a02      	ldr	r2, [sp, #8]
    7984:	9b00      	ldr	r3, [sp, #0]
    7986:	429a      	cmp	r2, r3
    7988:	d3ec      	bcc.n	7964 <svcRtxThreadEnumerate+0x6c>
  }

  // Wait List
  for (thread = osRtxInfo.thread.wait_list;
    798a:	4b13      	ldr	r3, [pc, #76]	; (79d8 <svcRtxThreadEnumerate+0xe0>)
    798c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    798e:	9303      	str	r3, [sp, #12]
    7990:	e00b      	b.n	79aa <svcRtxThreadEnumerate+0xb2>
       (thread != NULL) && (count < array_items); thread = thread->delay_next) {
    *thread_array = thread;
    7992:	9b01      	ldr	r3, [sp, #4]
    7994:	9a03      	ldr	r2, [sp, #12]
    7996:	601a      	str	r2, [r3, #0]
     thread_array++;
    7998:	9b01      	ldr	r3, [sp, #4]
    799a:	3304      	adds	r3, #4
    799c:	9301      	str	r3, [sp, #4]
     count++;
    799e:	9b02      	ldr	r3, [sp, #8]
    79a0:	3301      	adds	r3, #1
    79a2:	9302      	str	r3, [sp, #8]
       (thread != NULL) && (count < array_items); thread = thread->delay_next) {
    79a4:	9b03      	ldr	r3, [sp, #12]
    79a6:	691b      	ldr	r3, [r3, #16]
    79a8:	9303      	str	r3, [sp, #12]
  for (thread = osRtxInfo.thread.wait_list;
    79aa:	9b03      	ldr	r3, [sp, #12]
    79ac:	2b00      	cmp	r3, #0
    79ae:	d003      	beq.n	79b8 <svcRtxThreadEnumerate+0xc0>
       (thread != NULL) && (count < array_items); thread = thread->delay_next) {
    79b0:	9a02      	ldr	r2, [sp, #8]
    79b2:	9b00      	ldr	r3, [sp, #0]
    79b4:	429a      	cmp	r2, r3
    79b6:	d3ec      	bcc.n	7992 <svcRtxThreadEnumerate+0x9a>
  }

  EvrRtxThreadEnumerate(thread_array - count, array_items, count);
    79b8:	9b02      	ldr	r3, [sp, #8]
    79ba:	009b      	lsls	r3, r3, #2
    79bc:	425b      	negs	r3, r3
    79be:	9a01      	ldr	r2, [sp, #4]
    79c0:	4413      	add	r3, r2
    79c2:	9a02      	ldr	r2, [sp, #8]
    79c4:	9900      	ldr	r1, [sp, #0]
    79c6:	4618      	mov	r0, r3
    79c8:	f7fc feab 	bl	4722 <EvrRtxThreadEnumerate>

  return count;
    79cc:	9b02      	ldr	r3, [sp, #8]
}
    79ce:	4618      	mov	r0, r3
    79d0:	b005      	add	sp, #20
    79d2:	f85d fb04 	ldr.w	pc, [sp], #4
    79d6:	bf00      	nop
    79d8:	20000110 	.word	0x20000110

000079dc <osRtxThreadStartup>:

//  ==== Library functions ====

/// Thread startup (Idle and Timer Thread).
/// \return true - success, false - failure.
bool_t osRtxThreadStartup (void) {
    79dc:	b500      	push	{lr}
    79de:	b083      	sub	sp, #12
  bool_t ret = TRUE;
    79e0:	2301      	movs	r3, #1
    79e2:	f88d 3007 	strb.w	r3, [sp, #7]

  // Create Idle Thread
  if (osRtxInfo.thread.idle == NULL) {
    79e6:	4b1e      	ldr	r3, [pc, #120]	; (7a60 <osRtxThreadStartup+0x84>)
    79e8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    79ea:	2b00      	cmp	r3, #0
    79ec:	d114      	bne.n	7a18 <osRtxThreadStartup+0x3c>
    osRtxInfo.thread.idle = osRtxThreadId(
    79ee:	4b1d      	ldr	r3, [pc, #116]	; (7a64 <osRtxThreadStartup+0x88>)
    79f0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    79f2:	2300      	movs	r3, #0
    79f4:	2100      	movs	r1, #0
    79f6:	481c      	ldr	r0, [pc, #112]	; (7a68 <osRtxThreadStartup+0x8c>)
    79f8:	f7ff fc2c 	bl	7254 <svcRtxThreadNew>
    79fc:	4603      	mov	r3, r0
    79fe:	4618      	mov	r0, r3
    7a00:	f7ff f842 	bl	6a88 <osRtxThreadId>
    7a04:	4602      	mov	r2, r0
    7a06:	4b16      	ldr	r3, [pc, #88]	; (7a60 <osRtxThreadStartup+0x84>)
    7a08:	629a      	str	r2, [r3, #40]	; 0x28
      svcRtxThreadNew(osRtxIdleThread, NULL, osRtxConfig.idle_thread_attr, NULL)
    );
    if (osRtxInfo.thread.idle == NULL) {
    7a0a:	4b15      	ldr	r3, [pc, #84]	; (7a60 <osRtxThreadStartup+0x84>)
    7a0c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    7a0e:	2b00      	cmp	r3, #0
    7a10:	d102      	bne.n	7a18 <osRtxThreadStartup+0x3c>
      ret = FALSE;
    7a12:	2300      	movs	r3, #0
    7a14:	f88d 3007 	strb.w	r3, [sp, #7]
    }
  }

  // Create Timer Thread
  if (osRtxConfig.timer_mq_mcnt != 0U) {
    7a18:	4b12      	ldr	r3, [pc, #72]	; (7a64 <osRtxThreadStartup+0x88>)
    7a1a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    7a1c:	2b00      	cmp	r3, #0
    7a1e:	d018      	beq.n	7a52 <osRtxThreadStartup+0x76>
    if (osRtxInfo.timer.thread == NULL) {
    7a20:	4b0f      	ldr	r3, [pc, #60]	; (7a60 <osRtxThreadStartup+0x84>)
    7a22:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    7a24:	2b00      	cmp	r3, #0
    7a26:	d114      	bne.n	7a52 <osRtxThreadStartup+0x76>
      osRtxInfo.timer.thread = osRtxThreadId(
    7a28:	4b0e      	ldr	r3, [pc, #56]	; (7a64 <osRtxThreadStartup+0x88>)
    7a2a:	6dda      	ldr	r2, [r3, #92]	; 0x5c
    7a2c:	2300      	movs	r3, #0
    7a2e:	2100      	movs	r1, #0
    7a30:	480e      	ldr	r0, [pc, #56]	; (7a6c <osRtxThreadStartup+0x90>)
    7a32:	f7ff fc0f 	bl	7254 <svcRtxThreadNew>
    7a36:	4603      	mov	r3, r0
    7a38:	4618      	mov	r0, r3
    7a3a:	f7ff f825 	bl	6a88 <osRtxThreadId>
    7a3e:	4602      	mov	r2, r0
    7a40:	4b07      	ldr	r3, [pc, #28]	; (7a60 <osRtxThreadStartup+0x84>)
    7a42:	649a      	str	r2, [r3, #72]	; 0x48
        svcRtxThreadNew(osRtxTimerThread, NULL, osRtxConfig.timer_thread_attr, NULL)
      );
      if (osRtxInfo.timer.thread == NULL) {
    7a44:	4b06      	ldr	r3, [pc, #24]	; (7a60 <osRtxThreadStartup+0x84>)
    7a46:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    7a48:	2b00      	cmp	r3, #0
    7a4a:	d102      	bne.n	7a52 <osRtxThreadStartup+0x76>
        ret = FALSE;
    7a4c:	2300      	movs	r3, #0
    7a4e:	f88d 3007 	strb.w	r3, [sp, #7]
      }
    }
  }

  return ret;
    7a52:	f89d 3007 	ldrb.w	r3, [sp, #7]
}
    7a56:	4618      	mov	r0, r3
    7a58:	b003      	add	sp, #12
    7a5a:	f85d fb04 	ldr.w	pc, [sp], #4
    7a5e:	bf00      	nop
    7a60:	20000110 	.word	0x20000110
    7a64:	0001144c 	.word	0x0001144c
    7a68:	00004311 	.word	0x00004311
    7a6c:	00007db1 	.word	0x00007db1

00007a70 <osThreadNew>:


//  ==== Public API ====

/// Create a thread and add it to Active Threads.
osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
    7a70:	b500      	push	{lr}
    7a72:	b085      	sub	sp, #20
    7a74:	9003      	str	r0, [sp, #12]
    7a76:	9102      	str	r1, [sp, #8]
    7a78:	9201      	str	r2, [sp, #4]
  return osThreadContextNew(func, argument, attr, NULL);
    7a7a:	2300      	movs	r3, #0
    7a7c:	9a01      	ldr	r2, [sp, #4]
    7a7e:	9902      	ldr	r1, [sp, #8]
    7a80:	9803      	ldr	r0, [sp, #12]
    7a82:	f000 f805 	bl	7a90 <osThreadContextNew>
    7a86:	4603      	mov	r3, r0
}
    7a88:	4618      	mov	r0, r3
    7a8a:	b005      	add	sp, #20
    7a8c:	f85d fb04 	ldr.w	pc, [sp], #4

00007a90 <osThreadContextNew>:

osThreadId_t osThreadContextNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr, void *context) {
    7a90:	b510      	push	{r4, lr}
    7a92:	b08a      	sub	sp, #40	; 0x28
    7a94:	9003      	str	r0, [sp, #12]
    7a96:	9102      	str	r1, [sp, #8]
    7a98:	9201      	str	r2, [sp, #4]
    7a9a:	9300      	str	r3, [sp, #0]
  osThreadId_t thread_id;
  EvrRtxThreadNew(func, argument, attr);
    7a9c:	9a01      	ldr	r2, [sp, #4]
    7a9e:	9902      	ldr	r1, [sp, #8]
    7aa0:	9803      	ldr	r0, [sp, #12]
    7aa2:	f7fc fdfb 	bl	469c <EvrRtxThreadNew>
  if (IsIrqMode() || IsIrqMasked()) {
    7aa6:	f7fe ff94 	bl	69d2 <IsIrqMode>
    7aaa:	4603      	mov	r3, r0
    7aac:	2b00      	cmp	r3, #0
    7aae:	d104      	bne.n	7aba <osThreadContextNew+0x2a>
    7ab0:	f7fe ff9c 	bl	69ec <IsIrqMasked>
    7ab4:	4603      	mov	r3, r0
    7ab6:	2b00      	cmp	r3, #0
    7ab8:	d007      	beq.n	7aca <osThreadContextNew+0x3a>
    EvrRtxThreadError(NULL, (int32_t)osErrorISR);
    7aba:	f06f 0105 	mvn.w	r1, #5
    7abe:	2000      	movs	r0, #0
    7ac0:	f7fc fcdc 	bl	447c <EvrRtxThreadError>
    thread_id = NULL;
    7ac4:	2300      	movs	r3, #0
    7ac6:	9309      	str	r3, [sp, #36]	; 0x24
    7ac8:	e013      	b.n	7af2 <osThreadContextNew+0x62>
    7aca:	9b03      	ldr	r3, [sp, #12]
    7acc:	9308      	str	r3, [sp, #32]
    7ace:	9b02      	ldr	r3, [sp, #8]
    7ad0:	9307      	str	r3, [sp, #28]
    7ad2:	9b01      	ldr	r3, [sp, #4]
    7ad4:	9306      	str	r3, [sp, #24]
    7ad6:	9b00      	ldr	r3, [sp, #0]
    7ad8:	9305      	str	r3, [sp, #20]
SVC0_4 (ThreadNew,           osThreadId_t,    osThreadFunc_t, void *, const osThreadAttr_t *, void *)
    7ada:	9b08      	ldr	r3, [sp, #32]
    7adc:	4618      	mov	r0, r3
    7ade:	9b07      	ldr	r3, [sp, #28]
    7ae0:	4619      	mov	r1, r3
    7ae2:	9b06      	ldr	r3, [sp, #24]
    7ae4:	461a      	mov	r2, r3
    7ae6:	9b05      	ldr	r3, [sp, #20]
    7ae8:	4c04      	ldr	r4, [pc, #16]	; (7afc <osThreadContextNew+0x6c>)
    7aea:	46a4      	mov	ip, r4
    7aec:	df00      	svc	0
    7aee:	4603      	mov	r3, r0
  } else {
    thread_id = __svcThreadNew(func, argument, attr, context);
    7af0:	9309      	str	r3, [sp, #36]	; 0x24
  }
  return thread_id;
    7af2:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    7af4:	4618      	mov	r0, r3
    7af6:	b00a      	add	sp, #40	; 0x28
    7af8:	bd10      	pop	{r4, pc}
    7afa:	bf00      	nop
    7afc:	00007255 	.word	0x00007255

00007b00 <osThreadGetId>:
  }
  return name;
}

/// Return the thread ID of the current running thread.
osThreadId_t osThreadGetId (void) {
    7b00:	b500      	push	{lr}
    7b02:	b083      	sub	sp, #12
  osThreadId_t thread_id;

  if (IsIrqMode() || IsIrqMasked()) {
    7b04:	f7fe ff65 	bl	69d2 <IsIrqMode>
    7b08:	4603      	mov	r3, r0
    7b0a:	2b00      	cmp	r3, #0
    7b0c:	d104      	bne.n	7b18 <osThreadGetId+0x18>
    7b0e:	f7fe ff6d 	bl	69ec <IsIrqMasked>
    7b12:	4603      	mov	r3, r0
    7b14:	2b00      	cmp	r3, #0
    7b16:	d005      	beq.n	7b24 <osThreadGetId+0x24>
    EvrRtxThreadGetId(NULL);
    7b18:	2000      	movs	r0, #0
    7b1a:	f7fc fdcc 	bl	46b6 <EvrRtxThreadGetId>
    thread_id = NULL;
    7b1e:	2300      	movs	r3, #0
    7b20:	9301      	str	r3, [sp, #4]
    7b22:	e004      	b.n	7b2e <osThreadGetId+0x2e>
SVC0_0 (ThreadGetId,         osThreadId_t)
    7b24:	4b04      	ldr	r3, [pc, #16]	; (7b38 <osThreadGetId+0x38>)
    7b26:	469c      	mov	ip, r3
    7b28:	df00      	svc	0
    7b2a:	4603      	mov	r3, r0
  } else {
    thread_id = __svcThreadGetId();
    7b2c:	9301      	str	r3, [sp, #4]
  }
  return thread_id;
    7b2e:	9b01      	ldr	r3, [sp, #4]
}
    7b30:	4618      	mov	r0, r3
    7b32:	b003      	add	sp, #12
    7b34:	f85d fb04 	ldr.w	pc, [sp], #4
    7b38:	00007619 	.word	0x00007619

00007b3c <osThreadGetStackSize>:
  }
  return state;
}

/// Get stack size of a thread.
uint32_t osThreadGetStackSize (osThreadId_t thread_id) {
    7b3c:	b500      	push	{lr}
    7b3e:	b085      	sub	sp, #20
    7b40:	9001      	str	r0, [sp, #4]
  uint32_t stack_size;

  if (IsIrqMode() || IsIrqMasked()) {
    7b42:	f7fe ff46 	bl	69d2 <IsIrqMode>
    7b46:	4603      	mov	r3, r0
    7b48:	2b00      	cmp	r3, #0
    7b4a:	d104      	bne.n	7b56 <osThreadGetStackSize+0x1a>
    7b4c:	f7fe ff4e 	bl	69ec <IsIrqMasked>
    7b50:	4603      	mov	r3, r0
    7b52:	2b00      	cmp	r3, #0
    7b54:	d006      	beq.n	7b64 <osThreadGetStackSize+0x28>
    EvrRtxThreadGetStackSize(thread_id, 0U);
    7b56:	2100      	movs	r1, #0
    7b58:	9801      	ldr	r0, [sp, #4]
    7b5a:	f7fc fdb1 	bl	46c0 <EvrRtxThreadGetStackSize>
    stack_size = 0U;
    7b5e:	2300      	movs	r3, #0
    7b60:	9303      	str	r3, [sp, #12]
    7b62:	e008      	b.n	7b76 <osThreadGetStackSize+0x3a>
    7b64:	9b01      	ldr	r3, [sp, #4]
    7b66:	9302      	str	r3, [sp, #8]
SVC0_1 (ThreadGetStackSize,  uint32_t, osThreadId_t)
    7b68:	9b02      	ldr	r3, [sp, #8]
    7b6a:	4618      	mov	r0, r3
    7b6c:	4b04      	ldr	r3, [pc, #16]	; (7b80 <osThreadGetStackSize+0x44>)
    7b6e:	469c      	mov	ip, r3
    7b70:	df00      	svc	0
    7b72:	4603      	mov	r3, r0
  } else {
    stack_size = __svcThreadGetStackSize(thread_id);
    7b74:	9303      	str	r3, [sp, #12]
  }
  return stack_size;
    7b76:	9b03      	ldr	r3, [sp, #12]
}
    7b78:	4618      	mov	r0, r3
    7b7a:	b005      	add	sp, #20
    7b7c:	f85d fb04 	ldr.w	pc, [sp], #4
    7b80:	00007633 	.word	0x00007633

00007b84 <osThreadGetStackSpace>:

/// Get available stack space of a thread based on stack watermark recording during execution.
uint32_t osThreadGetStackSpace (osThreadId_t thread_id) {
    7b84:	b500      	push	{lr}
    7b86:	b085      	sub	sp, #20
    7b88:	9001      	str	r0, [sp, #4]
  uint32_t stack_space;

  if (IsIrqMode() || IsIrqMasked()) {
    7b8a:	f7fe ff22 	bl	69d2 <IsIrqMode>
    7b8e:	4603      	mov	r3, r0
    7b90:	2b00      	cmp	r3, #0
    7b92:	d104      	bne.n	7b9e <osThreadGetStackSpace+0x1a>
    7b94:	f7fe ff2a 	bl	69ec <IsIrqMasked>
    7b98:	4603      	mov	r3, r0
    7b9a:	2b00      	cmp	r3, #0
    7b9c:	d006      	beq.n	7bac <osThreadGetStackSpace+0x28>
    EvrRtxThreadGetStackSpace(thread_id, 0U);
    7b9e:	2100      	movs	r1, #0
    7ba0:	9801      	ldr	r0, [sp, #4]
    7ba2:	f7fc fd93 	bl	46cc <EvrRtxThreadGetStackSpace>
    stack_space = 0U;
    7ba6:	2300      	movs	r3, #0
    7ba8:	9303      	str	r3, [sp, #12]
    7baa:	e008      	b.n	7bbe <osThreadGetStackSpace+0x3a>
    7bac:	9b01      	ldr	r3, [sp, #4]
    7bae:	9302      	str	r3, [sp, #8]
SVC0_1 (ThreadGetStackSpace, uint32_t, osThreadId_t)
    7bb0:	9b02      	ldr	r3, [sp, #8]
    7bb2:	4618      	mov	r0, r3
    7bb4:	4b04      	ldr	r3, [pc, #16]	; (7bc8 <osThreadGetStackSpace+0x44>)
    7bb6:	469c      	mov	ip, r3
    7bb8:	df00      	svc	0
    7bba:	4603      	mov	r3, r0
  } else {
    stack_space = __svcThreadGetStackSpace(thread_id);
    7bbc:	9303      	str	r3, [sp, #12]
  }
  return stack_space;
    7bbe:	9b03      	ldr	r3, [sp, #12]
}
    7bc0:	4618      	mov	r0, r3
    7bc2:	b005      	add	sp, #20
    7bc4:	f85d fb04 	ldr.w	pc, [sp], #4
    7bc8:	00007689 	.word	0x00007689

00007bcc <osThreadExit>:
  }
  return status;
}

/// Terminate execution of current running thread.
__NO_RETURN void osThreadExit (void) {
    7bcc:	b508      	push	{r3, lr}
  EvrRtxThreadExit();
    7bce:	f7fc fc97 	bl	4500 <EvrRtxThreadExit>
SVC0_0N(ThreadExit,          void)
    7bd2:	4b04      	ldr	r3, [pc, #16]	; (7be4 <osThreadExit+0x18>)
    7bd4:	469c      	mov	ip, r3
    7bd6:	df00      	svc	0
  __svcThreadExit();
  EvrRtxThreadError(NULL, (int32_t)osError);
    7bd8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    7bdc:	2000      	movs	r0, #0
    7bde:	f7fc fc4d 	bl	447c <EvrRtxThreadError>
  for (;;) {}
    7be2:	e7fe      	b.n	7be2 <osThreadExit+0x16>
    7be4:	000077c1 	.word	0x000077c1

00007be8 <osThreadGetCount>:
  }
  return status;
}

/// Get number of active threads.
uint32_t osThreadGetCount (void) {
    7be8:	b500      	push	{lr}
    7bea:	b083      	sub	sp, #12
  uint32_t count;

  if (IsIrqMode() || IsIrqMasked()) {
    7bec:	f7fe fef1 	bl	69d2 <IsIrqMode>
    7bf0:	4603      	mov	r3, r0
    7bf2:	2b00      	cmp	r3, #0
    7bf4:	d104      	bne.n	7c00 <osThreadGetCount+0x18>
    7bf6:	f7fe fef9 	bl	69ec <IsIrqMasked>
    7bfa:	4603      	mov	r3, r0
    7bfc:	2b00      	cmp	r3, #0
    7bfe:	d005      	beq.n	7c0c <osThreadGetCount+0x24>
    EvrRtxThreadGetCount(0U);
    7c00:	2000      	movs	r0, #0
    7c02:	f7fc fd89 	bl	4718 <EvrRtxThreadGetCount>
    count = 0U;
    7c06:	2300      	movs	r3, #0
    7c08:	9301      	str	r3, [sp, #4]
    7c0a:	e004      	b.n	7c16 <osThreadGetCount+0x2e>
SVC0_0 (ThreadGetCount,      uint32_t)
    7c0c:	4b04      	ldr	r3, [pc, #16]	; (7c20 <osThreadGetCount+0x38>)
    7c0e:	469c      	mov	ip, r3
    7c10:	df00      	svc	0
    7c12:	4603      	mov	r3, r0
  } else {
    count = __svcThreadGetCount();
    7c14:	9301      	str	r3, [sp, #4]
  }
  return count;
    7c16:	9b01      	ldr	r3, [sp, #4]
}
    7c18:	4618      	mov	r0, r3
    7c1a:	b003      	add	sp, #12
    7c1c:	f85d fb04 	ldr.w	pc, [sp], #4
    7c20:	0000788d 	.word	0x0000788d

00007c24 <osThreadEnumerate>:

/// Enumerate active threads.
uint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items) {
    7c24:	b500      	push	{lr}
    7c26:	b087      	sub	sp, #28
    7c28:	9001      	str	r0, [sp, #4]
    7c2a:	9100      	str	r1, [sp, #0]
  uint32_t count;

  if (IsIrqMode() || IsIrqMasked()) {
    7c2c:	f7fe fed1 	bl	69d2 <IsIrqMode>
    7c30:	4603      	mov	r3, r0
    7c32:	2b00      	cmp	r3, #0
    7c34:	d104      	bne.n	7c40 <osThreadEnumerate+0x1c>
    7c36:	f7fe fed9 	bl	69ec <IsIrqMasked>
    7c3a:	4603      	mov	r3, r0
    7c3c:	2b00      	cmp	r3, #0
    7c3e:	d007      	beq.n	7c50 <osThreadEnumerate+0x2c>
    EvrRtxThreadEnumerate(thread_array, array_items, 0U);
    7c40:	2200      	movs	r2, #0
    7c42:	9900      	ldr	r1, [sp, #0]
    7c44:	9801      	ldr	r0, [sp, #4]
    7c46:	f7fc fd6c 	bl	4722 <EvrRtxThreadEnumerate>
    count = 0U;
    7c4a:	2300      	movs	r3, #0
    7c4c:	9305      	str	r3, [sp, #20]
    7c4e:	e00b      	b.n	7c68 <osThreadEnumerate+0x44>
    7c50:	9b01      	ldr	r3, [sp, #4]
    7c52:	9304      	str	r3, [sp, #16]
    7c54:	9b00      	ldr	r3, [sp, #0]
    7c56:	9303      	str	r3, [sp, #12]
SVC0_2 (ThreadEnumerate,     uint32_t,        osThreadId_t *, uint32_t)
    7c58:	9b04      	ldr	r3, [sp, #16]
    7c5a:	4618      	mov	r0, r3
    7c5c:	9903      	ldr	r1, [sp, #12]
    7c5e:	4b05      	ldr	r3, [pc, #20]	; (7c74 <osThreadEnumerate+0x50>)
    7c60:	469c      	mov	ip, r3
    7c62:	df00      	svc	0
    7c64:	4603      	mov	r3, r0
  } else {
    count = __svcThreadEnumerate(thread_array, array_items);
    7c66:	9305      	str	r3, [sp, #20]
  }
  return count;
    7c68:	9b05      	ldr	r3, [sp, #20]
}
    7c6a:	4618      	mov	r0, r3
    7c6c:	b007      	add	sp, #28
    7c6e:	f85d fb04 	ldr.w	pc, [sp], #4
    7c72:	bf00      	nop
    7c74:	000078f9 	.word	0x000078f9

00007c78 <osRtxMessageQueueId>:
__STATIC_INLINE os_message_queue_t *osRtxMessageQueueId (osMessageQueueId_t mq_id) {
    7c78:	b082      	sub	sp, #8
    7c7a:	9001      	str	r0, [sp, #4]
  return ((os_message_queue_t *)mq_id);
    7c7c:	9b01      	ldr	r3, [sp, #4]
}
    7c7e:	4618      	mov	r0, r3
    7c80:	b002      	add	sp, #8
    7c82:	4770      	bx	lr

00007c84 <TimerInsert>:
//  ==== Helper functions ====

/// Insert Timer into the Timer List sorted by Time.
/// \param[in]  timer           timer object.
/// \param[in]  tick            timer tick.
static void TimerInsert (os_timer_t *timer, uint32_t tick) {
    7c84:	b084      	sub	sp, #16
    7c86:	9001      	str	r0, [sp, #4]
    7c88:	9100      	str	r1, [sp, #0]
  os_timer_t *prev, *next;

  prev = NULL;
    7c8a:	2300      	movs	r3, #0
    7c8c:	9303      	str	r3, [sp, #12]
  next = osRtxInfo.timer.list;
    7c8e:	4b1c      	ldr	r3, [pc, #112]	; (7d00 <TimerInsert+0x7c>)
    7c90:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    7c92:	9302      	str	r3, [sp, #8]
  while ((next != NULL) && (next->tick <= tick)) {
    7c94:	e009      	b.n	7caa <TimerInsert+0x26>
    tick -= next->tick;
    7c96:	9b02      	ldr	r3, [sp, #8]
    7c98:	691b      	ldr	r3, [r3, #16]
    7c9a:	9a00      	ldr	r2, [sp, #0]
    7c9c:	1ad3      	subs	r3, r2, r3
    7c9e:	9300      	str	r3, [sp, #0]
    prev  = next;
    7ca0:	9b02      	ldr	r3, [sp, #8]
    7ca2:	9303      	str	r3, [sp, #12]
    next  = next->next;
    7ca4:	9b02      	ldr	r3, [sp, #8]
    7ca6:	68db      	ldr	r3, [r3, #12]
    7ca8:	9302      	str	r3, [sp, #8]
  while ((next != NULL) && (next->tick <= tick)) {
    7caa:	9b02      	ldr	r3, [sp, #8]
    7cac:	2b00      	cmp	r3, #0
    7cae:	d004      	beq.n	7cba <TimerInsert+0x36>
    7cb0:	9b02      	ldr	r3, [sp, #8]
    7cb2:	691a      	ldr	r2, [r3, #16]
    7cb4:	9b00      	ldr	r3, [sp, #0]
    7cb6:	429a      	cmp	r2, r3
    7cb8:	d9ed      	bls.n	7c96 <TimerInsert+0x12>
  }
  timer->tick = tick;
    7cba:	9b01      	ldr	r3, [sp, #4]
    7cbc:	9a00      	ldr	r2, [sp, #0]
    7cbe:	611a      	str	r2, [r3, #16]
  timer->prev = prev;
    7cc0:	9b01      	ldr	r3, [sp, #4]
    7cc2:	9a03      	ldr	r2, [sp, #12]
    7cc4:	609a      	str	r2, [r3, #8]
  timer->next = next;
    7cc6:	9b01      	ldr	r3, [sp, #4]
    7cc8:	9a02      	ldr	r2, [sp, #8]
    7cca:	60da      	str	r2, [r3, #12]
  if (next != NULL) {
    7ccc:	9b02      	ldr	r3, [sp, #8]
    7cce:	2b00      	cmp	r3, #0
    7cd0:	d009      	beq.n	7ce6 <TimerInsert+0x62>
    next->tick -= timer->tick;
    7cd2:	9b02      	ldr	r3, [sp, #8]
    7cd4:	691a      	ldr	r2, [r3, #16]
    7cd6:	9b01      	ldr	r3, [sp, #4]
    7cd8:	691b      	ldr	r3, [r3, #16]
    7cda:	1ad2      	subs	r2, r2, r3
    7cdc:	9b02      	ldr	r3, [sp, #8]
    7cde:	611a      	str	r2, [r3, #16]
    next->prev  = timer;
    7ce0:	9b02      	ldr	r3, [sp, #8]
    7ce2:	9a01      	ldr	r2, [sp, #4]
    7ce4:	609a      	str	r2, [r3, #8]
  }
  if (prev != NULL) {
    7ce6:	9b03      	ldr	r3, [sp, #12]
    7ce8:	2b00      	cmp	r3, #0
    7cea:	d003      	beq.n	7cf4 <TimerInsert+0x70>
    prev->next = timer;
    7cec:	9b03      	ldr	r3, [sp, #12]
    7cee:	9a01      	ldr	r2, [sp, #4]
    7cf0:	60da      	str	r2, [r3, #12]
  } else {
    osRtxInfo.timer.list = timer;
  }
}
    7cf2:	e002      	b.n	7cfa <TimerInsert+0x76>
    osRtxInfo.timer.list = timer;
    7cf4:	4a02      	ldr	r2, [pc, #8]	; (7d00 <TimerInsert+0x7c>)
    7cf6:	9b01      	ldr	r3, [sp, #4]
    7cf8:	6453      	str	r3, [r2, #68]	; 0x44
}
    7cfa:	bf00      	nop
    7cfc:	b004      	add	sp, #16
    7cfe:	4770      	bx	lr
    7d00:	20000110 	.word	0x20000110

00007d04 <TimerUnlink>:
  }
}

/// Unlink Timer from the Timer List Head.
/// \param[in]  timer           timer object.
static void TimerUnlink (const os_timer_t *timer) {
    7d04:	b082      	sub	sp, #8
    7d06:	9001      	str	r0, [sp, #4]

  if (timer->next != NULL) {
    7d08:	9b01      	ldr	r3, [sp, #4]
    7d0a:	68db      	ldr	r3, [r3, #12]
    7d0c:	2b00      	cmp	r3, #0
    7d0e:	d004      	beq.n	7d1a <TimerUnlink+0x16>
    timer->next->prev = timer->prev;
    7d10:	9b01      	ldr	r3, [sp, #4]
    7d12:	68db      	ldr	r3, [r3, #12]
    7d14:	9a01      	ldr	r2, [sp, #4]
    7d16:	6892      	ldr	r2, [r2, #8]
    7d18:	609a      	str	r2, [r3, #8]
  }
  osRtxInfo.timer.list = timer->next;
    7d1a:	9b01      	ldr	r3, [sp, #4]
    7d1c:	68db      	ldr	r3, [r3, #12]
    7d1e:	4a02      	ldr	r2, [pc, #8]	; (7d28 <TimerUnlink+0x24>)
    7d20:	6453      	str	r3, [r2, #68]	; 0x44
}
    7d22:	bf00      	nop
    7d24:	b002      	add	sp, #8
    7d26:	4770      	bx	lr
    7d28:	20000110 	.word	0x20000110

00007d2c <osRtxTimerTick>:


//  ==== Library functions ====

/// Timer Tick (called each SysTick).
static void osRtxTimerTick (void) {
    7d2c:	b500      	push	{lr}
    7d2e:	b083      	sub	sp, #12
  os_timer_t *timer;
  osStatus_t  status;

  timer = osRtxInfo.timer.list;
    7d30:	4b1e      	ldr	r3, [pc, #120]	; (7dac <osRtxTimerTick+0x80>)
    7d32:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    7d34:	9301      	str	r3, [sp, #4]
  if (timer == NULL) {
    7d36:	9b01      	ldr	r3, [sp, #4]
    7d38:	2b00      	cmp	r3, #0
    7d3a:	d032      	beq.n	7da2 <osRtxTimerTick+0x76>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }

  timer->tick--;
    7d3c:	9b01      	ldr	r3, [sp, #4]
    7d3e:	691b      	ldr	r3, [r3, #16]
    7d40:	1e5a      	subs	r2, r3, #1
    7d42:	9b01      	ldr	r3, [sp, #4]
    7d44:	611a      	str	r2, [r3, #16]
  while ((timer != NULL) && (timer->tick == 0U)) {
    7d46:	e024      	b.n	7d92 <osRtxTimerTick+0x66>
    TimerUnlink(timer);
    7d48:	9801      	ldr	r0, [sp, #4]
    7d4a:	f7ff ffdb 	bl	7d04 <TimerUnlink>
    status = osMessageQueuePut(osRtxInfo.timer.mq, &timer->finfo, 0U, 0U);
    7d4e:	4b17      	ldr	r3, [pc, #92]	; (7dac <osRtxTimerTick+0x80>)
    7d50:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
    7d52:	9b01      	ldr	r3, [sp, #4]
    7d54:	f103 0118 	add.w	r1, r3, #24
    7d58:	2300      	movs	r3, #0
    7d5a:	2200      	movs	r2, #0
    7d5c:	f7fe f8da 	bl	5f14 <osMessageQueuePut>
    7d60:	9000      	str	r0, [sp, #0]
    if (status != osOK) {
    7d62:	9b00      	ldr	r3, [sp, #0]
    7d64:	2b00      	cmp	r3, #0
    7d66:	d003      	beq.n	7d70 <osRtxTimerTick+0x44>
      (void)osRtxErrorNotify(osRtxErrorTimerQueueOverflow, timer);
    7d68:	9901      	ldr	r1, [sp, #4]
    7d6a:	2003      	movs	r0, #3
    7d6c:	f7fc fad6 	bl	431c <osRtxErrorNotify>
    }
    if (timer->type == osRtxTimerPeriodic) {
    7d70:	9b01      	ldr	r3, [sp, #4]
    7d72:	78db      	ldrb	r3, [r3, #3]
    7d74:	2b01      	cmp	r3, #1
    7d76:	d106      	bne.n	7d86 <osRtxTimerTick+0x5a>
      TimerInsert(timer, timer->load);
    7d78:	9b01      	ldr	r3, [sp, #4]
    7d7a:	695b      	ldr	r3, [r3, #20]
    7d7c:	4619      	mov	r1, r3
    7d7e:	9801      	ldr	r0, [sp, #4]
    7d80:	f7ff ff80 	bl	7c84 <TimerInsert>
    7d84:	e002      	b.n	7d8c <osRtxTimerTick+0x60>
    } else {
      timer->state = osRtxTimerStopped;
    7d86:	9b01      	ldr	r3, [sp, #4]
    7d88:	2201      	movs	r2, #1
    7d8a:	705a      	strb	r2, [r3, #1]
    }
    timer = osRtxInfo.timer.list;
    7d8c:	4b07      	ldr	r3, [pc, #28]	; (7dac <osRtxTimerTick+0x80>)
    7d8e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    7d90:	9301      	str	r3, [sp, #4]
  while ((timer != NULL) && (timer->tick == 0U)) {
    7d92:	9b01      	ldr	r3, [sp, #4]
    7d94:	2b00      	cmp	r3, #0
    7d96:	d005      	beq.n	7da4 <osRtxTimerTick+0x78>
    7d98:	9b01      	ldr	r3, [sp, #4]
    7d9a:	691b      	ldr	r3, [r3, #16]
    7d9c:	2b00      	cmp	r3, #0
    7d9e:	d0d3      	beq.n	7d48 <osRtxTimerTick+0x1c>
    7da0:	e000      	b.n	7da4 <osRtxTimerTick+0x78>
    return;
    7da2:	bf00      	nop
  }
}
    7da4:	b003      	add	sp, #12
    7da6:	f85d fb04 	ldr.w	pc, [sp], #4
    7daa:	bf00      	nop
    7dac:	20000110 	.word	0x20000110

00007db0 <osRtxTimerThread>:

/// Timer Thread
__WEAK void osRtxTimerThread (void *argument) {
    7db0:	b500      	push	{lr}
    7db2:	b087      	sub	sp, #28
    7db4:	9001      	str	r0, [sp, #4]
  os_timer_finfo_t finfo;
  osStatus_t       status;
  (void)           argument;

  osRtxInfo.timer.mq = osRtxMessageQueueId(
    7db6:	4b18      	ldr	r3, [pc, #96]	; (7e18 <osRtxTimerThread+0x68>)
    7db8:	6e58      	ldr	r0, [r3, #100]	; 0x64
    7dba:	4b17      	ldr	r3, [pc, #92]	; (7e18 <osRtxTimerThread+0x68>)
    7dbc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    7dbe:	461a      	mov	r2, r3
    7dc0:	2108      	movs	r1, #8
    7dc2:	f7fe f875 	bl	5eb0 <osMessageQueueNew>
    7dc6:	4603      	mov	r3, r0
    7dc8:	4618      	mov	r0, r3
    7dca:	f7ff ff55 	bl	7c78 <osRtxMessageQueueId>
    7dce:	4602      	mov	r2, r0
    7dd0:	4b12      	ldr	r3, [pc, #72]	; (7e1c <osRtxTimerThread+0x6c>)
    7dd2:	64da      	str	r2, [r3, #76]	; 0x4c
    osMessageQueueNew(osRtxConfig.timer_mq_mcnt, sizeof(os_timer_finfo_t), osRtxConfig.timer_mq_attr)
  );
  if (osRtxInfo.timer.mq == NULL) {
    7dd4:	4b11      	ldr	r3, [pc, #68]	; (7e1c <osRtxTimerThread+0x6c>)
    7dd6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    7dd8:	2b00      	cmp	r3, #0
    7dda:	d019      	beq.n	7e10 <osRtxTimerThread+0x60>
    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
    return;
  }
  osRtxInfo.timer.tick = osRtxTimerTick;
    7ddc:	4b0f      	ldr	r3, [pc, #60]	; (7e1c <osRtxTimerThread+0x6c>)
    7dde:	4a10      	ldr	r2, [pc, #64]	; (7e20 <osRtxTimerThread+0x70>)
    7de0:	651a      	str	r2, [r3, #80]	; 0x50
  for (;;) {
    //lint -e{934} "Taking address of near auto variable"
    status = osMessageQueueGet(osRtxInfo.timer.mq, &finfo, NULL, osWaitForever);
    7de2:	4b0e      	ldr	r3, [pc, #56]	; (7e1c <osRtxTimerThread+0x6c>)
    7de4:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
    7de6:	a903      	add	r1, sp, #12
    7de8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    7dec:	2200      	movs	r2, #0
    7dee:	f7fe f8d1 	bl	5f94 <osMessageQueueGet>
    7df2:	9005      	str	r0, [sp, #20]
    if (status == osOK) {
    7df4:	9b05      	ldr	r3, [sp, #20]
    7df6:	2b00      	cmp	r3, #0
    7df8:	d1f3      	bne.n	7de2 <osRtxTimerThread+0x32>
      EvrRtxTimerCallback(finfo.func, finfo.arg);
    7dfa:	9b03      	ldr	r3, [sp, #12]
    7dfc:	9a04      	ldr	r2, [sp, #16]
    7dfe:	4611      	mov	r1, r2
    7e00:	4618      	mov	r0, r3
    7e02:	f7fc fca5 	bl	4750 <EvrRtxTimerCallback>
      (finfo.func)(finfo.arg);
    7e06:	9b03      	ldr	r3, [sp, #12]
    7e08:	9a04      	ldr	r2, [sp, #16]
    7e0a:	4610      	mov	r0, r2
    7e0c:	4798      	blx	r3
    status = osMessageQueueGet(osRtxInfo.timer.mq, &finfo, NULL, osWaitForever);
    7e0e:	e7e8      	b.n	7de2 <osRtxTimerThread+0x32>
    return;
    7e10:	bf00      	nop
    }
  }
}
    7e12:	b007      	add	sp, #28
    7e14:	f85d fb04 	ldr.w	pc, [sp], #4
    7e18:	0001144c 	.word	0x0001144c
    7e1c:	20000110 	.word	0x20000110
    7e20:	00007d2d 	.word	0x00007d2d

00007e24 <OS_Tick_Setup>:
#endif

static uint8_t PendST;

// Setup OS Tick.
__WEAK int32_t OS_Tick_Setup (uint32_t freq, IRQHandler_t handler) {
    7e24:	b084      	sub	sp, #16
    7e26:	9001      	str	r0, [sp, #4]
    7e28:	9100      	str	r1, [sp, #0]
  uint32_t load;
  (void)handler;

  if (freq == 0U) {
    7e2a:	9b01      	ldr	r3, [sp, #4]
    7e2c:	2b00      	cmp	r3, #0
    7e2e:	d102      	bne.n	7e36 <OS_Tick_Setup+0x12>
    //lint -e{904} "Return statement before end of function"
    return (-1);
    7e30:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    7e34:	e01e      	b.n	7e74 <OS_Tick_Setup+0x50>
  }

  load = (SystemCoreClock / freq) - 1U;
    7e36:	4b11      	ldr	r3, [pc, #68]	; (7e7c <OS_Tick_Setup+0x58>)
    7e38:	681a      	ldr	r2, [r3, #0]
    7e3a:	9b01      	ldr	r3, [sp, #4]
    7e3c:	fbb2 f3f3 	udiv	r3, r2, r3
    7e40:	3b01      	subs	r3, #1
    7e42:	9303      	str	r3, [sp, #12]
  if (load > 0x00FFFFFFU) {
    7e44:	9b03      	ldr	r3, [sp, #12]
    7e46:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
    7e4a:	d302      	bcc.n	7e52 <OS_Tick_Setup+0x2e>
    //lint -e{904} "Return statement before end of function"
    return (-1);
    7e4c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    7e50:	e010      	b.n	7e74 <OS_Tick_Setup+0x50>
  SCB->SHPR[11] = SYSTICK_IRQ_PRIORITY;
#elif  (defined(__ARM_ARCH_8M_BASE__) && (__ARM_ARCH_8M_BASE__ != 0))
  SCB->SHPR[1] |= ((uint32_t)SYSTICK_IRQ_PRIORITY << 24);
#elif ((defined(__ARM_ARCH_7M__)      && (__ARM_ARCH_7M__      != 0)) || \
       (defined(__ARM_ARCH_7EM__)     && (__ARM_ARCH_7EM__     != 0)))
  SCB->SHP[11]  = SYSTICK_IRQ_PRIORITY;
    7e52:	4b0b      	ldr	r3, [pc, #44]	; (7e80 <OS_Tick_Setup+0x5c>)
    7e54:	22ff      	movs	r2, #255	; 0xff
    7e56:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
  SCB->SHP[1]  |= ((uint32_t)SYSTICK_IRQ_PRIORITY << 24);
#else
#error "Unknown ARM Core!"
#endif

  SysTick->CTRL =  SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk;
    7e5a:	4b0a      	ldr	r3, [pc, #40]	; (7e84 <OS_Tick_Setup+0x60>)
    7e5c:	2206      	movs	r2, #6
    7e5e:	601a      	str	r2, [r3, #0]
  SysTick->LOAD =  load;
    7e60:	4a08      	ldr	r2, [pc, #32]	; (7e84 <OS_Tick_Setup+0x60>)
    7e62:	9b03      	ldr	r3, [sp, #12]
    7e64:	6053      	str	r3, [r2, #4]
  SysTick->VAL  =  0U;
    7e66:	4b07      	ldr	r3, [pc, #28]	; (7e84 <OS_Tick_Setup+0x60>)
    7e68:	2200      	movs	r2, #0
    7e6a:	609a      	str	r2, [r3, #8]

  PendST = 0U;
    7e6c:	4b06      	ldr	r3, [pc, #24]	; (7e88 <OS_Tick_Setup+0x64>)
    7e6e:	2200      	movs	r2, #0
    7e70:	701a      	strb	r2, [r3, #0]

  return (0);
    7e72:	2300      	movs	r3, #0
}
    7e74:	4618      	mov	r0, r3
    7e76:	b004      	add	sp, #16
    7e78:	4770      	bx	lr
    7e7a:	bf00      	nop
    7e7c:	200001b4 	.word	0x200001b4
    7e80:	e000ed00 	.word	0xe000ed00
    7e84:	e000e010 	.word	0xe000e010
    7e88:	20001484 	.word	0x20001484

00007e8c <OS_Tick_Enable>:

/// Enable OS Tick.
__WEAK void OS_Tick_Enable (void) {

  if (PendST != 0U) {
    7e8c:	4b09      	ldr	r3, [pc, #36]	; (7eb4 <OS_Tick_Enable+0x28>)
    7e8e:	781b      	ldrb	r3, [r3, #0]
    7e90:	2b00      	cmp	r3, #0
    7e92:	d006      	beq.n	7ea2 <OS_Tick_Enable+0x16>
    PendST = 0U;
    7e94:	4b07      	ldr	r3, [pc, #28]	; (7eb4 <OS_Tick_Enable+0x28>)
    7e96:	2200      	movs	r2, #0
    7e98:	701a      	strb	r2, [r3, #0]
    SCB->ICSR = SCB_ICSR_PENDSTSET_Msk;
    7e9a:	4b07      	ldr	r3, [pc, #28]	; (7eb8 <OS_Tick_Enable+0x2c>)
    7e9c:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
    7ea0:	605a      	str	r2, [r3, #4]
  }

  SysTick->CTRL |=  SysTick_CTRL_ENABLE_Msk;
    7ea2:	4a06      	ldr	r2, [pc, #24]	; (7ebc <OS_Tick_Enable+0x30>)
    7ea4:	4b05      	ldr	r3, [pc, #20]	; (7ebc <OS_Tick_Enable+0x30>)
    7ea6:	681b      	ldr	r3, [r3, #0]
    7ea8:	f043 0301 	orr.w	r3, r3, #1
    7eac:	6013      	str	r3, [r2, #0]
}
    7eae:	bf00      	nop
    7eb0:	4770      	bx	lr
    7eb2:	bf00      	nop
    7eb4:	20001484 	.word	0x20001484
    7eb8:	e000ed00 	.word	0xe000ed00
    7ebc:	e000e010 	.word	0xe000e010

00007ec0 <OS_Tick_AcknowledgeIRQ>:
  }
}

// Acknowledge OS Tick IRQ.
__WEAK void OS_Tick_AcknowledgeIRQ (void) {
  (void)SysTick->CTRL;
    7ec0:	4b01      	ldr	r3, [pc, #4]	; (7ec8 <OS_Tick_AcknowledgeIRQ+0x8>)
    7ec2:	681b      	ldr	r3, [r3, #0]
}
    7ec4:	bf00      	nop
    7ec6:	4770      	bx	lr
    7ec8:	e000e010 	.word	0xe000e010

00007ecc <OS_Tick_GetIRQn>:

// Get OS Tick IRQ number.
__WEAK int32_t  OS_Tick_GetIRQn (void) {
  return ((int32_t)SysTick_IRQn);
    7ecc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
    7ed0:	4618      	mov	r0, r3
    7ed2:	4770      	bx	lr

00007ed4 <thread_terminate_hook>:
MBED_STATIC_ASSERT(ALIGN_DOWN(7, 8) == 0, "ALIGN_DOWN macro error");
MBED_STATIC_ASSERT(ALIGN_DOWN(8, 8) == 8, "ALIGN_DOWN macro error");

static void (*terminate_hook)(osThreadId_t id) = 0;
extern "C" void thread_terminate_hook(osThreadId_t id)
{
    7ed4:	b500      	push	{lr}
    7ed6:	b083      	sub	sp, #12
    7ed8:	9001      	str	r0, [sp, #4]
    if (terminate_hook != (void (*)(osThreadId_t))NULL) {
    7eda:	4b06      	ldr	r3, [pc, #24]	; (7ef4 <thread_terminate_hook+0x20>)
    7edc:	681b      	ldr	r3, [r3, #0]
    7ede:	2b00      	cmp	r3, #0
    7ee0:	d003      	beq.n	7eea <thread_terminate_hook+0x16>
        terminate_hook(id);
    7ee2:	4b04      	ldr	r3, [pc, #16]	; (7ef4 <thread_terminate_hook+0x20>)
    7ee4:	681b      	ldr	r3, [r3, #0]
    7ee6:	9801      	ldr	r0, [sp, #4]
    7ee8:	4798      	blx	r3
    }
}
    7eea:	bf00      	nop
    7eec:	b003      	add	sp, #12
    7eee:	f85d fb04 	ldr.w	pc, [sp], #4
    7ef2:	bf00      	nop
    7ef4:	20001488 	.word	0x20001488

00007ef8 <_ZN4rtos6Thread4waitEm>:
    }

    return evt;
}

osStatus Thread::wait(uint32_t millisec) {
    7ef8:	b500      	push	{lr}
    7efa:	b083      	sub	sp, #12
    7efc:	9001      	str	r0, [sp, #4]
    return osDelay(millisec);
    7efe:	9801      	ldr	r0, [sp, #4]
    7f00:	f7fc fb5e 	bl	45c0 <osDelay>
    7f04:	4603      	mov	r3, r0
}
    7f06:	4618      	mov	r0, r3
    7f08:	b003      	add	sp, #12
    7f0a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00007f10 <CLOCK_SetSimSafeDivs>:
 *
 * @param config Pointer to the configure structure.
 */
static inline void CLOCK_SetSimSafeDivs(void)
{
    __FSL_CLOCK_SECURE_WRITE(&SIM->CLKDIV1, 0x01240000UL);
    7f10:	4b02      	ldr	r3, [pc, #8]	; (7f1c <CLOCK_SetSimSafeDivs+0xc>)
    7f12:	f04f 7292 	mov.w	r2, #19136512	; 0x1240000
    7f16:	601a      	str	r2, [r3, #0]
}
    7f18:	bf00      	nop
    7f1a:	4770      	bx	lr
    7f1c:	40048044 	.word	0x40048044

00007f20 <CLOCK_SetXtal0Freq>:
 * @brief Sets the XTAL0 frequency based on board settings.
 *
 * @param freq The XTAL0/EXTAL0 input clock frequency in Hz.
 */
static inline void CLOCK_SetXtal0Freq(uint32_t freq)
{
    7f20:	b082      	sub	sp, #8
    7f22:	9001      	str	r0, [sp, #4]
    g_xtal0Freq = freq;
    7f24:	4a02      	ldr	r2, [pc, #8]	; (7f30 <CLOCK_SetXtal0Freq+0x10>)
    7f26:	9b01      	ldr	r3, [sp, #4]
    7f28:	6013      	str	r3, [r2, #0]
}
    7f2a:	bf00      	nop
    7f2c:	b002      	add	sp, #8
    7f2e:	4770      	bx	lr
    7f30:	20002f60 	.word	0x20002f60

00007f34 <BOARD_BootClockRUN>:
    {
    }
}

void BOARD_BootClockRUN(void)
{
    7f34:	b508      	push	{r3, lr}
    CLOCK_SetSimSafeDivs();
    7f36:	f7ff ffeb 	bl	7f10 <CLOCK_SetSimSafeDivs>

    CLOCK_InitOsc0(&g_defaultClockConfigRun.oscConfig);
    7f3a:	480d      	ldr	r0, [pc, #52]	; (7f70 <BOARD_BootClockRUN+0x3c>)
    7f3c:	f000 fcfc 	bl	8938 <CLOCK_InitOsc0>
    CLOCK_SetXtal0Freq(BOARD_XTAL0_CLK_HZ);
    7f40:	480c      	ldr	r0, [pc, #48]	; (7f74 <BOARD_BootClockRUN+0x40>)
    7f42:	f7ff ffed 	bl	7f20 <CLOCK_SetXtal0Freq>

    CLOCK_BootToPeeMode(g_defaultClockConfigRun.mcgConfig.oscsel, kMCG_PllClkSelPll0,
    7f46:	2300      	movs	r3, #0
    7f48:	4a0b      	ldr	r2, [pc, #44]	; (7f78 <BOARD_BootClockRUN+0x44>)
    7f4a:	2100      	movs	r1, #0
    7f4c:	4618      	mov	r0, r3
    7f4e:	f000 fd9f 	bl	8a90 <CLOCK_BootToPeeMode>
                        &g_defaultClockConfigRun.mcgConfig.pll0Config);

    CLOCK_SetInternalRefClkConfig(g_defaultClockConfigRun.mcgConfig.irclkEnableMode,
    7f52:	2302      	movs	r3, #2
    7f54:	2100      	movs	r1, #0
    7f56:	2200      	movs	r2, #0
    7f58:	4618      	mov	r0, r3
    7f5a:	f000 fc09 	bl	8770 <CLOCK_SetInternalRefClkConfig>
                                  g_defaultClockConfigRun.mcgConfig.ircs, g_defaultClockConfigRun.mcgConfig.fcrdiv);

    CLOCK_SetSimConfig(&g_defaultClockConfigRun.simConfig);
    7f5e:	4807      	ldr	r0, [pc, #28]	; (7f7c <BOARD_BootClockRUN+0x48>)
    7f60:	f000 fac4 	bl	84ec <CLOCK_SetSimConfig>

    SystemCoreClock = g_defaultClockConfigRun.coreClock;
    7f64:	4a06      	ldr	r2, [pc, #24]	; (7f80 <BOARD_BootClockRUN+0x4c>)
    7f66:	4b07      	ldr	r3, [pc, #28]	; (7f84 <BOARD_BootClockRUN+0x50>)
    7f68:	601a      	str	r2, [r3, #0]
}
    7f6a:	bf00      	nop
    7f6c:	bd08      	pop	{r3, pc}
    7f6e:	bf00      	nop
    7f70:	00012724 	.word	0x00012724
    7f74:	02faf080 	.word	0x02faf080
    7f78:	00012718 	.word	0x00012718
    7f7c:	0001271c 	.word	0x0001271c
    7f80:	07270e00 	.word	0x07270e00
    7f84:	200001b4 	.word	0x200001b4

00007f88 <mbed_sdk_init>:
#include "crc.h"
#include "fsl_clock_config.h"

// called before main
void mbed_sdk_init()
{
    7f88:	b508      	push	{r3, lr}
    BOARD_BootClockRUN();
    7f8a:	f7ff ffd3 	bl	7f34 <BOARD_BootClockRUN>
}
    7f8e:	bf00      	nop
    7f90:	bd08      	pop	{r3, pc}

00007f92 <NMI_Handler>:

// Change the NMI pin to an input. This allows NMI pin to
//  be used as a low power mode wakeup.  The application will
//  need to change the pin back to NMI_b or wakeup only occurs once!
void NMI_Handler(void)
{
    7f92:	b500      	push	{lr}
    7f94:	b083      	sub	sp, #12
    gpio_t gpio;
    gpio_init_in(&gpio, PTA4);
    7f96:	ab01      	add	r3, sp, #4
    7f98:	2104      	movs	r1, #4
    7f9a:	4618      	mov	r0, r3
    7f9c:	f7f9 fe7f 	bl	1c9e <gpio_init_in>
}
    7fa0:	bf00      	nop
    7fa2:	b003      	add	sp, #12
    7fa4:	f85d fb04 	ldr.w	pc, [sp], #4

00007fa8 <SystemInit>:
   -- SystemInit()
   ---------------------------------------------------------------------------- */

void SystemInit (void) {
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) | (3UL << 11*2));    /* set CP10, CP11 Full Access */
    7fa8:	4a0a      	ldr	r2, [pc, #40]	; (7fd4 <SystemInit+0x2c>)
    7faa:	4b0a      	ldr	r3, [pc, #40]	; (7fd4 <SystemInit+0x2c>)
    7fac:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    7fb0:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
    7fb4:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
#endif /* ((__FPU_PRESENT == 1) && (__FPU_USED == 1)) */
#if (DISABLE_WDOG)
  /* WDOG->UNLOCK: WDOGUNLOCK=0xC520 */
  WDOG->UNLOCK = WDOG_UNLOCK_WDOGUNLOCK(0xC520); /* Key 1 */
    7fb8:	4b07      	ldr	r3, [pc, #28]	; (7fd8 <SystemInit+0x30>)
    7fba:	f24c 5220 	movw	r2, #50464	; 0xc520
    7fbe:	81da      	strh	r2, [r3, #14]
  /* WDOG->UNLOCK: WDOGUNLOCK=0xD928 */
  WDOG->UNLOCK = WDOG_UNLOCK_WDOGUNLOCK(0xD928); /* Key 2 */
    7fc0:	4b05      	ldr	r3, [pc, #20]	; (7fd8 <SystemInit+0x30>)
    7fc2:	f64d 1228 	movw	r2, #55592	; 0xd928
    7fc6:	81da      	strh	r2, [r3, #14]
  /* WDOG->STCTRLH: ?=0,DISTESTWDOG=0,BYTESEL=0,TESTSEL=0,TESTWDOG=0,?=0,?=1,WAITEN=1,STOPEN=1,DBGEN=0,ALLOWUPDATE=1,WINEN=0,IRQRSTEN=0,CLKSRC=1,WDOGEN=0 */
  WDOG->STCTRLH = WDOG_STCTRLH_BYTESEL(0x00) |
    7fc8:	4b03      	ldr	r3, [pc, #12]	; (7fd8 <SystemInit+0x30>)
    7fca:	f44f 72e9 	mov.w	r2, #466	; 0x1d2
    7fce:	801a      	strh	r2, [r3, #0]
                 WDOG_STCTRLH_ALLOWUPDATE_MASK |
                 WDOG_STCTRLH_CLKSRC_MASK |
                 0x0100U;
#endif /* (DISABLE_WDOG) */

}
    7fd0:	bf00      	nop
    7fd2:	4770      	bx	lr
    7fd4:	e000ed00 	.word	0xe000ed00
    7fd8:	40052000 	.word	0x40052000

00007fdc <CLOCK_SetEr32kClock>:
{
    7fdc:	b082      	sub	sp, #8
    7fde:	9001      	str	r0, [sp, #4]
    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&SIM->SOPT1, SIM_SOPT1_OSC32KSEL_MASK, SIM_SOPT1_OSC32KSEL(src));
    7fe0:	4906      	ldr	r1, [pc, #24]	; (7ffc <CLOCK_SetEr32kClock+0x20>)
    7fe2:	4b06      	ldr	r3, [pc, #24]	; (7ffc <CLOCK_SetEr32kClock+0x20>)
    7fe4:	681b      	ldr	r3, [r3, #0]
    7fe6:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
    7fea:	9b01      	ldr	r3, [sp, #4]
    7fec:	049b      	lsls	r3, r3, #18
    7fee:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
    7ff2:	4313      	orrs	r3, r2
    7ff4:	600b      	str	r3, [r1, #0]
}
    7ff6:	bf00      	nop
    7ff8:	b002      	add	sp, #8
    7ffa:	4770      	bx	lr
    7ffc:	40047000 	.word	0x40047000

00008000 <CLOCK_SetPllFllSelClock>:
{
    8000:	b082      	sub	sp, #8
    8002:	9001      	str	r0, [sp, #4]
    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&SIM->SOPT2, SIM_SOPT2_PLLFLLSEL_MASK, SIM_SOPT2_PLLFLLSEL(src));
    8004:	4906      	ldr	r1, [pc, #24]	; (8020 <CLOCK_SetPllFllSelClock+0x20>)
    8006:	4b06      	ldr	r3, [pc, #24]	; (8020 <CLOCK_SetPllFllSelClock+0x20>)
    8008:	681b      	ldr	r3, [r3, #0]
    800a:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
    800e:	9b01      	ldr	r3, [sp, #4]
    8010:	041b      	lsls	r3, r3, #16
    8012:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
    8016:	4313      	orrs	r3, r2
    8018:	600b      	str	r3, [r1, #0]
}
    801a:	bf00      	nop
    801c:	b002      	add	sp, #8
    801e:	4770      	bx	lr
    8020:	40048004 	.word	0x40048004

00008024 <OSC_SetExtRefClkConfig>:
{
    8024:	b084      	sub	sp, #16
    8026:	9001      	str	r0, [sp, #4]
    8028:	9100      	str	r1, [sp, #0]
    uint8_t reg = base->CR;
    802a:	9b01      	ldr	r3, [sp, #4]
    802c:	781b      	ldrb	r3, [r3, #0]
    802e:	f88d 300f 	strb.w	r3, [sp, #15]
    reg &= ~(OSC_CR_ERCLKEN_MASK | OSC_CR_EREFSTEN_MASK);
    8032:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8036:	f003 035f 	and.w	r3, r3, #95	; 0x5f
    803a:	f88d 300f 	strb.w	r3, [sp, #15]
    reg |= config->enableMode;
    803e:	9b00      	ldr	r3, [sp, #0]
    8040:	781a      	ldrb	r2, [r3, #0]
    8042:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8046:	4313      	orrs	r3, r2
    8048:	f88d 300f 	strb.w	r3, [sp, #15]
    base->CR = reg;
    804c:	9b01      	ldr	r3, [sp, #4]
    804e:	f89d 200f 	ldrb.w	r2, [sp, #15]
    8052:	701a      	strb	r2, [r3, #0]
}
    8054:	bf00      	nop
    8056:	b004      	add	sp, #16
    8058:	4770      	bx	lr

0000805a <OSC_SetCapLoad>:
{
    805a:	b084      	sub	sp, #16
    805c:	9001      	str	r0, [sp, #4]
    805e:	460b      	mov	r3, r1
    8060:	f88d 3003 	strb.w	r3, [sp, #3]
    uint8_t reg = base->CR;
    8064:	9b01      	ldr	r3, [sp, #4]
    8066:	781b      	ldrb	r3, [r3, #0]
    8068:	f88d 300f 	strb.w	r3, [sp, #15]
    reg &= ~(OSC_CR_SC2P_MASK | OSC_CR_SC4P_MASK | OSC_CR_SC8P_MASK | OSC_CR_SC16P_MASK);
    806c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8070:	f023 030f 	bic.w	r3, r3, #15
    8074:	f88d 300f 	strb.w	r3, [sp, #15]
    reg |= capLoad;
    8078:	f89d 200f 	ldrb.w	r2, [sp, #15]
    807c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    8080:	4313      	orrs	r3, r2
    8082:	f88d 300f 	strb.w	r3, [sp, #15]
    base->CR = reg;
    8086:	9b01      	ldr	r3, [sp, #4]
    8088:	f89d 200f 	ldrb.w	r2, [sp, #15]
    808c:	701a      	strb	r2, [r3, #0]
}
    808e:	bf00      	nop
    8090:	b004      	add	sp, #16
    8092:	4770      	bx	lr

00008094 <CLOCK_GetMcgExtClkFreq>:
/*******************************************************************************
 * Code
 ******************************************************************************/

static uint32_t CLOCK_GetMcgExtClkFreq(void)
{
    8094:	b500      	push	{lr}
    8096:	b083      	sub	sp, #12
    uint32_t freq;

    switch (MCG_C7_OSCSEL_VAL)
    8098:	4b19      	ldr	r3, [pc, #100]	; (8100 <CLOCK_GetMcgExtClkFreq+0x6c>)
    809a:	781b      	ldrb	r3, [r3, #0]
    809c:	b2db      	uxtb	r3, r3
    809e:	f003 0303 	and.w	r3, r3, #3
    80a2:	2b01      	cmp	r3, #1
    80a4:	d012      	beq.n	80cc <CLOCK_GetMcgExtClkFreq+0x38>
    80a6:	2b01      	cmp	r3, #1
    80a8:	d302      	bcc.n	80b0 <CLOCK_GetMcgExtClkFreq+0x1c>
    80aa:	2b02      	cmp	r3, #2
    80ac:	d01c      	beq.n	80e8 <CLOCK_GetMcgExtClkFreq+0x54>
    80ae:	e01e      	b.n	80ee <CLOCK_GetMcgExtClkFreq+0x5a>
    {
        case 0U:
            /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
            assert(g_xtal0Freq);
    80b0:	4b14      	ldr	r3, [pc, #80]	; (8104 <CLOCK_GetMcgExtClkFreq+0x70>)
    80b2:	681b      	ldr	r3, [r3, #0]
    80b4:	2b00      	cmp	r3, #0
    80b6:	d105      	bne.n	80c4 <CLOCK_GetMcgExtClkFreq+0x30>
    80b8:	4b13      	ldr	r3, [pc, #76]	; (8108 <CLOCK_GetMcgExtClkFreq+0x74>)
    80ba:	4a14      	ldr	r2, [pc, #80]	; (810c <CLOCK_GetMcgExtClkFreq+0x78>)
    80bc:	21d4      	movs	r1, #212	; 0xd4
    80be:	4814      	ldr	r0, [pc, #80]	; (8110 <CLOCK_GetMcgExtClkFreq+0x7c>)
    80c0:	f002 f920 	bl	a304 <__assert_func>
            freq = g_xtal0Freq;
    80c4:	4b0f      	ldr	r3, [pc, #60]	; (8104 <CLOCK_GetMcgExtClkFreq+0x70>)
    80c6:	681b      	ldr	r3, [r3, #0]
    80c8:	9301      	str	r3, [sp, #4]
            break;
    80ca:	e013      	b.n	80f4 <CLOCK_GetMcgExtClkFreq+0x60>
        case 1U:
            /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN clock. */
            assert(g_xtal32Freq);
    80cc:	4b11      	ldr	r3, [pc, #68]	; (8114 <CLOCK_GetMcgExtClkFreq+0x80>)
    80ce:	681b      	ldr	r3, [r3, #0]
    80d0:	2b00      	cmp	r3, #0
    80d2:	d105      	bne.n	80e0 <CLOCK_GetMcgExtClkFreq+0x4c>
    80d4:	4b10      	ldr	r3, [pc, #64]	; (8118 <CLOCK_GetMcgExtClkFreq+0x84>)
    80d6:	4a0d      	ldr	r2, [pc, #52]	; (810c <CLOCK_GetMcgExtClkFreq+0x78>)
    80d8:	21d9      	movs	r1, #217	; 0xd9
    80da:	480d      	ldr	r0, [pc, #52]	; (8110 <CLOCK_GetMcgExtClkFreq+0x7c>)
    80dc:	f002 f912 	bl	a304 <__assert_func>
            freq = g_xtal32Freq;
    80e0:	4b0c      	ldr	r3, [pc, #48]	; (8114 <CLOCK_GetMcgExtClkFreq+0x80>)
    80e2:	681b      	ldr	r3, [r3, #0]
    80e4:	9301      	str	r3, [sp, #4]
            break;
    80e6:	e005      	b.n	80f4 <CLOCK_GetMcgExtClkFreq+0x60>
        case 2U:
            freq = MCG_INTERNAL_IRC_48M;
    80e8:	4b0c      	ldr	r3, [pc, #48]	; (811c <CLOCK_GetMcgExtClkFreq+0x88>)
    80ea:	9301      	str	r3, [sp, #4]
            break;
    80ec:	e002      	b.n	80f4 <CLOCK_GetMcgExtClkFreq+0x60>
        default:
            freq = 0U;
    80ee:	2300      	movs	r3, #0
    80f0:	9301      	str	r3, [sp, #4]
            break;
    80f2:	bf00      	nop
    }

    return freq;
    80f4:	9b01      	ldr	r3, [sp, #4]
}
    80f6:	4618      	mov	r0, r3
    80f8:	b003      	add	sp, #12
    80fa:	f85d fb04 	ldr.w	pc, [sp], #4
    80fe:	bf00      	nop
    8100:	4006400c 	.word	0x4006400c
    8104:	20002f60 	.word	0x20002f60
    8108:	000114ec 	.word	0x000114ec
    810c:	00012730 	.word	0x00012730
    8110:	000114f8 	.word	0x000114f8
    8114:	20002f5c 	.word	0x20002f5c
    8118:	00011558 	.word	0x00011558
    811c:	02dc6c00 	.word	0x02dc6c00

00008120 <CLOCK_GetFllExtRefClkFreq>:

static uint32_t CLOCK_GetFllExtRefClkFreq(void)
{
    8120:	b500      	push	{lr}
    8122:	b083      	sub	sp, #12
    /* FllExtRef = McgExtRef / FllExtRefDiv */
    uint8_t frdiv;
    uint8_t range;
    uint8_t oscsel;

    uint32_t freq = CLOCK_GetMcgExtClkFreq();
    8124:	f7ff ffb6 	bl	8094 <CLOCK_GetMcgExtClkFreq>
    8128:	9001      	str	r0, [sp, #4]

    if (!freq)
    812a:	9b01      	ldr	r3, [sp, #4]
    812c:	2b00      	cmp	r3, #0
    812e:	d101      	bne.n	8134 <CLOCK_GetFllExtRefClkFreq+0x14>
    {
        return freq;
    8130:	9b01      	ldr	r3, [sp, #4]
    8132:	e057      	b.n	81e4 <CLOCK_GetFllExtRefClkFreq+0xc4>
    }

    frdiv = MCG_C1_FRDIV_VAL;
    8134:	4b2d      	ldr	r3, [pc, #180]	; (81ec <CLOCK_GetFllExtRefClkFreq+0xcc>)
    8136:	781b      	ldrb	r3, [r3, #0]
    8138:	b2db      	uxtb	r3, r3
    813a:	08db      	lsrs	r3, r3, #3
    813c:	b2db      	uxtb	r3, r3
    813e:	f003 0307 	and.w	r3, r3, #7
    8142:	f88d 3003 	strb.w	r3, [sp, #3]
    freq >>= frdiv;
    8146:	f89d 3003 	ldrb.w	r3, [sp, #3]
    814a:	9a01      	ldr	r2, [sp, #4]
    814c:	fa22 f303 	lsr.w	r3, r2, r3
    8150:	9301      	str	r3, [sp, #4]

    range = MCG_C2_RANGE_VAL;
    8152:	4b27      	ldr	r3, [pc, #156]	; (81f0 <CLOCK_GetFllExtRefClkFreq+0xd0>)
    8154:	781b      	ldrb	r3, [r3, #0]
    8156:	b2db      	uxtb	r3, r3
    8158:	091b      	lsrs	r3, r3, #4
    815a:	b2db      	uxtb	r3, r3
    815c:	f003 0303 	and.w	r3, r3, #3
    8160:	f88d 3002 	strb.w	r3, [sp, #2]
    oscsel = MCG_C7_OSCSEL_VAL;
    8164:	4b23      	ldr	r3, [pc, #140]	; (81f4 <CLOCK_GetFllExtRefClkFreq+0xd4>)
    8166:	781b      	ldrb	r3, [r3, #0]
    8168:	b2db      	uxtb	r3, r3
    816a:	f003 0303 	and.w	r3, r3, #3
    816e:	f88d 3001 	strb.w	r3, [sp, #1]
    /*
       When should use divider 32, 64, 128, 256, 512, 1024, 1280, 1536.
       1. MCG_C7[OSCSEL] selects IRC48M.
       2. MCG_C7[OSCSEL] selects OSC0 and MCG_C2[RANGE] is not 0.
    */
    if (((0U != range) && (kMCG_OscselOsc == oscsel)) || (kMCG_OscselIrc == oscsel))
    8172:	f89d 3002 	ldrb.w	r3, [sp, #2]
    8176:	2b00      	cmp	r3, #0
    8178:	d003      	beq.n	8182 <CLOCK_GetFllExtRefClkFreq+0x62>
    817a:	f89d 3001 	ldrb.w	r3, [sp, #1]
    817e:	2b00      	cmp	r3, #0
    8180:	d003      	beq.n	818a <CLOCK_GetFllExtRefClkFreq+0x6a>
    8182:	f89d 3001 	ldrb.w	r3, [sp, #1]
    8186:	2b02      	cmp	r3, #2
    8188:	d12b      	bne.n	81e2 <CLOCK_GetFllExtRefClkFreq+0xc2>
    {
        switch (frdiv)
    818a:	f89d 3003 	ldrb.w	r3, [sp, #3]
    818e:	2b07      	cmp	r3, #7
    8190:	d824      	bhi.n	81dc <CLOCK_GetFllExtRefClkFreq+0xbc>
    8192:	a201      	add	r2, pc, #4	; (adr r2, 8198 <CLOCK_GetFllExtRefClkFreq+0x78>)
    8194:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    8198:	000081b9 	.word	0x000081b9
    819c:	000081b9 	.word	0x000081b9
    81a0:	000081b9 	.word	0x000081b9
    81a4:	000081b9 	.word	0x000081b9
    81a8:	000081b9 	.word	0x000081b9
    81ac:	000081b9 	.word	0x000081b9
    81b0:	000081c1 	.word	0x000081c1
    81b4:	000081cf 	.word	0x000081cf
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                freq >>= 5u;
    81b8:	9b01      	ldr	r3, [sp, #4]
    81ba:	095b      	lsrs	r3, r3, #5
    81bc:	9301      	str	r3, [sp, #4]
                break;
    81be:	e010      	b.n	81e2 <CLOCK_GetFllExtRefClkFreq+0xc2>
            case 6:
                /* 64*20=1280 */
                freq /= 20u;
    81c0:	9b01      	ldr	r3, [sp, #4]
    81c2:	4a0d      	ldr	r2, [pc, #52]	; (81f8 <CLOCK_GetFllExtRefClkFreq+0xd8>)
    81c4:	fba2 2303 	umull	r2, r3, r2, r3
    81c8:	091b      	lsrs	r3, r3, #4
    81ca:	9301      	str	r3, [sp, #4]
                break;
    81cc:	e009      	b.n	81e2 <CLOCK_GetFllExtRefClkFreq+0xc2>
            case 7:
                /* 128*12=1536 */
                freq /= 12u;
    81ce:	9b01      	ldr	r3, [sp, #4]
    81d0:	4a0a      	ldr	r2, [pc, #40]	; (81fc <CLOCK_GetFllExtRefClkFreq+0xdc>)
    81d2:	fba2 2303 	umull	r2, r3, r2, r3
    81d6:	08db      	lsrs	r3, r3, #3
    81d8:	9301      	str	r3, [sp, #4]
                break;
    81da:	e002      	b.n	81e2 <CLOCK_GetFllExtRefClkFreq+0xc2>
            default:
                freq = 0u;
    81dc:	2300      	movs	r3, #0
    81de:	9301      	str	r3, [sp, #4]
                break;
    81e0:	bf00      	nop
        }
    }

    return freq;
    81e2:	9b01      	ldr	r3, [sp, #4]
}
    81e4:	4618      	mov	r0, r3
    81e6:	b003      	add	sp, #12
    81e8:	f85d fb04 	ldr.w	pc, [sp], #4
    81ec:	40064000 	.word	0x40064000
    81f0:	40064001 	.word	0x40064001
    81f4:	4006400c 	.word	0x4006400c
    81f8:	cccccccd 	.word	0xcccccccd
    81fc:	aaaaaaab 	.word	0xaaaaaaab

00008200 <CLOCK_GetInternalRefClkSelectFreq>:

static uint32_t CLOCK_GetInternalRefClkSelectFreq(void)
{
    if (kMCG_IrcSlow == MCG_S_IRCST_VAL)
    8200:	4b0a      	ldr	r3, [pc, #40]	; (822c <CLOCK_GetInternalRefClkSelectFreq+0x2c>)
    8202:	799b      	ldrb	r3, [r3, #6]
    8204:	b2db      	uxtb	r3, r3
    8206:	f003 0301 	and.w	r3, r3, #1
    820a:	2b00      	cmp	r3, #0
    820c:	d102      	bne.n	8214 <CLOCK_GetInternalRefClkSelectFreq+0x14>
    {
        /* Slow internal reference clock selected*/
        return s_slowIrcFreq;
    820e:	4b08      	ldr	r3, [pc, #32]	; (8230 <CLOCK_GetInternalRefClkSelectFreq+0x30>)
    8210:	681b      	ldr	r3, [r3, #0]
    8212:	e009      	b.n	8228 <CLOCK_GetInternalRefClkSelectFreq+0x28>
    }
    else
    {
        /* Fast internal reference clock selected*/
        return s_fastIrcFreq >> MCG_SC_FCRDIV_VAL;
    8214:	4b07      	ldr	r3, [pc, #28]	; (8234 <CLOCK_GetInternalRefClkSelectFreq+0x34>)
    8216:	681a      	ldr	r2, [r3, #0]
    8218:	4b07      	ldr	r3, [pc, #28]	; (8238 <CLOCK_GetInternalRefClkSelectFreq+0x38>)
    821a:	781b      	ldrb	r3, [r3, #0]
    821c:	b2db      	uxtb	r3, r3
    821e:	085b      	lsrs	r3, r3, #1
    8220:	f003 0307 	and.w	r3, r3, #7
    8224:	fa22 f303 	lsr.w	r3, r2, r3
    }
}
    8228:	4618      	mov	r0, r3
    822a:	4770      	bx	lr
    822c:	40064000 	.word	0x40064000
    8230:	200001b8 	.word	0x200001b8
    8234:	200001bc 	.word	0x200001bc
    8238:	40064008 	.word	0x40064008

0000823c <CLOCK_GetFllRefClkFreq>:

static uint32_t CLOCK_GetFllRefClkFreq(void)
{
    823c:	b508      	push	{r3, lr}
    /* If use external reference clock. */
    if (kMCG_FllSrcExternal == MCG_S_IREFST_VAL)
    823e:	4b07      	ldr	r3, [pc, #28]	; (825c <CLOCK_GetFllRefClkFreq+0x20>)
    8240:	799b      	ldrb	r3, [r3, #6]
    8242:	b2db      	uxtb	r3, r3
    8244:	f003 0310 	and.w	r3, r3, #16
    8248:	2b00      	cmp	r3, #0
    824a:	d103      	bne.n	8254 <CLOCK_GetFllRefClkFreq+0x18>
    {
        return CLOCK_GetFllExtRefClkFreq();
    824c:	f7ff ff68 	bl	8120 <CLOCK_GetFllExtRefClkFreq>
    8250:	4603      	mov	r3, r0
    8252:	e001      	b.n	8258 <CLOCK_GetFllRefClkFreq+0x1c>
    }
    /* If use internal reference clock. */
    else
    {
        return s_slowIrcFreq;
    8254:	4b02      	ldr	r3, [pc, #8]	; (8260 <CLOCK_GetFllRefClkFreq+0x24>)
    8256:	681b      	ldr	r3, [r3, #0]
    }
}
    8258:	4618      	mov	r0, r3
    825a:	bd08      	pop	{r3, pc}
    825c:	40064000 	.word	0x40064000
    8260:	200001b8 	.word	0x200001b8

00008264 <CLOCK_GetPll0RefFreq>:

static uint32_t CLOCK_GetPll0RefFreq(void)
{
    8264:	b508      	push	{r3, lr}
    /* MCG external reference clock. */
    return CLOCK_GetMcgExtClkFreq();
    8266:	f7ff ff15 	bl	8094 <CLOCK_GetMcgExtClkFreq>
    826a:	4603      	mov	r3, r0
}
    826c:	4618      	mov	r0, r3
    826e:	bd08      	pop	{r3, pc}

00008270 <CLOCK_GetOscRangeFromFreq>:

static uint8_t CLOCK_GetOscRangeFromFreq(uint32_t freq)
{
    8270:	b084      	sub	sp, #16
    8272:	9001      	str	r0, [sp, #4]
    uint8_t range;

    if (freq <= 39063U)
    8274:	9b01      	ldr	r3, [sp, #4]
    8276:	f649 0297 	movw	r2, #39063	; 0x9897
    827a:	4293      	cmp	r3, r2
    827c:	d803      	bhi.n	8286 <CLOCK_GetOscRangeFromFreq+0x16>
    {
        range = 0U;
    827e:	2300      	movs	r3, #0
    8280:	f88d 300f 	strb.w	r3, [sp, #15]
    8284:	e00a      	b.n	829c <CLOCK_GetOscRangeFromFreq+0x2c>
    }
    else if (freq <= 8000000U)
    8286:	9b01      	ldr	r3, [sp, #4]
    8288:	4a07      	ldr	r2, [pc, #28]	; (82a8 <CLOCK_GetOscRangeFromFreq+0x38>)
    828a:	4293      	cmp	r3, r2
    828c:	d803      	bhi.n	8296 <CLOCK_GetOscRangeFromFreq+0x26>
    {
        range = 1U;
    828e:	2301      	movs	r3, #1
    8290:	f88d 300f 	strb.w	r3, [sp, #15]
    8294:	e002      	b.n	829c <CLOCK_GetOscRangeFromFreq+0x2c>
    }
    else
    {
        range = 2U;
    8296:	2302      	movs	r3, #2
    8298:	f88d 300f 	strb.w	r3, [sp, #15]
    }

    return range;
    829c:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    82a0:	4618      	mov	r0, r3
    82a2:	b004      	add	sp, #16
    82a4:	4770      	bx	lr
    82a6:	bf00      	nop
    82a8:	007a1200 	.word	0x007a1200

000082ac <CLOCK_GetOsc0ErClkFreq>:
        __NOP();
    }
}

uint32_t CLOCK_GetOsc0ErClkFreq(void)
{
    82ac:	b508      	push	{r3, lr}
    if (OSC0->CR & OSC_CR_ERCLKEN_MASK)
    82ae:	4b0b      	ldr	r3, [pc, #44]	; (82dc <CLOCK_GetOsc0ErClkFreq+0x30>)
    82b0:	781b      	ldrb	r3, [r3, #0]
    82b2:	b2db      	uxtb	r3, r3
    82b4:	b25b      	sxtb	r3, r3
    82b6:	2b00      	cmp	r3, #0
    82b8:	da0d      	bge.n	82d6 <CLOCK_GetOsc0ErClkFreq+0x2a>
    {
        /* Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock. */
        assert(g_xtal0Freq);
    82ba:	4b09      	ldr	r3, [pc, #36]	; (82e0 <CLOCK_GetOsc0ErClkFreq+0x34>)
    82bc:	681b      	ldr	r3, [r3, #0]
    82be:	2b00      	cmp	r3, #0
    82c0:	d106      	bne.n	82d0 <CLOCK_GetOsc0ErClkFreq+0x24>
    82c2:	4b08      	ldr	r3, [pc, #32]	; (82e4 <CLOCK_GetOsc0ErClkFreq+0x38>)
    82c4:	4a08      	ldr	r2, [pc, #32]	; (82e8 <CLOCK_GetOsc0ErClkFreq+0x3c>)
    82c6:	f240 1165 	movw	r1, #357	; 0x165
    82ca:	4808      	ldr	r0, [pc, #32]	; (82ec <CLOCK_GetOsc0ErClkFreq+0x40>)
    82cc:	f002 f81a 	bl	a304 <__assert_func>
        return g_xtal0Freq;
    82d0:	4b03      	ldr	r3, [pc, #12]	; (82e0 <CLOCK_GetOsc0ErClkFreq+0x34>)
    82d2:	681b      	ldr	r3, [r3, #0]
    82d4:	e000      	b.n	82d8 <CLOCK_GetOsc0ErClkFreq+0x2c>
    }
    else
    {
        return 0U;
    82d6:	2300      	movs	r3, #0
    }
}
    82d8:	4618      	mov	r0, r3
    82da:	bd08      	pop	{r3, pc}
    82dc:	40065000 	.word	0x40065000
    82e0:	20002f60 	.word	0x20002f60
    82e4:	000114ec 	.word	0x000114ec
    82e8:	00012748 	.word	0x00012748
    82ec:	000114f8 	.word	0x000114f8

000082f0 <CLOCK_GetEr32kClkFreq>:

uint32_t CLOCK_GetEr32kClkFreq(void)
{
    82f0:	b500      	push	{lr}
    82f2:	b083      	sub	sp, #12
    uint32_t freq;

    switch (SIM_SOPT1_OSC32KSEL_VAL)
    82f4:	4b18      	ldr	r3, [pc, #96]	; (8358 <CLOCK_GetEr32kClkFreq+0x68>)
    82f6:	681b      	ldr	r3, [r3, #0]
    82f8:	0c9b      	lsrs	r3, r3, #18
    82fa:	f003 0303 	and.w	r3, r3, #3
    82fe:	2b02      	cmp	r3, #2
    8300:	d00f      	beq.n	8322 <CLOCK_GetEr32kClkFreq+0x32>
    8302:	2b03      	cmp	r3, #3
    8304:	d01c      	beq.n	8340 <CLOCK_GetEr32kClkFreq+0x50>
    8306:	2b00      	cmp	r3, #0
    8308:	d11e      	bne.n	8348 <CLOCK_GetEr32kClkFreq+0x58>
    {
        case 0U: /* OSC 32k clock  */
            freq = (CLOCK_GetOsc0ErClkFreq() == 32768U) ? 32768U : 0U;
    830a:	f7ff ffcf 	bl	82ac <CLOCK_GetOsc0ErClkFreq>
    830e:	4603      	mov	r3, r0
    8310:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    8314:	d102      	bne.n	831c <CLOCK_GetEr32kClkFreq+0x2c>
    8316:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    831a:	e000      	b.n	831e <CLOCK_GetEr32kClkFreq+0x2e>
    831c:	2300      	movs	r3, #0
    831e:	9301      	str	r3, [sp, #4]
            break;
    8320:	e015      	b.n	834e <CLOCK_GetEr32kClkFreq+0x5e>
        case 2U: /* RTC 32k clock  */
            /* Please call CLOCK_SetXtal32Freq base on board setting before using XTAL32K/RTC_CLKIN clock. */
            assert(g_xtal32Freq);
    8322:	4b0e      	ldr	r3, [pc, #56]	; (835c <CLOCK_GetEr32kClkFreq+0x6c>)
    8324:	681b      	ldr	r3, [r3, #0]
    8326:	2b00      	cmp	r3, #0
    8328:	d106      	bne.n	8338 <CLOCK_GetEr32kClkFreq+0x48>
    832a:	4b0d      	ldr	r3, [pc, #52]	; (8360 <CLOCK_GetEr32kClkFreq+0x70>)
    832c:	4a0d      	ldr	r2, [pc, #52]	; (8364 <CLOCK_GetEr32kClkFreq+0x74>)
    832e:	f240 1179 	movw	r1, #377	; 0x179
    8332:	480d      	ldr	r0, [pc, #52]	; (8368 <CLOCK_GetEr32kClkFreq+0x78>)
    8334:	f001 ffe6 	bl	a304 <__assert_func>
            freq = g_xtal32Freq;
    8338:	4b08      	ldr	r3, [pc, #32]	; (835c <CLOCK_GetEr32kClkFreq+0x6c>)
    833a:	681b      	ldr	r3, [r3, #0]
    833c:	9301      	str	r3, [sp, #4]
            break;
    833e:	e006      	b.n	834e <CLOCK_GetEr32kClkFreq+0x5e>
        case 3U: /* LPO clock      */
            freq = LPO_CLK_FREQ;
    8340:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    8344:	9301      	str	r3, [sp, #4]
            break;
    8346:	e002      	b.n	834e <CLOCK_GetEr32kClkFreq+0x5e>
        default:
            freq = 0U;
    8348:	2300      	movs	r3, #0
    834a:	9301      	str	r3, [sp, #4]
            break;
    834c:	bf00      	nop
    }
    return freq;
    834e:	9b01      	ldr	r3, [sp, #4]
}
    8350:	4618      	mov	r0, r3
    8352:	b003      	add	sp, #12
    8354:	f85d fb04 	ldr.w	pc, [sp], #4
    8358:	40047000 	.word	0x40047000
    835c:	20002f5c 	.word	0x20002f5c
    8360:	00011558 	.word	0x00011558
    8364:	00012760 	.word	0x00012760
    8368:	000114f8 	.word	0x000114f8

0000836c <CLOCK_GetPllFllSelClkFreq>:

uint32_t CLOCK_GetPllFllSelClkFreq(void)
{
    836c:	b500      	push	{lr}
    836e:	b083      	sub	sp, #12
    uint32_t freq;

    switch (SIM_SOPT2_PLLFLLSEL_VAL)
    8370:	4b0f      	ldr	r3, [pc, #60]	; (83b0 <CLOCK_GetPllFllSelClkFreq+0x44>)
    8372:	681b      	ldr	r3, [r3, #0]
    8374:	0c1b      	lsrs	r3, r3, #16
    8376:	f003 0303 	and.w	r3, r3, #3
    837a:	2b01      	cmp	r3, #1
    837c:	d008      	beq.n	8390 <CLOCK_GetPllFllSelClkFreq+0x24>
    837e:	2b01      	cmp	r3, #1
    8380:	d302      	bcc.n	8388 <CLOCK_GetPllFllSelClkFreq+0x1c>
    8382:	2b03      	cmp	r3, #3
    8384:	d008      	beq.n	8398 <CLOCK_GetPllFllSelClkFreq+0x2c>
    8386:	e00a      	b.n	839e <CLOCK_GetPllFllSelClkFreq+0x32>
    {
        case 0U: /* FLL. */
            freq = CLOCK_GetFllFreq();
    8388:	f000 f8fa 	bl	8580 <CLOCK_GetFllFreq>
    838c:	9001      	str	r0, [sp, #4]
            break;
    838e:	e009      	b.n	83a4 <CLOCK_GetPllFllSelClkFreq+0x38>
        case 1U: /* PLL. */
            freq = CLOCK_GetPll0Freq();
    8390:	f000 f962 	bl	8658 <CLOCK_GetPll0Freq>
    8394:	9001      	str	r0, [sp, #4]
            break;
    8396:	e005      	b.n	83a4 <CLOCK_GetPllFllSelClkFreq+0x38>
        case 3U: /* MCG IRC48M. */
            freq = MCG_INTERNAL_IRC_48M;
    8398:	4b06      	ldr	r3, [pc, #24]	; (83b4 <CLOCK_GetPllFllSelClkFreq+0x48>)
    839a:	9301      	str	r3, [sp, #4]
            break;
    839c:	e002      	b.n	83a4 <CLOCK_GetPllFllSelClkFreq+0x38>
        default:
            freq = 0U;
    839e:	2300      	movs	r3, #0
    83a0:	9301      	str	r3, [sp, #4]
            break;
    83a2:	bf00      	nop
    }

    return freq;
    83a4:	9b01      	ldr	r3, [sp, #4]
}
    83a6:	4618      	mov	r0, r3
    83a8:	b003      	add	sp, #12
    83aa:	f85d fb04 	ldr.w	pc, [sp], #4
    83ae:	bf00      	nop
    83b0:	40048004 	.word	0x40048004
    83b4:	02dc6c00 	.word	0x02dc6c00

000083b8 <CLOCK_GetFreq>:
{
    return CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
}

uint32_t CLOCK_GetFreq(clock_name_t clockName)
{
    83b8:	b500      	push	{lr}
    83ba:	b085      	sub	sp, #20
    83bc:	4603      	mov	r3, r0
    83be:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32_t freq;

    switch (clockName)
    83c2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    83c6:	2b13      	cmp	r3, #19
    83c8:	f200 8083 	bhi.w	84d2 <CLOCK_GetFreq+0x11a>
    83cc:	a201      	add	r2, pc, #4	; (adr r2, 83d4 <CLOCK_GetFreq+0x1c>)
    83ce:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    83d2:	bf00      	nop
    83d4:	00008425 	.word	0x00008425
    83d8:	00008425 	.word	0x00008425
    83dc:	0000843f 	.word	0x0000843f
    83e0:	00008459 	.word	0x00008459
    83e4:	00008473 	.word	0x00008473
    83e8:	000084d3 	.word	0x000084d3
    83ec:	0000848d 	.word	0x0000848d
    83f0:	00008495 	.word	0x00008495
    83f4:	0000849d 	.word	0x0000849d
    83f8:	000084d3 	.word	0x000084d3
    83fc:	000084d3 	.word	0x000084d3
    8400:	000084a5 	.word	0x000084a5
    8404:	000084ad 	.word	0x000084ad
    8408:	000084b5 	.word	0x000084b5
    840c:	000084bd 	.word	0x000084bd
    8410:	000084d3 	.word	0x000084d3
    8414:	000084d3 	.word	0x000084d3
    8418:	000084d3 	.word	0x000084d3
    841c:	000084c5 	.word	0x000084c5
    8420:	000084cb 	.word	0x000084cb
    {
        case kCLOCK_CoreSysClk:
        case kCLOCK_PlatClk:
            freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV1_VAL + 1);
    8424:	f000 f87a 	bl	851c <CLOCK_GetOutClkFreq>
    8428:	4602      	mov	r2, r0
    842a:	4b2e      	ldr	r3, [pc, #184]	; (84e4 <CLOCK_GetFreq+0x12c>)
    842c:	681b      	ldr	r3, [r3, #0]
    842e:	0f1b      	lsrs	r3, r3, #28
    8430:	f003 030f 	and.w	r3, r3, #15
    8434:	3301      	adds	r3, #1
    8436:	fbb2 f3f3 	udiv	r3, r2, r3
    843a:	9303      	str	r3, [sp, #12]
            break;
    843c:	e04c      	b.n	84d8 <CLOCK_GetFreq+0x120>
        case kCLOCK_BusClk:
            freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV2_VAL + 1);
    843e:	f000 f86d 	bl	851c <CLOCK_GetOutClkFreq>
    8442:	4602      	mov	r2, r0
    8444:	4b27      	ldr	r3, [pc, #156]	; (84e4 <CLOCK_GetFreq+0x12c>)
    8446:	681b      	ldr	r3, [r3, #0]
    8448:	0e1b      	lsrs	r3, r3, #24
    844a:	f003 030f 	and.w	r3, r3, #15
    844e:	3301      	adds	r3, #1
    8450:	fbb2 f3f3 	udiv	r3, r2, r3
    8454:	9303      	str	r3, [sp, #12]
            break;
    8456:	e03f      	b.n	84d8 <CLOCK_GetFreq+0x120>
        case kCLOCK_FlexBusClk:
            freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV3_VAL + 1);
    8458:	f000 f860 	bl	851c <CLOCK_GetOutClkFreq>
    845c:	4602      	mov	r2, r0
    845e:	4b21      	ldr	r3, [pc, #132]	; (84e4 <CLOCK_GetFreq+0x12c>)
    8460:	681b      	ldr	r3, [r3, #0]
    8462:	0d1b      	lsrs	r3, r3, #20
    8464:	f003 030f 	and.w	r3, r3, #15
    8468:	3301      	adds	r3, #1
    846a:	fbb2 f3f3 	udiv	r3, r2, r3
    846e:	9303      	str	r3, [sp, #12]
            break;
    8470:	e032      	b.n	84d8 <CLOCK_GetFreq+0x120>
        case kCLOCK_FlashClk:
            freq = CLOCK_GetOutClkFreq() / (SIM_CLKDIV1_OUTDIV4_VAL + 1);
    8472:	f000 f853 	bl	851c <CLOCK_GetOutClkFreq>
    8476:	4602      	mov	r2, r0
    8478:	4b1a      	ldr	r3, [pc, #104]	; (84e4 <CLOCK_GetFreq+0x12c>)
    847a:	681b      	ldr	r3, [r3, #0]
    847c:	0c1b      	lsrs	r3, r3, #16
    847e:	f003 030f 	and.w	r3, r3, #15
    8482:	3301      	adds	r3, #1
    8484:	fbb2 f3f3 	udiv	r3, r2, r3
    8488:	9303      	str	r3, [sp, #12]
            break;
    848a:	e025      	b.n	84d8 <CLOCK_GetFreq+0x120>
        case kCLOCK_PllFllSelClk:
            freq = CLOCK_GetPllFllSelClkFreq();
    848c:	f7ff ff6e 	bl	836c <CLOCK_GetPllFllSelClkFreq>
    8490:	9003      	str	r0, [sp, #12]
            break;
    8492:	e021      	b.n	84d8 <CLOCK_GetFreq+0x120>
        case kCLOCK_Er32kClk:
            freq = CLOCK_GetEr32kClkFreq();
    8494:	f7ff ff2c 	bl	82f0 <CLOCK_GetEr32kClkFreq>
    8498:	9003      	str	r0, [sp, #12]
            break;
    849a:	e01d      	b.n	84d8 <CLOCK_GetFreq+0x120>
        case kCLOCK_Osc0ErClk:
            freq = CLOCK_GetOsc0ErClkFreq();
    849c:	f7ff ff06 	bl	82ac <CLOCK_GetOsc0ErClkFreq>
    84a0:	9003      	str	r0, [sp, #12]
            break;
    84a2:	e019      	b.n	84d8 <CLOCK_GetFreq+0x120>
        case kCLOCK_McgFixedFreqClk:
            freq = CLOCK_GetFixedFreqClkFreq();
    84a4:	f000 f8c2 	bl	862c <CLOCK_GetFixedFreqClkFreq>
    84a8:	9003      	str	r0, [sp, #12]
            break;
    84aa:	e015      	b.n	84d8 <CLOCK_GetFreq+0x120>
        case kCLOCK_McgInternalRefClk:
            freq = CLOCK_GetInternalRefClkFreq();
    84ac:	f000 f8ac 	bl	8608 <CLOCK_GetInternalRefClkFreq>
    84b0:	9003      	str	r0, [sp, #12]
            break;
    84b2:	e011      	b.n	84d8 <CLOCK_GetFreq+0x120>
        case kCLOCK_McgFllClk:
            freq = CLOCK_GetFllFreq();
    84b4:	f000 f864 	bl	8580 <CLOCK_GetFllFreq>
    84b8:	9003      	str	r0, [sp, #12]
            break;
    84ba:	e00d      	b.n	84d8 <CLOCK_GetFreq+0x120>
        case kCLOCK_McgPll0Clk:
            freq = CLOCK_GetPll0Freq();
    84bc:	f000 f8cc 	bl	8658 <CLOCK_GetPll0Freq>
    84c0:	9003      	str	r0, [sp, #12]
            break;
    84c2:	e009      	b.n	84d8 <CLOCK_GetFreq+0x120>
        case kCLOCK_McgIrc48MClk:
            freq = MCG_INTERNAL_IRC_48M;
    84c4:	4b08      	ldr	r3, [pc, #32]	; (84e8 <CLOCK_GetFreq+0x130>)
    84c6:	9303      	str	r3, [sp, #12]
            break;
    84c8:	e006      	b.n	84d8 <CLOCK_GetFreq+0x120>
        case kCLOCK_LpoClk:
            freq = LPO_CLK_FREQ;
    84ca:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    84ce:	9303      	str	r3, [sp, #12]
            break;
    84d0:	e002      	b.n	84d8 <CLOCK_GetFreq+0x120>
        default:
            freq = 0U;
    84d2:	2300      	movs	r3, #0
    84d4:	9303      	str	r3, [sp, #12]
            break;
    84d6:	bf00      	nop
    }

    return freq;
    84d8:	9b03      	ldr	r3, [sp, #12]
}
    84da:	4618      	mov	r0, r3
    84dc:	b005      	add	sp, #20
    84de:	f85d fb04 	ldr.w	pc, [sp], #4
    84e2:	bf00      	nop
    84e4:	40048044 	.word	0x40048044
    84e8:	02dc6c00 	.word	0x02dc6c00

000084ec <CLOCK_SetSimConfig>:

void CLOCK_SetSimConfig(sim_clock_config_t const *config)
{
    84ec:	b500      	push	{lr}
    84ee:	b083      	sub	sp, #12
    84f0:	9001      	str	r0, [sp, #4]
    __FSL_CLOCK_SECURE_WRITE(&SIM->CLKDIV1, config->clkdiv1);
    84f2:	4a09      	ldr	r2, [pc, #36]	; (8518 <CLOCK_SetSimConfig+0x2c>)
    84f4:	9b01      	ldr	r3, [sp, #4]
    84f6:	685b      	ldr	r3, [r3, #4]
    84f8:	6013      	str	r3, [r2, #0]

    CLOCK_SetPllFllSelClock(config->pllFllSel);
    84fa:	9b01      	ldr	r3, [sp, #4]
    84fc:	781b      	ldrb	r3, [r3, #0]
    84fe:	4618      	mov	r0, r3
    8500:	f7ff fd7e 	bl	8000 <CLOCK_SetPllFllSelClock>
    CLOCK_SetEr32kClock(config->er32kSrc);
    8504:	9b01      	ldr	r3, [sp, #4]
    8506:	785b      	ldrb	r3, [r3, #1]
    8508:	4618      	mov	r0, r3
    850a:	f7ff fd67 	bl	7fdc <CLOCK_SetEr32kClock>
}
    850e:	bf00      	nop
    8510:	b003      	add	sp, #12
    8512:	f85d fb04 	ldr.w	pc, [sp], #4
    8516:	bf00      	nop
    8518:	40048044 	.word	0x40048044

0000851c <CLOCK_GetOutClkFreq>:
    }
    return ret;
}

uint32_t CLOCK_GetOutClkFreq(void)
{
    851c:	b500      	push	{lr}
    851e:	b083      	sub	sp, #12
    uint32_t mcgoutclk;
    uint32_t clkst = MCG_S_CLKST_VAL;
    8520:	4b16      	ldr	r3, [pc, #88]	; (857c <CLOCK_GetOutClkFreq+0x60>)
    8522:	799b      	ldrb	r3, [r3, #6]
    8524:	b2db      	uxtb	r3, r3
    8526:	089b      	lsrs	r3, r3, #2
    8528:	f003 0303 	and.w	r3, r3, #3
    852c:	9300      	str	r3, [sp, #0]

    switch (clkst)
    852e:	9b00      	ldr	r3, [sp, #0]
    8530:	2b03      	cmp	r3, #3
    8532:	d81b      	bhi.n	856c <CLOCK_GetOutClkFreq+0x50>
    8534:	a201      	add	r2, pc, #4	; (adr r2, 853c <CLOCK_GetOutClkFreq+0x20>)
    8536:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    853a:	bf00      	nop
    853c:	00008555 	.word	0x00008555
    8540:	0000855d 	.word	0x0000855d
    8544:	00008565 	.word	0x00008565
    8548:	0000854d 	.word	0x0000854d
    {
        case kMCG_ClkOutStatPll:
            mcgoutclk = CLOCK_GetPll0Freq();
    854c:	f000 f884 	bl	8658 <CLOCK_GetPll0Freq>
    8550:	9001      	str	r0, [sp, #4]
            break;
    8552:	e00e      	b.n	8572 <CLOCK_GetOutClkFreq+0x56>
        case kMCG_ClkOutStatFll:
            mcgoutclk = CLOCK_GetFllFreq();
    8554:	f000 f814 	bl	8580 <CLOCK_GetFllFreq>
    8558:	9001      	str	r0, [sp, #4]
            break;
    855a:	e00a      	b.n	8572 <CLOCK_GetOutClkFreq+0x56>
        case kMCG_ClkOutStatInt:
            mcgoutclk = CLOCK_GetInternalRefClkSelectFreq();
    855c:	f7ff fe50 	bl	8200 <CLOCK_GetInternalRefClkSelectFreq>
    8560:	9001      	str	r0, [sp, #4]
            break;
    8562:	e006      	b.n	8572 <CLOCK_GetOutClkFreq+0x56>
        case kMCG_ClkOutStatExt:
            mcgoutclk = CLOCK_GetMcgExtClkFreq();
    8564:	f7ff fd96 	bl	8094 <CLOCK_GetMcgExtClkFreq>
    8568:	9001      	str	r0, [sp, #4]
            break;
    856a:	e002      	b.n	8572 <CLOCK_GetOutClkFreq+0x56>
        default:
            mcgoutclk = 0U;
    856c:	2300      	movs	r3, #0
    856e:	9301      	str	r3, [sp, #4]
            break;
    8570:	bf00      	nop
    }
    return mcgoutclk;
    8572:	9b01      	ldr	r3, [sp, #4]
}
    8574:	4618      	mov	r0, r3
    8576:	b003      	add	sp, #12
    8578:	f85d fb04 	ldr.w	pc, [sp], #4
    857c:	40064000 	.word	0x40064000

00008580 <CLOCK_GetFllFreq>:

uint32_t CLOCK_GetFllFreq(void)
{
    8580:	b500      	push	{lr}
    8582:	b083      	sub	sp, #12

    uint8_t drs, dmx32;
    uint32_t freq;

    /* If FLL is not enabled currently, then return 0U. */
    if ((__FSL_CLOCK_SECURE_READ(&MCG->C2) & MCG_C2_LP_MASK) || (MCG->S & MCG_S_PLLST_MASK))
    8584:	4b1d      	ldr	r3, [pc, #116]	; (85fc <CLOCK_GetFllFreq+0x7c>)
    8586:	781b      	ldrb	r3, [r3, #0]
    8588:	b2db      	uxtb	r3, r3
    858a:	f003 0302 	and.w	r3, r3, #2
    858e:	2b00      	cmp	r3, #0
    8590:	d106      	bne.n	85a0 <CLOCK_GetFllFreq+0x20>
    8592:	4b1b      	ldr	r3, [pc, #108]	; (8600 <CLOCK_GetFllFreq+0x80>)
    8594:	799b      	ldrb	r3, [r3, #6]
    8596:	b2db      	uxtb	r3, r3
    8598:	f003 0320 	and.w	r3, r3, #32
    859c:	2b00      	cmp	r3, #0
    859e:	d001      	beq.n	85a4 <CLOCK_GetFllFreq+0x24>
    {
        return 0U;
    85a0:	2300      	movs	r3, #0
    85a2:	e026      	b.n	85f2 <CLOCK_GetFllFreq+0x72>
    }

    /* Get FLL reference clock frequency. */
    freq = CLOCK_GetFllRefClkFreq();
    85a4:	f7ff fe4a 	bl	823c <CLOCK_GetFllRefClkFreq>
    85a8:	9001      	str	r0, [sp, #4]
    if (!freq)
    85aa:	9b01      	ldr	r3, [sp, #4]
    85ac:	2b00      	cmp	r3, #0
    85ae:	d101      	bne.n	85b4 <CLOCK_GetFllFreq+0x34>
    {
        return freq;
    85b0:	9b01      	ldr	r3, [sp, #4]
    85b2:	e01e      	b.n	85f2 <CLOCK_GetFllFreq+0x72>
    }

    drs = MCG_C4_DRST_DRS_VAL;
    85b4:	4b12      	ldr	r3, [pc, #72]	; (8600 <CLOCK_GetFllFreq+0x80>)
    85b6:	78db      	ldrb	r3, [r3, #3]
    85b8:	b2db      	uxtb	r3, r3
    85ba:	095b      	lsrs	r3, r3, #5
    85bc:	b2db      	uxtb	r3, r3
    85be:	f003 0303 	and.w	r3, r3, #3
    85c2:	f88d 3003 	strb.w	r3, [sp, #3]
    dmx32 = MCG_C4_DMX32_VAL;
    85c6:	4b0e      	ldr	r3, [pc, #56]	; (8600 <CLOCK_GetFllFreq+0x80>)
    85c8:	78db      	ldrb	r3, [r3, #3]
    85ca:	b2db      	uxtb	r3, r3
    85cc:	09db      	lsrs	r3, r3, #7
    85ce:	b2db      	uxtb	r3, r3
    85d0:	f003 0301 	and.w	r3, r3, #1
    85d4:	f88d 3002 	strb.w	r3, [sp, #2]

    return freq * fllFactorTable[drs][dmx32];
    85d8:	f89d 2003 	ldrb.w	r2, [sp, #3]
    85dc:	f89d 3002 	ldrb.w	r3, [sp, #2]
    85e0:	4908      	ldr	r1, [pc, #32]	; (8604 <CLOCK_GetFllFreq+0x84>)
    85e2:	0052      	lsls	r2, r2, #1
    85e4:	4413      	add	r3, r2
    85e6:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    85ea:	461a      	mov	r2, r3
    85ec:	9b01      	ldr	r3, [sp, #4]
    85ee:	fb03 f302 	mul.w	r3, r3, r2
}
    85f2:	4618      	mov	r0, r3
    85f4:	b003      	add	sp, #12
    85f6:	f85d fb04 	ldr.w	pc, [sp], #4
    85fa:	bf00      	nop
    85fc:	40064001 	.word	0x40064001
    8600:	40064000 	.word	0x40064000
    8604:	00012778 	.word	0x00012778

00008608 <CLOCK_GetInternalRefClkFreq>:

uint32_t CLOCK_GetInternalRefClkFreq(void)
{
    8608:	b508      	push	{r3, lr}
    /* If MCGIRCLK is gated. */
    if (!(__FSL_CLOCK_SECURE_READ(&MCG->C1) & MCG_C1_IRCLKEN_MASK))
    860a:	4b07      	ldr	r3, [pc, #28]	; (8628 <CLOCK_GetInternalRefClkFreq+0x20>)
    860c:	781b      	ldrb	r3, [r3, #0]
    860e:	b2db      	uxtb	r3, r3
    8610:	f003 0302 	and.w	r3, r3, #2
    8614:	2b00      	cmp	r3, #0
    8616:	d101      	bne.n	861c <CLOCK_GetInternalRefClkFreq+0x14>
    {
        return 0U;
    8618:	2300      	movs	r3, #0
    861a:	e002      	b.n	8622 <CLOCK_GetInternalRefClkFreq+0x1a>
    }

    return CLOCK_GetInternalRefClkSelectFreq();
    861c:	f7ff fdf0 	bl	8200 <CLOCK_GetInternalRefClkSelectFreq>
    8620:	4603      	mov	r3, r0
}
    8622:	4618      	mov	r0, r3
    8624:	bd08      	pop	{r3, pc}
    8626:	bf00      	nop
    8628:	40064000 	.word	0x40064000

0000862c <CLOCK_GetFixedFreqClkFreq>:

uint32_t CLOCK_GetFixedFreqClkFreq(void)
{
    862c:	b500      	push	{lr}
    862e:	b083      	sub	sp, #12
    uint32_t freq = CLOCK_GetFllRefClkFreq();
    8630:	f7ff fe04 	bl	823c <CLOCK_GetFllRefClkFreq>
    8634:	9001      	str	r0, [sp, #4]

    /* MCGFFCLK must be no more than MCGOUTCLK/8. */
    if ((freq) && (freq <= (CLOCK_GetOutClkFreq() / 8U)))
    8636:	9b01      	ldr	r3, [sp, #4]
    8638:	2b00      	cmp	r3, #0
    863a:	d008      	beq.n	864e <CLOCK_GetFixedFreqClkFreq+0x22>
    863c:	f7ff ff6e 	bl	851c <CLOCK_GetOutClkFreq>
    8640:	4603      	mov	r3, r0
    8642:	08da      	lsrs	r2, r3, #3
    8644:	9b01      	ldr	r3, [sp, #4]
    8646:	429a      	cmp	r2, r3
    8648:	d301      	bcc.n	864e <CLOCK_GetFixedFreqClkFreq+0x22>
    {
        return freq;
    864a:	9b01      	ldr	r3, [sp, #4]
    864c:	e000      	b.n	8650 <CLOCK_GetFixedFreqClkFreq+0x24>
    }
    else
    {
        return 0U;
    864e:	2300      	movs	r3, #0
    }
}
    8650:	4618      	mov	r0, r3
    8652:	b003      	add	sp, #12
    8654:	f85d fb04 	ldr.w	pc, [sp], #4

00008658 <CLOCK_GetPll0Freq>:

uint32_t CLOCK_GetPll0Freq(void)
{
    8658:	b500      	push	{lr}
    865a:	b083      	sub	sp, #12
    uint32_t mcgpll0clk;

    /* If PLL0 is not enabled, return 0. */
    if (!(MCG->S & MCG_S_LOCK0_MASK))
    865c:	4b17      	ldr	r3, [pc, #92]	; (86bc <CLOCK_GetPll0Freq+0x64>)
    865e:	799b      	ldrb	r3, [r3, #6]
    8660:	b2db      	uxtb	r3, r3
    8662:	f003 0340 	and.w	r3, r3, #64	; 0x40
    8666:	2b00      	cmp	r3, #0
    8668:	d101      	bne.n	866e <CLOCK_GetPll0Freq+0x16>
    {
        return 0U;
    866a:	2300      	movs	r3, #0
    866c:	e022      	b.n	86b4 <CLOCK_GetPll0Freq+0x5c>
    }

    mcgpll0clk = CLOCK_GetPll0RefFreq();
    866e:	f7ff fdf9 	bl	8264 <CLOCK_GetPll0RefFreq>
    8672:	9001      	str	r0, [sp, #4]

    /*
     * Please call CLOCK_SetXtal0Freq base on board setting before using OSC0 clock.
     * Please call CLOCK_SetXtal1Freq base on board setting before using OSC1 clock.
     */
    assert(mcgpll0clk);
    8674:	9b01      	ldr	r3, [sp, #4]
    8676:	2b00      	cmp	r3, #0
    8678:	d106      	bne.n	8688 <CLOCK_GetPll0Freq+0x30>
    867a:	4b11      	ldr	r3, [pc, #68]	; (86c0 <CLOCK_GetPll0Freq+0x68>)
    867c:	4a11      	ldr	r2, [pc, #68]	; (86c4 <CLOCK_GetPll0Freq+0x6c>)
    867e:	f240 217e 	movw	r1, #638	; 0x27e
    8682:	4811      	ldr	r0, [pc, #68]	; (86c8 <CLOCK_GetPll0Freq+0x70>)
    8684:	f001 fe3e 	bl	a304 <__assert_func>

    mcgpll0clk /= (FSL_FEATURE_MCG_PLL_PRDIV_BASE + MCG_C5_PRDIV0_VAL);
    8688:	4b10      	ldr	r3, [pc, #64]	; (86cc <CLOCK_GetPll0Freq+0x74>)
    868a:	781b      	ldrb	r3, [r3, #0]
    868c:	b2db      	uxtb	r3, r3
    868e:	f003 031f 	and.w	r3, r3, #31
    8692:	3301      	adds	r3, #1
    8694:	9a01      	ldr	r2, [sp, #4]
    8696:	fbb2 f3f3 	udiv	r3, r2, r3
    869a:	9301      	str	r3, [sp, #4]
    mcgpll0clk *= (FSL_FEATURE_MCG_PLL_VDIV_BASE + MCG_C6_VDIV0_VAL);
    869c:	4b0c      	ldr	r3, [pc, #48]	; (86d0 <CLOCK_GetPll0Freq+0x78>)
    869e:	781b      	ldrb	r3, [r3, #0]
    86a0:	b2db      	uxtb	r3, r3
    86a2:	f003 031f 	and.w	r3, r3, #31
    86a6:	f103 0218 	add.w	r2, r3, #24
    86aa:	9b01      	ldr	r3, [sp, #4]
    86ac:	fb02 f303 	mul.w	r3, r2, r3
    86b0:	9301      	str	r3, [sp, #4]

    return mcgpll0clk;
    86b2:	9b01      	ldr	r3, [sp, #4]
}
    86b4:	4618      	mov	r0, r3
    86b6:	b003      	add	sp, #12
    86b8:	f85d fb04 	ldr.w	pc, [sp], #4
    86bc:	40064000 	.word	0x40064000
    86c0:	00011568 	.word	0x00011568
    86c4:	00012788 	.word	0x00012788
    86c8:	000114f8 	.word	0x000114f8
    86cc:	40064004 	.word	0x40064004
    86d0:	40064005 	.word	0x40064005

000086d4 <CLOCK_SetExternalRefClkConfig>:

status_t CLOCK_SetExternalRefClkConfig(mcg_oscsel_t oscsel)
{
    86d4:	b084      	sub	sp, #16
    86d6:	4603      	mov	r3, r0
    86d8:	f88d 3007 	strb.w	r3, [sp, #7]
    {
        return kStatus_MCG_SourceUsed;
    }
#endif /* MCG_CONFIG_CHECK_PARAM */

    if (MCG_C7_OSCSEL_VAL != oscsel)
    86dc:	4b21      	ldr	r3, [pc, #132]	; (8764 <CLOCK_SetExternalRefClkConfig+0x90>)
    86de:	781b      	ldrb	r3, [r3, #0]
    86e0:	b2db      	uxtb	r3, r3
    86e2:	f003 0203 	and.w	r2, r3, #3
    86e6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    86ea:	429a      	cmp	r2, r3
    86ec:	d003      	beq.n	86f6 <CLOCK_SetExternalRefClkConfig+0x22>
    {
        /* If change OSCSEL, need to delay, ERR009878. */
        needDelay = true;
    86ee:	2301      	movs	r3, #1
    86f0:	f88d 300f 	strb.w	r3, [sp, #15]
    86f4:	e002      	b.n	86fc <CLOCK_SetExternalRefClkConfig+0x28>
    }
    else
    {
        needDelay = false;
    86f6:	2300      	movs	r3, #0
    86f8:	f88d 300f 	strb.w	r3, [sp, #15]
    }

    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C7, MCG_C7_OSCSEL_MASK, MCG_C7_OSCSEL(oscsel));
    86fc:	4919      	ldr	r1, [pc, #100]	; (8764 <CLOCK_SetExternalRefClkConfig+0x90>)
    86fe:	4b19      	ldr	r3, [pc, #100]	; (8764 <CLOCK_SetExternalRefClkConfig+0x90>)
    8700:	781b      	ldrb	r3, [r3, #0]
    8702:	b2db      	uxtb	r3, r3
    8704:	f023 0303 	bic.w	r3, r3, #3
    8708:	b2da      	uxtb	r2, r3
    870a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    870e:	f003 0303 	and.w	r3, r3, #3
    8712:	b2db      	uxtb	r3, r3
    8714:	4313      	orrs	r3, r2
    8716:	b2db      	uxtb	r3, r3
    8718:	700b      	strb	r3, [r1, #0]
    if (kMCG_OscselOsc == oscsel)
    871a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    871e:	2b00      	cmp	r3, #0
    8720:	d10e      	bne.n	8740 <CLOCK_SetExternalRefClkConfig+0x6c>
    {
        if (__FSL_CLOCK_SECURE_READ(&MCG->C2) & MCG_C2_EREFS_MASK)
    8722:	4b11      	ldr	r3, [pc, #68]	; (8768 <CLOCK_SetExternalRefClkConfig+0x94>)
    8724:	781b      	ldrb	r3, [r3, #0]
    8726:	b2db      	uxtb	r3, r3
    8728:	f003 0304 	and.w	r3, r3, #4
    872c:	2b00      	cmp	r3, #0
    872e:	d007      	beq.n	8740 <CLOCK_SetExternalRefClkConfig+0x6c>
        {
            while (!(MCG->S & MCG_S_OSCINIT0_MASK))
    8730:	bf00      	nop
    8732:	4b0e      	ldr	r3, [pc, #56]	; (876c <CLOCK_SetExternalRefClkConfig+0x98>)
    8734:	799b      	ldrb	r3, [r3, #6]
    8736:	b2db      	uxtb	r3, r3
    8738:	f003 0302 	and.w	r3, r3, #2
    873c:	2b00      	cmp	r3, #0
    873e:	d0f8      	beq.n	8732 <CLOCK_SetExternalRefClkConfig+0x5e>
            {
            }
        }
    }

    if (needDelay)
    8740:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8744:	2b00      	cmp	r3, #0
    8746:	d009      	beq.n	875c <CLOCK_SetExternalRefClkConfig+0x88>
    {
        /* ERR009878 Delay at least 50 micro-seconds for external clock change valid. */
        i = 1500U;
    8748:	f240 53dc 	movw	r3, #1500	; 0x5dc
    874c:	9302      	str	r3, [sp, #8]
        while (i--)
    874e:	e000      	b.n	8752 <CLOCK_SetExternalRefClkConfig+0x7e>
        {
            __NOP();
    8750:	bf00      	nop
        while (i--)
    8752:	9b02      	ldr	r3, [sp, #8]
    8754:	1e5a      	subs	r2, r3, #1
    8756:	9202      	str	r2, [sp, #8]
    8758:	2b00      	cmp	r3, #0
    875a:	d1f9      	bne.n	8750 <CLOCK_SetExternalRefClkConfig+0x7c>
        }
    }

    return kStatus_Success;
    875c:	2300      	movs	r3, #0
}
    875e:	4618      	mov	r0, r3
    8760:	b004      	add	sp, #16
    8762:	4770      	bx	lr
    8764:	4006400c 	.word	0x4006400c
    8768:	40064001 	.word	0x40064001
    876c:	40064000 	.word	0x40064000

00008770 <CLOCK_SetInternalRefClkConfig>:

status_t CLOCK_SetInternalRefClkConfig(uint8_t enableMode, mcg_irc_mode_t ircs, uint8_t fcrdiv)
{
    8770:	b084      	sub	sp, #16
    8772:	4603      	mov	r3, r0
    8774:	f88d 3007 	strb.w	r3, [sp, #7]
    8778:	460b      	mov	r3, r1
    877a:	f88d 3006 	strb.w	r3, [sp, #6]
    877e:	4613      	mov	r3, r2
    8780:	f88d 3005 	strb.w	r3, [sp, #5]
    uint32_t mcgOutClkState = MCG_S_CLKST_VAL;
    8784:	4b40      	ldr	r3, [pc, #256]	; (8888 <CLOCK_SetInternalRefClkConfig+0x118>)
    8786:	799b      	ldrb	r3, [r3, #6]
    8788:	b2db      	uxtb	r3, r3
    878a:	089b      	lsrs	r3, r3, #2
    878c:	f003 0303 	and.w	r3, r3, #3
    8790:	9303      	str	r3, [sp, #12]
    mcg_irc_mode_t curIrcs = (mcg_irc_mode_t)MCG_S_IRCST_VAL;
    8792:	4b3d      	ldr	r3, [pc, #244]	; (8888 <CLOCK_SetInternalRefClkConfig+0x118>)
    8794:	799b      	ldrb	r3, [r3, #6]
    8796:	b2db      	uxtb	r3, r3
    8798:	f003 0301 	and.w	r3, r3, #1
    879c:	f88d 300b 	strb.w	r3, [sp, #11]
    uint8_t curFcrdiv = MCG_SC_FCRDIV_VAL;
    87a0:	4b3a      	ldr	r3, [pc, #232]	; (888c <CLOCK_SetInternalRefClkConfig+0x11c>)
    87a2:	781b      	ldrb	r3, [r3, #0]
    87a4:	b2db      	uxtb	r3, r3
    87a6:	085b      	lsrs	r3, r3, #1
    87a8:	b2db      	uxtb	r3, r3
    87aa:	f003 0307 	and.w	r3, r3, #7
    87ae:	f88d 300a 	strb.w	r3, [sp, #10]
        }
    }
#endif

    /* If need to update the FCRDIV. */
    if (fcrdiv != curFcrdiv)
    87b2:	f89d 2005 	ldrb.w	r2, [sp, #5]
    87b6:	f89d 300a 	ldrb.w	r3, [sp, #10]
    87ba:	429a      	cmp	r2, r3
    87bc:	d02e      	beq.n	881c <CLOCK_SetInternalRefClkConfig+0xac>
    {
        /* If fast IRC is in use currently, change to slow IRC. */
        if ((kMCG_IrcFast == curIrcs) && ((mcgOutClkState == kMCG_ClkOutStatInt) || (__FSL_CLOCK_SECURE_READ(&MCG->C1) & MCG_C1_IRCLKEN_MASK)))
    87be:	f89d 300b 	ldrb.w	r3, [sp, #11]
    87c2:	2b01      	cmp	r3, #1
    87c4:	d119      	bne.n	87fa <CLOCK_SetInternalRefClkConfig+0x8a>
    87c6:	9b03      	ldr	r3, [sp, #12]
    87c8:	2b01      	cmp	r3, #1
    87ca:	d006      	beq.n	87da <CLOCK_SetInternalRefClkConfig+0x6a>
    87cc:	4b2e      	ldr	r3, [pc, #184]	; (8888 <CLOCK_SetInternalRefClkConfig+0x118>)
    87ce:	781b      	ldrb	r3, [r3, #0]
    87d0:	b2db      	uxtb	r3, r3
    87d2:	f003 0302 	and.w	r3, r3, #2
    87d6:	2b00      	cmp	r3, #0
    87d8:	d00f      	beq.n	87fa <CLOCK_SetInternalRefClkConfig+0x8a>
        {
            __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C2, MCG_C2_IRCS_MASK, MCG_C2_IRCS(kMCG_IrcSlow));
    87da:	4a2d      	ldr	r2, [pc, #180]	; (8890 <CLOCK_SetInternalRefClkConfig+0x120>)
    87dc:	4b2c      	ldr	r3, [pc, #176]	; (8890 <CLOCK_SetInternalRefClkConfig+0x120>)
    87de:	781b      	ldrb	r3, [r3, #0]
    87e0:	b2db      	uxtb	r3, r3
    87e2:	f023 0301 	bic.w	r3, r3, #1
    87e6:	b2db      	uxtb	r3, r3
    87e8:	7013      	strb	r3, [r2, #0]
            while (MCG_S_IRCST_VAL != kMCG_IrcSlow)
    87ea:	bf00      	nop
    87ec:	4b26      	ldr	r3, [pc, #152]	; (8888 <CLOCK_SetInternalRefClkConfig+0x118>)
    87ee:	799b      	ldrb	r3, [r3, #6]
    87f0:	b2db      	uxtb	r3, r3
    87f2:	f003 0301 	and.w	r3, r3, #1
    87f6:	2b00      	cmp	r3, #0
    87f8:	d1f8      	bne.n	87ec <CLOCK_SetInternalRefClkConfig+0x7c>
            {
            }
        }
        /* Update FCRDIV. */
        __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->SC, MCG_SC_FCRDIV_MASK | MCG_SC_ATMF_MASK | MCG_SC_LOCS0_MASK, MCG_SC_FCRDIV(fcrdiv));
    87fa:	4924      	ldr	r1, [pc, #144]	; (888c <CLOCK_SetInternalRefClkConfig+0x11c>)
    87fc:	4b23      	ldr	r3, [pc, #140]	; (888c <CLOCK_SetInternalRefClkConfig+0x11c>)
    87fe:	781b      	ldrb	r3, [r3, #0]
    8800:	b2db      	uxtb	r3, r3
    8802:	f023 032f 	bic.w	r3, r3, #47	; 0x2f
    8806:	b2da      	uxtb	r2, r3
    8808:	f89d 3005 	ldrb.w	r3, [sp, #5]
    880c:	005b      	lsls	r3, r3, #1
    880e:	b2db      	uxtb	r3, r3
    8810:	f003 030e 	and.w	r3, r3, #14
    8814:	b2db      	uxtb	r3, r3
    8816:	4313      	orrs	r3, r2
    8818:	b2db      	uxtb	r3, r3
    881a:	700b      	strb	r3, [r1, #0]
    }

    /* Set internal reference clock selection. */
    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C2, MCG_C2_IRCS_MASK, MCG_C2_IRCS(ircs));
    881c:	491c      	ldr	r1, [pc, #112]	; (8890 <CLOCK_SetInternalRefClkConfig+0x120>)
    881e:	4b1c      	ldr	r3, [pc, #112]	; (8890 <CLOCK_SetInternalRefClkConfig+0x120>)
    8820:	781b      	ldrb	r3, [r3, #0]
    8822:	b2db      	uxtb	r3, r3
    8824:	f023 0301 	bic.w	r3, r3, #1
    8828:	b2da      	uxtb	r2, r3
    882a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    882e:	f003 0301 	and.w	r3, r3, #1
    8832:	b2db      	uxtb	r3, r3
    8834:	4313      	orrs	r3, r2
    8836:	b2db      	uxtb	r3, r3
    8838:	700b      	strb	r3, [r1, #0]
    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C1, MCG_C1_IRCLKEN_MASK | MCG_C1_IREFSTEN_MASK, (uint8_t)enableMode);
    883a:	4913      	ldr	r1, [pc, #76]	; (8888 <CLOCK_SetInternalRefClkConfig+0x118>)
    883c:	4b12      	ldr	r3, [pc, #72]	; (8888 <CLOCK_SetInternalRefClkConfig+0x118>)
    883e:	781b      	ldrb	r3, [r3, #0]
    8840:	b2db      	uxtb	r3, r3
    8842:	f023 0303 	bic.w	r3, r3, #3
    8846:	b2da      	uxtb	r2, r3
    8848:	f89d 3007 	ldrb.w	r3, [sp, #7]
    884c:	f003 0303 	and.w	r3, r3, #3
    8850:	b2db      	uxtb	r3, r3
    8852:	4313      	orrs	r3, r2
    8854:	b2db      	uxtb	r3, r3
    8856:	700b      	strb	r3, [r1, #0]

    /* If MCGIRCLK is used, need to wait for MCG_S_IRCST. */
    if ((mcgOutClkState == kMCG_ClkOutStatInt) || (enableMode & kMCG_IrclkEnable))
    8858:	9b03      	ldr	r3, [sp, #12]
    885a:	2b01      	cmp	r3, #1
    885c:	d005      	beq.n	886a <CLOCK_SetInternalRefClkConfig+0xfa>
    885e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8862:	f003 0302 	and.w	r3, r3, #2
    8866:	2b00      	cmp	r3, #0
    8868:	d009      	beq.n	887e <CLOCK_SetInternalRefClkConfig+0x10e>
    {
        while (MCG_S_IRCST_VAL != ircs)
    886a:	bf00      	nop
    886c:	4b06      	ldr	r3, [pc, #24]	; (8888 <CLOCK_SetInternalRefClkConfig+0x118>)
    886e:	799b      	ldrb	r3, [r3, #6]
    8870:	b2db      	uxtb	r3, r3
    8872:	f003 0201 	and.w	r2, r3, #1
    8876:	f89d 3006 	ldrb.w	r3, [sp, #6]
    887a:	429a      	cmp	r2, r3
    887c:	d1f6      	bne.n	886c <CLOCK_SetInternalRefClkConfig+0xfc>
        {
        }
    }

    return kStatus_Success;
    887e:	2300      	movs	r3, #0
}
    8880:	4618      	mov	r0, r3
    8882:	b004      	add	sp, #16
    8884:	4770      	bx	lr
    8886:	bf00      	nop
    8888:	40064000 	.word	0x40064000
    888c:	40064008 	.word	0x40064008
    8890:	40064001 	.word	0x40064001

00008894 <CLOCK_EnablePll0>:
        return 0U;
    }
}

void CLOCK_EnablePll0(mcg_pll_config_t const *config)
{
    8894:	b500      	push	{lr}
    8896:	b085      	sub	sp, #20
    8898:	9001      	str	r0, [sp, #4]
    assert(config);
    889a:	9b01      	ldr	r3, [sp, #4]
    889c:	2b00      	cmp	r3, #0
    889e:	d106      	bne.n	88ae <CLOCK_EnablePll0+0x1a>
    88a0:	4b1f      	ldr	r3, [pc, #124]	; (8920 <CLOCK_EnablePll0+0x8c>)
    88a2:	4a20      	ldr	r2, [pc, #128]	; (8924 <CLOCK_EnablePll0+0x90>)
    88a4:	f44f 7152 	mov.w	r1, #840	; 0x348
    88a8:	481f      	ldr	r0, [pc, #124]	; (8928 <CLOCK_EnablePll0+0x94>)
    88aa:	f001 fd2b 	bl	a304 <__assert_func>

    uint8_t mcg_c5 = 0U;
    88ae:	2300      	movs	r3, #0
    88b0:	f88d 300f 	strb.w	r3, [sp, #15]

    mcg_c5 |= MCG_C5_PRDIV0(config->prdiv);
    88b4:	9b01      	ldr	r3, [sp, #4]
    88b6:	785b      	ldrb	r3, [r3, #1]
    88b8:	f003 031f 	and.w	r3, r3, #31
    88bc:	b2da      	uxtb	r2, r3
    88be:	f89d 300f 	ldrb.w	r3, [sp, #15]
    88c2:	4313      	orrs	r3, r2
    88c4:	f88d 300f 	strb.w	r3, [sp, #15]
    __FSL_CLOCK_SECURE_WRITE(&MCG->C5, mcg_c5); /* Disable the PLL first. */
    88c8:	4a18      	ldr	r2, [pc, #96]	; (892c <CLOCK_EnablePll0+0x98>)
    88ca:	f89d 300f 	ldrb.w	r3, [sp, #15]
    88ce:	7013      	strb	r3, [r2, #0]

    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C6, MCG_C6_VDIV0_MASK, MCG_C6_VDIV0(config->vdiv));
    88d0:	4917      	ldr	r1, [pc, #92]	; (8930 <CLOCK_EnablePll0+0x9c>)
    88d2:	4b17      	ldr	r3, [pc, #92]	; (8930 <CLOCK_EnablePll0+0x9c>)
    88d4:	781b      	ldrb	r3, [r3, #0]
    88d6:	b2db      	uxtb	r3, r3
    88d8:	f023 031f 	bic.w	r3, r3, #31
    88dc:	b2da      	uxtb	r2, r3
    88de:	9b01      	ldr	r3, [sp, #4]
    88e0:	789b      	ldrb	r3, [r3, #2]
    88e2:	f003 031f 	and.w	r3, r3, #31
    88e6:	b2db      	uxtb	r3, r3
    88e8:	4313      	orrs	r3, r2
    88ea:	b2db      	uxtb	r3, r3
    88ec:	700b      	strb	r3, [r1, #0]

    /* Set enable mode. */
    __FSL_CLOCK_SECURE_BITS_SET(&MCG->C5, ((uint32_t)kMCG_PllEnableIndependent | (uint32_t)config->enableMode));
    88ee:	490f      	ldr	r1, [pc, #60]	; (892c <CLOCK_EnablePll0+0x98>)
    88f0:	4b0e      	ldr	r3, [pc, #56]	; (892c <CLOCK_EnablePll0+0x98>)
    88f2:	781b      	ldrb	r3, [r3, #0]
    88f4:	b2da      	uxtb	r2, r3
    88f6:	9b01      	ldr	r3, [sp, #4]
    88f8:	781b      	ldrb	r3, [r3, #0]
    88fa:	4313      	orrs	r3, r2
    88fc:	b2db      	uxtb	r3, r3
    88fe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    8902:	b2db      	uxtb	r3, r3
    8904:	700b      	strb	r3, [r1, #0]

    /* Wait for PLL lock. */
    while (!(MCG->S & MCG_S_LOCK0_MASK))
    8906:	bf00      	nop
    8908:	4b0a      	ldr	r3, [pc, #40]	; (8934 <CLOCK_EnablePll0+0xa0>)
    890a:	799b      	ldrb	r3, [r3, #6]
    890c:	b2db      	uxtb	r3, r3
    890e:	f003 0340 	and.w	r3, r3, #64	; 0x40
    8912:	2b00      	cmp	r3, #0
    8914:	d0f8      	beq.n	8908 <CLOCK_EnablePll0+0x74>
    {
    }
}
    8916:	bf00      	nop
    8918:	b005      	add	sp, #20
    891a:	f85d fb04 	ldr.w	pc, [sp], #4
    891e:	bf00      	nop
    8920:	00011574 	.word	0x00011574
    8924:	0001279c 	.word	0x0001279c
    8928:	000114f8 	.word	0x000114f8
    892c:	40064004 	.word	0x40064004
    8930:	40064005 	.word	0x40064005
    8934:	40064000 	.word	0x40064000

00008938 <CLOCK_InitOsc0>:
        MCG->S = MCG_S_LOLS0_MASK;
    }
}

void CLOCK_InitOsc0(osc_config_t const *config)
{
    8938:	b500      	push	{lr}
    893a:	b085      	sub	sp, #20
    893c:	9001      	str	r0, [sp, #4]
    uint8_t range = CLOCK_GetOscRangeFromFreq(config->freq);
    893e:	9b01      	ldr	r3, [sp, #4]
    8940:	681b      	ldr	r3, [r3, #0]
    8942:	4618      	mov	r0, r3
    8944:	f7ff fc94 	bl	8270 <CLOCK_GetOscRangeFromFreq>
    8948:	4603      	mov	r3, r0
    894a:	f88d 300f 	strb.w	r3, [sp, #15]

    OSC_SetCapLoad(OSC0, config->capLoad);
    894e:	9b01      	ldr	r3, [sp, #4]
    8950:	791b      	ldrb	r3, [r3, #4]
    8952:	4619      	mov	r1, r3
    8954:	481b      	ldr	r0, [pc, #108]	; (89c4 <CLOCK_InitOsc0+0x8c>)
    8956:	f7ff fb80 	bl	805a <OSC_SetCapLoad>
    OSC_SetExtRefClkConfig(OSC0, &config->oscerConfig);
    895a:	9b01      	ldr	r3, [sp, #4]
    895c:	3306      	adds	r3, #6
    895e:	4619      	mov	r1, r3
    8960:	4818      	ldr	r0, [pc, #96]	; (89c4 <CLOCK_InitOsc0+0x8c>)
    8962:	f7ff fb5f 	bl	8024 <OSC_SetExtRefClkConfig>

    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C2, OSC_MODE_MASK, MCG_C2_RANGE(range) | (uint8_t)config->workMode);
    8966:	4818      	ldr	r0, [pc, #96]	; (89c8 <CLOCK_InitOsc0+0x90>)
    8968:	4b17      	ldr	r3, [pc, #92]	; (89c8 <CLOCK_InitOsc0+0x90>)
    896a:	781b      	ldrb	r3, [r3, #0]
    896c:	b2db      	uxtb	r3, r3
    896e:	f023 033c 	bic.w	r3, r3, #60	; 0x3c
    8972:	b2da      	uxtb	r2, r3
    8974:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8978:	011b      	lsls	r3, r3, #4
    897a:	b2db      	uxtb	r3, r3
    897c:	f003 0330 	and.w	r3, r3, #48	; 0x30
    8980:	b2d9      	uxtb	r1, r3
    8982:	9b01      	ldr	r3, [sp, #4]
    8984:	795b      	ldrb	r3, [r3, #5]
    8986:	430b      	orrs	r3, r1
    8988:	b2db      	uxtb	r3, r3
    898a:	f003 033c 	and.w	r3, r3, #60	; 0x3c
    898e:	b2db      	uxtb	r3, r3
    8990:	4313      	orrs	r3, r2
    8992:	b2db      	uxtb	r3, r3
    8994:	7003      	strb	r3, [r0, #0]

    if ((kOSC_ModeExt != config->workMode) && (OSC0->CR & OSC_CR_ERCLKEN_MASK))
    8996:	9b01      	ldr	r3, [sp, #4]
    8998:	795b      	ldrb	r3, [r3, #5]
    899a:	2b00      	cmp	r3, #0
    899c:	d00d      	beq.n	89ba <CLOCK_InitOsc0+0x82>
    899e:	4b09      	ldr	r3, [pc, #36]	; (89c4 <CLOCK_InitOsc0+0x8c>)
    89a0:	781b      	ldrb	r3, [r3, #0]
    89a2:	b2db      	uxtb	r3, r3
    89a4:	b25b      	sxtb	r3, r3
    89a6:	2b00      	cmp	r3, #0
    89a8:	da07      	bge.n	89ba <CLOCK_InitOsc0+0x82>
    {
        /* Wait for stable. */
        while (!(MCG->S & MCG_S_OSCINIT0_MASK))
    89aa:	bf00      	nop
    89ac:	4b07      	ldr	r3, [pc, #28]	; (89cc <CLOCK_InitOsc0+0x94>)
    89ae:	799b      	ldrb	r3, [r3, #6]
    89b0:	b2db      	uxtb	r3, r3
    89b2:	f003 0302 	and.w	r3, r3, #2
    89b6:	2b00      	cmp	r3, #0
    89b8:	d0f8      	beq.n	89ac <CLOCK_InitOsc0+0x74>
        {
        }
    }
}
    89ba:	bf00      	nop
    89bc:	b005      	add	sp, #20
    89be:	f85d fb04 	ldr.w	pc, [sp], #4
    89c2:	bf00      	nop
    89c4:	40065000 	.word	0x40065000
    89c8:	40064001 	.word	0x40064001
    89cc:	40064000 	.word	0x40064000

000089d0 <CLOCK_SetPbeMode>:

    return kStatus_Success;
}

status_t CLOCK_SetPbeMode(mcg_pll_clk_select_t pllcs, mcg_pll_config_t const *config)
{
    89d0:	b500      	push	{lr}
    89d2:	b083      	sub	sp, #12
    89d4:	4603      	mov	r3, r0
    89d6:	9100      	str	r1, [sp, #0]
    89d8:	f88d 3007 	strb.w	r3, [sp, #7]
    assert(config);
    89dc:	9b00      	ldr	r3, [sp, #0]
    89de:	2b00      	cmp	r3, #0
    89e0:	d106      	bne.n	89f0 <CLOCK_SetPbeMode+0x20>
    89e2:	4b25      	ldr	r3, [pc, #148]	; (8a78 <CLOCK_SetPbeMode+0xa8>)
    89e4:	4a25      	ldr	r2, [pc, #148]	; (8a7c <CLOCK_SetPbeMode+0xac>)
    89e6:	f240 51be 	movw	r1, #1470	; 0x5be
    89ea:	4825      	ldr	r0, [pc, #148]	; (8a80 <CLOCK_SetPbeMode+0xb0>)
    89ec:	f001 fc8a 	bl	a304 <__assert_func>

    /*
       This function is designed to change MCG to PBE mode from PEE/BLPE/FBE,
       but with this workflow, the source mode could be all modes except PEI/PBI.
     */
    __FSL_CLOCK_SECURE_BITS_CLEAR(&MCG->C2, MCG_C2_LP_MASK); /* Disable lowpower. */
    89f0:	4a24      	ldr	r2, [pc, #144]	; (8a84 <CLOCK_SetPbeMode+0xb4>)
    89f2:	4b24      	ldr	r3, [pc, #144]	; (8a84 <CLOCK_SetPbeMode+0xb4>)
    89f4:	781b      	ldrb	r3, [r3, #0]
    89f6:	b2db      	uxtb	r3, r3
    89f8:	f023 0302 	bic.w	r3, r3, #2
    89fc:	b2db      	uxtb	r3, r3
    89fe:	7013      	strb	r3, [r2, #0]

    /* Change to use external clock first. */
    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C1, MCG_C1_CLKS_MASK | MCG_C1_IREFS_MASK, MCG_C1_CLKS(kMCG_ClkOutSrcExternal));
    8a00:	4a21      	ldr	r2, [pc, #132]	; (8a88 <CLOCK_SetPbeMode+0xb8>)
    8a02:	4b21      	ldr	r3, [pc, #132]	; (8a88 <CLOCK_SetPbeMode+0xb8>)
    8a04:	781b      	ldrb	r3, [r3, #0]
    8a06:	b2db      	uxtb	r3, r3
    8a08:	f003 033b 	and.w	r3, r3, #59	; 0x3b
    8a0c:	b2db      	uxtb	r3, r3
    8a0e:	f063 037f 	orn	r3, r3, #127	; 0x7f
    8a12:	b2db      	uxtb	r3, r3
    8a14:	7013      	strb	r3, [r2, #0]

    /* Wait for CLKST clock status bits to show clock source is ext ref clk */
    while ((MCG->S & (MCG_S_IREFST_MASK | MCG_S_CLKST_MASK)) !=
    8a16:	bf00      	nop
    8a18:	4b1b      	ldr	r3, [pc, #108]	; (8a88 <CLOCK_SetPbeMode+0xb8>)
    8a1a:	799b      	ldrb	r3, [r3, #6]
    8a1c:	b2db      	uxtb	r3, r3
    8a1e:	f003 031c 	and.w	r3, r3, #28
    8a22:	2b08      	cmp	r3, #8
    8a24:	d1f8      	bne.n	8a18 <CLOCK_SetPbeMode+0x48>
           (MCG_S_IREFST(kMCG_FllSrcExternal) | MCG_S_CLKST(kMCG_ClkOutStatExt)))
    {
    }

    /* Disable PLL first, then configure PLL. */
    __FSL_CLOCK_SECURE_BITS_CLEAR(&MCG->C6, MCG_C6_PLLS_MASK);
    8a26:	4a19      	ldr	r2, [pc, #100]	; (8a8c <CLOCK_SetPbeMode+0xbc>)
    8a28:	4b18      	ldr	r3, [pc, #96]	; (8a8c <CLOCK_SetPbeMode+0xbc>)
    8a2a:	781b      	ldrb	r3, [r3, #0]
    8a2c:	b2db      	uxtb	r3, r3
    8a2e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    8a32:	b2db      	uxtb	r3, r3
    8a34:	7013      	strb	r3, [r2, #0]
    while (MCG->S & MCG_S_PLLST_MASK)
    8a36:	bf00      	nop
    8a38:	4b13      	ldr	r3, [pc, #76]	; (8a88 <CLOCK_SetPbeMode+0xb8>)
    8a3a:	799b      	ldrb	r3, [r3, #6]
    8a3c:	b2db      	uxtb	r3, r3
    8a3e:	f003 0320 	and.w	r3, r3, #32
    8a42:	2b00      	cmp	r3, #0
    8a44:	d1f8      	bne.n	8a38 <CLOCK_SetPbeMode+0x68>
    {
    }

    /* Configure the PLL. */
    {
        CLOCK_EnablePll0(config);
    8a46:	9800      	ldr	r0, [sp, #0]
    8a48:	f7ff ff24 	bl	8894 <CLOCK_EnablePll0>
    }

    /* Change to PLL mode. */
    __FSL_CLOCK_SECURE_BITS_SET(&MCG->C6, MCG_C6_PLLS_MASK);
    8a4c:	4a0f      	ldr	r2, [pc, #60]	; (8a8c <CLOCK_SetPbeMode+0xbc>)
    8a4e:	4b0f      	ldr	r3, [pc, #60]	; (8a8c <CLOCK_SetPbeMode+0xbc>)
    8a50:	781b      	ldrb	r3, [r3, #0]
    8a52:	b2db      	uxtb	r3, r3
    8a54:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    8a58:	b2db      	uxtb	r3, r3
    8a5a:	7013      	strb	r3, [r2, #0]

    /* Wait for PLL mode changed. */
    while (!(MCG->S & MCG_S_PLLST_MASK))
    8a5c:	bf00      	nop
    8a5e:	4b0a      	ldr	r3, [pc, #40]	; (8a88 <CLOCK_SetPbeMode+0xb8>)
    8a60:	799b      	ldrb	r3, [r3, #6]
    8a62:	b2db      	uxtb	r3, r3
    8a64:	f003 0320 	and.w	r3, r3, #32
    8a68:	2b00      	cmp	r3, #0
    8a6a:	d0f8      	beq.n	8a5e <CLOCK_SetPbeMode+0x8e>
    {
    }

    return kStatus_Success;
    8a6c:	2300      	movs	r3, #0
}
    8a6e:	4618      	mov	r0, r3
    8a70:	b003      	add	sp, #12
    8a72:	f85d fb04 	ldr.w	pc, [sp], #4
    8a76:	bf00      	nop
    8a78:	00011574 	.word	0x00011574
    8a7c:	000127b0 	.word	0x000127b0
    8a80:	000114f8 	.word	0x000114f8
    8a84:	40064001 	.word	0x40064001
    8a88:	40064000 	.word	0x40064000
    8a8c:	40064005 	.word	0x40064005

00008a90 <CLOCK_BootToPeeMode>:

    return kStatus_Success;
}

status_t CLOCK_BootToPeeMode(mcg_oscsel_t oscsel, mcg_pll_clk_select_t pllcs, mcg_pll_config_t const *config)
{
    8a90:	b500      	push	{lr}
    8a92:	b083      	sub	sp, #12
    8a94:	4603      	mov	r3, r0
    8a96:	9200      	str	r2, [sp, #0]
    8a98:	f88d 3007 	strb.w	r3, [sp, #7]
    8a9c:	460b      	mov	r3, r1
    8a9e:	f88d 3006 	strb.w	r3, [sp, #6]
    assert(config);
    8aa2:	9b00      	ldr	r3, [sp, #0]
    8aa4:	2b00      	cmp	r3, #0
    8aa6:	d106      	bne.n	8ab6 <CLOCK_BootToPeeMode+0x26>
    8aa8:	4b13      	ldr	r3, [pc, #76]	; (8af8 <CLOCK_BootToPeeMode+0x68>)
    8aaa:	4a14      	ldr	r2, [pc, #80]	; (8afc <CLOCK_BootToPeeMode+0x6c>)
    8aac:	f240 615d 	movw	r1, #1629	; 0x65d
    8ab0:	4813      	ldr	r0, [pc, #76]	; (8b00 <CLOCK_BootToPeeMode+0x70>)
    8ab2:	f001 fc27 	bl	a304 <__assert_func>

    CLOCK_SetExternalRefClkConfig(oscsel);
    8ab6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8aba:	4618      	mov	r0, r3
    8abc:	f7ff fe0a 	bl	86d4 <CLOCK_SetExternalRefClkConfig>

    CLOCK_SetPbeMode(pllcs, config);
    8ac0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8ac4:	9900      	ldr	r1, [sp, #0]
    8ac6:	4618      	mov	r0, r3
    8ac8:	f7ff ff82 	bl	89d0 <CLOCK_SetPbeMode>

    /* Change to use PLL output clock. */
    __FSL_CLOCK_SECURE_BITS_SET_VALUE(&MCG->C1, MCG_C1_CLKS_MASK, MCG_C1_CLKS(kMCG_ClkOutSrcOut));
    8acc:	4a0d      	ldr	r2, [pc, #52]	; (8b04 <CLOCK_BootToPeeMode+0x74>)
    8ace:	4b0d      	ldr	r3, [pc, #52]	; (8b04 <CLOCK_BootToPeeMode+0x74>)
    8ad0:	781b      	ldrb	r3, [r3, #0]
    8ad2:	b2db      	uxtb	r3, r3
    8ad4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    8ad8:	b2db      	uxtb	r3, r3
    8ada:	7013      	strb	r3, [r2, #0]
    while (MCG_S_CLKST_VAL != kMCG_ClkOutStatPll)
    8adc:	bf00      	nop
    8ade:	4b09      	ldr	r3, [pc, #36]	; (8b04 <CLOCK_BootToPeeMode+0x74>)
    8ae0:	799b      	ldrb	r3, [r3, #6]
    8ae2:	b2db      	uxtb	r3, r3
    8ae4:	089b      	lsrs	r3, r3, #2
    8ae6:	f003 0303 	and.w	r3, r3, #3
    8aea:	2b03      	cmp	r3, #3
    8aec:	d1f7      	bne.n	8ade <CLOCK_BootToPeeMode+0x4e>
    {
    }

    return kStatus_Success;
    8aee:	2300      	movs	r3, #0
}
    8af0:	4618      	mov	r0, r3
    8af2:	b003      	add	sp, #12
    8af4:	f85d fb04 	ldr.w	pc, [sp], #4
    8af8:	00011574 	.word	0x00011574
    8afc:	000127c4 	.word	0x000127c4
    8b00:	000114f8 	.word	0x000114f8
    8b04:	40064000 	.word	0x40064000

00008b08 <DSPI_IsMaster>:
 *
 * @param base DSPI peripheral address.
 * @return Returns true if the module is in master mode or false if the module is in slave mode.
 */
static inline bool DSPI_IsMaster(SPI_Type *base)
{
    8b08:	b082      	sub	sp, #8
    8b0a:	9001      	str	r0, [sp, #4]
    return (bool)((base->MCR) & SPI_MCR_MSTR_MASK);
    8b0c:	9b01      	ldr	r3, [sp, #4]
    8b0e:	681b      	ldr	r3, [r3, #0]
    8b10:	0fdb      	lsrs	r3, r3, #31
    8b12:	b2db      	uxtb	r3, r3
}
    8b14:	4618      	mov	r0, r3
    8b16:	b002      	add	sp, #8
    8b18:	4770      	bx	lr
	...

00008b1c <DSPI_CommonIRQHandler>:
        handle->errorCount++;
    }
}

static void DSPI_CommonIRQHandler(SPI_Type *base, void *param)
{
    8b1c:	b500      	push	{lr}
    8b1e:	b083      	sub	sp, #12
    8b20:	9001      	str	r0, [sp, #4]
    8b22:	9100      	str	r1, [sp, #0]
    if (DSPI_IsMaster(base))
    8b24:	9801      	ldr	r0, [sp, #4]
    8b26:	f7ff ffef 	bl	8b08 <DSPI_IsMaster>
    8b2a:	4603      	mov	r3, r0
    8b2c:	2b00      	cmp	r3, #0
    8b2e:	d005      	beq.n	8b3c <DSPI_CommonIRQHandler+0x20>
    {
        s_dspiMasterIsr(base, (dspi_master_handle_t *)param);
    8b30:	4b07      	ldr	r3, [pc, #28]	; (8b50 <DSPI_CommonIRQHandler+0x34>)
    8b32:	681b      	ldr	r3, [r3, #0]
    8b34:	9900      	ldr	r1, [sp, #0]
    8b36:	9801      	ldr	r0, [sp, #4]
    8b38:	4798      	blx	r3
    }
    else
    {
        s_dspiSlaveIsr(base, (dspi_slave_handle_t *)param);
    }
}
    8b3a:	e004      	b.n	8b46 <DSPI_CommonIRQHandler+0x2a>
        s_dspiSlaveIsr(base, (dspi_slave_handle_t *)param);
    8b3c:	4b05      	ldr	r3, [pc, #20]	; (8b54 <DSPI_CommonIRQHandler+0x38>)
    8b3e:	681b      	ldr	r3, [r3, #0]
    8b40:	9900      	ldr	r1, [sp, #0]
    8b42:	9801      	ldr	r0, [sp, #4]
    8b44:	4798      	blx	r3
}
    8b46:	bf00      	nop
    8b48:	b003      	add	sp, #12
    8b4a:	f85d fb04 	ldr.w	pc, [sp], #4
    8b4e:	bf00      	nop
    8b50:	20001498 	.word	0x20001498
    8b54:	2000149c 	.word	0x2000149c

00008b58 <SPI0_DriverIRQHandler>:

#if defined(SPI0)
void SPI0_DriverIRQHandler(void)
{
    8b58:	b508      	push	{r3, lr}
    assert(g_dspiHandle[0]);
    8b5a:	4b09      	ldr	r3, [pc, #36]	; (8b80 <SPI0_DriverIRQHandler+0x28>)
    8b5c:	681b      	ldr	r3, [r3, #0]
    8b5e:	2b00      	cmp	r3, #0
    8b60:	d106      	bne.n	8b70 <SPI0_DriverIRQHandler+0x18>
    8b62:	4b08      	ldr	r3, [pc, #32]	; (8b84 <SPI0_DriverIRQHandler+0x2c>)
    8b64:	4a08      	ldr	r2, [pc, #32]	; (8b88 <SPI0_DriverIRQHandler+0x30>)
    8b66:	f240 6161 	movw	r1, #1633	; 0x661
    8b6a:	4808      	ldr	r0, [pc, #32]	; (8b8c <SPI0_DriverIRQHandler+0x34>)
    8b6c:	f001 fbca 	bl	a304 <__assert_func>
    DSPI_CommonIRQHandler(SPI0, g_dspiHandle[0]);
    8b70:	4b03      	ldr	r3, [pc, #12]	; (8b80 <SPI0_DriverIRQHandler+0x28>)
    8b72:	681b      	ldr	r3, [r3, #0]
    8b74:	4619      	mov	r1, r3
    8b76:	4806      	ldr	r0, [pc, #24]	; (8b90 <SPI0_DriverIRQHandler+0x38>)
    8b78:	f7ff ffd0 	bl	8b1c <DSPI_CommonIRQHandler>
}
    8b7c:	bf00      	nop
    8b7e:	bd08      	pop	{r3, pc}
    8b80:	2000148c 	.word	0x2000148c
    8b84:	00011640 	.word	0x00011640
    8b88:	000127d8 	.word	0x000127d8
    8b8c:	000115a0 	.word	0x000115a0
    8b90:	4002c000 	.word	0x4002c000

00008b94 <SPI1_DriverIRQHandler>:
#endif

#if defined(SPI1)
void SPI1_DriverIRQHandler(void)
{
    8b94:	b508      	push	{r3, lr}
    assert(g_dspiHandle[1]);
    8b96:	4b09      	ldr	r3, [pc, #36]	; (8bbc <SPI1_DriverIRQHandler+0x28>)
    8b98:	685b      	ldr	r3, [r3, #4]
    8b9a:	2b00      	cmp	r3, #0
    8b9c:	d106      	bne.n	8bac <SPI1_DriverIRQHandler+0x18>
    8b9e:	4b08      	ldr	r3, [pc, #32]	; (8bc0 <SPI1_DriverIRQHandler+0x2c>)
    8ba0:	4a08      	ldr	r2, [pc, #32]	; (8bc4 <SPI1_DriverIRQHandler+0x30>)
    8ba2:	f240 6169 	movw	r1, #1641	; 0x669
    8ba6:	4808      	ldr	r0, [pc, #32]	; (8bc8 <SPI1_DriverIRQHandler+0x34>)
    8ba8:	f001 fbac 	bl	a304 <__assert_func>
    DSPI_CommonIRQHandler(SPI1, g_dspiHandle[1]);
    8bac:	4b03      	ldr	r3, [pc, #12]	; (8bbc <SPI1_DriverIRQHandler+0x28>)
    8bae:	685b      	ldr	r3, [r3, #4]
    8bb0:	4619      	mov	r1, r3
    8bb2:	4806      	ldr	r0, [pc, #24]	; (8bcc <SPI1_DriverIRQHandler+0x38>)
    8bb4:	f7ff ffb2 	bl	8b1c <DSPI_CommonIRQHandler>
}
    8bb8:	bf00      	nop
    8bba:	bd08      	pop	{r3, pc}
    8bbc:	2000148c 	.word	0x2000148c
    8bc0:	00011650 	.word	0x00011650
    8bc4:	000127f0 	.word	0x000127f0
    8bc8:	000115a0 	.word	0x000115a0
    8bcc:	4002d000 	.word	0x4002d000

00008bd0 <SPI2_DriverIRQHandler>:
#endif

#if defined(SPI2)
void SPI2_DriverIRQHandler(void)
{
    8bd0:	b508      	push	{r3, lr}
    assert(g_dspiHandle[2]);
    8bd2:	4b09      	ldr	r3, [pc, #36]	; (8bf8 <SPI2_DriverIRQHandler+0x28>)
    8bd4:	689b      	ldr	r3, [r3, #8]
    8bd6:	2b00      	cmp	r3, #0
    8bd8:	d106      	bne.n	8be8 <SPI2_DriverIRQHandler+0x18>
    8bda:	4b08      	ldr	r3, [pc, #32]	; (8bfc <SPI2_DriverIRQHandler+0x2c>)
    8bdc:	4a08      	ldr	r2, [pc, #32]	; (8c00 <SPI2_DriverIRQHandler+0x30>)
    8bde:	f240 6171 	movw	r1, #1649	; 0x671
    8be2:	4808      	ldr	r0, [pc, #32]	; (8c04 <SPI2_DriverIRQHandler+0x34>)
    8be4:	f001 fb8e 	bl	a304 <__assert_func>
    DSPI_CommonIRQHandler(SPI2, g_dspiHandle[2]);
    8be8:	4b03      	ldr	r3, [pc, #12]	; (8bf8 <SPI2_DriverIRQHandler+0x28>)
    8bea:	689b      	ldr	r3, [r3, #8]
    8bec:	4619      	mov	r1, r3
    8bee:	4806      	ldr	r0, [pc, #24]	; (8c08 <SPI2_DriverIRQHandler+0x38>)
    8bf0:	f7ff ff94 	bl	8b1c <DSPI_CommonIRQHandler>
}
    8bf4:	bf00      	nop
    8bf6:	bd08      	pop	{r3, pc}
    8bf8:	2000148c 	.word	0x2000148c
    8bfc:	00011660 	.word	0x00011660
    8c00:	00012808 	.word	0x00012808
    8c04:	000115a0 	.word	0x000115a0
    8c08:	400ac000 	.word	0x400ac000

00008c0c <EDMA_HandleIRQ>:
    /* Cancel all next TCD transfer. */
    handle->base->TCD[handle->channel].DLAST_SGA = 0;
}

void EDMA_HandleIRQ(edma_handle_t *handle)
{
    8c0c:	b510      	push	{r4, lr}
    8c0e:	b088      	sub	sp, #32
    8c10:	9001      	str	r0, [sp, #4]
    assert(handle != NULL);
    8c12:	9b01      	ldr	r3, [sp, #4]
    8c14:	2b00      	cmp	r3, #0
    8c16:	d106      	bne.n	8c26 <EDMA_HandleIRQ+0x1a>
    8c18:	4b51      	ldr	r3, [pc, #324]	; (8d60 <EDMA_HandleIRQ+0x154>)
    8c1a:	4a52      	ldr	r2, [pc, #328]	; (8d64 <EDMA_HandleIRQ+0x158>)
    8c1c:	f240 313a 	movw	r1, #826	; 0x33a
    8c20:	4851      	ldr	r0, [pc, #324]	; (8d68 <EDMA_HandleIRQ+0x15c>)
    8c22:	f001 fb6f 	bl	a304 <__assert_func>

    /* Clear EDMA interrupt flag */
    handle->base->CINT = handle->channel;
    8c26:	9b01      	ldr	r3, [sp, #4]
    8c28:	689b      	ldr	r3, [r3, #8]
    8c2a:	9a01      	ldr	r2, [sp, #4]
    8c2c:	7c12      	ldrb	r2, [r2, #16]
    8c2e:	77da      	strb	r2, [r3, #31]
    if ((handle->tcdPool == NULL) && (handle->callback != NULL))
    8c30:	9b01      	ldr	r3, [sp, #4]
    8c32:	68db      	ldr	r3, [r3, #12]
    8c34:	2b00      	cmp	r3, #0
    8c36:	d10c      	bne.n	8c52 <EDMA_HandleIRQ+0x46>
    8c38:	9b01      	ldr	r3, [sp, #4]
    8c3a:	681b      	ldr	r3, [r3, #0]
    8c3c:	2b00      	cmp	r3, #0
    8c3e:	d008      	beq.n	8c52 <EDMA_HandleIRQ+0x46>
    {
        (handle->callback)(handle, handle->userData, true, 0);
    8c40:	9b01      	ldr	r3, [sp, #4]
    8c42:	681c      	ldr	r4, [r3, #0]
    8c44:	9b01      	ldr	r3, [sp, #4]
    8c46:	6859      	ldr	r1, [r3, #4]
    8c48:	2300      	movs	r3, #0
    8c4a:	2201      	movs	r2, #1
    8c4c:	9801      	ldr	r0, [sp, #4]
    8c4e:	47a0      	blx	r4
        if (handle->callback)
        {
            (handle->callback)(handle, handle->userData, transfer_done, tcds_done);
        }
    }
}
    8c50:	e082      	b.n	8d58 <EDMA_HandleIRQ+0x14c>
        uint32_t sga = handle->base->TCD[handle->channel].DLAST_SGA;
    8c52:	9b01      	ldr	r3, [sp, #4]
    8c54:	689a      	ldr	r2, [r3, #8]
    8c56:	9b01      	ldr	r3, [sp, #4]
    8c58:	7c1b      	ldrb	r3, [r3, #16]
    8c5a:	015b      	lsls	r3, r3, #5
    8c5c:	4413      	add	r3, r2
    8c5e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    8c62:	3318      	adds	r3, #24
    8c64:	681b      	ldr	r3, [r3, #0]
    8c66:	9305      	str	r3, [sp, #20]
        transfer_done = ((handle->base->TCD[handle->channel].CSR & DMA_CSR_DONE_MASK) != 0);
    8c68:	9b01      	ldr	r3, [sp, #4]
    8c6a:	689a      	ldr	r2, [r3, #8]
    8c6c:	9b01      	ldr	r3, [sp, #4]
    8c6e:	7c1b      	ldrb	r3, [r3, #16]
    8c70:	015b      	lsls	r3, r3, #5
    8c72:	4413      	add	r3, r2
    8c74:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    8c78:	331c      	adds	r3, #28
    8c7a:	881b      	ldrh	r3, [r3, #0]
    8c7c:	b29b      	uxth	r3, r3
    8c7e:	f003 0380 	and.w	r3, r3, #128	; 0x80
    8c82:	2b00      	cmp	r3, #0
    8c84:	bf14      	ite	ne
    8c86:	2301      	movne	r3, #1
    8c88:	2300      	moveq	r3, #0
    8c8a:	f88d 3013 	strb.w	r3, [sp, #19]
        sga -= (uint32_t)handle->tcdPool;
    8c8e:	9b01      	ldr	r3, [sp, #4]
    8c90:	68db      	ldr	r3, [r3, #12]
    8c92:	461a      	mov	r2, r3
    8c94:	9b05      	ldr	r3, [sp, #20]
    8c96:	1a9b      	subs	r3, r3, r2
    8c98:	9305      	str	r3, [sp, #20]
        sga_index = sga / sizeof(edma_tcd_t);
    8c9a:	9b05      	ldr	r3, [sp, #20]
    8c9c:	095b      	lsrs	r3, r3, #5
    8c9e:	9303      	str	r3, [sp, #12]
        if (transfer_done)
    8ca0:	f89d 3013 	ldrb.w	r3, [sp, #19]
    8ca4:	2b00      	cmp	r3, #0
    8ca6:	d003      	beq.n	8cb0 <EDMA_HandleIRQ+0xa4>
            new_header = sga_index;
    8ca8:	9b03      	ldr	r3, [sp, #12]
    8caa:	f88d 301b 	strb.w	r3, [sp, #27]
    8cae:	e00f      	b.n	8cd0 <EDMA_HandleIRQ+0xc4>
            new_header = sga_index ? sga_index - 1U : handle->tcdSize - 1U;
    8cb0:	9b03      	ldr	r3, [sp, #12]
    8cb2:	2b00      	cmp	r3, #0
    8cb4:	d004      	beq.n	8cc0 <EDMA_HandleIRQ+0xb4>
    8cb6:	9b03      	ldr	r3, [sp, #12]
    8cb8:	b2db      	uxtb	r3, r3
    8cba:	3b01      	subs	r3, #1
    8cbc:	b2db      	uxtb	r3, r3
    8cbe:	e005      	b.n	8ccc <EDMA_HandleIRQ+0xc0>
    8cc0:	9b01      	ldr	r3, [sp, #4]
    8cc2:	7d1b      	ldrb	r3, [r3, #20]
    8cc4:	b25b      	sxtb	r3, r3
    8cc6:	b2db      	uxtb	r3, r3
    8cc8:	3b01      	subs	r3, #1
    8cca:	b2db      	uxtb	r3, r3
    8ccc:	f88d 301b 	strb.w	r3, [sp, #27]
        if (new_header == handle->header)
    8cd0:	f89d 301b 	ldrb.w	r3, [sp, #27]
    8cd4:	9a01      	ldr	r2, [sp, #4]
    8cd6:	7c52      	ldrb	r2, [r2, #17]
    8cd8:	b252      	sxtb	r2, r2
    8cda:	4293      	cmp	r3, r2
    8cdc:	d10f      	bne.n	8cfe <EDMA_HandleIRQ+0xf2>
            if (handle->tcdUsed == handle->tcdSize)
    8cde:	9b01      	ldr	r3, [sp, #4]
    8ce0:	7cdb      	ldrb	r3, [r3, #19]
    8ce2:	b25a      	sxtb	r2, r3
    8ce4:	9b01      	ldr	r3, [sp, #4]
    8ce6:	7d1b      	ldrb	r3, [r3, #20]
    8ce8:	b25b      	sxtb	r3, r3
    8cea:	429a      	cmp	r2, r3
    8cec:	d104      	bne.n	8cf8 <EDMA_HandleIRQ+0xec>
                tcds_done = handle->tcdUsed;
    8cee:	9b01      	ldr	r3, [sp, #4]
    8cf0:	7cdb      	ldrb	r3, [r3, #19]
    8cf2:	b25b      	sxtb	r3, r3
    8cf4:	9307      	str	r3, [sp, #28]
    8cf6:	e013      	b.n	8d20 <EDMA_HandleIRQ+0x114>
                tcds_done = 0;
    8cf8:	2300      	movs	r3, #0
    8cfa:	9307      	str	r3, [sp, #28]
    8cfc:	e010      	b.n	8d20 <EDMA_HandleIRQ+0x114>
            tcds_done = new_header - handle->header;
    8cfe:	f89d 301b 	ldrb.w	r3, [sp, #27]
    8d02:	9a01      	ldr	r2, [sp, #4]
    8d04:	7c52      	ldrb	r2, [r2, #17]
    8d06:	b252      	sxtb	r2, r2
    8d08:	1a9b      	subs	r3, r3, r2
    8d0a:	9307      	str	r3, [sp, #28]
            if (tcds_done < 0)
    8d0c:	9b07      	ldr	r3, [sp, #28]
    8d0e:	2b00      	cmp	r3, #0
    8d10:	da06      	bge.n	8d20 <EDMA_HandleIRQ+0x114>
                tcds_done += handle->tcdSize;
    8d12:	9b01      	ldr	r3, [sp, #4]
    8d14:	7d1b      	ldrb	r3, [r3, #20]
    8d16:	b25b      	sxtb	r3, r3
    8d18:	461a      	mov	r2, r3
    8d1a:	9b07      	ldr	r3, [sp, #28]
    8d1c:	4413      	add	r3, r2
    8d1e:	9307      	str	r3, [sp, #28]
        handle->header = new_header;
    8d20:	f99d 201b 	ldrsb.w	r2, [sp, #27]
    8d24:	9b01      	ldr	r3, [sp, #4]
    8d26:	745a      	strb	r2, [r3, #17]
        handle->tcdUsed -= tcds_done;
    8d28:	9b01      	ldr	r3, [sp, #4]
    8d2a:	7cdb      	ldrb	r3, [r3, #19]
    8d2c:	b25b      	sxtb	r3, r3
    8d2e:	b2da      	uxtb	r2, r3
    8d30:	9b07      	ldr	r3, [sp, #28]
    8d32:	b2db      	uxtb	r3, r3
    8d34:	1ad3      	subs	r3, r2, r3
    8d36:	b2db      	uxtb	r3, r3
    8d38:	b25a      	sxtb	r2, r3
    8d3a:	9b01      	ldr	r3, [sp, #4]
    8d3c:	74da      	strb	r2, [r3, #19]
        if (handle->callback)
    8d3e:	9b01      	ldr	r3, [sp, #4]
    8d40:	681b      	ldr	r3, [r3, #0]
    8d42:	2b00      	cmp	r3, #0
    8d44:	d008      	beq.n	8d58 <EDMA_HandleIRQ+0x14c>
            (handle->callback)(handle, handle->userData, transfer_done, tcds_done);
    8d46:	9b01      	ldr	r3, [sp, #4]
    8d48:	681c      	ldr	r4, [r3, #0]
    8d4a:	9b01      	ldr	r3, [sp, #4]
    8d4c:	6859      	ldr	r1, [r3, #4]
    8d4e:	9b07      	ldr	r3, [sp, #28]
    8d50:	f89d 2013 	ldrb.w	r2, [sp, #19]
    8d54:	9801      	ldr	r0, [sp, #4]
    8d56:	47a0      	blx	r4
}
    8d58:	bf00      	nop
    8d5a:	b008      	add	sp, #32
    8d5c:	bd10      	pop	{r4, pc}
    8d5e:	bf00      	nop
    8d60:	000117b4 	.word	0x000117b4
    8d64:	00012820 	.word	0x00012820
    8d68:	00011698 	.word	0x00011698

00008d6c <DMA0_DriverIRQHandler>:

/* 4 channels (No Shared): kv10  */
#if defined(FSL_FEATURE_EDMA_MODULE_CHANNEL) && FSL_FEATURE_EDMA_MODULE_CHANNEL > 0

void DMA0_DriverIRQHandler(void)
{
    8d6c:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[0]);
    8d6e:	4b03      	ldr	r3, [pc, #12]	; (8d7c <DMA0_DriverIRQHandler+0x10>)
    8d70:	681b      	ldr	r3, [r3, #0]
    8d72:	4618      	mov	r0, r3
    8d74:	f7ff ff4a 	bl	8c0c <EDMA_HandleIRQ>
}
    8d78:	bf00      	nop
    8d7a:	bd08      	pop	{r3, pc}
    8d7c:	200014a0 	.word	0x200014a0

00008d80 <DMA1_DriverIRQHandler>:

void DMA1_DriverIRQHandler(void)
{
    8d80:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[1]);
    8d82:	4b03      	ldr	r3, [pc, #12]	; (8d90 <DMA1_DriverIRQHandler+0x10>)
    8d84:	685b      	ldr	r3, [r3, #4]
    8d86:	4618      	mov	r0, r3
    8d88:	f7ff ff40 	bl	8c0c <EDMA_HandleIRQ>
}
    8d8c:	bf00      	nop
    8d8e:	bd08      	pop	{r3, pc}
    8d90:	200014a0 	.word	0x200014a0

00008d94 <DMA2_DriverIRQHandler>:

void DMA2_DriverIRQHandler(void)
{
    8d94:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[2]);
    8d96:	4b03      	ldr	r3, [pc, #12]	; (8da4 <DMA2_DriverIRQHandler+0x10>)
    8d98:	689b      	ldr	r3, [r3, #8]
    8d9a:	4618      	mov	r0, r3
    8d9c:	f7ff ff36 	bl	8c0c <EDMA_HandleIRQ>
}
    8da0:	bf00      	nop
    8da2:	bd08      	pop	{r3, pc}
    8da4:	200014a0 	.word	0x200014a0

00008da8 <DMA3_DriverIRQHandler>:

void DMA3_DriverIRQHandler(void)
{
    8da8:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[3]);
    8daa:	4b03      	ldr	r3, [pc, #12]	; (8db8 <DMA3_DriverIRQHandler+0x10>)
    8dac:	68db      	ldr	r3, [r3, #12]
    8dae:	4618      	mov	r0, r3
    8db0:	f7ff ff2c 	bl	8c0c <EDMA_HandleIRQ>
}
    8db4:	bf00      	nop
    8db6:	bd08      	pop	{r3, pc}
    8db8:	200014a0 	.word	0x200014a0

00008dbc <DMA4_DriverIRQHandler>:

/* 8 channels (No Shared) */
#if defined(FSL_FEATURE_EDMA_MODULE_CHANNEL) && FSL_FEATURE_EDMA_MODULE_CHANNEL > 4U

void DMA4_DriverIRQHandler(void)
{
    8dbc:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[4]);
    8dbe:	4b03      	ldr	r3, [pc, #12]	; (8dcc <DMA4_DriverIRQHandler+0x10>)
    8dc0:	691b      	ldr	r3, [r3, #16]
    8dc2:	4618      	mov	r0, r3
    8dc4:	f7ff ff22 	bl	8c0c <EDMA_HandleIRQ>
}
    8dc8:	bf00      	nop
    8dca:	bd08      	pop	{r3, pc}
    8dcc:	200014a0 	.word	0x200014a0

00008dd0 <DMA5_DriverIRQHandler>:

void DMA5_DriverIRQHandler(void)
{
    8dd0:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[5]);
    8dd2:	4b03      	ldr	r3, [pc, #12]	; (8de0 <DMA5_DriverIRQHandler+0x10>)
    8dd4:	695b      	ldr	r3, [r3, #20]
    8dd6:	4618      	mov	r0, r3
    8dd8:	f7ff ff18 	bl	8c0c <EDMA_HandleIRQ>
}
    8ddc:	bf00      	nop
    8dde:	bd08      	pop	{r3, pc}
    8de0:	200014a0 	.word	0x200014a0

00008de4 <DMA6_DriverIRQHandler>:

void DMA6_DriverIRQHandler(void)
{
    8de4:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[6]);
    8de6:	4b03      	ldr	r3, [pc, #12]	; (8df4 <DMA6_DriverIRQHandler+0x10>)
    8de8:	699b      	ldr	r3, [r3, #24]
    8dea:	4618      	mov	r0, r3
    8dec:	f7ff ff0e 	bl	8c0c <EDMA_HandleIRQ>
}
    8df0:	bf00      	nop
    8df2:	bd08      	pop	{r3, pc}
    8df4:	200014a0 	.word	0x200014a0

00008df8 <DMA7_DriverIRQHandler>:

void DMA7_DriverIRQHandler(void)
{
    8df8:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[7]);
    8dfa:	4b03      	ldr	r3, [pc, #12]	; (8e08 <DMA7_DriverIRQHandler+0x10>)
    8dfc:	69db      	ldr	r3, [r3, #28]
    8dfe:	4618      	mov	r0, r3
    8e00:	f7ff ff04 	bl	8c0c <EDMA_HandleIRQ>
}
    8e04:	bf00      	nop
    8e06:	bd08      	pop	{r3, pc}
    8e08:	200014a0 	.word	0x200014a0

00008e0c <DMA8_DriverIRQHandler>:

/* 16 channels (No Shared) */
#if defined(FSL_FEATURE_EDMA_MODULE_CHANNEL) && FSL_FEATURE_EDMA_MODULE_CHANNEL > 8U

void DMA8_DriverIRQHandler(void)
{
    8e0c:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[8]);
    8e0e:	4b03      	ldr	r3, [pc, #12]	; (8e1c <DMA8_DriverIRQHandler+0x10>)
    8e10:	6a1b      	ldr	r3, [r3, #32]
    8e12:	4618      	mov	r0, r3
    8e14:	f7ff fefa 	bl	8c0c <EDMA_HandleIRQ>
}
    8e18:	bf00      	nop
    8e1a:	bd08      	pop	{r3, pc}
    8e1c:	200014a0 	.word	0x200014a0

00008e20 <DMA9_DriverIRQHandler>:

void DMA9_DriverIRQHandler(void)
{
    8e20:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[9]);
    8e22:	4b03      	ldr	r3, [pc, #12]	; (8e30 <DMA9_DriverIRQHandler+0x10>)
    8e24:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8e26:	4618      	mov	r0, r3
    8e28:	f7ff fef0 	bl	8c0c <EDMA_HandleIRQ>
}
    8e2c:	bf00      	nop
    8e2e:	bd08      	pop	{r3, pc}
    8e30:	200014a0 	.word	0x200014a0

00008e34 <DMA10_DriverIRQHandler>:

void DMA10_DriverIRQHandler(void)
{
    8e34:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[10]);
    8e36:	4b03      	ldr	r3, [pc, #12]	; (8e44 <DMA10_DriverIRQHandler+0x10>)
    8e38:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    8e3a:	4618      	mov	r0, r3
    8e3c:	f7ff fee6 	bl	8c0c <EDMA_HandleIRQ>
}
    8e40:	bf00      	nop
    8e42:	bd08      	pop	{r3, pc}
    8e44:	200014a0 	.word	0x200014a0

00008e48 <DMA11_DriverIRQHandler>:

void DMA11_DriverIRQHandler(void)
{
    8e48:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[11]);
    8e4a:	4b03      	ldr	r3, [pc, #12]	; (8e58 <DMA11_DriverIRQHandler+0x10>)
    8e4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    8e4e:	4618      	mov	r0, r3
    8e50:	f7ff fedc 	bl	8c0c <EDMA_HandleIRQ>
}
    8e54:	bf00      	nop
    8e56:	bd08      	pop	{r3, pc}
    8e58:	200014a0 	.word	0x200014a0

00008e5c <DMA12_DriverIRQHandler>:

void DMA12_DriverIRQHandler(void)
{
    8e5c:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[12]);
    8e5e:	4b03      	ldr	r3, [pc, #12]	; (8e6c <DMA12_DriverIRQHandler+0x10>)
    8e60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    8e62:	4618      	mov	r0, r3
    8e64:	f7ff fed2 	bl	8c0c <EDMA_HandleIRQ>
}
    8e68:	bf00      	nop
    8e6a:	bd08      	pop	{r3, pc}
    8e6c:	200014a0 	.word	0x200014a0

00008e70 <DMA13_DriverIRQHandler>:

void DMA13_DriverIRQHandler(void)
{
    8e70:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[13]);
    8e72:	4b03      	ldr	r3, [pc, #12]	; (8e80 <DMA13_DriverIRQHandler+0x10>)
    8e74:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    8e76:	4618      	mov	r0, r3
    8e78:	f7ff fec8 	bl	8c0c <EDMA_HandleIRQ>
}
    8e7c:	bf00      	nop
    8e7e:	bd08      	pop	{r3, pc}
    8e80:	200014a0 	.word	0x200014a0

00008e84 <DMA14_DriverIRQHandler>:

void DMA14_DriverIRQHandler(void)
{
    8e84:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[14]);
    8e86:	4b03      	ldr	r3, [pc, #12]	; (8e94 <DMA14_DriverIRQHandler+0x10>)
    8e88:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    8e8a:	4618      	mov	r0, r3
    8e8c:	f7ff febe 	bl	8c0c <EDMA_HandleIRQ>
}
    8e90:	bf00      	nop
    8e92:	bd08      	pop	{r3, pc}
    8e94:	200014a0 	.word	0x200014a0

00008e98 <DMA15_DriverIRQHandler>:

void DMA15_DriverIRQHandler(void)
{
    8e98:	b508      	push	{r3, lr}
    EDMA_HandleIRQ(s_EDMAHandle[15]);
    8e9a:	4b03      	ldr	r3, [pc, #12]	; (8ea8 <DMA15_DriverIRQHandler+0x10>)
    8e9c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    8e9e:	4618      	mov	r0, r3
    8ea0:	f7ff feb4 	bl	8c0c <EDMA_HandleIRQ>
}
    8ea4:	bf00      	nop
    8ea6:	bd08      	pop	{r3, pc}
    8ea8:	200014a0 	.word	0x200014a0

00008eac <ENET_Transmit_IRQHandler>:
    ENET_Ptp1588TimerIRQHandler(ENET, s_ENETHandle[0]);
}
#endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */

void ENET_Transmit_IRQHandler(void)
{
    8eac:	b508      	push	{r3, lr}
    s_enetTxIsr(ENET, s_ENETHandle[0]);
    8eae:	4b04      	ldr	r3, [pc, #16]	; (8ec0 <ENET_Transmit_IRQHandler+0x14>)
    8eb0:	681b      	ldr	r3, [r3, #0]
    8eb2:	4a04      	ldr	r2, [pc, #16]	; (8ec4 <ENET_Transmit_IRQHandler+0x18>)
    8eb4:	6812      	ldr	r2, [r2, #0]
    8eb6:	4611      	mov	r1, r2
    8eb8:	4803      	ldr	r0, [pc, #12]	; (8ec8 <ENET_Transmit_IRQHandler+0x1c>)
    8eba:	4798      	blx	r3
}
    8ebc:	bf00      	nop
    8ebe:	bd08      	pop	{r3, pc}
    8ec0:	200014e4 	.word	0x200014e4
    8ec4:	200014e0 	.word	0x200014e0
    8ec8:	400c0000 	.word	0x400c0000

00008ecc <ENET_Receive_IRQHandler>:

void ENET_Receive_IRQHandler(void)
{
    8ecc:	b508      	push	{r3, lr}
    s_enetRxIsr(ENET, s_ENETHandle[0]);
    8ece:	4b04      	ldr	r3, [pc, #16]	; (8ee0 <ENET_Receive_IRQHandler+0x14>)
    8ed0:	681b      	ldr	r3, [r3, #0]
    8ed2:	4a04      	ldr	r2, [pc, #16]	; (8ee4 <ENET_Receive_IRQHandler+0x18>)
    8ed4:	6812      	ldr	r2, [r2, #0]
    8ed6:	4611      	mov	r1, r2
    8ed8:	4803      	ldr	r0, [pc, #12]	; (8ee8 <ENET_Receive_IRQHandler+0x1c>)
    8eda:	4798      	blx	r3
}
    8edc:	bf00      	nop
    8ede:	bd08      	pop	{r3, pc}
    8ee0:	200014e8 	.word	0x200014e8
    8ee4:	200014e0 	.word	0x200014e0
    8ee8:	400c0000 	.word	0x400c0000

00008eec <ENET_Error_IRQHandler>:

void ENET_Error_IRQHandler(void)
{
    8eec:	b508      	push	{r3, lr}
    s_enetErrIsr(ENET, s_ENETHandle[0]);
    8eee:	4b04      	ldr	r3, [pc, #16]	; (8f00 <ENET_Error_IRQHandler+0x14>)
    8ef0:	681b      	ldr	r3, [r3, #0]
    8ef2:	4a04      	ldr	r2, [pc, #16]	; (8f04 <ENET_Error_IRQHandler+0x18>)
    8ef4:	6812      	ldr	r2, [r2, #0]
    8ef6:	4611      	mov	r1, r2
    8ef8:	4803      	ldr	r0, [pc, #12]	; (8f08 <ENET_Error_IRQHandler+0x1c>)
    8efa:	4798      	blx	r3
}
    8efc:	bf00      	nop
    8efe:	bd08      	pop	{r3, pc}
    8f00:	200014ec 	.word	0x200014ec
    8f04:	200014e0 	.word	0x200014e0
    8f08:	400c0000 	.word	0x400c0000

00008f0c <CAN0_DriverIRQHandler>:
#endif
}

#if (FSL_FEATURE_SOC_FLEXCAN_COUNT > 0)
void CAN0_DriverIRQHandler(void)
{
    8f0c:	b508      	push	{r3, lr}
    assert(s_flexcanHandle[0]);
    8f0e:	4b0a      	ldr	r3, [pc, #40]	; (8f38 <CAN0_DriverIRQHandler+0x2c>)
    8f10:	681b      	ldr	r3, [r3, #0]
    8f12:	2b00      	cmp	r3, #0
    8f14:	d106      	bne.n	8f24 <CAN0_DriverIRQHandler+0x18>
    8f16:	4b09      	ldr	r3, [pc, #36]	; (8f3c <CAN0_DriverIRQHandler+0x30>)
    8f18:	4a09      	ldr	r2, [pc, #36]	; (8f40 <CAN0_DriverIRQHandler+0x34>)
    8f1a:	f240 511f 	movw	r1, #1311	; 0x51f
    8f1e:	4809      	ldr	r0, [pc, #36]	; (8f44 <CAN0_DriverIRQHandler+0x38>)
    8f20:	f001 f9f0 	bl	a304 <__assert_func>

    s_flexcanIsr(CAN0, s_flexcanHandle[0]);
    8f24:	4b08      	ldr	r3, [pc, #32]	; (8f48 <CAN0_DriverIRQHandler+0x3c>)
    8f26:	681b      	ldr	r3, [r3, #0]
    8f28:	4a03      	ldr	r2, [pc, #12]	; (8f38 <CAN0_DriverIRQHandler+0x2c>)
    8f2a:	6812      	ldr	r2, [r2, #0]
    8f2c:	4611      	mov	r1, r2
    8f2e:	4807      	ldr	r0, [pc, #28]	; (8f4c <CAN0_DriverIRQHandler+0x40>)
    8f30:	4798      	blx	r3
}
    8f32:	bf00      	nop
    8f34:	bd08      	pop	{r3, pc}
    8f36:	bf00      	nop
    8f38:	200014f0 	.word	0x200014f0
    8f3c:	00011c30 	.word	0x00011c30
    8f40:	00012830 	.word	0x00012830
    8f44:	0001192c 	.word	0x0001192c
    8f48:	200014f4 	.word	0x200014f4
    8f4c:	40024000 	.word	0x40024000

00008f50 <I2C_TransferCommonIRQHandler>:

    return result;
}

static void I2C_TransferCommonIRQHandler(I2C_Type *base, void *handle)
{
    8f50:	b500      	push	{lr}
    8f52:	b083      	sub	sp, #12
    8f54:	9001      	str	r0, [sp, #4]
    8f56:	9100      	str	r1, [sp, #0]
    /* Check if master interrupt. */
    if ((base->S & kI2C_ArbitrationLostFlag) || (base->C1 & I2C_C1_MST_MASK))
    8f58:	9b01      	ldr	r3, [sp, #4]
    8f5a:	78db      	ldrb	r3, [r3, #3]
    8f5c:	b2db      	uxtb	r3, r3
    8f5e:	f003 0310 	and.w	r3, r3, #16
    8f62:	2b00      	cmp	r3, #0
    8f64:	d106      	bne.n	8f74 <I2C_TransferCommonIRQHandler+0x24>
    8f66:	9b01      	ldr	r3, [sp, #4]
    8f68:	789b      	ldrb	r3, [r3, #2]
    8f6a:	b2db      	uxtb	r3, r3
    8f6c:	f003 0320 	and.w	r3, r3, #32
    8f70:	2b00      	cmp	r3, #0
    8f72:	d005      	beq.n	8f80 <I2C_TransferCommonIRQHandler+0x30>
    {
        s_i2cMasterIsr(base, handle);
    8f74:	4b08      	ldr	r3, [pc, #32]	; (8f98 <I2C_TransferCommonIRQHandler+0x48>)
    8f76:	681b      	ldr	r3, [r3, #0]
    8f78:	9900      	ldr	r1, [sp, #0]
    8f7a:	9801      	ldr	r0, [sp, #4]
    8f7c:	4798      	blx	r3
    8f7e:	e004      	b.n	8f8a <I2C_TransferCommonIRQHandler+0x3a>
    }
    else
    {
        s_i2cSlaveIsr(base, handle);
    8f80:	4b06      	ldr	r3, [pc, #24]	; (8f9c <I2C_TransferCommonIRQHandler+0x4c>)
    8f82:	681b      	ldr	r3, [r3, #0]
    8f84:	9900      	ldr	r1, [sp, #0]
    8f86:	9801      	ldr	r0, [sp, #4]
    8f88:	4798      	blx	r3
  __ASM volatile ("dsb 0xF":::"memory");
    8f8a:	f3bf 8f4f 	dsb	sy
    }
    __DSB();
}
    8f8e:	bf00      	nop
    8f90:	b003      	add	sp, #12
    8f92:	f85d fb04 	ldr.w	pc, [sp], #4
    8f96:	bf00      	nop
    8f98:	20001504 	.word	0x20001504
    8f9c:	20001508 	.word	0x20001508

00008fa0 <I2C0_DriverIRQHandler>:
        }
    }
}

void I2C0_DriverIRQHandler(void)
{
    8fa0:	b508      	push	{r3, lr}
    I2C_TransferCommonIRQHandler(I2C0, s_i2cHandle[0]);
    8fa2:	4b04      	ldr	r3, [pc, #16]	; (8fb4 <I2C0_DriverIRQHandler+0x14>)
    8fa4:	681b      	ldr	r3, [r3, #0]
    8fa6:	4619      	mov	r1, r3
    8fa8:	4803      	ldr	r0, [pc, #12]	; (8fb8 <I2C0_DriverIRQHandler+0x18>)
    8faa:	f7ff ffd1 	bl	8f50 <I2C_TransferCommonIRQHandler>
}
    8fae:	bf00      	nop
    8fb0:	bd08      	pop	{r3, pc}
    8fb2:	bf00      	nop
    8fb4:	200014f8 	.word	0x200014f8
    8fb8:	40066000 	.word	0x40066000

00008fbc <I2C1_DriverIRQHandler>:

#if (FSL_FEATURE_SOC_I2C_COUNT > 1)
void I2C1_DriverIRQHandler(void)
{
    8fbc:	b508      	push	{r3, lr}
    I2C_TransferCommonIRQHandler(I2C1, s_i2cHandle[1]);
    8fbe:	4b04      	ldr	r3, [pc, #16]	; (8fd0 <I2C1_DriverIRQHandler+0x14>)
    8fc0:	685b      	ldr	r3, [r3, #4]
    8fc2:	4619      	mov	r1, r3
    8fc4:	4803      	ldr	r0, [pc, #12]	; (8fd4 <I2C1_DriverIRQHandler+0x18>)
    8fc6:	f7ff ffc3 	bl	8f50 <I2C_TransferCommonIRQHandler>
}
    8fca:	bf00      	nop
    8fcc:	bd08      	pop	{r3, pc}
    8fce:	bf00      	nop
    8fd0:	200014f8 	.word	0x200014f8
    8fd4:	40067000 	.word	0x40067000

00008fd8 <I2C2_DriverIRQHandler>:
#endif /* I2C COUNT > 1 */

#if (FSL_FEATURE_SOC_I2C_COUNT > 2)
void I2C2_DriverIRQHandler(void)
{
    8fd8:	b508      	push	{r3, lr}
    I2C_TransferCommonIRQHandler(I2C2, s_i2cHandle[2]);
    8fda:	4b04      	ldr	r3, [pc, #16]	; (8fec <I2C2_DriverIRQHandler+0x14>)
    8fdc:	689b      	ldr	r3, [r3, #8]
    8fde:	4619      	mov	r1, r3
    8fe0:	4803      	ldr	r0, [pc, #12]	; (8ff0 <I2C2_DriverIRQHandler+0x18>)
    8fe2:	f7ff ffb5 	bl	8f50 <I2C_TransferCommonIRQHandler>
}
    8fe6:	bf00      	nop
    8fe8:	bd08      	pop	{r3, pc}
    8fea:	bf00      	nop
    8fec:	200014f8 	.word	0x200014f8
    8ff0:	400e6000 	.word	0x400e6000

00008ff4 <CLOCK_EnableClock>:
{
    8ff4:	b084      	sub	sp, #16
    8ff6:	9001      	str	r0, [sp, #4]
    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
    8ff8:	9b01      	ldr	r3, [sp, #4]
    8ffa:	0c1b      	lsrs	r3, r3, #16
    8ffc:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    9000:	f503 238e 	add.w	r3, r3, #290816	; 0x47000
    9004:	9303      	str	r3, [sp, #12]
    __FSL_CLOCK_SECURE_BITS_SET((volatile uint32_t *) regAddr, (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name)));
    9006:	9b03      	ldr	r3, [sp, #12]
    9008:	9a03      	ldr	r2, [sp, #12]
    900a:	6811      	ldr	r1, [r2, #0]
    900c:	9a01      	ldr	r2, [sp, #4]
    900e:	b292      	uxth	r2, r2
    9010:	2001      	movs	r0, #1
    9012:	fa00 f202 	lsl.w	r2, r0, r2
    9016:	430a      	orrs	r2, r1
    9018:	601a      	str	r2, [r3, #0]
}
    901a:	bf00      	nop
    901c:	b004      	add	sp, #16
    901e:	4770      	bx	lr

00009020 <PIT_GetInstance>:

/*******************************************************************************
 * Code
 ******************************************************************************/
static uint32_t PIT_GetInstance(PIT_Type *base)
{
    9020:	b500      	push	{lr}
    9022:	b085      	sub	sp, #20
    9024:	9001      	str	r0, [sp, #4]
    uint32_t instance;

    /* Find the instance index from base address mappings. */
    for (instance = 0; instance < FSL_FEATURE_SOC_PIT_COUNT; instance++)
    9026:	2300      	movs	r3, #0
    9028:	9303      	str	r3, [sp, #12]
    902a:	e006      	b.n	903a <PIT_GetInstance+0x1a>
    {
        if (s_pitBases[instance] == base)
    902c:	4a0c      	ldr	r2, [pc, #48]	; (9060 <PIT_GetInstance+0x40>)
    902e:	9b01      	ldr	r3, [sp, #4]
    9030:	429a      	cmp	r2, r3
    9032:	d006      	beq.n	9042 <PIT_GetInstance+0x22>
    for (instance = 0; instance < FSL_FEATURE_SOC_PIT_COUNT; instance++)
    9034:	9b03      	ldr	r3, [sp, #12]
    9036:	3301      	adds	r3, #1
    9038:	9303      	str	r3, [sp, #12]
    903a:	9b03      	ldr	r3, [sp, #12]
    903c:	2b00      	cmp	r3, #0
    903e:	d0f5      	beq.n	902c <PIT_GetInstance+0xc>
    9040:	e000      	b.n	9044 <PIT_GetInstance+0x24>
        {
            break;
    9042:	bf00      	nop
        }
    }

    assert(instance < FSL_FEATURE_SOC_PIT_COUNT);
    9044:	9b03      	ldr	r3, [sp, #12]
    9046:	2b00      	cmp	r3, #0
    9048:	d005      	beq.n	9056 <PIT_GetInstance+0x36>
    904a:	4b06      	ldr	r3, [pc, #24]	; (9064 <PIT_GetInstance+0x44>)
    904c:	4a06      	ldr	r2, [pc, #24]	; (9068 <PIT_GetInstance+0x48>)
    904e:	2148      	movs	r1, #72	; 0x48
    9050:	4806      	ldr	r0, [pc, #24]	; (906c <PIT_GetInstance+0x4c>)
    9052:	f001 f957 	bl	a304 <__assert_func>

    return instance;
    9056:	9b03      	ldr	r3, [sp, #12]
}
    9058:	4618      	mov	r0, r3
    905a:	b005      	add	sp, #20
    905c:	f85d fb04 	ldr.w	pc, [sp], #4
    9060:	40037000 	.word	0x40037000
    9064:	00011c44 	.word	0x00011c44
    9068:	00012848 	.word	0x00012848
    906c:	00011c6c 	.word	0x00011c6c

00009070 <PIT_Init>:

void PIT_Init(PIT_Type *base, const pit_config_t *config)
{
    9070:	b500      	push	{lr}
    9072:	b083      	sub	sp, #12
    9074:	9001      	str	r0, [sp, #4]
    9076:	9100      	str	r1, [sp, #0]
    assert(config);
    9078:	9b00      	ldr	r3, [sp, #0]
    907a:	2b00      	cmp	r3, #0
    907c:	d105      	bne.n	908a <PIT_Init+0x1a>
    907e:	4b14      	ldr	r3, [pc, #80]	; (90d0 <PIT_Init+0x60>)
    9080:	4a14      	ldr	r2, [pc, #80]	; (90d4 <PIT_Init+0x64>)
    9082:	214f      	movs	r1, #79	; 0x4f
    9084:	4814      	ldr	r0, [pc, #80]	; (90d8 <PIT_Init+0x68>)
    9086:	f001 f93d 	bl	a304 <__assert_func>

#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    /* Ungate the PIT clock*/
    CLOCK_EnableClock(s_pitClocks[PIT_GetInstance(base)]);
    908a:	9801      	ldr	r0, [sp, #4]
    908c:	f7ff ffc8 	bl	9020 <PIT_GetInstance>
    9090:	4b12      	ldr	r3, [pc, #72]	; (90dc <PIT_Init+0x6c>)
    9092:	4618      	mov	r0, r3
    9094:	f7ff ffae 	bl	8ff4 <CLOCK_EnableClock>
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */

    /* Enable PIT timers */
    base->MCR &= ~PIT_MCR_MDIS_MASK;
    9098:	9b01      	ldr	r3, [sp, #4]
    909a:	681b      	ldr	r3, [r3, #0]
    909c:	f023 0202 	bic.w	r2, r3, #2
    90a0:	9b01      	ldr	r3, [sp, #4]
    90a2:	601a      	str	r2, [r3, #0]

    /* Config timer operation when in debug mode */
    if (config->enableRunInDebug)
    90a4:	9b00      	ldr	r3, [sp, #0]
    90a6:	781b      	ldrb	r3, [r3, #0]
    90a8:	2b00      	cmp	r3, #0
    90aa:	d006      	beq.n	90ba <PIT_Init+0x4a>
    {
        base->MCR &= ~PIT_MCR_FRZ_MASK;
    90ac:	9b01      	ldr	r3, [sp, #4]
    90ae:	681b      	ldr	r3, [r3, #0]
    90b0:	f023 0201 	bic.w	r2, r3, #1
    90b4:	9b01      	ldr	r3, [sp, #4]
    90b6:	601a      	str	r2, [r3, #0]
    }
    else
    {
        base->MCR |= PIT_MCR_FRZ_MASK;
    }
}
    90b8:	e005      	b.n	90c6 <PIT_Init+0x56>
        base->MCR |= PIT_MCR_FRZ_MASK;
    90ba:	9b01      	ldr	r3, [sp, #4]
    90bc:	681b      	ldr	r3, [r3, #0]
    90be:	f043 0201 	orr.w	r2, r3, #1
    90c2:	9b01      	ldr	r3, [sp, #4]
    90c4:	601a      	str	r2, [r3, #0]
}
    90c6:	bf00      	nop
    90c8:	b003      	add	sp, #12
    90ca:	f85d fb04 	ldr.w	pc, [sp], #4
    90ce:	bf00      	nop
    90d0:	00011cc8 	.word	0x00011cc8
    90d4:	00012858 	.word	0x00012858
    90d8:	00011c6c 	.word	0x00011c6c
    90dc:	103c0017 	.word	0x103c0017

000090e0 <I2S0_Tx_DriverIRQHandler>:
        s_saiTxIsr(I2S0, s_saiHandle[0][0]);
    }
}
#else
void I2S0_Tx_DriverIRQHandler(void)
{
    90e0:	b508      	push	{r3, lr}
    assert(s_saiHandle[0][0]);
    90e2:	4b0a      	ldr	r3, [pc, #40]	; (910c <I2S0_Tx_DriverIRQHandler+0x2c>)
    90e4:	681b      	ldr	r3, [r3, #0]
    90e6:	2b00      	cmp	r3, #0
    90e8:	d106      	bne.n	90f8 <I2S0_Tx_DriverIRQHandler+0x18>
    90ea:	4b09      	ldr	r3, [pc, #36]	; (9110 <I2S0_Tx_DriverIRQHandler+0x30>)
    90ec:	4a09      	ldr	r2, [pc, #36]	; (9114 <I2S0_Tx_DriverIRQHandler+0x34>)
    90ee:	f240 411a 	movw	r1, #1050	; 0x41a
    90f2:	4809      	ldr	r0, [pc, #36]	; (9118 <I2S0_Tx_DriverIRQHandler+0x38>)
    90f4:	f001 f906 	bl	a304 <__assert_func>
    s_saiTxIsr(I2S0, s_saiHandle[0][0]);
    90f8:	4b08      	ldr	r3, [pc, #32]	; (911c <I2S0_Tx_DriverIRQHandler+0x3c>)
    90fa:	681b      	ldr	r3, [r3, #0]
    90fc:	4a03      	ldr	r2, [pc, #12]	; (910c <I2S0_Tx_DriverIRQHandler+0x2c>)
    90fe:	6812      	ldr	r2, [r2, #0]
    9100:	4611      	mov	r1, r2
    9102:	4807      	ldr	r0, [pc, #28]	; (9120 <I2S0_Tx_DriverIRQHandler+0x40>)
    9104:	4798      	blx	r3
}
    9106:	bf00      	nop
    9108:	bd08      	pop	{r3, pc}
    910a:	bf00      	nop
    910c:	20002f64 	.word	0x20002f64
    9110:	00011d5c 	.word	0x00011d5c
    9114:	00012864 	.word	0x00012864
    9118:	00011cf8 	.word	0x00011cf8
    911c:	2000150c 	.word	0x2000150c
    9120:	4002f000 	.word	0x4002f000

00009124 <I2S0_Rx_DriverIRQHandler>:

void I2S0_Rx_DriverIRQHandler(void)
{
    9124:	b508      	push	{r3, lr}
    assert(s_saiHandle[0][1]);
    9126:	4b0a      	ldr	r3, [pc, #40]	; (9150 <I2S0_Rx_DriverIRQHandler+0x2c>)
    9128:	685b      	ldr	r3, [r3, #4]
    912a:	2b00      	cmp	r3, #0
    912c:	d106      	bne.n	913c <I2S0_Rx_DriverIRQHandler+0x18>
    912e:	4b09      	ldr	r3, [pc, #36]	; (9154 <I2S0_Rx_DriverIRQHandler+0x30>)
    9130:	4a09      	ldr	r2, [pc, #36]	; (9158 <I2S0_Rx_DriverIRQHandler+0x34>)
    9132:	f44f 6184 	mov.w	r1, #1056	; 0x420
    9136:	4809      	ldr	r0, [pc, #36]	; (915c <I2S0_Rx_DriverIRQHandler+0x38>)
    9138:	f001 f8e4 	bl	a304 <__assert_func>
    s_saiRxIsr(I2S0, s_saiHandle[0][1]);
    913c:	4b08      	ldr	r3, [pc, #32]	; (9160 <I2S0_Rx_DriverIRQHandler+0x3c>)
    913e:	681b      	ldr	r3, [r3, #0]
    9140:	4a03      	ldr	r2, [pc, #12]	; (9150 <I2S0_Rx_DriverIRQHandler+0x2c>)
    9142:	6852      	ldr	r2, [r2, #4]
    9144:	4611      	mov	r1, r2
    9146:	4807      	ldr	r0, [pc, #28]	; (9164 <I2S0_Rx_DriverIRQHandler+0x40>)
    9148:	4798      	blx	r3
}
    914a:	bf00      	nop
    914c:	bd08      	pop	{r3, pc}
    914e:	bf00      	nop
    9150:	20002f64 	.word	0x20002f64
    9154:	00011d70 	.word	0x00011d70
    9158:	00012880 	.word	0x00012880
    915c:	00011cf8 	.word	0x00011cf8
    9160:	20001510 	.word	0x20001510
    9164:	4002f000 	.word	0x4002f000

00009168 <SDHC_DriverIRQHandler>:
    SDHC_ClearInterruptStatusFlags(base, interruptFlags);
}

#if defined(SDHC)
void SDHC_DriverIRQHandler(void)
{
    9168:	b508      	push	{r3, lr}
    assert(s_sdhcHandle[0]);
    916a:	4b0a      	ldr	r3, [pc, #40]	; (9194 <SDHC_DriverIRQHandler+0x2c>)
    916c:	681b      	ldr	r3, [r3, #0]
    916e:	2b00      	cmp	r3, #0
    9170:	d106      	bne.n	9180 <SDHC_DriverIRQHandler+0x18>
    9172:	4b09      	ldr	r3, [pc, #36]	; (9198 <SDHC_DriverIRQHandler+0x30>)
    9174:	4a09      	ldr	r2, [pc, #36]	; (919c <SDHC_DriverIRQHandler+0x34>)
    9176:	f44f 61a9 	mov.w	r1, #1352	; 0x548
    917a:	4809      	ldr	r0, [pc, #36]	; (91a0 <SDHC_DriverIRQHandler+0x38>)
    917c:	f001 f8c2 	bl	a304 <__assert_func>

    s_sdhcIsr(SDHC, s_sdhcHandle[0]);
    9180:	4b08      	ldr	r3, [pc, #32]	; (91a4 <SDHC_DriverIRQHandler+0x3c>)
    9182:	681b      	ldr	r3, [r3, #0]
    9184:	4a03      	ldr	r2, [pc, #12]	; (9194 <SDHC_DriverIRQHandler+0x2c>)
    9186:	6812      	ldr	r2, [r2, #0]
    9188:	4611      	mov	r1, r2
    918a:	4807      	ldr	r0, [pc, #28]	; (91a8 <SDHC_DriverIRQHandler+0x40>)
    918c:	4798      	blx	r3
}
    918e:	bf00      	nop
    9190:	bd08      	pop	{r3, pc}
    9192:	bf00      	nop
    9194:	20001514 	.word	0x20001514
    9198:	00012130 	.word	0x00012130
    919c:	0001289c 	.word	0x0001289c
    91a0:	00011e18 	.word	0x00011e18
    91a4:	20001518 	.word	0x20001518
    91a8:	400b1000 	.word	0x400b1000

000091ac <SMC_SetPowerModeWait>:
    return kStatus_Success;
}
#endif /* FSL_FEATURE_SMC_HAS_HIGH_SPEED_RUN_MODE */

status_t SMC_SetPowerModeWait(SMC_Type *base)
{
    91ac:	b082      	sub	sp, #8
    91ae:	9001      	str	r0, [sp, #4]
    /* configure Normal Wait mode */
    SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
    91b0:	4a07      	ldr	r2, [pc, #28]	; (91d0 <SMC_SetPowerModeWait+0x24>)
    91b2:	4b07      	ldr	r3, [pc, #28]	; (91d0 <SMC_SetPowerModeWait+0x24>)
    91b4:	691b      	ldr	r3, [r3, #16]
    91b6:	f023 0304 	bic.w	r3, r3, #4
    91ba:	6113      	str	r3, [r2, #16]
    91bc:	f3bf 8f4f 	dsb	sy
    __DSB();
    __WFI();
    91c0:	bf30      	wfi
  __ASM volatile ("isb 0xF":::"memory");
    91c2:	f3bf 8f6f 	isb	sy
    __ISB();

    return kStatus_Success;
    91c6:	2300      	movs	r3, #0
}
    91c8:	4618      	mov	r0, r3
    91ca:	b002      	add	sp, #8
    91cc:	4770      	bx	lr
    91ce:	bf00      	nop
    91d0:	e000ed00 	.word	0xe000ed00

000091d4 <CLOCK_EnableClock>:
{
    91d4:	b084      	sub	sp, #16
    91d6:	9001      	str	r0, [sp, #4]
    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
    91d8:	9b01      	ldr	r3, [sp, #4]
    91da:	0c1b      	lsrs	r3, r3, #16
    91dc:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    91e0:	f503 238e 	add.w	r3, r3, #290816	; 0x47000
    91e4:	9303      	str	r3, [sp, #12]
    __FSL_CLOCK_SECURE_BITS_SET((volatile uint32_t *) regAddr, (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name)));
    91e6:	9b03      	ldr	r3, [sp, #12]
    91e8:	9a03      	ldr	r2, [sp, #12]
    91ea:	6811      	ldr	r1, [r2, #0]
    91ec:	9a01      	ldr	r2, [sp, #4]
    91ee:	b292      	uxth	r2, r2
    91f0:	2001      	movs	r0, #1
    91f2:	fa00 f202 	lsl.w	r2, r0, r2
    91f6:	430a      	orrs	r2, r1
    91f8:	601a      	str	r2, [r3, #0]
}
    91fa:	bf00      	nop
    91fc:	b004      	add	sp, #16
    91fe:	4770      	bx	lr

00009200 <UART_GetInstance>:
/*******************************************************************************
 * Code
 ******************************************************************************/

uint32_t UART_GetInstance(UART_Type *base)
{
    9200:	b500      	push	{lr}
    9202:	b085      	sub	sp, #20
    9204:	9001      	str	r0, [sp, #4]
    uint32_t instance;
    uint32_t uartArrayCount = (sizeof(s_uartBases) / sizeof(s_uartBases[0]));
    9206:	2306      	movs	r3, #6
    9208:	9302      	str	r3, [sp, #8]

    /* Find the instance index from base address mappings. */
    for (instance = 0; instance < uartArrayCount; instance++)
    920a:	2300      	movs	r3, #0
    920c:	9303      	str	r3, [sp, #12]
    920e:	e009      	b.n	9224 <UART_GetInstance+0x24>
    {
        if (s_uartBases[instance] == base)
    9210:	4a0f      	ldr	r2, [pc, #60]	; (9250 <UART_GetInstance+0x50>)
    9212:	9b03      	ldr	r3, [sp, #12]
    9214:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    9218:	9b01      	ldr	r3, [sp, #4]
    921a:	429a      	cmp	r2, r3
    921c:	d007      	beq.n	922e <UART_GetInstance+0x2e>
    for (instance = 0; instance < uartArrayCount; instance++)
    921e:	9b03      	ldr	r3, [sp, #12]
    9220:	3301      	adds	r3, #1
    9222:	9303      	str	r3, [sp, #12]
    9224:	9a03      	ldr	r2, [sp, #12]
    9226:	9b02      	ldr	r3, [sp, #8]
    9228:	429a      	cmp	r2, r3
    922a:	d3f1      	bcc.n	9210 <UART_GetInstance+0x10>
    922c:	e000      	b.n	9230 <UART_GetInstance+0x30>
        {
            break;
    922e:	bf00      	nop
        }
    }

    assert(instance < uartArrayCount);
    9230:	9a03      	ldr	r2, [sp, #12]
    9232:	9b02      	ldr	r3, [sp, #8]
    9234:	429a      	cmp	r2, r3
    9236:	d305      	bcc.n	9244 <UART_GetInstance+0x44>
    9238:	4b06      	ldr	r3, [pc, #24]	; (9254 <UART_GetInstance+0x54>)
    923a:	4a07      	ldr	r2, [pc, #28]	; (9258 <UART_GetInstance+0x58>)
    923c:	21a9      	movs	r1, #169	; 0xa9
    923e:	4807      	ldr	r0, [pc, #28]	; (925c <UART_GetInstance+0x5c>)
    9240:	f001 f860 	bl	a304 <__assert_func>

    return instance;
    9244:	9b03      	ldr	r3, [sp, #12]
}
    9246:	4618      	mov	r0, r3
    9248:	b005      	add	sp, #20
    924a:	f85d fb04 	ldr.w	pc, [sp], #4
    924e:	bf00      	nop
    9250:	000128b4 	.word	0x000128b4
    9254:	00012140 	.word	0x00012140
    9258:	000128e4 	.word	0x000128e4
    925c:	0001215c 	.word	0x0001215c

00009260 <UART_Init>:

    return full;
}

status_t UART_Init(UART_Type *base, const uart_config_t *config, uint32_t srcClock_Hz)
{
    9260:	b500      	push	{lr}
    9262:	b089      	sub	sp, #36	; 0x24
    9264:	9003      	str	r0, [sp, #12]
    9266:	9102      	str	r1, [sp, #8]
    9268:	9201      	str	r2, [sp, #4]
    assert(config);
    926a:	9b02      	ldr	r3, [sp, #8]
    926c:	2b00      	cmp	r3, #0
    926e:	d105      	bne.n	927c <UART_Init+0x1c>
    9270:	4bac      	ldr	r3, [pc, #688]	; (9524 <UART_Init+0x2c4>)
    9272:	4aad      	ldr	r2, [pc, #692]	; (9528 <UART_Init+0x2c8>)
    9274:	21d4      	movs	r1, #212	; 0xd4
    9276:	48ad      	ldr	r0, [pc, #692]	; (952c <UART_Init+0x2cc>)
    9278:	f001 f844 	bl	a304 <__assert_func>
    assert(config->baudRate_Bps);
    927c:	9b02      	ldr	r3, [sp, #8]
    927e:	681b      	ldr	r3, [r3, #0]
    9280:	2b00      	cmp	r3, #0
    9282:	d105      	bne.n	9290 <UART_Init+0x30>
    9284:	4baa      	ldr	r3, [pc, #680]	; (9530 <UART_Init+0x2d0>)
    9286:	4aa8      	ldr	r2, [pc, #672]	; (9528 <UART_Init+0x2c8>)
    9288:	21d5      	movs	r1, #213	; 0xd5
    928a:	48a8      	ldr	r0, [pc, #672]	; (952c <UART_Init+0x2cc>)
    928c:	f001 f83a 	bl	a304 <__assert_func>
#if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    assert(FSL_FEATURE_UART_FIFO_SIZEn(base) >= config->txFifoWatermark);
    9290:	9b03      	ldr	r3, [sp, #12]
    9292:	4aa8      	ldr	r2, [pc, #672]	; (9534 <UART_Init+0x2d4>)
    9294:	4293      	cmp	r3, r2
    9296:	d020      	beq.n	92da <UART_Init+0x7a>
    9298:	9b03      	ldr	r3, [sp, #12]
    929a:	4aa7      	ldr	r2, [pc, #668]	; (9538 <UART_Init+0x2d8>)
    929c:	4293      	cmp	r3, r2
    929e:	d01a      	beq.n	92d6 <UART_Init+0x76>
    92a0:	9b03      	ldr	r3, [sp, #12]
    92a2:	4aa6      	ldr	r2, [pc, #664]	; (953c <UART_Init+0x2dc>)
    92a4:	4293      	cmp	r3, r2
    92a6:	d014      	beq.n	92d2 <UART_Init+0x72>
    92a8:	9b03      	ldr	r3, [sp, #12]
    92aa:	4aa5      	ldr	r2, [pc, #660]	; (9540 <UART_Init+0x2e0>)
    92ac:	4293      	cmp	r3, r2
    92ae:	d00e      	beq.n	92ce <UART_Init+0x6e>
    92b0:	9b03      	ldr	r3, [sp, #12]
    92b2:	4aa4      	ldr	r2, [pc, #656]	; (9544 <UART_Init+0x2e4>)
    92b4:	4293      	cmp	r3, r2
    92b6:	d008      	beq.n	92ca <UART_Init+0x6a>
    92b8:	9b03      	ldr	r3, [sp, #12]
    92ba:	4aa3      	ldr	r2, [pc, #652]	; (9548 <UART_Init+0x2e8>)
    92bc:	4293      	cmp	r3, r2
    92be:	d101      	bne.n	92c4 <UART_Init+0x64>
    92c0:	2301      	movs	r3, #1
    92c2:	e00b      	b.n	92dc <UART_Init+0x7c>
    92c4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    92c8:	e008      	b.n	92dc <UART_Init+0x7c>
    92ca:	2301      	movs	r3, #1
    92cc:	e006      	b.n	92dc <UART_Init+0x7c>
    92ce:	2301      	movs	r3, #1
    92d0:	e004      	b.n	92dc <UART_Init+0x7c>
    92d2:	2301      	movs	r3, #1
    92d4:	e002      	b.n	92dc <UART_Init+0x7c>
    92d6:	2308      	movs	r3, #8
    92d8:	e000      	b.n	92dc <UART_Init+0x7c>
    92da:	2308      	movs	r3, #8
    92dc:	9a02      	ldr	r2, [sp, #8]
    92de:	7992      	ldrb	r2, [r2, #6]
    92e0:	4293      	cmp	r3, r2
    92e2:	da05      	bge.n	92f0 <UART_Init+0x90>
    92e4:	4b99      	ldr	r3, [pc, #612]	; (954c <UART_Init+0x2ec>)
    92e6:	4a90      	ldr	r2, [pc, #576]	; (9528 <UART_Init+0x2c8>)
    92e8:	21d7      	movs	r1, #215	; 0xd7
    92ea:	4890      	ldr	r0, [pc, #576]	; (952c <UART_Init+0x2cc>)
    92ec:	f001 f80a 	bl	a304 <__assert_func>
    assert(FSL_FEATURE_UART_FIFO_SIZEn(base) >= config->rxFifoWatermark);
    92f0:	9b03      	ldr	r3, [sp, #12]
    92f2:	4a90      	ldr	r2, [pc, #576]	; (9534 <UART_Init+0x2d4>)
    92f4:	4293      	cmp	r3, r2
    92f6:	d020      	beq.n	933a <UART_Init+0xda>
    92f8:	9b03      	ldr	r3, [sp, #12]
    92fa:	4a8f      	ldr	r2, [pc, #572]	; (9538 <UART_Init+0x2d8>)
    92fc:	4293      	cmp	r3, r2
    92fe:	d01a      	beq.n	9336 <UART_Init+0xd6>
    9300:	9b03      	ldr	r3, [sp, #12]
    9302:	4a8e      	ldr	r2, [pc, #568]	; (953c <UART_Init+0x2dc>)
    9304:	4293      	cmp	r3, r2
    9306:	d014      	beq.n	9332 <UART_Init+0xd2>
    9308:	9b03      	ldr	r3, [sp, #12]
    930a:	4a8d      	ldr	r2, [pc, #564]	; (9540 <UART_Init+0x2e0>)
    930c:	4293      	cmp	r3, r2
    930e:	d00e      	beq.n	932e <UART_Init+0xce>
    9310:	9b03      	ldr	r3, [sp, #12]
    9312:	4a8c      	ldr	r2, [pc, #560]	; (9544 <UART_Init+0x2e4>)
    9314:	4293      	cmp	r3, r2
    9316:	d008      	beq.n	932a <UART_Init+0xca>
    9318:	9b03      	ldr	r3, [sp, #12]
    931a:	4a8b      	ldr	r2, [pc, #556]	; (9548 <UART_Init+0x2e8>)
    931c:	4293      	cmp	r3, r2
    931e:	d101      	bne.n	9324 <UART_Init+0xc4>
    9320:	2301      	movs	r3, #1
    9322:	e00b      	b.n	933c <UART_Init+0xdc>
    9324:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    9328:	e008      	b.n	933c <UART_Init+0xdc>
    932a:	2301      	movs	r3, #1
    932c:	e006      	b.n	933c <UART_Init+0xdc>
    932e:	2301      	movs	r3, #1
    9330:	e004      	b.n	933c <UART_Init+0xdc>
    9332:	2301      	movs	r3, #1
    9334:	e002      	b.n	933c <UART_Init+0xdc>
    9336:	2308      	movs	r3, #8
    9338:	e000      	b.n	933c <UART_Init+0xdc>
    933a:	2308      	movs	r3, #8
    933c:	9a02      	ldr	r2, [sp, #8]
    933e:	79d2      	ldrb	r2, [r2, #7]
    9340:	4293      	cmp	r3, r2
    9342:	da05      	bge.n	9350 <UART_Init+0xf0>
    9344:	4b82      	ldr	r3, [pc, #520]	; (9550 <UART_Init+0x2f0>)
    9346:	4a78      	ldr	r2, [pc, #480]	; (9528 <UART_Init+0x2c8>)
    9348:	21d8      	movs	r1, #216	; 0xd8
    934a:	4878      	ldr	r0, [pc, #480]	; (952c <UART_Init+0x2cc>)
    934c:	f000 ffda 	bl	a304 <__assert_func>
#endif

    uint16_t sbr = 0;
    9350:	2300      	movs	r3, #0
    9352:	f8ad 301e 	strh.w	r3, [sp, #30]
    uint8_t temp = 0;
    9356:	2300      	movs	r3, #0
    9358:	f88d 301d 	strb.w	r3, [sp, #29]
    uint32_t baudDiff = 0;
    935c:	2300      	movs	r3, #0
    935e:	9306      	str	r3, [sp, #24]

    /* Calculate the baud rate modulo divisor, sbr*/
    sbr = srcClock_Hz / (config->baudRate_Bps * 16);
    9360:	9b02      	ldr	r3, [sp, #8]
    9362:	681b      	ldr	r3, [r3, #0]
    9364:	011b      	lsls	r3, r3, #4
    9366:	9a01      	ldr	r2, [sp, #4]
    9368:	fbb2 f3f3 	udiv	r3, r2, r3
    936c:	f8ad 301e 	strh.w	r3, [sp, #30]
    /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
    if (sbr == 0)
    9370:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    9374:	2b00      	cmp	r3, #0
    9376:	d102      	bne.n	937e <UART_Init+0x11e>
    {
        sbr = 1;
    9378:	2301      	movs	r3, #1
    937a:	f8ad 301e 	strh.w	r3, [sp, #30]
    }
#if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    /* Determine if a fractional divider is needed to fine tune closer to the
     * desired baud, each value of brfa is in 1/32 increments,
     * hence the multiply-by-32. */
    uint32_t tempBaud = 0;
    937e:	2300      	movs	r3, #0
    9380:	9305      	str	r3, [sp, #20]

    uint16_t brfa = (2 * srcClock_Hz / (config->baudRate_Bps)) - 32 * sbr;
    9382:	9b01      	ldr	r3, [sp, #4]
    9384:	005a      	lsls	r2, r3, #1
    9386:	9b02      	ldr	r3, [sp, #8]
    9388:	681b      	ldr	r3, [r3, #0]
    938a:	fbb2 f3f3 	udiv	r3, r2, r3
    938e:	b29a      	uxth	r2, r3
    9390:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    9394:	015b      	lsls	r3, r3, #5
    9396:	b29b      	uxth	r3, r3
    9398:	1ad3      	subs	r3, r2, r3
    939a:	f8ad 3012 	strh.w	r3, [sp, #18]

    /* Calculate the baud rate based on the temporary SBR values and BRFA */
    tempBaud = (srcClock_Hz * 2 / ((sbr * 32 + brfa)));
    939e:	9b01      	ldr	r3, [sp, #4]
    93a0:	005b      	lsls	r3, r3, #1
    93a2:	f8bd 201e 	ldrh.w	r2, [sp, #30]
    93a6:	0151      	lsls	r1, r2, #5
    93a8:	f8bd 2012 	ldrh.w	r2, [sp, #18]
    93ac:	440a      	add	r2, r1
    93ae:	fbb3 f3f2 	udiv	r3, r3, r2
    93b2:	9305      	str	r3, [sp, #20]
    baudDiff =
        (tempBaud > config->baudRate_Bps) ? (tempBaud - config->baudRate_Bps) : (config->baudRate_Bps - tempBaud);
    93b4:	9b02      	ldr	r3, [sp, #8]
    93b6:	681a      	ldr	r2, [r3, #0]
    93b8:	9b05      	ldr	r3, [sp, #20]
    93ba:	429a      	cmp	r2, r3
    93bc:	d204      	bcs.n	93c8 <UART_Init+0x168>
    93be:	9b02      	ldr	r3, [sp, #8]
    93c0:	681b      	ldr	r3, [r3, #0]
    93c2:	9a05      	ldr	r2, [sp, #20]
    93c4:	1ad3      	subs	r3, r2, r3
    93c6:	e003      	b.n	93d0 <UART_Init+0x170>
    93c8:	9b02      	ldr	r3, [sp, #8]
    93ca:	681a      	ldr	r2, [r3, #0]
    93cc:	9b05      	ldr	r3, [sp, #20]
    93ce:	1ad3      	subs	r3, r2, r3
    baudDiff =
    93d0:	9306      	str	r3, [sp, #24]
    }
#endif

    /* next, check to see if actual baud rate is within 3% of desired baud rate
     * based on the calculate SBR value */
    if (baudDiff > ((config->baudRate_Bps / 100) * 3))
    93d2:	9b02      	ldr	r3, [sp, #8]
    93d4:	681b      	ldr	r3, [r3, #0]
    93d6:	4a5f      	ldr	r2, [pc, #380]	; (9554 <UART_Init+0x2f4>)
    93d8:	fba2 2303 	umull	r2, r3, r2, r3
    93dc:	095a      	lsrs	r2, r3, #5
    93de:	4613      	mov	r3, r2
    93e0:	005b      	lsls	r3, r3, #1
    93e2:	441a      	add	r2, r3
    93e4:	9b06      	ldr	r3, [sp, #24]
    93e6:	429a      	cmp	r2, r3
    93e8:	d202      	bcs.n	93f0 <UART_Init+0x190>
    {
        /* Unacceptable baud rate difference of more than 3%*/
        return kStatus_UART_BaudrateNotSupport;
    93ea:	f240 33f5 	movw	r3, #1013	; 0x3f5
    93ee:	e094      	b.n	951a <UART_Init+0x2ba>
    }

#if !(defined(FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL) && FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL)
    /* Enable uart clock */
    CLOCK_EnableClock(s_uartClock[UART_GetInstance(base)]);
    93f0:	9803      	ldr	r0, [sp, #12]
    93f2:	f7ff ff05 	bl	9200 <UART_GetInstance>
    93f6:	4602      	mov	r2, r0
    93f8:	4b57      	ldr	r3, [pc, #348]	; (9558 <UART_Init+0x2f8>)
    93fa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    93fe:	4618      	mov	r0, r3
    9400:	f7ff fee8 	bl	91d4 <CLOCK_EnableClock>
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */

    /* Disable UART TX RX before setting. */
    base->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK);
    9404:	9b03      	ldr	r3, [sp, #12]
    9406:	78db      	ldrb	r3, [r3, #3]
    9408:	b2db      	uxtb	r3, r3
    940a:	f023 030c 	bic.w	r3, r3, #12
    940e:	b2da      	uxtb	r2, r3
    9410:	9b03      	ldr	r3, [sp, #12]
    9412:	70da      	strb	r2, [r3, #3]

    /* Write the sbr value to the BDH and BDL registers*/
    base->BDH = (base->BDH & ~UART_BDH_SBR_MASK) | (uint8_t)(sbr >> 8);
    9414:	9b03      	ldr	r3, [sp, #12]
    9416:	781b      	ldrb	r3, [r3, #0]
    9418:	b2db      	uxtb	r3, r3
    941a:	f023 031f 	bic.w	r3, r3, #31
    941e:	b2da      	uxtb	r2, r3
    9420:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    9424:	0a1b      	lsrs	r3, r3, #8
    9426:	b29b      	uxth	r3, r3
    9428:	b2db      	uxtb	r3, r3
    942a:	4313      	orrs	r3, r2
    942c:	b2da      	uxtb	r2, r3
    942e:	9b03      	ldr	r3, [sp, #12]
    9430:	701a      	strb	r2, [r3, #0]
    base->BDL = (uint8_t)sbr;
    9432:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    9436:	b2da      	uxtb	r2, r3
    9438:	9b03      	ldr	r3, [sp, #12]
    943a:	705a      	strb	r2, [r3, #1]

#if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    /* Write the brfa value to the register*/
    base->C4 = (base->C4 & ~UART_C4_BRFA_MASK) | (brfa & UART_C4_BRFA_MASK);
    943c:	9b03      	ldr	r3, [sp, #12]
    943e:	7a9b      	ldrb	r3, [r3, #10]
    9440:	b2db      	uxtb	r3, r3
    9442:	f023 031f 	bic.w	r3, r3, #31
    9446:	b2da      	uxtb	r2, r3
    9448:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    944c:	b2db      	uxtb	r3, r3
    944e:	f003 031f 	and.w	r3, r3, #31
    9452:	b2db      	uxtb	r3, r3
    9454:	4313      	orrs	r3, r2
    9456:	b2da      	uxtb	r2, r3
    9458:	9b03      	ldr	r3, [sp, #12]
    945a:	729a      	strb	r2, [r3, #10]
#endif

    /* Set bit count and parity mode. */
    temp = base->C1 & ~(UART_C1_PE_MASK | UART_C1_PT_MASK | UART_C1_M_MASK);
    945c:	9b03      	ldr	r3, [sp, #12]
    945e:	789b      	ldrb	r3, [r3, #2]
    9460:	b2db      	uxtb	r3, r3
    9462:	f023 0313 	bic.w	r3, r3, #19
    9466:	f88d 301d 	strb.w	r3, [sp, #29]

    if (kUART_ParityDisabled != config->parityMode)
    946a:	9b02      	ldr	r3, [sp, #8]
    946c:	791b      	ldrb	r3, [r3, #4]
    946e:	2b00      	cmp	r3, #0
    9470:	d009      	beq.n	9486 <UART_Init+0x226>
    {
        temp |= (UART_C1_M_MASK | (uint8_t)config->parityMode);
    9472:	9b02      	ldr	r3, [sp, #8]
    9474:	791a      	ldrb	r2, [r3, #4]
    9476:	f89d 301d 	ldrb.w	r3, [sp, #29]
    947a:	4313      	orrs	r3, r2
    947c:	b2db      	uxtb	r3, r3
    947e:	f043 0310 	orr.w	r3, r3, #16
    9482:	f88d 301d 	strb.w	r3, [sp, #29]
    }

    base->C1 = temp;
    9486:	9b03      	ldr	r3, [sp, #12]
    9488:	f89d 201d 	ldrb.w	r2, [sp, #29]
    948c:	709a      	strb	r2, [r3, #2]

#if defined(FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT
    /* Set stop bit per char */
    base->BDH = (base->BDH & ~UART_BDH_SBNS_MASK) | UART_BDH_SBNS((uint8_t)config->stopBitCount);
    948e:	9b03      	ldr	r3, [sp, #12]
    9490:	781b      	ldrb	r3, [r3, #0]
    9492:	b2db      	uxtb	r3, r3
    9494:	f023 0320 	bic.w	r3, r3, #32
    9498:	b2da      	uxtb	r2, r3
    949a:	9b02      	ldr	r3, [sp, #8]
    949c:	795b      	ldrb	r3, [r3, #5]
    949e:	015b      	lsls	r3, r3, #5
    94a0:	b2db      	uxtb	r3, r3
    94a2:	f003 0320 	and.w	r3, r3, #32
    94a6:	b2db      	uxtb	r3, r3
    94a8:	4313      	orrs	r3, r2
    94aa:	b2da      	uxtb	r2, r3
    94ac:	9b03      	ldr	r3, [sp, #12]
    94ae:	701a      	strb	r2, [r3, #0]
#endif

#if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    /* Set tx/rx FIFO watermark */
    base->TWFIFO = config->txFifoWatermark;
    94b0:	9b02      	ldr	r3, [sp, #8]
    94b2:	799a      	ldrb	r2, [r3, #6]
    94b4:	9b03      	ldr	r3, [sp, #12]
    94b6:	74da      	strb	r2, [r3, #19]
    base->RWFIFO = config->rxFifoWatermark;
    94b8:	9b02      	ldr	r3, [sp, #8]
    94ba:	79da      	ldrb	r2, [r3, #7]
    94bc:	9b03      	ldr	r3, [sp, #12]
    94be:	755a      	strb	r2, [r3, #21]

    /* Enable tx/rx FIFO */
    base->PFIFO |= (UART_PFIFO_TXFE_MASK | UART_PFIFO_RXFE_MASK);
    94c0:	9b03      	ldr	r3, [sp, #12]
    94c2:	7c1b      	ldrb	r3, [r3, #16]
    94c4:	b2db      	uxtb	r3, r3
    94c6:	f063 0377 	orn	r3, r3, #119	; 0x77
    94ca:	b2da      	uxtb	r2, r3
    94cc:	9b03      	ldr	r3, [sp, #12]
    94ce:	741a      	strb	r2, [r3, #16]

    /* Flush FIFO */
    base->CFIFO |= (UART_CFIFO_TXFLUSH_MASK | UART_CFIFO_RXFLUSH_MASK);
    94d0:	9b03      	ldr	r3, [sp, #12]
    94d2:	7c5b      	ldrb	r3, [r3, #17]
    94d4:	b2db      	uxtb	r3, r3
    94d6:	f063 033f 	orn	r3, r3, #63	; 0x3f
    94da:	b2da      	uxtb	r2, r3
    94dc:	9b03      	ldr	r3, [sp, #12]
    94de:	745a      	strb	r2, [r3, #17]
#endif

    /* Enable TX/RX base on configure structure. */
    temp = base->C2;
    94e0:	9b03      	ldr	r3, [sp, #12]
    94e2:	78db      	ldrb	r3, [r3, #3]
    94e4:	f88d 301d 	strb.w	r3, [sp, #29]

    if (config->enableTx)
    94e8:	9b02      	ldr	r3, [sp, #8]
    94ea:	7a1b      	ldrb	r3, [r3, #8]
    94ec:	2b00      	cmp	r3, #0
    94ee:	d005      	beq.n	94fc <UART_Init+0x29c>
    {
        temp |= UART_C2_TE_MASK;
    94f0:	f89d 301d 	ldrb.w	r3, [sp, #29]
    94f4:	f043 0308 	orr.w	r3, r3, #8
    94f8:	f88d 301d 	strb.w	r3, [sp, #29]
    }

    if (config->enableRx)
    94fc:	9b02      	ldr	r3, [sp, #8]
    94fe:	7a5b      	ldrb	r3, [r3, #9]
    9500:	2b00      	cmp	r3, #0
    9502:	d005      	beq.n	9510 <UART_Init+0x2b0>
    {
        temp |= UART_C2_RE_MASK;
    9504:	f89d 301d 	ldrb.w	r3, [sp, #29]
    9508:	f043 0304 	orr.w	r3, r3, #4
    950c:	f88d 301d 	strb.w	r3, [sp, #29]
    }

    base->C2 = temp;
    9510:	9b03      	ldr	r3, [sp, #12]
    9512:	f89d 201d 	ldrb.w	r2, [sp, #29]
    9516:	70da      	strb	r2, [r3, #3]

    return kStatus_Success;
    9518:	2300      	movs	r3, #0
}
    951a:	4618      	mov	r0, r3
    951c:	b009      	add	sp, #36	; 0x24
    951e:	f85d fb04 	ldr.w	pc, [sp], #4
    9522:	bf00      	nop
    9524:	000121c4 	.word	0x000121c4
    9528:	000128f8 	.word	0x000128f8
    952c:	0001215c 	.word	0x0001215c
    9530:	000121cc 	.word	0x000121cc
    9534:	4006a000 	.word	0x4006a000
    9538:	4006b000 	.word	0x4006b000
    953c:	4006c000 	.word	0x4006c000
    9540:	4006d000 	.word	0x4006d000
    9544:	400ea000 	.word	0x400ea000
    9548:	400eb000 	.word	0x400eb000
    954c:	000121e4 	.word	0x000121e4
    9550:	00012224 	.word	0x00012224
    9554:	51eb851f 	.word	0x51eb851f
    9558:	000128cc 	.word	0x000128cc

0000955c <UART_GetDefaultConfig>:
    CLOCK_DisableClock(s_uartClock[UART_GetInstance(base)]);
#endif /* FSL_SDK_DISABLE_DRIVER_CLOCK_CONTROL */
}

void UART_GetDefaultConfig(uart_config_t *config)
{
    955c:	b500      	push	{lr}
    955e:	b083      	sub	sp, #12
    9560:	9001      	str	r0, [sp, #4]
    assert(config);
    9562:	9b01      	ldr	r3, [sp, #4]
    9564:	2b00      	cmp	r3, #0
    9566:	d106      	bne.n	9576 <UART_GetDefaultConfig+0x1a>
    9568:	4b10      	ldr	r3, [pc, #64]	; (95ac <UART_GetDefaultConfig+0x50>)
    956a:	4a11      	ldr	r2, [pc, #68]	; (95b0 <UART_GetDefaultConfig+0x54>)
    956c:	f240 115d 	movw	r1, #349	; 0x15d
    9570:	4810      	ldr	r0, [pc, #64]	; (95b4 <UART_GetDefaultConfig+0x58>)
    9572:	f000 fec7 	bl	a304 <__assert_func>

    config->baudRate_Bps = 115200U;
    9576:	9b01      	ldr	r3, [sp, #4]
    9578:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
    957c:	601a      	str	r2, [r3, #0]
    config->parityMode = kUART_ParityDisabled;
    957e:	9b01      	ldr	r3, [sp, #4]
    9580:	2200      	movs	r2, #0
    9582:	711a      	strb	r2, [r3, #4]
#if defined(FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT) && FSL_FEATURE_UART_HAS_STOP_BIT_CONFIG_SUPPORT
    config->stopBitCount = kUART_OneStopBit;
    9584:	9b01      	ldr	r3, [sp, #4]
    9586:	2200      	movs	r2, #0
    9588:	715a      	strb	r2, [r3, #5]
#endif
#if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    config->txFifoWatermark = 0;
    958a:	9b01      	ldr	r3, [sp, #4]
    958c:	2200      	movs	r2, #0
    958e:	719a      	strb	r2, [r3, #6]
    config->rxFifoWatermark = 1;
    9590:	9b01      	ldr	r3, [sp, #4]
    9592:	2201      	movs	r2, #1
    9594:	71da      	strb	r2, [r3, #7]
#endif
    config->enableTx = false;
    9596:	9b01      	ldr	r3, [sp, #4]
    9598:	2200      	movs	r2, #0
    959a:	721a      	strb	r2, [r3, #8]
    config->enableRx = false;
    959c:	9b01      	ldr	r3, [sp, #4]
    959e:	2200      	movs	r2, #0
    95a0:	725a      	strb	r2, [r3, #9]
}
    95a2:	bf00      	nop
    95a4:	b003      	add	sp, #12
    95a6:	f85d fb04 	ldr.w	pc, [sp], #4
    95aa:	bf00      	nop
    95ac:	000121c4 	.word	0x000121c4
    95b0:	00012904 	.word	0x00012904
    95b4:	0001215c 	.word	0x0001215c

000095b8 <UART_SetBaudRate>:

status_t UART_SetBaudRate(UART_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)
{
    95b8:	b500      	push	{lr}
    95ba:	b089      	sub	sp, #36	; 0x24
    95bc:	9003      	str	r0, [sp, #12]
    95be:	9102      	str	r1, [sp, #8]
    95c0:	9201      	str	r2, [sp, #4]
    assert(baudRate_Bps);
    95c2:	9b02      	ldr	r3, [sp, #8]
    95c4:	2b00      	cmp	r3, #0
    95c6:	d106      	bne.n	95d6 <UART_SetBaudRate+0x1e>
    95c8:	4b43      	ldr	r3, [pc, #268]	; (96d8 <UART_SetBaudRate+0x120>)
    95ca:	4a44      	ldr	r2, [pc, #272]	; (96dc <UART_SetBaudRate+0x124>)
    95cc:	f44f 71b7 	mov.w	r1, #366	; 0x16e
    95d0:	4843      	ldr	r0, [pc, #268]	; (96e0 <UART_SetBaudRate+0x128>)
    95d2:	f000 fe97 	bl	a304 <__assert_func>

    uint16_t sbr = 0;
    95d6:	2300      	movs	r3, #0
    95d8:	f8ad 301e 	strh.w	r3, [sp, #30]
    uint32_t baudDiff = 0;
    95dc:	2300      	movs	r3, #0
    95de:	9306      	str	r3, [sp, #24]
    uint8_t oldCtrl;

    /* Calculate the baud rate modulo divisor, sbr*/
    sbr = srcClock_Hz / (baudRate_Bps * 16);
    95e0:	9b02      	ldr	r3, [sp, #8]
    95e2:	011b      	lsls	r3, r3, #4
    95e4:	9a01      	ldr	r2, [sp, #4]
    95e6:	fbb2 f3f3 	udiv	r3, r2, r3
    95ea:	f8ad 301e 	strh.w	r3, [sp, #30]
    /* set sbrTemp to 1 if the sourceClockInHz can not satisfy the desired baud rate */
    if (sbr == 0)
    95ee:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    95f2:	2b00      	cmp	r3, #0
    95f4:	d102      	bne.n	95fc <UART_SetBaudRate+0x44>
    {
        sbr = 1;
    95f6:	2301      	movs	r3, #1
    95f8:	f8ad 301e 	strh.w	r3, [sp, #30]
    }
#if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
    /* Determine if a fractional divider is needed to fine tune closer to the
     * desired baud, each value of brfa is in 1/32 increments,
     * hence the multiply-by-32. */
    uint32_t tempBaud = 0;
    95fc:	2300      	movs	r3, #0
    95fe:	9305      	str	r3, [sp, #20]

    uint16_t brfa = (2 * srcClock_Hz / (baudRate_Bps)) - 32 * sbr;
    9600:	9b01      	ldr	r3, [sp, #4]
    9602:	005a      	lsls	r2, r3, #1
    9604:	9b02      	ldr	r3, [sp, #8]
    9606:	fbb2 f3f3 	udiv	r3, r2, r3
    960a:	b29a      	uxth	r2, r3
    960c:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    9610:	015b      	lsls	r3, r3, #5
    9612:	b29b      	uxth	r3, r3
    9614:	1ad3      	subs	r3, r2, r3
    9616:	f8ad 3012 	strh.w	r3, [sp, #18]

    /* Calculate the baud rate based on the temporary SBR values and BRFA */
    tempBaud = (srcClock_Hz * 2 / ((sbr * 32 + brfa)));
    961a:	9b01      	ldr	r3, [sp, #4]
    961c:	005b      	lsls	r3, r3, #1
    961e:	f8bd 201e 	ldrh.w	r2, [sp, #30]
    9622:	0151      	lsls	r1, r2, #5
    9624:	f8bd 2012 	ldrh.w	r2, [sp, #18]
    9628:	440a      	add	r2, r1
    962a:	fbb3 f3f2 	udiv	r3, r3, r2
    962e:	9305      	str	r3, [sp, #20]
    baudDiff = (tempBaud > baudRate_Bps) ? (tempBaud - baudRate_Bps) : (baudRate_Bps - tempBaud);
    9630:	9a05      	ldr	r2, [sp, #20]
    9632:	9b02      	ldr	r3, [sp, #8]
    9634:	429a      	cmp	r2, r3
    9636:	d903      	bls.n	9640 <UART_SetBaudRate+0x88>
    9638:	9a05      	ldr	r2, [sp, #20]
    963a:	9b02      	ldr	r3, [sp, #8]
    963c:	1ad3      	subs	r3, r2, r3
    963e:	e002      	b.n	9646 <UART_SetBaudRate+0x8e>
    9640:	9a02      	ldr	r2, [sp, #8]
    9642:	9b05      	ldr	r3, [sp, #20]
    9644:	1ad3      	subs	r3, r2, r3
    9646:	9306      	str	r3, [sp, #24]
    }
#endif

    /* next, check to see if actual baud rate is within 3% of desired baud rate
     * based on the calculate SBR value */
    if (baudDiff < ((baudRate_Bps / 100) * 3))
    9648:	9b02      	ldr	r3, [sp, #8]
    964a:	4a26      	ldr	r2, [pc, #152]	; (96e4 <UART_SetBaudRate+0x12c>)
    964c:	fba2 2303 	umull	r2, r3, r2, r3
    9650:	095a      	lsrs	r2, r3, #5
    9652:	4613      	mov	r3, r2
    9654:	005b      	lsls	r3, r3, #1
    9656:	441a      	add	r2, r3
    9658:	9b06      	ldr	r3, [sp, #24]
    965a:	429a      	cmp	r2, r3
    965c:	d935      	bls.n	96ca <UART_SetBaudRate+0x112>
    {
        /* Store C2 before disable Tx and Rx */
        oldCtrl = base->C2;
    965e:	9b03      	ldr	r3, [sp, #12]
    9660:	78db      	ldrb	r3, [r3, #3]
    9662:	f88d 3011 	strb.w	r3, [sp, #17]

        /* Disable UART TX RX before setting. */
        base->C2 &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK);
    9666:	9b03      	ldr	r3, [sp, #12]
    9668:	78db      	ldrb	r3, [r3, #3]
    966a:	b2db      	uxtb	r3, r3
    966c:	f023 030c 	bic.w	r3, r3, #12
    9670:	b2da      	uxtb	r2, r3
    9672:	9b03      	ldr	r3, [sp, #12]
    9674:	70da      	strb	r2, [r3, #3]

        /* Write the sbr value to the BDH and BDL registers*/
        base->BDH = (base->BDH & ~UART_BDH_SBR_MASK) | (uint8_t)(sbr >> 8);
    9676:	9b03      	ldr	r3, [sp, #12]
    9678:	781b      	ldrb	r3, [r3, #0]
    967a:	b2db      	uxtb	r3, r3
    967c:	f023 031f 	bic.w	r3, r3, #31
    9680:	b2da      	uxtb	r2, r3
    9682:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    9686:	0a1b      	lsrs	r3, r3, #8
    9688:	b29b      	uxth	r3, r3
    968a:	b2db      	uxtb	r3, r3
    968c:	4313      	orrs	r3, r2
    968e:	b2da      	uxtb	r2, r3
    9690:	9b03      	ldr	r3, [sp, #12]
    9692:	701a      	strb	r2, [r3, #0]
        base->BDL = (uint8_t)sbr;
    9694:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    9698:	b2da      	uxtb	r2, r3
    969a:	9b03      	ldr	r3, [sp, #12]
    969c:	705a      	strb	r2, [r3, #1]

#if defined(FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT) && FSL_FEATURE_UART_HAS_BAUD_RATE_FINE_ADJUST_SUPPORT
        /* Write the brfa value to the register*/
        base->C4 = (base->C4 & ~UART_C4_BRFA_MASK) | (brfa & UART_C4_BRFA_MASK);
    969e:	9b03      	ldr	r3, [sp, #12]
    96a0:	7a9b      	ldrb	r3, [r3, #10]
    96a2:	b2db      	uxtb	r3, r3
    96a4:	f023 031f 	bic.w	r3, r3, #31
    96a8:	b2da      	uxtb	r2, r3
    96aa:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    96ae:	b2db      	uxtb	r3, r3
    96b0:	f003 031f 	and.w	r3, r3, #31
    96b4:	b2db      	uxtb	r3, r3
    96b6:	4313      	orrs	r3, r2
    96b8:	b2da      	uxtb	r2, r3
    96ba:	9b03      	ldr	r3, [sp, #12]
    96bc:	729a      	strb	r2, [r3, #10]
#endif
        /* Restore C2. */
        base->C2 = oldCtrl;
    96be:	9b03      	ldr	r3, [sp, #12]
    96c0:	f89d 2011 	ldrb.w	r2, [sp, #17]
    96c4:	70da      	strb	r2, [r3, #3]

        return kStatus_Success;
    96c6:	2300      	movs	r3, #0
    96c8:	e001      	b.n	96ce <UART_SetBaudRate+0x116>
    }
    else
    {
        /* Unacceptable baud rate difference of more than 3%*/
        return kStatus_UART_BaudrateNotSupport;
    96ca:	f240 33f5 	movw	r3, #1013	; 0x3f5
    }
}
    96ce:	4618      	mov	r0, r3
    96d0:	b009      	add	sp, #36	; 0x24
    96d2:	f85d fb04 	ldr.w	pc, [sp], #4
    96d6:	bf00      	nop
    96d8:	00012264 	.word	0x00012264
    96dc:	0001291c 	.word	0x0001291c
    96e0:	0001215c 	.word	0x0001215c
    96e4:	51eb851f 	.word	0x51eb851f

000096e8 <UART_GetStatusFlags>:

    return temp & kUART_AllInterruptsEnable;
}

uint32_t UART_GetStatusFlags(UART_Type *base)
{
    96e8:	b084      	sub	sp, #16
    96ea:	9001      	str	r0, [sp, #4]
    uint32_t status_flag;

    status_flag = base->S1 | ((uint32_t)(base->S2) << 8);
    96ec:	9b01      	ldr	r3, [sp, #4]
    96ee:	791b      	ldrb	r3, [r3, #4]
    96f0:	b2db      	uxtb	r3, r3
    96f2:	461a      	mov	r2, r3
    96f4:	9b01      	ldr	r3, [sp, #4]
    96f6:	795b      	ldrb	r3, [r3, #5]
    96f8:	b2db      	uxtb	r3, r3
    96fa:	021b      	lsls	r3, r3, #8
    96fc:	4313      	orrs	r3, r2
    96fe:	9303      	str	r3, [sp, #12]

#if defined(FSL_FEATURE_UART_HAS_EXTENDED_DATA_REGISTER_FLAGS) && FSL_FEATURE_UART_HAS_EXTENDED_DATA_REGISTER_FLAGS
    status_flag |= ((uint32_t)(base->ED) << 16);
    9700:	9b01      	ldr	r3, [sp, #4]
    9702:	7b1b      	ldrb	r3, [r3, #12]
    9704:	b2db      	uxtb	r3, r3
    9706:	041b      	lsls	r3, r3, #16
    9708:	9a03      	ldr	r2, [sp, #12]
    970a:	4313      	orrs	r3, r2
    970c:	9303      	str	r3, [sp, #12]
#endif

#if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    status_flag |= ((uint32_t)(base->SFIFO) << 24);
    970e:	9b01      	ldr	r3, [sp, #4]
    9710:	7c9b      	ldrb	r3, [r3, #18]
    9712:	b2db      	uxtb	r3, r3
    9714:	061b      	lsls	r3, r3, #24
    9716:	9a03      	ldr	r2, [sp, #12]
    9718:	4313      	orrs	r3, r2
    971a:	9303      	str	r3, [sp, #12]
#endif

    return status_flag;
    971c:	9b03      	ldr	r3, [sp, #12]
}
    971e:	4618      	mov	r0, r3
    9720:	b004      	add	sp, #16
    9722:	4770      	bx	lr

00009724 <UART_ClearStatusFlags>:

status_t UART_ClearStatusFlags(UART_Type *base, uint32_t mask)
{
    9724:	b500      	push	{lr}
    9726:	b085      	sub	sp, #20
    9728:	9001      	str	r0, [sp, #4]
    972a:	9100      	str	r1, [sp, #0]
    uint8_t reg = base->S2;
    972c:	9b01      	ldr	r3, [sp, #4]
    972e:	795b      	ldrb	r3, [r3, #5]
    9730:	f88d 300b 	strb.w	r3, [sp, #11]
    status_t status;

#if defined(FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT) && FSL_FEATURE_UART_HAS_LIN_BREAK_DETECT
    reg &= ~(UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK);
    9734:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9738:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    973c:	f88d 300b 	strb.w	r3, [sp, #11]
#else
    reg &= ~UART_S2_RXEDGIF_MASK;
#endif

    base->S2 = reg | (uint8_t)(mask >> 8);
    9740:	9b00      	ldr	r3, [sp, #0]
    9742:	0a1b      	lsrs	r3, r3, #8
    9744:	b2da      	uxtb	r2, r3
    9746:	f89d 300b 	ldrb.w	r3, [sp, #11]
    974a:	4313      	orrs	r3, r2
    974c:	b2da      	uxtb	r2, r3
    974e:	9b01      	ldr	r3, [sp, #4]
    9750:	715a      	strb	r2, [r3, #5]

#if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
    base->SFIFO = (uint8_t)(mask >> 24);
    9752:	9b00      	ldr	r3, [sp, #0]
    9754:	0e1b      	lsrs	r3, r3, #24
    9756:	b2da      	uxtb	r2, r3
    9758:	9b01      	ldr	r3, [sp, #4]
    975a:	749a      	strb	r2, [r3, #18]
#endif

    if (mask & (kUART_IdleLineFlag | kUART_NoiseErrorFlag | kUART_FramingErrorFlag | kUART_ParityErrorFlag))
    975c:	9b00      	ldr	r3, [sp, #0]
    975e:	f003 0317 	and.w	r3, r3, #23
    9762:	2b00      	cmp	r3, #0
    9764:	d003      	beq.n	976e <UART_ClearStatusFlags+0x4a>
    {
        /* Read base->D to clear the flags. */
        (void)base->S1;
    9766:	9b01      	ldr	r3, [sp, #4]
    9768:	791b      	ldrb	r3, [r3, #4]
        (void)base->D;
    976a:	9b01      	ldr	r3, [sp, #4]
    976c:	79db      	ldrb	r3, [r3, #7]
    }

    if (mask & kUART_RxOverrunFlag)
    976e:	9b00      	ldr	r3, [sp, #0]
    9770:	f003 0308 	and.w	r3, r3, #8
    9774:	2b00      	cmp	r3, #0
    9776:	d00b      	beq.n	9790 <UART_ClearStatusFlags+0x6c>
    {
        /* Read base->D to clear the flags and Flush all data in FIFO. */
        (void)base->S1;
    9778:	9b01      	ldr	r3, [sp, #4]
    977a:	791b      	ldrb	r3, [r3, #4]
        (void)base->D;
    977c:	9b01      	ldr	r3, [sp, #4]
    977e:	79db      	ldrb	r3, [r3, #7]
#if defined(FSL_FEATURE_UART_HAS_FIFO) && FSL_FEATURE_UART_HAS_FIFO
        /* Flush FIFO date, otherwise FIFO pointer will be in unknown state. */
        base->CFIFO |= UART_CFIFO_RXFLUSH_MASK;
    9780:	9b01      	ldr	r3, [sp, #4]
    9782:	7c5b      	ldrb	r3, [r3, #17]
    9784:	b2db      	uxtb	r3, r3
    9786:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    978a:	b2da      	uxtb	r2, r3
    978c:	9b01      	ldr	r3, [sp, #4]
    978e:	745a      	strb	r2, [r3, #17]
#endif
    }

    /* If some flags still pending. */
    if (mask & UART_GetStatusFlags(base))
    9790:	9801      	ldr	r0, [sp, #4]
    9792:	f7ff ffa9 	bl	96e8 <UART_GetStatusFlags>
    9796:	4602      	mov	r2, r0
    9798:	9b00      	ldr	r3, [sp, #0]
    979a:	4013      	ands	r3, r2
    979c:	2b00      	cmp	r3, #0
    979e:	d003      	beq.n	97a8 <UART_ClearStatusFlags+0x84>
    {
        /* Some flags can only clear or set by the hardware itself, these flags are: kUART_TxDataRegEmptyFlag,
        kUART_TransmissionCompleteFlag, kUART_RxDataRegFullFlag, kUART_RxActiveFlag, kUART_NoiseErrorInRxDataRegFlag,
        kUART_ParityErrorInRxDataRegFlag, kUART_TxFifoEmptyFlag, kUART_RxFifoEmptyFlag. */
        status = kStatus_UART_FlagCannotClearManually;
    97a0:	f240 33ee 	movw	r3, #1006	; 0x3ee
    97a4:	9303      	str	r3, [sp, #12]
    97a6:	e001      	b.n	97ac <UART_ClearStatusFlags+0x88>
    }
    else
    {
        status = kStatus_Success;
    97a8:	2300      	movs	r3, #0
    97aa:	9303      	str	r3, [sp, #12]
    }

    return status;
    97ac:	9b03      	ldr	r3, [sp, #12]
}
    97ae:	4618      	mov	r0, r3
    97b0:	b005      	add	sp, #20
    97b2:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000097b8 <UART0_DriverIRQHandler>:

#if defined(UART0)
#if ((!(defined(FSL_FEATURE_SOC_LPSCI_COUNT))) || \
     ((defined(FSL_FEATURE_SOC_LPSCI_COUNT)) && (FSL_FEATURE_SOC_LPSCI_COUNT == 0)))
void UART0_DriverIRQHandler(void)
{
    97b8:	b508      	push	{r3, lr}
    s_uartIsr(UART0, s_uartHandle[0]);
    97ba:	4b04      	ldr	r3, [pc, #16]	; (97cc <UART0_DriverIRQHandler+0x14>)
    97bc:	681b      	ldr	r3, [r3, #0]
    97be:	4a04      	ldr	r2, [pc, #16]	; (97d0 <UART0_DriverIRQHandler+0x18>)
    97c0:	6812      	ldr	r2, [r2, #0]
    97c2:	4611      	mov	r1, r2
    97c4:	4803      	ldr	r0, [pc, #12]	; (97d4 <UART0_DriverIRQHandler+0x1c>)
    97c6:	4798      	blx	r3
}
    97c8:	bf00      	nop
    97ca:	bd08      	pop	{r3, pc}
    97cc:	20001534 	.word	0x20001534
    97d0:	2000151c 	.word	0x2000151c
    97d4:	4006a000 	.word	0x4006a000

000097d8 <UART0_RX_TX_DriverIRQHandler>:

void UART0_RX_TX_DriverIRQHandler(void)
{
    97d8:	b508      	push	{r3, lr}
    UART0_DriverIRQHandler();
    97da:	f7ff ffed 	bl	97b8 <UART0_DriverIRQHandler>
}
    97de:	bf00      	nop
    97e0:	bd08      	pop	{r3, pc}
	...

000097e4 <UART1_DriverIRQHandler>:
#endif
#endif

#if defined(UART1)
void UART1_DriverIRQHandler(void)
{
    97e4:	b508      	push	{r3, lr}
    s_uartIsr(UART1, s_uartHandle[1]);
    97e6:	4b04      	ldr	r3, [pc, #16]	; (97f8 <UART1_DriverIRQHandler+0x14>)
    97e8:	681b      	ldr	r3, [r3, #0]
    97ea:	4a04      	ldr	r2, [pc, #16]	; (97fc <UART1_DriverIRQHandler+0x18>)
    97ec:	6852      	ldr	r2, [r2, #4]
    97ee:	4611      	mov	r1, r2
    97f0:	4803      	ldr	r0, [pc, #12]	; (9800 <UART1_DriverIRQHandler+0x1c>)
    97f2:	4798      	blx	r3
}
    97f4:	bf00      	nop
    97f6:	bd08      	pop	{r3, pc}
    97f8:	20001534 	.word	0x20001534
    97fc:	2000151c 	.word	0x2000151c
    9800:	4006b000 	.word	0x4006b000

00009804 <UART1_RX_TX_DriverIRQHandler>:

void UART1_RX_TX_DriverIRQHandler(void)
{
    9804:	b508      	push	{r3, lr}
    UART1_DriverIRQHandler();
    9806:	f7ff ffed 	bl	97e4 <UART1_DriverIRQHandler>
}
    980a:	bf00      	nop
    980c:	bd08      	pop	{r3, pc}
	...

00009810 <UART2_DriverIRQHandler>:
#endif

#if defined(UART2)
void UART2_DriverIRQHandler(void)
{
    9810:	b508      	push	{r3, lr}
    s_uartIsr(UART2, s_uartHandle[2]);
    9812:	4b04      	ldr	r3, [pc, #16]	; (9824 <UART2_DriverIRQHandler+0x14>)
    9814:	681b      	ldr	r3, [r3, #0]
    9816:	4a04      	ldr	r2, [pc, #16]	; (9828 <UART2_DriverIRQHandler+0x18>)
    9818:	6892      	ldr	r2, [r2, #8]
    981a:	4611      	mov	r1, r2
    981c:	4803      	ldr	r0, [pc, #12]	; (982c <UART2_DriverIRQHandler+0x1c>)
    981e:	4798      	blx	r3
}
    9820:	bf00      	nop
    9822:	bd08      	pop	{r3, pc}
    9824:	20001534 	.word	0x20001534
    9828:	2000151c 	.word	0x2000151c
    982c:	4006c000 	.word	0x4006c000

00009830 <UART2_RX_TX_DriverIRQHandler>:

void UART2_RX_TX_DriverIRQHandler(void)
{
    9830:	b508      	push	{r3, lr}
    UART2_DriverIRQHandler();
    9832:	f7ff ffed 	bl	9810 <UART2_DriverIRQHandler>
}
    9836:	bf00      	nop
    9838:	bd08      	pop	{r3, pc}
	...

0000983c <UART3_DriverIRQHandler>:
#endif

#if defined(UART3)
void UART3_DriverIRQHandler(void)
{
    983c:	b508      	push	{r3, lr}
    s_uartIsr(UART3, s_uartHandle[3]);
    983e:	4b04      	ldr	r3, [pc, #16]	; (9850 <UART3_DriverIRQHandler+0x14>)
    9840:	681b      	ldr	r3, [r3, #0]
    9842:	4a04      	ldr	r2, [pc, #16]	; (9854 <UART3_DriverIRQHandler+0x18>)
    9844:	68d2      	ldr	r2, [r2, #12]
    9846:	4611      	mov	r1, r2
    9848:	4803      	ldr	r0, [pc, #12]	; (9858 <UART3_DriverIRQHandler+0x1c>)
    984a:	4798      	blx	r3
}
    984c:	bf00      	nop
    984e:	bd08      	pop	{r3, pc}
    9850:	20001534 	.word	0x20001534
    9854:	2000151c 	.word	0x2000151c
    9858:	4006d000 	.word	0x4006d000

0000985c <UART3_RX_TX_DriverIRQHandler>:

void UART3_RX_TX_DriverIRQHandler(void)
{
    985c:	b508      	push	{r3, lr}
    UART3_DriverIRQHandler();
    985e:	f7ff ffed 	bl	983c <UART3_DriverIRQHandler>
}
    9862:	bf00      	nop
    9864:	bd08      	pop	{r3, pc}
	...

00009868 <UART4_DriverIRQHandler>:
#endif

#if defined(UART4)
void UART4_DriverIRQHandler(void)
{
    9868:	b508      	push	{r3, lr}
    s_uartIsr(UART4, s_uartHandle[4]);
    986a:	4b04      	ldr	r3, [pc, #16]	; (987c <UART4_DriverIRQHandler+0x14>)
    986c:	681b      	ldr	r3, [r3, #0]
    986e:	4a04      	ldr	r2, [pc, #16]	; (9880 <UART4_DriverIRQHandler+0x18>)
    9870:	6912      	ldr	r2, [r2, #16]
    9872:	4611      	mov	r1, r2
    9874:	4803      	ldr	r0, [pc, #12]	; (9884 <UART4_DriverIRQHandler+0x1c>)
    9876:	4798      	blx	r3
}
    9878:	bf00      	nop
    987a:	bd08      	pop	{r3, pc}
    987c:	20001534 	.word	0x20001534
    9880:	2000151c 	.word	0x2000151c
    9884:	400ea000 	.word	0x400ea000

00009888 <UART4_RX_TX_DriverIRQHandler>:

void UART4_RX_TX_DriverIRQHandler(void)
{
    9888:	b508      	push	{r3, lr}
    UART4_DriverIRQHandler();
    988a:	f7ff ffed 	bl	9868 <UART4_DriverIRQHandler>
}
    988e:	bf00      	nop
    9890:	bd08      	pop	{r3, pc}
	...

00009894 <UART5_DriverIRQHandler>:
#endif

#if defined(UART5)
void UART5_DriverIRQHandler(void)
{
    9894:	b508      	push	{r3, lr}
    s_uartIsr(UART5, s_uartHandle[5]);
    9896:	4b04      	ldr	r3, [pc, #16]	; (98a8 <UART5_DriverIRQHandler+0x14>)
    9898:	681b      	ldr	r3, [r3, #0]
    989a:	4a04      	ldr	r2, [pc, #16]	; (98ac <UART5_DriverIRQHandler+0x18>)
    989c:	6952      	ldr	r2, [r2, #20]
    989e:	4611      	mov	r1, r2
    98a0:	4803      	ldr	r0, [pc, #12]	; (98b0 <UART5_DriverIRQHandler+0x1c>)
    98a2:	4798      	blx	r3
}
    98a4:	bf00      	nop
    98a6:	bd08      	pop	{r3, pc}
    98a8:	20001534 	.word	0x20001534
    98ac:	2000151c 	.word	0x2000151c
    98b0:	400eb000 	.word	0x400eb000

000098b4 <UART5_RX_TX_DriverIRQHandler>:

void UART5_RX_TX_DriverIRQHandler(void)
{
    98b4:	b508      	push	{r3, lr}
    UART5_DriverIRQHandler();
    98b6:	f7ff ffed 	bl	9894 <UART5_DriverIRQHandler>
}
    98ba:	bf00      	nop
    98bc:	bd08      	pop	{r3, pc}

000098be <UART_EnableTx>:
 *
 * @param base UART peripheral base address.
 * @param enable True to enable, false to disable.
 */
static inline void UART_EnableTx(UART_Type *base, bool enable)
{
    98be:	b082      	sub	sp, #8
    98c0:	9001      	str	r0, [sp, #4]
    98c2:	460b      	mov	r3, r1
    98c4:	f88d 3003 	strb.w	r3, [sp, #3]
    if (enable)
    98c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
    98cc:	2b00      	cmp	r3, #0
    98ce:	d008      	beq.n	98e2 <UART_EnableTx+0x24>
    {
        base->C2 |= UART_C2_TE_MASK;
    98d0:	9b01      	ldr	r3, [sp, #4]
    98d2:	78db      	ldrb	r3, [r3, #3]
    98d4:	b2db      	uxtb	r3, r3
    98d6:	f043 0308 	orr.w	r3, r3, #8
    98da:	b2da      	uxtb	r2, r3
    98dc:	9b01      	ldr	r3, [sp, #4]
    98de:	70da      	strb	r2, [r3, #3]
    }
    else
    {
        base->C2 &= ~UART_C2_TE_MASK;
    }
}
    98e0:	e007      	b.n	98f2 <UART_EnableTx+0x34>
        base->C2 &= ~UART_C2_TE_MASK;
    98e2:	9b01      	ldr	r3, [sp, #4]
    98e4:	78db      	ldrb	r3, [r3, #3]
    98e6:	b2db      	uxtb	r3, r3
    98e8:	f023 0308 	bic.w	r3, r3, #8
    98ec:	b2da      	uxtb	r2, r3
    98ee:	9b01      	ldr	r3, [sp, #4]
    98f0:	70da      	strb	r2, [r3, #3]
}
    98f2:	bf00      	nop
    98f4:	b002      	add	sp, #8
    98f6:	4770      	bx	lr

000098f8 <UART_EnableRx>:
 *
 * @param base UART peripheral base address.
 * @param enable True to enable, false to disable.
 */
static inline void UART_EnableRx(UART_Type *base, bool enable)
{
    98f8:	b082      	sub	sp, #8
    98fa:	9001      	str	r0, [sp, #4]
    98fc:	460b      	mov	r3, r1
    98fe:	f88d 3003 	strb.w	r3, [sp, #3]
    if (enable)
    9902:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9906:	2b00      	cmp	r3, #0
    9908:	d008      	beq.n	991c <UART_EnableRx+0x24>
    {
        base->C2 |= UART_C2_RE_MASK;
    990a:	9b01      	ldr	r3, [sp, #4]
    990c:	78db      	ldrb	r3, [r3, #3]
    990e:	b2db      	uxtb	r3, r3
    9910:	f043 0304 	orr.w	r3, r3, #4
    9914:	b2da      	uxtb	r2, r3
    9916:	9b01      	ldr	r3, [sp, #4]
    9918:	70da      	strb	r2, [r3, #3]
    }
    else
    {
        base->C2 &= ~UART_C2_RE_MASK;
    }
}
    991a:	e007      	b.n	992c <UART_EnableRx+0x34>
        base->C2 &= ~UART_C2_RE_MASK;
    991c:	9b01      	ldr	r3, [sp, #4]
    991e:	78db      	ldrb	r3, [r3, #3]
    9920:	b2db      	uxtb	r3, r3
    9922:	f023 0304 	bic.w	r3, r3, #4
    9926:	b2da      	uxtb	r2, r3
    9928:	9b01      	ldr	r3, [sp, #4]
    992a:	70da      	strb	r2, [r3, #3]
}
    992c:	bf00      	nop
    992e:	b002      	add	sp, #8
    9930:	4770      	bx	lr

00009932 <UART_WriteByte>:
 *
 * @param base UART peripheral base address.
 * @param data The byte to write.
 */
static inline void UART_WriteByte(UART_Type *base, uint8_t data)
{
    9932:	b082      	sub	sp, #8
    9934:	9001      	str	r0, [sp, #4]
    9936:	460b      	mov	r3, r1
    9938:	f88d 3003 	strb.w	r3, [sp, #3]
    base->D = data;
    993c:	9b01      	ldr	r3, [sp, #4]
    993e:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9942:	71da      	strb	r2, [r3, #7]
}
    9944:	bf00      	nop
    9946:	b002      	add	sp, #8
    9948:	4770      	bx	lr

0000994a <UART_ReadByte>:
 *
 * @param base UART peripheral base address.
 * @return The byte read from UART data register.
 */
static inline uint8_t UART_ReadByte(UART_Type *base)
{
    994a:	b082      	sub	sp, #8
    994c:	9001      	str	r0, [sp, #4]
    return base->D;
    994e:	9b01      	ldr	r3, [sp, #4]
    9950:	79db      	ldrb	r3, [r3, #7]
    9952:	b2db      	uxtb	r3, r3
}
    9954:	4618      	mov	r0, r3
    9956:	b002      	add	sp, #8
    9958:	4770      	bx	lr
	...

0000995c <serial_init>:

int stdio_uart_inited = 0;
serial_t stdio_uart;

void serial_init(serial_t *obj, PinName tx, PinName rx)
{
    995c:	b510      	push	{r4, lr}
    995e:	b08a      	sub	sp, #40	; 0x28
    9960:	9003      	str	r0, [sp, #12]
    9962:	9102      	str	r1, [sp, #8]
    9964:	9201      	str	r2, [sp, #4]
    uint32_t uart_tx = pinmap_peripheral(tx, PinMap_UART_TX);
    9966:	4942      	ldr	r1, [pc, #264]	; (9a70 <serial_init+0x114>)
    9968:	9802      	ldr	r0, [sp, #8]
    996a:	f7f8 fa47 	bl	1dfc <pinmap_peripheral>
    996e:	9009      	str	r0, [sp, #36]	; 0x24
    uint32_t uart_rx = pinmap_peripheral(rx, PinMap_UART_RX);
    9970:	4940      	ldr	r1, [pc, #256]	; (9a74 <serial_init+0x118>)
    9972:	9801      	ldr	r0, [sp, #4]
    9974:	f7f8 fa42 	bl	1dfc <pinmap_peripheral>
    9978:	9008      	str	r0, [sp, #32]
    obj->serial.index = pinmap_merge(uart_tx, uart_rx);
    997a:	9908      	ldr	r1, [sp, #32]
    997c:	9809      	ldr	r0, [sp, #36]	; 0x24
    997e:	f7f8 f9fb 	bl	1d78 <pinmap_merge>
    9982:	4603      	mov	r3, r0
    9984:	461a      	mov	r2, r3
    9986:	9b03      	ldr	r3, [sp, #12]
    9988:	601a      	str	r2, [r3, #0]
    MBED_ASSERT((int)obj->serial.index != NC);
    998a:	9b03      	ldr	r3, [sp, #12]
    998c:	681b      	ldr	r3, [r3, #0]
    998e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    9992:	d104      	bne.n	999e <serial_init+0x42>
    9994:	2237      	movs	r2, #55	; 0x37
    9996:	4938      	ldr	r1, [pc, #224]	; (9a78 <serial_init+0x11c>)
    9998:	4838      	ldr	r0, [pc, #224]	; (9a7c <serial_init+0x120>)
    999a:	f7f9 f82d 	bl	29f8 <mbed_assert_internal>

    uart_config_t config;

    UART_GetDefaultConfig(&config);
    999e:	ab05      	add	r3, sp, #20
    99a0:	4618      	mov	r0, r3
    99a2:	f7ff fddb 	bl	955c <UART_GetDefaultConfig>
    config.baudRate_Bps = 9600;
    99a6:	f44f 5316 	mov.w	r3, #9600	; 0x2580
    99aa:	9305      	str	r3, [sp, #20]
    config.enableTx = false;
    99ac:	2300      	movs	r3, #0
    99ae:	f88d 301c 	strb.w	r3, [sp, #28]
    config.enableRx = false;
    99b2:	2300      	movs	r3, #0
    99b4:	f88d 301d 	strb.w	r3, [sp, #29]

    UART_Init(uart_addrs[obj->serial.index], &config, CLOCK_GetFreq(uart_clocks[obj->serial.index]));
    99b8:	9b03      	ldr	r3, [sp, #12]
    99ba:	681b      	ldr	r3, [r3, #0]
    99bc:	4a30      	ldr	r2, [pc, #192]	; (9a80 <serial_init+0x124>)
    99be:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    99c2:	9b03      	ldr	r3, [sp, #12]
    99c4:	681b      	ldr	r3, [r3, #0]
    99c6:	4a2f      	ldr	r2, [pc, #188]	; (9a84 <serial_init+0x128>)
    99c8:	5cd3      	ldrb	r3, [r2, r3]
    99ca:	4618      	mov	r0, r3
    99cc:	f7fe fcf4 	bl	83b8 <CLOCK_GetFreq>
    99d0:	4602      	mov	r2, r0
    99d2:	ab05      	add	r3, sp, #20
    99d4:	4619      	mov	r1, r3
    99d6:	4620      	mov	r0, r4
    99d8:	f7ff fc42 	bl	9260 <UART_Init>

    pinmap_pinout(tx, PinMap_UART_TX);
    99dc:	4924      	ldr	r1, [pc, #144]	; (9a70 <serial_init+0x114>)
    99de:	9802      	ldr	r0, [sp, #8]
    99e0:	f7f8 f998 	bl	1d14 <pinmap_pinout>
    pinmap_pinout(rx, PinMap_UART_RX);
    99e4:	4923      	ldr	r1, [pc, #140]	; (9a74 <serial_init+0x118>)
    99e6:	9801      	ldr	r0, [sp, #4]
    99e8:	f7f8 f994 	bl	1d14 <pinmap_pinout>

    if (tx != NC) {
    99ec:	9b02      	ldr	r3, [sp, #8]
    99ee:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    99f2:	d00c      	beq.n	9a0e <serial_init+0xb2>
        UART_EnableTx(uart_addrs[obj->serial.index], true);
    99f4:	9b03      	ldr	r3, [sp, #12]
    99f6:	681b      	ldr	r3, [r3, #0]
    99f8:	4a21      	ldr	r2, [pc, #132]	; (9a80 <serial_init+0x124>)
    99fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    99fe:	2101      	movs	r1, #1
    9a00:	4618      	mov	r0, r3
    9a02:	f7ff ff5c 	bl	98be <UART_EnableTx>
        pin_mode(tx, PullUp);
    9a06:	2102      	movs	r1, #2
    9a08:	9802      	ldr	r0, [sp, #8]
    9a0a:	f000 fc11 	bl	a230 <pin_mode>
    }
    if (rx != NC) {
    9a0e:	9b01      	ldr	r3, [sp, #4]
    9a10:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    9a14:	d00c      	beq.n	9a30 <serial_init+0xd4>
        UART_EnableRx(uart_addrs[obj->serial.index], true);
    9a16:	9b03      	ldr	r3, [sp, #12]
    9a18:	681b      	ldr	r3, [r3, #0]
    9a1a:	4a19      	ldr	r2, [pc, #100]	; (9a80 <serial_init+0x124>)
    9a1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a20:	2101      	movs	r1, #1
    9a22:	4618      	mov	r0, r3
    9a24:	f7ff ff68 	bl	98f8 <UART_EnableRx>
        pin_mode(rx, PullUp);
    9a28:	2102      	movs	r1, #2
    9a2a:	9801      	ldr	r0, [sp, #4]
    9a2c:	f000 fc00 	bl	a230 <pin_mode>
    }

    if (obj->serial.index == STDIO_UART) {
    9a30:	9b03      	ldr	r3, [sp, #12]
    9a32:	681b      	ldr	r3, [r3, #0]
    9a34:	2b00      	cmp	r3, #0
    9a36:	d107      	bne.n	9a48 <serial_init+0xec>
        stdio_uart_inited = 1;
    9a38:	4b13      	ldr	r3, [pc, #76]	; (9a88 <serial_init+0x12c>)
    9a3a:	2201      	movs	r2, #1
    9a3c:	601a      	str	r2, [r3, #0]
        memcpy(&stdio_uart, obj, sizeof(serial_t));
    9a3e:	22bc      	movs	r2, #188	; 0xbc
    9a40:	9903      	ldr	r1, [sp, #12]
    9a42:	4812      	ldr	r0, [pc, #72]	; (9a8c <serial_init+0x130>)
    9a44:	f7f6 ff6c 	bl	920 <memcpy>
    }

    obj->serial.uartDmaRx.dmaUsageState = DMA_USAGE_OPPORTUNISTIC;;
    9a48:	9b03      	ldr	r3, [sp, #12]
    9a4a:	2201      	movs	r2, #1
    9a4c:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
    obj->serial.txstate = kUART_TxIdle;
    9a50:	9b03      	ldr	r3, [sp, #12]
    9a52:	2200      	movs	r2, #0
    9a54:	711a      	strb	r2, [r3, #4]
    obj->serial.rxstate = kUART_RxIdle;
    9a56:	9b03      	ldr	r3, [sp, #12]
    9a58:	2202      	movs	r2, #2
    9a5a:	715a      	strb	r2, [r3, #5]

    /* Zero the handle. */
    memset(&(obj->serial.uart_transfer_handle), 0, sizeof(obj->serial.uart_transfer_handle));
    9a5c:	9b03      	ldr	r3, [sp, #12]
    9a5e:	330c      	adds	r3, #12
    9a60:	2230      	movs	r2, #48	; 0x30
    9a62:	2100      	movs	r1, #0
    9a64:	4618      	mov	r0, r3
    9a66:	f001 fd0d 	bl	b484 <memset>
}
    9a6a:	bf00      	nop
    9a6c:	b00a      	add	sp, #40	; 0x28
    9a6e:	bd10      	pop	{r4, pc}
    9a70:	000125f0 	.word	0x000125f0
    9a74:	00012680 	.word	0x00012680
    9a78:	000122b4 	.word	0x000122b4
    9a7c:	0001230c 	.word	0x0001230c
    9a80:	00012930 	.word	0x00012930
    9a84:	00012948 	.word	0x00012948
    9a88:	20001538 	.word	0x20001538
    9a8c:	20002f6c 	.word	0x20002f6c

00009a90 <serial_baud>:
    UART_Deinit(uart_addrs[obj->serial.index]);
    serial_irq_ids[obj->serial.index] = 0;
}

void serial_baud(serial_t *obj, int baudrate)
{
    9a90:	b530      	push	{r4, r5, lr}
    9a92:	b083      	sub	sp, #12
    9a94:	9001      	str	r0, [sp, #4]
    9a96:	9100      	str	r1, [sp, #0]
    UART_SetBaudRate(uart_addrs[obj->serial.index], (uint32_t)baudrate, CLOCK_GetFreq(uart_clocks[obj->serial.index]));
    9a98:	9b01      	ldr	r3, [sp, #4]
    9a9a:	681b      	ldr	r3, [r3, #0]
    9a9c:	4a09      	ldr	r2, [pc, #36]	; (9ac4 <serial_baud+0x34>)
    9a9e:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    9aa2:	9d00      	ldr	r5, [sp, #0]
    9aa4:	9b01      	ldr	r3, [sp, #4]
    9aa6:	681b      	ldr	r3, [r3, #0]
    9aa8:	4a07      	ldr	r2, [pc, #28]	; (9ac8 <serial_baud+0x38>)
    9aaa:	5cd3      	ldrb	r3, [r2, r3]
    9aac:	4618      	mov	r0, r3
    9aae:	f7fe fc83 	bl	83b8 <CLOCK_GetFreq>
    9ab2:	4603      	mov	r3, r0
    9ab4:	461a      	mov	r2, r3
    9ab6:	4629      	mov	r1, r5
    9ab8:	4620      	mov	r0, r4
    9aba:	f7ff fd7d 	bl	95b8 <UART_SetBaudRate>
}
    9abe:	bf00      	nop
    9ac0:	b003      	add	sp, #12
    9ac2:	bd30      	pop	{r4, r5, pc}
    9ac4:	00012930 	.word	0x00012930
    9ac8:	00012948 	.word	0x00012948

00009acc <serial_getc>:
            NVIC_DisableIRQ(uart_irqs[obj->serial.index]);
    }
}

int serial_getc(serial_t *obj)
{
    9acc:	b500      	push	{lr}
    9ace:	b085      	sub	sp, #20
    9ad0:	9001      	str	r0, [sp, #4]
    while (!serial_readable(obj));
    9ad2:	bf00      	nop
    9ad4:	9801      	ldr	r0, [sp, #4]
    9ad6:	f000 f833 	bl	9b40 <serial_readable>
    9ada:	4603      	mov	r3, r0
    9adc:	2b00      	cmp	r3, #0
    9ade:	d0f9      	beq.n	9ad4 <serial_getc+0x8>
    uint8_t data;
    data = UART_ReadByte(uart_addrs[obj->serial.index]);
    9ae0:	9b01      	ldr	r3, [sp, #4]
    9ae2:	681b      	ldr	r3, [r3, #0]
    9ae4:	4a07      	ldr	r2, [pc, #28]	; (9b04 <serial_getc+0x38>)
    9ae6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9aea:	4618      	mov	r0, r3
    9aec:	f7ff ff2d 	bl	994a <UART_ReadByte>
    9af0:	4603      	mov	r3, r0
    9af2:	f88d 300f 	strb.w	r3, [sp, #15]

    return data;
    9af6:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    9afa:	4618      	mov	r0, r3
    9afc:	b005      	add	sp, #20
    9afe:	f85d fb04 	ldr.w	pc, [sp], #4
    9b02:	bf00      	nop
    9b04:	00012930 	.word	0x00012930

00009b08 <serial_putc>:

void serial_putc(serial_t *obj, int c)
{
    9b08:	b500      	push	{lr}
    9b0a:	b083      	sub	sp, #12
    9b0c:	9001      	str	r0, [sp, #4]
    9b0e:	9100      	str	r1, [sp, #0]
    while (!serial_writable(obj));
    9b10:	bf00      	nop
    9b12:	9801      	ldr	r0, [sp, #4]
    9b14:	f000 f838 	bl	9b88 <serial_writable>
    9b18:	4603      	mov	r3, r0
    9b1a:	2b00      	cmp	r3, #0
    9b1c:	d0f9      	beq.n	9b12 <serial_putc+0xa>
    UART_WriteByte(uart_addrs[obj->serial.index], (uint8_t)c);
    9b1e:	9b01      	ldr	r3, [sp, #4]
    9b20:	681b      	ldr	r3, [r3, #0]
    9b22:	4a06      	ldr	r2, [pc, #24]	; (9b3c <serial_putc+0x34>)
    9b24:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b28:	9a00      	ldr	r2, [sp, #0]
    9b2a:	b2d2      	uxtb	r2, r2
    9b2c:	4611      	mov	r1, r2
    9b2e:	4618      	mov	r0, r3
    9b30:	f7ff feff 	bl	9932 <UART_WriteByte>
}
    9b34:	bf00      	nop
    9b36:	b003      	add	sp, #12
    9b38:	f85d fb04 	ldr.w	pc, [sp], #4
    9b3c:	00012930 	.word	0x00012930

00009b40 <serial_readable>:

int serial_readable(serial_t *obj)
{
    9b40:	b500      	push	{lr}
    9b42:	b085      	sub	sp, #20
    9b44:	9001      	str	r0, [sp, #4]
    uint32_t status_flags = UART_GetStatusFlags(uart_addrs[obj->serial.index]);
    9b46:	9b01      	ldr	r3, [sp, #4]
    9b48:	681b      	ldr	r3, [r3, #0]
    9b4a:	4a0e      	ldr	r2, [pc, #56]	; (9b84 <serial_readable+0x44>)
    9b4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b50:	4618      	mov	r0, r3
    9b52:	f7ff fdc9 	bl	96e8 <UART_GetStatusFlags>
    9b56:	9003      	str	r0, [sp, #12]
    if (status_flags & kUART_RxOverrunFlag)
    9b58:	9b03      	ldr	r3, [sp, #12]
    9b5a:	f003 0308 	and.w	r3, r3, #8
    9b5e:	2b00      	cmp	r3, #0
    9b60:	d008      	beq.n	9b74 <serial_readable+0x34>
        UART_ClearStatusFlags(uart_addrs[obj->serial.index], kUART_RxOverrunFlag);
    9b62:	9b01      	ldr	r3, [sp, #4]
    9b64:	681b      	ldr	r3, [r3, #0]
    9b66:	4a07      	ldr	r2, [pc, #28]	; (9b84 <serial_readable+0x44>)
    9b68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b6c:	2108      	movs	r1, #8
    9b6e:	4618      	mov	r0, r3
    9b70:	f7ff fdd8 	bl	9724 <UART_ClearStatusFlags>
    return (status_flags & kUART_RxDataRegFullFlag);
    9b74:	9b03      	ldr	r3, [sp, #12]
    9b76:	f003 0320 	and.w	r3, r3, #32
}
    9b7a:	4618      	mov	r0, r3
    9b7c:	b005      	add	sp, #20
    9b7e:	f85d fb04 	ldr.w	pc, [sp], #4
    9b82:	bf00      	nop
    9b84:	00012930 	.word	0x00012930

00009b88 <serial_writable>:

int serial_writable(serial_t *obj)
{
    9b88:	b500      	push	{lr}
    9b8a:	b085      	sub	sp, #20
    9b8c:	9001      	str	r0, [sp, #4]
    uint32_t status_flags = UART_GetStatusFlags(uart_addrs[obj->serial.index]);
    9b8e:	9b01      	ldr	r3, [sp, #4]
    9b90:	681b      	ldr	r3, [r3, #0]
    9b92:	4a0e      	ldr	r2, [pc, #56]	; (9bcc <serial_writable+0x44>)
    9b94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b98:	4618      	mov	r0, r3
    9b9a:	f7ff fda5 	bl	96e8 <UART_GetStatusFlags>
    9b9e:	9003      	str	r0, [sp, #12]
    if (status_flags & kUART_RxOverrunFlag)
    9ba0:	9b03      	ldr	r3, [sp, #12]
    9ba2:	f003 0308 	and.w	r3, r3, #8
    9ba6:	2b00      	cmp	r3, #0
    9ba8:	d008      	beq.n	9bbc <serial_writable+0x34>
        UART_ClearStatusFlags(uart_addrs[obj->serial.index], kUART_RxOverrunFlag);
    9baa:	9b01      	ldr	r3, [sp, #4]
    9bac:	681b      	ldr	r3, [r3, #0]
    9bae:	4a07      	ldr	r2, [pc, #28]	; (9bcc <serial_writable+0x44>)
    9bb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9bb4:	2108      	movs	r1, #8
    9bb6:	4618      	mov	r0, r3
    9bb8:	f7ff fdb4 	bl	9724 <UART_ClearStatusFlags>
    return (status_flags & kUART_TxDataRegEmptyFlag);
    9bbc:	9b03      	ldr	r3, [sp, #12]
    9bbe:	f003 0380 	and.w	r3, r3, #128	; 0x80
}
    9bc2:	4618      	mov	r0, r3
    9bc4:	b005      	add	sp, #20
    9bc6:	f85d fb04 	ldr.w	pc, [sp], #4
    9bca:	bf00      	nop
    9bcc:	00012930 	.word	0x00012930

00009bd0 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
    9bd0:	b082      	sub	sp, #8
    9bd2:	4603      	mov	r3, r0
    9bd4:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) >= 0)
    9bd8:	f99d 3007 	ldrsb.w	r3, [sp, #7]
    9bdc:	2b00      	cmp	r3, #0
    9bde:	db0c      	blt.n	9bfa <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    9be0:	4907      	ldr	r1, [pc, #28]	; (9c00 <__NVIC_EnableIRQ+0x30>)
    9be2:	f99d 3007 	ldrsb.w	r3, [sp, #7]
    9be6:	095b      	lsrs	r3, r3, #5
    9be8:	f89d 2007 	ldrb.w	r2, [sp, #7]
    9bec:	f002 021f 	and.w	r2, r2, #31
    9bf0:	2001      	movs	r0, #1
    9bf2:	fa00 f202 	lsl.w	r2, r0, r2
    9bf6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
    9bfa:	bf00      	nop
    9bfc:	b002      	add	sp, #8
    9bfe:	4770      	bx	lr
    9c00:	e000e100 	.word	0xe000e100

00009c04 <__NVIC_SetPendingIRQ>:
  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
    9c04:	b082      	sub	sp, #8
    9c06:	4603      	mov	r3, r0
    9c08:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) >= 0)
    9c0c:	f99d 3007 	ldrsb.w	r3, [sp, #7]
    9c10:	2b00      	cmp	r3, #0
    9c12:	db0d      	blt.n	9c30 <__NVIC_SetPendingIRQ+0x2c>
  {
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    9c14:	4908      	ldr	r1, [pc, #32]	; (9c38 <__NVIC_SetPendingIRQ+0x34>)
    9c16:	f99d 3007 	ldrsb.w	r3, [sp, #7]
    9c1a:	095b      	lsrs	r3, r3, #5
    9c1c:	f89d 2007 	ldrb.w	r2, [sp, #7]
    9c20:	f002 021f 	and.w	r2, r2, #31
    9c24:	2001      	movs	r0, #1
    9c26:	fa00 f202 	lsl.w	r2, r0, r2
    9c2a:	3340      	adds	r3, #64	; 0x40
    9c2c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
    9c30:	bf00      	nop
    9c32:	b002      	add	sp, #8
    9c34:	4770      	bx	lr
    9c36:	bf00      	nop
    9c38:	e000e100 	.word	0xe000e100

00009c3c <__NVIC_SetVector>:
           VTOR must been relocated to SRAM before.
  \param [in]   IRQn      Interrupt number
  \param [in]   vector    Address of interrupt handler function
 */
__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
{
    9c3c:	b084      	sub	sp, #16
    9c3e:	4603      	mov	r3, r0
    9c40:	9100      	str	r1, [sp, #0]
    9c42:	f88d 3007 	strb.w	r3, [sp, #7]
  uint32_t *vectors = (uint32_t *)SCB->VTOR;
    9c46:	4b07      	ldr	r3, [pc, #28]	; (9c64 <__NVIC_SetVector+0x28>)
    9c48:	689b      	ldr	r3, [r3, #8]
    9c4a:	9303      	str	r3, [sp, #12]
  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
    9c4c:	f99d 3007 	ldrsb.w	r3, [sp, #7]
    9c50:	3310      	adds	r3, #16
    9c52:	009b      	lsls	r3, r3, #2
    9c54:	9a03      	ldr	r2, [sp, #12]
    9c56:	4413      	add	r3, r2
    9c58:	9a00      	ldr	r2, [sp, #0]
    9c5a:	601a      	str	r2, [r3, #0]
}
    9c5c:	bf00      	nop
    9c5e:	b004      	add	sp, #16
    9c60:	4770      	bx	lr
    9c62:	bf00      	nop
    9c64:	e000ed00 	.word	0xe000ed00

00009c68 <PIT_GetDefaultConfig>:
 *     config->enableRunInDebug = false;
 * @endcode
 * @param config Pointer to the onfiguration structure.
 */
static inline void PIT_GetDefaultConfig(pit_config_t *config)
{
    9c68:	b500      	push	{lr}
    9c6a:	b083      	sub	sp, #12
    9c6c:	9001      	str	r0, [sp, #4]
    assert(config);
    9c6e:	9b01      	ldr	r3, [sp, #4]
    9c70:	2b00      	cmp	r3, #0
    9c72:	d105      	bne.n	9c80 <PIT_GetDefaultConfig+0x18>
    9c74:	4b06      	ldr	r3, [pc, #24]	; (9c90 <PIT_GetDefaultConfig+0x28>)
    9c76:	4a07      	ldr	r2, [pc, #28]	; (9c94 <PIT_GetDefaultConfig+0x2c>)
    9c78:	2181      	movs	r1, #129	; 0x81
    9c7a:	4807      	ldr	r0, [pc, #28]	; (9c98 <PIT_GetDefaultConfig+0x30>)
    9c7c:	f000 fb42 	bl	a304 <__assert_func>

    /* Timers are stopped in Debug mode */
    config->enableRunInDebug = false;
    9c80:	9b01      	ldr	r3, [sp, #4]
    9c82:	2200      	movs	r2, #0
    9c84:	701a      	strb	r2, [r3, #0]
}
    9c86:	bf00      	nop
    9c88:	b003      	add	sp, #12
    9c8a:	f85d fb04 	ldr.w	pc, [sp], #4
    9c8e:	bf00      	nop
    9c90:	0001237c 	.word	0x0001237c
    9c94:	00012958 	.word	0x00012958
    9c98:	00012384 	.word	0x00012384

00009c9c <PIT_SetTimerChainMode>:
 * @param enable  Enable or disable chain.
 *                true:  Current timer is chained with the previous timer.
 *                false: Timer doesn't chain with other timers.
 */
static inline void PIT_SetTimerChainMode(PIT_Type *base, pit_chnl_t channel, bool enable)
{
    9c9c:	b082      	sub	sp, #8
    9c9e:	9001      	str	r0, [sp, #4]
    9ca0:	460b      	mov	r3, r1
    9ca2:	f88d 3003 	strb.w	r3, [sp, #3]
    9ca6:	4613      	mov	r3, r2
    9ca8:	f88d 3002 	strb.w	r3, [sp, #2]
    if (enable)
    9cac:	f89d 3002 	ldrb.w	r3, [sp, #2]
    9cb0:	2b00      	cmp	r3, #0
    9cb2:	d012      	beq.n	9cda <PIT_SetTimerChainMode+0x3e>
    {
        base->CHANNEL[channel].TCTRL |= PIT_TCTRL_CHN_MASK;
    9cb4:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9cb8:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9cbc:	9901      	ldr	r1, [sp, #4]
    9cbe:	0112      	lsls	r2, r2, #4
    9cc0:	440a      	add	r2, r1
    9cc2:	f502 7284 	add.w	r2, r2, #264	; 0x108
    9cc6:	6812      	ldr	r2, [r2, #0]
    9cc8:	f042 0204 	orr.w	r2, r2, #4
    9ccc:	9901      	ldr	r1, [sp, #4]
    9cce:	011b      	lsls	r3, r3, #4
    9cd0:	440b      	add	r3, r1
    9cd2:	f503 7384 	add.w	r3, r3, #264	; 0x108
    9cd6:	601a      	str	r2, [r3, #0]
    }
    else
    {
        base->CHANNEL[channel].TCTRL &= ~PIT_TCTRL_CHN_MASK;
    }
}
    9cd8:	e011      	b.n	9cfe <PIT_SetTimerChainMode+0x62>
        base->CHANNEL[channel].TCTRL &= ~PIT_TCTRL_CHN_MASK;
    9cda:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9cde:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9ce2:	9901      	ldr	r1, [sp, #4]
    9ce4:	0112      	lsls	r2, r2, #4
    9ce6:	440a      	add	r2, r1
    9ce8:	f502 7284 	add.w	r2, r2, #264	; 0x108
    9cec:	6812      	ldr	r2, [r2, #0]
    9cee:	f022 0204 	bic.w	r2, r2, #4
    9cf2:	9901      	ldr	r1, [sp, #4]
    9cf4:	011b      	lsls	r3, r3, #4
    9cf6:	440b      	add	r3, r1
    9cf8:	f503 7384 	add.w	r3, r3, #264	; 0x108
    9cfc:	601a      	str	r2, [r3, #0]
}
    9cfe:	bf00      	nop
    9d00:	b002      	add	sp, #8
    9d02:	4770      	bx	lr

00009d04 <PIT_EnableInterrupts>:
 * @param channel Timer channel number
 * @param mask    The interrupts to enable. This is a logical OR of members of the
 *                enumeration ::pit_interrupt_enable_t
 */
static inline void PIT_EnableInterrupts(PIT_Type *base, pit_chnl_t channel, uint32_t mask)
{
    9d04:	b084      	sub	sp, #16
    9d06:	9003      	str	r0, [sp, #12]
    9d08:	460b      	mov	r3, r1
    9d0a:	9201      	str	r2, [sp, #4]
    9d0c:	f88d 300b 	strb.w	r3, [sp, #11]
    base->CHANNEL[channel].TCTRL |= mask;
    9d10:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9d14:	f89d 200b 	ldrb.w	r2, [sp, #11]
    9d18:	9903      	ldr	r1, [sp, #12]
    9d1a:	0112      	lsls	r2, r2, #4
    9d1c:	440a      	add	r2, r1
    9d1e:	f502 7284 	add.w	r2, r2, #264	; 0x108
    9d22:	6811      	ldr	r1, [r2, #0]
    9d24:	9a01      	ldr	r2, [sp, #4]
    9d26:	430a      	orrs	r2, r1
    9d28:	9903      	ldr	r1, [sp, #12]
    9d2a:	011b      	lsls	r3, r3, #4
    9d2c:	440b      	add	r3, r1
    9d2e:	f503 7384 	add.w	r3, r3, #264	; 0x108
    9d32:	601a      	str	r2, [r3, #0]
}
    9d34:	bf00      	nop
    9d36:	b004      	add	sp, #16
    9d38:	4770      	bx	lr

00009d3a <PIT_DisableInterrupts>:
 * @param channel Timer channel number
 * @param mask    The interrupts to disable. This is a logical OR of members of the
 *                enumeration ::pit_interrupt_enable_t
 */
static inline void PIT_DisableInterrupts(PIT_Type *base, pit_chnl_t channel, uint32_t mask)
{
    9d3a:	b084      	sub	sp, #16
    9d3c:	9003      	str	r0, [sp, #12]
    9d3e:	460b      	mov	r3, r1
    9d40:	9201      	str	r2, [sp, #4]
    9d42:	f88d 300b 	strb.w	r3, [sp, #11]
    base->CHANNEL[channel].TCTRL &= ~mask;
    9d46:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9d4a:	f89d 200b 	ldrb.w	r2, [sp, #11]
    9d4e:	9903      	ldr	r1, [sp, #12]
    9d50:	0112      	lsls	r2, r2, #4
    9d52:	440a      	add	r2, r1
    9d54:	f502 7284 	add.w	r2, r2, #264	; 0x108
    9d58:	6811      	ldr	r1, [r2, #0]
    9d5a:	9a01      	ldr	r2, [sp, #4]
    9d5c:	43d2      	mvns	r2, r2
    9d5e:	400a      	ands	r2, r1
    9d60:	9903      	ldr	r1, [sp, #12]
    9d62:	011b      	lsls	r3, r3, #4
    9d64:	440b      	add	r3, r1
    9d66:	f503 7384 	add.w	r3, r3, #264	; 0x108
    9d6a:	601a      	str	r2, [r3, #0]
}
    9d6c:	bf00      	nop
    9d6e:	b004      	add	sp, #16
    9d70:	4770      	bx	lr

00009d72 <PIT_ClearStatusFlags>:
 * @param channel Timer channel number
 * @param mask    The status flags to clear. This is a logical OR of members of the
 *                enumeration ::pit_status_flags_t
 */
static inline void PIT_ClearStatusFlags(PIT_Type *base, pit_chnl_t channel, uint32_t mask)
{
    9d72:	b084      	sub	sp, #16
    9d74:	9003      	str	r0, [sp, #12]
    9d76:	460b      	mov	r3, r1
    9d78:	9201      	str	r2, [sp, #4]
    9d7a:	f88d 300b 	strb.w	r3, [sp, #11]
    base->CHANNEL[channel].TFLG = mask;
    9d7e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9d82:	9a03      	ldr	r2, [sp, #12]
    9d84:	011b      	lsls	r3, r3, #4
    9d86:	4413      	add	r3, r2
    9d88:	f503 7386 	add.w	r3, r3, #268	; 0x10c
    9d8c:	9a01      	ldr	r2, [sp, #4]
    9d8e:	601a      	str	r2, [r3, #0]
}
    9d90:	bf00      	nop
    9d92:	b004      	add	sp, #16
    9d94:	4770      	bx	lr

00009d96 <PIT_SetTimerPeriod>:
 * @param base    PIT peripheral base address
 * @param channel Timer channel number
 * @param count   Timer period in units of ticks
 */
static inline void PIT_SetTimerPeriod(PIT_Type *base, pit_chnl_t channel, uint32_t count)
{
    9d96:	b084      	sub	sp, #16
    9d98:	9003      	str	r0, [sp, #12]
    9d9a:	460b      	mov	r3, r1
    9d9c:	9201      	str	r2, [sp, #4]
    9d9e:	f88d 300b 	strb.w	r3, [sp, #11]
    base->CHANNEL[channel].LDVAL = count;
    9da2:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9da6:	9a03      	ldr	r2, [sp, #12]
    9da8:	3310      	adds	r3, #16
    9daa:	011b      	lsls	r3, r3, #4
    9dac:	4413      	add	r3, r2
    9dae:	9a01      	ldr	r2, [sp, #4]
    9db0:	601a      	str	r2, [r3, #0]
}
    9db2:	bf00      	nop
    9db4:	b004      	add	sp, #16
    9db6:	4770      	bx	lr

00009db8 <PIT_GetCurrentTimerCount>:
 * @param channel Timer channel number
 *
 * @return Current timer counting value in ticks
 */
static inline uint32_t PIT_GetCurrentTimerCount(PIT_Type *base, pit_chnl_t channel)
{
    9db8:	b082      	sub	sp, #8
    9dba:	9001      	str	r0, [sp, #4]
    9dbc:	460b      	mov	r3, r1
    9dbe:	f88d 3003 	strb.w	r3, [sp, #3]
    return base->CHANNEL[channel].CVAL;
    9dc2:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9dc6:	9a01      	ldr	r2, [sp, #4]
    9dc8:	3310      	adds	r3, #16
    9dca:	011b      	lsls	r3, r3, #4
    9dcc:	4413      	add	r3, r2
    9dce:	3304      	adds	r3, #4
    9dd0:	681b      	ldr	r3, [r3, #0]
}
    9dd2:	4618      	mov	r0, r3
    9dd4:	b002      	add	sp, #8
    9dd6:	4770      	bx	lr

00009dd8 <PIT_StartTimer>:
 *
 * @param base    PIT peripheral base address
 * @param channel Timer channel number.
 */
static inline void PIT_StartTimer(PIT_Type *base, pit_chnl_t channel)
{
    9dd8:	b082      	sub	sp, #8
    9dda:	9001      	str	r0, [sp, #4]
    9ddc:	460b      	mov	r3, r1
    9dde:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CHANNEL[channel].TCTRL |= PIT_TCTRL_TEN_MASK;
    9de2:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9de6:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9dea:	9901      	ldr	r1, [sp, #4]
    9dec:	0112      	lsls	r2, r2, #4
    9dee:	440a      	add	r2, r1
    9df0:	f502 7284 	add.w	r2, r2, #264	; 0x108
    9df4:	6812      	ldr	r2, [r2, #0]
    9df6:	f042 0201 	orr.w	r2, r2, #1
    9dfa:	9901      	ldr	r1, [sp, #4]
    9dfc:	011b      	lsls	r3, r3, #4
    9dfe:	440b      	add	r3, r1
    9e00:	f503 7384 	add.w	r3, r3, #264	; 0x108
    9e04:	601a      	str	r2, [r3, #0]
}
    9e06:	bf00      	nop
    9e08:	b002      	add	sp, #8
    9e0a:	4770      	bx	lr

00009e0c <PIT_StopTimer>:
 *
 * @param base    PIT peripheral base address
 * @param channel Timer channel number.
 */
static inline void PIT_StopTimer(PIT_Type *base, pit_chnl_t channel)
{
    9e0c:	b082      	sub	sp, #8
    9e0e:	9001      	str	r0, [sp, #4]
    9e10:	460b      	mov	r3, r1
    9e12:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CHANNEL[channel].TCTRL &= ~PIT_TCTRL_TEN_MASK;
    9e16:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9e1a:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9e1e:	9901      	ldr	r1, [sp, #4]
    9e20:	0112      	lsls	r2, r2, #4
    9e22:	440a      	add	r2, r1
    9e24:	f502 7284 	add.w	r2, r2, #264	; 0x108
    9e28:	6812      	ldr	r2, [r2, #0]
    9e2a:	f022 0201 	bic.w	r2, r2, #1
    9e2e:	9901      	ldr	r1, [sp, #4]
    9e30:	011b      	lsls	r3, r3, #4
    9e32:	440b      	add	r3, r1
    9e34:	f503 7384 	add.w	r3, r3, #264	; 0x108
    9e38:	601a      	str	r2, [r3, #0]
}
    9e3a:	bf00      	nop
    9e3c:	b002      	add	sp, #8
    9e3e:	4770      	bx	lr

00009e40 <us_ticker_get_info>:
{
    static const ticker_info_t info = {
        1000000,    // 1 MHz
             32     // 32 bit counter
    };
    return &info;
    9e40:	4b01      	ldr	r3, [pc, #4]	; (9e48 <us_ticker_get_info+0x8>)
}
    9e42:	4618      	mov	r0, r3
    9e44:	4770      	bx	lr
    9e46:	bf00      	nop
    9e48:	00012950 	.word	0x00012950

00009e4c <pit_isr>:

static bool us_ticker_inited = false;

static void pit_isr(void)
{
    9e4c:	b508      	push	{r3, lr}
    PIT_ClearStatusFlags(PIT, kPIT_Chnl_3, PIT_TFLG_TIF_MASK);
    9e4e:	2201      	movs	r2, #1
    9e50:	2103      	movs	r1, #3
    9e52:	480a      	ldr	r0, [pc, #40]	; (9e7c <pit_isr+0x30>)
    9e54:	f7ff ff8d 	bl	9d72 <PIT_ClearStatusFlags>
    PIT_ClearStatusFlags(PIT, kPIT_Chnl_2, PIT_TFLG_TIF_MASK);
    9e58:	2201      	movs	r2, #1
    9e5a:	2102      	movs	r1, #2
    9e5c:	4807      	ldr	r0, [pc, #28]	; (9e7c <pit_isr+0x30>)
    9e5e:	f7ff ff88 	bl	9d72 <PIT_ClearStatusFlags>
    PIT_StopTimer(PIT, kPIT_Chnl_2);
    9e62:	2102      	movs	r1, #2
    9e64:	4805      	ldr	r0, [pc, #20]	; (9e7c <pit_isr+0x30>)
    9e66:	f7ff ffd1 	bl	9e0c <PIT_StopTimer>
    PIT_StopTimer(PIT, kPIT_Chnl_3);
    9e6a:	2103      	movs	r1, #3
    9e6c:	4803      	ldr	r0, [pc, #12]	; (9e7c <pit_isr+0x30>)
    9e6e:	f7ff ffcd 	bl	9e0c <PIT_StopTimer>

    us_ticker_irq_handler();
    9e72:	f7f8 fc3b 	bl	26ec <us_ticker_irq_handler>
}
    9e76:	bf00      	nop
    9e78:	bd08      	pop	{r3, pc}
    9e7a:	bf00      	nop
    9e7c:	40037000 	.word	0x40037000

00009e80 <us_ticker_init>:

/** Initialize the high frequency ticker
 *
 */
void us_ticker_init(void)
{
    9e80:	b500      	push	{lr}
    9e82:	b083      	sub	sp, #12
    /* Common for ticker/timer. */
    uint32_t busClock;
    /* Structure to initialize PIT. */
    pit_config_t pitConfig;

    PIT_GetDefaultConfig(&pitConfig);
    9e84:	466b      	mov	r3, sp
    9e86:	4618      	mov	r0, r3
    9e88:	f7ff feee 	bl	9c68 <PIT_GetDefaultConfig>
    PIT_Init(PIT, &pitConfig);
    9e8c:	466b      	mov	r3, sp
    9e8e:	4619      	mov	r1, r3
    9e90:	482b      	ldr	r0, [pc, #172]	; (9f40 <us_ticker_init+0xc0>)
    9e92:	f7ff f8ed 	bl	9070 <PIT_Init>

    busClock = CLOCK_GetFreq(kCLOCK_BusClk);
    9e96:	2002      	movs	r0, #2
    9e98:	f7fe fa8e 	bl	83b8 <CLOCK_GetFreq>
    9e9c:	9001      	str	r0, [sp, #4]

    /* Let the timer to count if re-init. */
    if (!us_ticker_inited) {
    9e9e:	4b29      	ldr	r3, [pc, #164]	; (9f44 <us_ticker_init+0xc4>)
    9ea0:	781b      	ldrb	r3, [r3, #0]
    9ea2:	f083 0301 	eor.w	r3, r3, #1
    9ea6:	b2db      	uxtb	r3, r3
    9ea8:	2b00      	cmp	r3, #0
    9eaa:	d01d      	beq.n	9ee8 <us_ticker_init+0x68>

        PIT_SetTimerPeriod(PIT, kPIT_Chnl_0, busClock / 1000000 - 1);
    9eac:	9b01      	ldr	r3, [sp, #4]
    9eae:	4a26      	ldr	r2, [pc, #152]	; (9f48 <us_ticker_init+0xc8>)
    9eb0:	fba2 2303 	umull	r2, r3, r2, r3
    9eb4:	0c9b      	lsrs	r3, r3, #18
    9eb6:	3b01      	subs	r3, #1
    9eb8:	461a      	mov	r2, r3
    9eba:	2100      	movs	r1, #0
    9ebc:	4820      	ldr	r0, [pc, #128]	; (9f40 <us_ticker_init+0xc0>)
    9ebe:	f7ff ff6a 	bl	9d96 <PIT_SetTimerPeriod>
        PIT_SetTimerPeriod(PIT, kPIT_Chnl_1, 0xFFFFFFFF);
    9ec2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    9ec6:	2101      	movs	r1, #1
    9ec8:	481d      	ldr	r0, [pc, #116]	; (9f40 <us_ticker_init+0xc0>)
    9eca:	f7ff ff64 	bl	9d96 <PIT_SetTimerPeriod>
        PIT_SetTimerChainMode(PIT, kPIT_Chnl_1, true);
    9ece:	2201      	movs	r2, #1
    9ed0:	2101      	movs	r1, #1
    9ed2:	481b      	ldr	r0, [pc, #108]	; (9f40 <us_ticker_init+0xc0>)
    9ed4:	f7ff fee2 	bl	9c9c <PIT_SetTimerChainMode>
        PIT_StartTimer(PIT, kPIT_Chnl_0);
    9ed8:	2100      	movs	r1, #0
    9eda:	4819      	ldr	r0, [pc, #100]	; (9f40 <us_ticker_init+0xc0>)
    9edc:	f7ff ff7c 	bl	9dd8 <PIT_StartTimer>
        PIT_StartTimer(PIT, kPIT_Chnl_1);
    9ee0:	2101      	movs	r1, #1
    9ee2:	4817      	ldr	r0, [pc, #92]	; (9f40 <us_ticker_init+0xc0>)
    9ee4:	f7ff ff78 	bl	9dd8 <PIT_StartTimer>
    }

    /* Configure interrupt generation counters and disable ticker interrupts. */
    PIT_StopTimer(PIT, kPIT_Chnl_3);
    9ee8:	2103      	movs	r1, #3
    9eea:	4815      	ldr	r0, [pc, #84]	; (9f40 <us_ticker_init+0xc0>)
    9eec:	f7ff ff8e 	bl	9e0c <PIT_StopTimer>
    PIT_StopTimer(PIT, kPIT_Chnl_2);
    9ef0:	2102      	movs	r1, #2
    9ef2:	4813      	ldr	r0, [pc, #76]	; (9f40 <us_ticker_init+0xc0>)
    9ef4:	f7ff ff8a 	bl	9e0c <PIT_StopTimer>
    PIT_SetTimerPeriod(PIT, kPIT_Chnl_2, busClock / 1000000 - 1);
    9ef8:	9b01      	ldr	r3, [sp, #4]
    9efa:	4a13      	ldr	r2, [pc, #76]	; (9f48 <us_ticker_init+0xc8>)
    9efc:	fba2 2303 	umull	r2, r3, r2, r3
    9f00:	0c9b      	lsrs	r3, r3, #18
    9f02:	3b01      	subs	r3, #1
    9f04:	461a      	mov	r2, r3
    9f06:	2102      	movs	r1, #2
    9f08:	480d      	ldr	r0, [pc, #52]	; (9f40 <us_ticker_init+0xc0>)
    9f0a:	f7ff ff44 	bl	9d96 <PIT_SetTimerPeriod>
    PIT_SetTimerChainMode(PIT, kPIT_Chnl_3, true);
    9f0e:	2201      	movs	r2, #1
    9f10:	2103      	movs	r1, #3
    9f12:	480b      	ldr	r0, [pc, #44]	; (9f40 <us_ticker_init+0xc0>)
    9f14:	f7ff fec2 	bl	9c9c <PIT_SetTimerChainMode>
    NVIC_SetVector(PIT3_IRQn, (uint32_t) pit_isr);
    9f18:	4b0c      	ldr	r3, [pc, #48]	; (9f4c <us_ticker_init+0xcc>)
    9f1a:	4619      	mov	r1, r3
    9f1c:	2033      	movs	r0, #51	; 0x33
    9f1e:	f7ff fe8d 	bl	9c3c <__NVIC_SetVector>
    NVIC_EnableIRQ(PIT3_IRQn);
    9f22:	2033      	movs	r0, #51	; 0x33
    9f24:	f7ff fe54 	bl	9bd0 <__NVIC_EnableIRQ>
    PIT_DisableInterrupts(PIT, kPIT_Chnl_3, kPIT_TimerInterruptEnable);
    9f28:	2202      	movs	r2, #2
    9f2a:	2103      	movs	r1, #3
    9f2c:	4804      	ldr	r0, [pc, #16]	; (9f40 <us_ticker_init+0xc0>)
    9f2e:	f7ff ff04 	bl	9d3a <PIT_DisableInterrupts>

    us_ticker_inited = true;
    9f32:	4b04      	ldr	r3, [pc, #16]	; (9f44 <us_ticker_init+0xc4>)
    9f34:	2201      	movs	r2, #1
    9f36:	701a      	strb	r2, [r3, #0]
}
    9f38:	bf00      	nop
    9f3a:	b003      	add	sp, #12
    9f3c:	f85d fb04 	ldr.w	pc, [sp], #4
    9f40:	40037000 	.word	0x40037000
    9f44:	2000153c 	.word	0x2000153c
    9f48:	431bde83 	.word	0x431bde83
    9f4c:	00009e4d 	.word	0x00009e4d

00009f50 <us_ticker_read>:
/** Read the current counter
 *
 * @return The current timer's counter value in ticks
 */
uint32_t us_ticker_read()
{
    9f50:	b508      	push	{r3, lr}
    return ~(PIT_GetCurrentTimerCount(PIT, kPIT_Chnl_1));
    9f52:	2101      	movs	r1, #1
    9f54:	4803      	ldr	r0, [pc, #12]	; (9f64 <us_ticker_read+0x14>)
    9f56:	f7ff ff2f 	bl	9db8 <PIT_GetCurrentTimerCount>
    9f5a:	4603      	mov	r3, r0
    9f5c:	43db      	mvns	r3, r3
}
    9f5e:	4618      	mov	r0, r3
    9f60:	bd08      	pop	{r3, pc}
    9f62:	bf00      	nop
    9f64:	40037000 	.word	0x40037000

00009f68 <us_ticker_disable_interrupt>:

/** Disable us ticker interrupt
 *
 */
void us_ticker_disable_interrupt(void)
{
    9f68:	b508      	push	{r3, lr}
    PIT_DisableInterrupts(PIT, kPIT_Chnl_3, kPIT_TimerInterruptEnable);
    9f6a:	2202      	movs	r2, #2
    9f6c:	2103      	movs	r1, #3
    9f6e:	4802      	ldr	r0, [pc, #8]	; (9f78 <us_ticker_disable_interrupt+0x10>)
    9f70:	f7ff fee3 	bl	9d3a <PIT_DisableInterrupts>
}
    9f74:	bf00      	nop
    9f76:	bd08      	pop	{r3, pc}
    9f78:	40037000 	.word	0x40037000

00009f7c <us_ticker_clear_interrupt>:

/** Clear us ticker interrupt
 *
 */
void us_ticker_clear_interrupt(void)
{
    9f7c:	b508      	push	{r3, lr}
    PIT_ClearStatusFlags(PIT, kPIT_Chnl_3, PIT_TFLG_TIF_MASK);
    9f7e:	2201      	movs	r2, #1
    9f80:	2103      	movs	r1, #3
    9f82:	4802      	ldr	r0, [pc, #8]	; (9f8c <us_ticker_clear_interrupt+0x10>)
    9f84:	f7ff fef5 	bl	9d72 <PIT_ClearStatusFlags>
}
    9f88:	bf00      	nop
    9f8a:	bd08      	pop	{r3, pc}
    9f8c:	40037000 	.word	0x40037000

00009f90 <us_ticker_set_interrupt>:
/** Set interrupt for specified timestamp
 *
 * @param timestamp The time in ticks when interrupt should be generated
 */
void us_ticker_set_interrupt(timestamp_t timestamp)
{
    9f90:	b500      	push	{lr}
    9f92:	b085      	sub	sp, #20
    9f94:	9001      	str	r0, [sp, #4]
    /* We get here absolute interrupt time which takes into account counter overflow.
     * Since we use additional count-down timer to generate interrupt we need to calculate
     * load value based on time-stamp.
     */
    const uint32_t now_ticks = us_ticker_read();
    9f96:	f7ff ffdb 	bl	9f50 <us_ticker_read>
    9f9a:	9002      	str	r0, [sp, #8]
    uint32_t delta_ticks =
            timestamp >= now_ticks ? timestamp - now_ticks : (uint32_t)((uint64_t) timestamp + 0xFFFFFFFF - now_ticks);
    9f9c:	9a01      	ldr	r2, [sp, #4]
    9f9e:	9b02      	ldr	r3, [sp, #8]
    9fa0:	429a      	cmp	r2, r3
    9fa2:	d303      	bcc.n	9fac <us_ticker_set_interrupt+0x1c>
    9fa4:	9a01      	ldr	r2, [sp, #4]
    9fa6:	9b02      	ldr	r3, [sp, #8]
    9fa8:	1ad3      	subs	r3, r2, r3
    9faa:	e003      	b.n	9fb4 <us_ticker_set_interrupt+0x24>
    9fac:	9a01      	ldr	r2, [sp, #4]
    9fae:	9b02      	ldr	r3, [sp, #8]
    9fb0:	1ad3      	subs	r3, r2, r3
    9fb2:	3b01      	subs	r3, #1
    uint32_t delta_ticks =
    9fb4:	9303      	str	r3, [sp, #12]

    if (delta_ticks == 0) {
    9fb6:	9b03      	ldr	r3, [sp, #12]
    9fb8:	2b00      	cmp	r3, #0
    9fba:	d101      	bne.n	9fc0 <us_ticker_set_interrupt+0x30>
        /* The requested delay is less than the minimum resolution of this counter. */
        delta_ticks = 1;
    9fbc:	2301      	movs	r3, #1
    9fbe:	9303      	str	r3, [sp, #12]
    }

    PIT_StopTimer(PIT, kPIT_Chnl_3);
    9fc0:	2103      	movs	r1, #3
    9fc2:	480e      	ldr	r0, [pc, #56]	; (9ffc <us_ticker_set_interrupt+0x6c>)
    9fc4:	f7ff ff22 	bl	9e0c <PIT_StopTimer>
    PIT_StopTimer(PIT, kPIT_Chnl_2);
    9fc8:	2102      	movs	r1, #2
    9fca:	480c      	ldr	r0, [pc, #48]	; (9ffc <us_ticker_set_interrupt+0x6c>)
    9fcc:	f7ff ff1e 	bl	9e0c <PIT_StopTimer>
    PIT_SetTimerPeriod(PIT, kPIT_Chnl_3, delta_ticks);
    9fd0:	9a03      	ldr	r2, [sp, #12]
    9fd2:	2103      	movs	r1, #3
    9fd4:	4809      	ldr	r0, [pc, #36]	; (9ffc <us_ticker_set_interrupt+0x6c>)
    9fd6:	f7ff fede 	bl	9d96 <PIT_SetTimerPeriod>
    PIT_EnableInterrupts(PIT, kPIT_Chnl_3, kPIT_TimerInterruptEnable);
    9fda:	2202      	movs	r2, #2
    9fdc:	2103      	movs	r1, #3
    9fde:	4807      	ldr	r0, [pc, #28]	; (9ffc <us_ticker_set_interrupt+0x6c>)
    9fe0:	f7ff fe90 	bl	9d04 <PIT_EnableInterrupts>
    PIT_StartTimer(PIT, kPIT_Chnl_3);
    9fe4:	2103      	movs	r1, #3
    9fe6:	4805      	ldr	r0, [pc, #20]	; (9ffc <us_ticker_set_interrupt+0x6c>)
    9fe8:	f7ff fef6 	bl	9dd8 <PIT_StartTimer>
    PIT_StartTimer(PIT, kPIT_Chnl_2);
    9fec:	2102      	movs	r1, #2
    9fee:	4803      	ldr	r0, [pc, #12]	; (9ffc <us_ticker_set_interrupt+0x6c>)
    9ff0:	f7ff fef2 	bl	9dd8 <PIT_StartTimer>
}
    9ff4:	bf00      	nop
    9ff6:	b005      	add	sp, #20
    9ff8:	f85d fb04 	ldr.w	pc, [sp], #4
    9ffc:	40037000 	.word	0x40037000

0000a000 <us_ticker_fire_interrupt>:

/** Fire us ticker interrupt
 *
 */
void us_ticker_fire_interrupt(void)
{
    a000:	b508      	push	{r3, lr}
    NVIC_SetPendingIRQ(PIT3_IRQn);
    a002:	2033      	movs	r0, #51	; 0x33
    a004:	f7ff fdfe 	bl	9c04 <__NVIC_SetPendingIRQ>
}
    a008:	bf00      	nop
    a00a:	bd08      	pop	{r3, pc}

0000a00c <GPIO_WritePinOutput>:
 * @param output  GPIO pin output logic level.
 *        - 0: corresponding pin output low-logic level.
 *        - 1: corresponding pin output high-logic level.
 */
static inline void GPIO_WritePinOutput(GPIO_Type *base, uint32_t pin, uint8_t output)
{
    a00c:	b084      	sub	sp, #16
    a00e:	9003      	str	r0, [sp, #12]
    a010:	9102      	str	r1, [sp, #8]
    a012:	4613      	mov	r3, r2
    a014:	f88d 3007 	strb.w	r3, [sp, #7]
    if (output == 0U)
    a018:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a01c:	2b00      	cmp	r3, #0
    a01e:	d105      	bne.n	a02c <GPIO_WritePinOutput+0x20>
    {
        base->PCOR = 1U << pin;
    a020:	2201      	movs	r2, #1
    a022:	9b02      	ldr	r3, [sp, #8]
    a024:	409a      	lsls	r2, r3
    a026:	9b03      	ldr	r3, [sp, #12]
    a028:	609a      	str	r2, [r3, #8]
    }
    else
    {
        base->PSOR = 1U << pin;
    }
}
    a02a:	e004      	b.n	a036 <GPIO_WritePinOutput+0x2a>
        base->PSOR = 1U << pin;
    a02c:	2201      	movs	r2, #1
    a02e:	9b02      	ldr	r3, [sp, #8]
    a030:	409a      	lsls	r2, r3
    a032:	9b03      	ldr	r3, [sp, #12]
    a034:	605a      	str	r2, [r3, #4]
}
    a036:	bf00      	nop
    a038:	b004      	add	sp, #16
    a03a:	4770      	bx	lr

0000a03c <gpio_init>:
    pin_function(pin, (int)kPORT_MuxAsGpio);
    return 1 << pin_num;
}

void gpio_init(gpio_t *obj, PinName pin)
{
    a03c:	b500      	push	{lr}
    a03e:	b083      	sub	sp, #12
    a040:	9001      	str	r0, [sp, #4]
    a042:	9100      	str	r1, [sp, #0]
    obj->pin = pin;
    a044:	9b01      	ldr	r3, [sp, #4]
    a046:	9a00      	ldr	r2, [sp, #0]
    a048:	601a      	str	r2, [r3, #0]
    if (pin == (PinName)NC)
    a04a:	9b00      	ldr	r3, [sp, #0]
    a04c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    a050:	d004      	beq.n	a05c <gpio_init+0x20>
        return;

    pin_function(pin, (int)kPORT_MuxAsGpio);
    a052:	2101      	movs	r1, #1
    a054:	9800      	ldr	r0, [sp, #0]
    a056:	f000 f8b5 	bl	a1c4 <pin_function>
    a05a:	e000      	b.n	a05e <gpio_init+0x22>
        return;
    a05c:	bf00      	nop
}
    a05e:	b003      	add	sp, #12
    a060:	f85d fb04 	ldr.w	pc, [sp], #4

0000a064 <gpio_mode>:

void gpio_mode(gpio_t *obj, PinMode mode)
{
    a064:	b500      	push	{lr}
    a066:	b083      	sub	sp, #12
    a068:	9001      	str	r0, [sp, #4]
    a06a:	460b      	mov	r3, r1
    a06c:	f88d 3003 	strb.w	r3, [sp, #3]
    pin_mode(obj->pin, mode);
    a070:	9b01      	ldr	r3, [sp, #4]
    a072:	681b      	ldr	r3, [r3, #0]
    a074:	f89d 2003 	ldrb.w	r2, [sp, #3]
    a078:	4611      	mov	r1, r2
    a07a:	4618      	mov	r0, r3
    a07c:	f000 f8d8 	bl	a230 <pin_mode>
}
    a080:	bf00      	nop
    a082:	b003      	add	sp, #12
    a084:	f85d fb04 	ldr.w	pc, [sp], #4

0000a088 <gpio_dir>:

void gpio_dir(gpio_t *obj, PinDirection direction)
{
    a088:	b500      	push	{lr}
    a08a:	b087      	sub	sp, #28
    a08c:	9001      	str	r0, [sp, #4]
    a08e:	460b      	mov	r3, r1
    a090:	f88d 3003 	strb.w	r3, [sp, #3]
    MBED_ASSERT(obj->pin != (PinName)NC);
    a094:	9b01      	ldr	r3, [sp, #4]
    a096:	681b      	ldr	r3, [r3, #0]
    a098:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    a09c:	d104      	bne.n	a0a8 <gpio_dir+0x20>
    a09e:	2231      	movs	r2, #49	; 0x31
    a0a0:	4918      	ldr	r1, [pc, #96]	; (a104 <gpio_dir+0x7c>)
    a0a2:	4819      	ldr	r0, [pc, #100]	; (a108 <gpio_dir+0x80>)
    a0a4:	f7f8 fca8 	bl	29f8 <mbed_assert_internal>
    uint32_t port = obj->pin >> GPIO_PORT_SHIFT;
    a0a8:	9b01      	ldr	r3, [sp, #4]
    a0aa:	681b      	ldr	r3, [r3, #0]
    a0ac:	131b      	asrs	r3, r3, #12
    a0ae:	9305      	str	r3, [sp, #20]
    uint32_t pin_num = obj->pin & 0xFF;
    a0b0:	9b01      	ldr	r3, [sp, #4]
    a0b2:	681b      	ldr	r3, [r3, #0]
    a0b4:	b2db      	uxtb	r3, r3
    a0b6:	9304      	str	r3, [sp, #16]
    GPIO_Type *base = gpio_addrs[port];
    a0b8:	4a14      	ldr	r2, [pc, #80]	; (a10c <gpio_dir+0x84>)
    a0ba:	9b05      	ldr	r3, [sp, #20]
    a0bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a0c0:	9303      	str	r3, [sp, #12]

    switch (direction) {
    a0c2:	f89d 3003 	ldrb.w	r3, [sp, #3]
    a0c6:	2b00      	cmp	r3, #0
    a0c8:	d002      	beq.n	a0d0 <gpio_dir+0x48>
    a0ca:	2b01      	cmp	r3, #1
    a0cc:	d00b      	beq.n	a0e6 <gpio_dir+0x5e>
            break;
        case PIN_OUTPUT:
            base->PDDR |= (1U << pin_num);
            break;
    }
}
    a0ce:	e014      	b.n	a0fa <gpio_dir+0x72>
            base->PDDR &= ~(1U << pin_num);
    a0d0:	9b03      	ldr	r3, [sp, #12]
    a0d2:	695a      	ldr	r2, [r3, #20]
    a0d4:	2101      	movs	r1, #1
    a0d6:	9b04      	ldr	r3, [sp, #16]
    a0d8:	fa01 f303 	lsl.w	r3, r1, r3
    a0dc:	43db      	mvns	r3, r3
    a0de:	401a      	ands	r2, r3
    a0e0:	9b03      	ldr	r3, [sp, #12]
    a0e2:	615a      	str	r2, [r3, #20]
            break;
    a0e4:	e009      	b.n	a0fa <gpio_dir+0x72>
            base->PDDR |= (1U << pin_num);
    a0e6:	9b03      	ldr	r3, [sp, #12]
    a0e8:	695a      	ldr	r2, [r3, #20]
    a0ea:	2101      	movs	r1, #1
    a0ec:	9b04      	ldr	r3, [sp, #16]
    a0ee:	fa01 f303 	lsl.w	r3, r1, r3
    a0f2:	431a      	orrs	r2, r3
    a0f4:	9b03      	ldr	r3, [sp, #12]
    a0f6:	615a      	str	r2, [r3, #20]
            break;
    a0f8:	bf00      	nop
}
    a0fa:	bf00      	nop
    a0fc:	b007      	add	sp, #28
    a0fe:	f85d fb04 	ldr.w	pc, [sp], #4
    a102:	bf00      	nop
    a104:	000123e0 	.word	0x000123e0
    a108:	00012440 	.word	0x00012440
    a10c:	00012970 	.word	0x00012970

0000a110 <gpio_write>:

void gpio_write(gpio_t *obj, int value)
{
    a110:	b500      	push	{lr}
    a112:	b085      	sub	sp, #20
    a114:	9001      	str	r0, [sp, #4]
    a116:	9100      	str	r1, [sp, #0]
    MBED_ASSERT(obj->pin != (PinName)NC);
    a118:	9b01      	ldr	r3, [sp, #4]
    a11a:	681b      	ldr	r3, [r3, #0]
    a11c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    a120:	d104      	bne.n	a12c <gpio_write+0x1c>
    a122:	2242      	movs	r2, #66	; 0x42
    a124:	490c      	ldr	r1, [pc, #48]	; (a158 <gpio_write+0x48>)
    a126:	480d      	ldr	r0, [pc, #52]	; (a15c <gpio_write+0x4c>)
    a128:	f7f8 fc66 	bl	29f8 <mbed_assert_internal>
    uint32_t port = obj->pin >> GPIO_PORT_SHIFT;
    a12c:	9b01      	ldr	r3, [sp, #4]
    a12e:	681b      	ldr	r3, [r3, #0]
    a130:	131b      	asrs	r3, r3, #12
    a132:	9303      	str	r3, [sp, #12]
    uint32_t pin = obj->pin & 0xFF;
    a134:	9b01      	ldr	r3, [sp, #4]
    a136:	681b      	ldr	r3, [r3, #0]
    a138:	b2db      	uxtb	r3, r3
    a13a:	9302      	str	r3, [sp, #8]

    GPIO_WritePinOutput(gpio_addrs[port], pin, value);
    a13c:	4a08      	ldr	r2, [pc, #32]	; (a160 <gpio_write+0x50>)
    a13e:	9b03      	ldr	r3, [sp, #12]
    a140:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a144:	9a00      	ldr	r2, [sp, #0]
    a146:	b2d2      	uxtb	r2, r2
    a148:	9902      	ldr	r1, [sp, #8]
    a14a:	4618      	mov	r0, r3
    a14c:	f7ff ff5e 	bl	a00c <GPIO_WritePinOutput>
}
    a150:	bf00      	nop
    a152:	b005      	add	sp, #20
    a154:	f85d fb04 	ldr.w	pc, [sp], #4
    a158:	000123e0 	.word	0x000123e0
    a15c:	00012440 	.word	0x00012440
    a160:	00012970 	.word	0x00012970

0000a164 <CLOCK_EnableClock>:
{
    a164:	b084      	sub	sp, #16
    a166:	9001      	str	r0, [sp, #4]
    uint32_t regAddr = SIM_BASE + CLK_GATE_ABSTRACT_REG_OFFSET((uint32_t)name);
    a168:	9b01      	ldr	r3, [sp, #4]
    a16a:	0c1b      	lsrs	r3, r3, #16
    a16c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    a170:	f503 238e 	add.w	r3, r3, #290816	; 0x47000
    a174:	9303      	str	r3, [sp, #12]
    __FSL_CLOCK_SECURE_BITS_SET((volatile uint32_t *) regAddr, (1U << CLK_GATE_ABSTRACT_BITS_SHIFT((uint32_t)name)));
    a176:	9b03      	ldr	r3, [sp, #12]
    a178:	9a03      	ldr	r2, [sp, #12]
    a17a:	6811      	ldr	r1, [r2, #0]
    a17c:	9a01      	ldr	r2, [sp, #4]
    a17e:	b292      	uxth	r2, r2
    a180:	2001      	movs	r0, #1
    a182:	fa00 f202 	lsl.w	r2, r0, r2
    a186:	430a      	orrs	r2, r1
    a188:	601a      	str	r2, [r3, #0]
}
    a18a:	bf00      	nop
    a18c:	b004      	add	sp, #16
    a18e:	4770      	bx	lr

0000a190 <PORT_SetPinMux>:
 *         reset to zero : kPORT_PinDisabledOrAnalog).
 *        This function is recommended to use to reset the pin mux
 *
 */
static inline void PORT_SetPinMux(PORT_Type *base, uint32_t pin, port_mux_t mux)
{
    a190:	b084      	sub	sp, #16
    a192:	9003      	str	r0, [sp, #12]
    a194:	9102      	str	r1, [sp, #8]
    a196:	4613      	mov	r3, r2
    a198:	f88d 3007 	strb.w	r3, [sp, #7]
    base->PCR[pin] = (base->PCR[pin] & ~PORT_PCR_MUX_MASK) | PORT_PCR_MUX(mux);
    a19c:	9b03      	ldr	r3, [sp, #12]
    a19e:	9a02      	ldr	r2, [sp, #8]
    a1a0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    a1a4:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
    a1a8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a1ac:	021b      	lsls	r3, r3, #8
    a1ae:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    a1b2:	ea42 0103 	orr.w	r1, r2, r3
    a1b6:	9b03      	ldr	r3, [sp, #12]
    a1b8:	9a02      	ldr	r2, [sp, #8]
    a1ba:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    a1be:	bf00      	nop
    a1c0:	b004      	add	sp, #16
    a1c2:	4770      	bx	lr

0000a1c4 <pin_function>:

/* Array of PORT peripheral base address. */
static PORT_Type *const port_addrs[] = PORT_BASE_PTRS;

void pin_function(PinName pin, int function)
{
    a1c4:	b530      	push	{r4, r5, lr}
    a1c6:	b089      	sub	sp, #36	; 0x24
    a1c8:	9001      	str	r0, [sp, #4]
    a1ca:	9100      	str	r1, [sp, #0]
    MBED_ASSERT(pin != (PinName)NC);
    a1cc:	9b01      	ldr	r3, [sp, #4]
    a1ce:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    a1d2:	d104      	bne.n	a1de <pin_function+0x1a>
    a1d4:	221a      	movs	r2, #26
    a1d6:	4912      	ldr	r1, [pc, #72]	; (a220 <pin_function+0x5c>)
    a1d8:	4812      	ldr	r0, [pc, #72]	; (a224 <pin_function+0x60>)
    a1da:	f7f8 fc0d 	bl	29f8 <mbed_assert_internal>
    clock_ip_name_t port_clocks[] = PORT_CLOCKS;
    a1de:	4b12      	ldr	r3, [pc, #72]	; (a228 <pin_function+0x64>)
    a1e0:	ac03      	add	r4, sp, #12
    a1e2:	461d      	mov	r5, r3
    a1e4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    a1e6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    a1e8:	682b      	ldr	r3, [r5, #0]
    a1ea:	6023      	str	r3, [r4, #0]

    CLOCK_EnableClock(port_clocks[pin >> GPIO_PORT_SHIFT]);
    a1ec:	9b01      	ldr	r3, [sp, #4]
    a1ee:	131b      	asrs	r3, r3, #12
    a1f0:	009b      	lsls	r3, r3, #2
    a1f2:	aa08      	add	r2, sp, #32
    a1f4:	4413      	add	r3, r2
    a1f6:	f853 3c14 	ldr.w	r3, [r3, #-20]
    a1fa:	4618      	mov	r0, r3
    a1fc:	f7ff ffb2 	bl	a164 <CLOCK_EnableClock>

    PORT_SetPinMux(port_addrs[pin >> GPIO_PORT_SHIFT], pin & 0xFF, (port_mux_t)function);
    a200:	9b01      	ldr	r3, [sp, #4]
    a202:	131b      	asrs	r3, r3, #12
    a204:	4a09      	ldr	r2, [pc, #36]	; (a22c <pin_function+0x68>)
    a206:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a20a:	9a01      	ldr	r2, [sp, #4]
    a20c:	b2d1      	uxtb	r1, r2
    a20e:	9a00      	ldr	r2, [sp, #0]
    a210:	b2d2      	uxtb	r2, r2
    a212:	4618      	mov	r0, r3
    a214:	f7ff ffbc 	bl	a190 <PORT_SetPinMux>
}
    a218:	bf00      	nop
    a21a:	b009      	add	sp, #36	; 0x24
    a21c:	bd30      	pop	{r4, r5, pc}
    a21e:	bf00      	nop
    a220:	00012458 	.word	0x00012458
    a224:	000124a0 	.word	0x000124a0
    a228:	000124b4 	.word	0x000124b4
    a22c:	00012984 	.word	0x00012984

0000a230 <pin_mode>:

void pin_mode(PinName pin, PinMode mode)
{
    a230:	b500      	push	{lr}
    a232:	b087      	sub	sp, #28
    a234:	9001      	str	r0, [sp, #4]
    a236:	460b      	mov	r3, r1
    a238:	f88d 3003 	strb.w	r3, [sp, #3]
    MBED_ASSERT(pin != (PinName)NC);
    a23c:	9b01      	ldr	r3, [sp, #4]
    a23e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    a242:	d104      	bne.n	a24e <pin_mode+0x1e>
    a244:	2224      	movs	r2, #36	; 0x24
    a246:	4920      	ldr	r1, [pc, #128]	; (a2c8 <pin_mode+0x98>)
    a248:	4820      	ldr	r0, [pc, #128]	; (a2cc <pin_mode+0x9c>)
    a24a:	f7f8 fbd5 	bl	29f8 <mbed_assert_internal>
    uint32_t instance = pin >> GPIO_PORT_SHIFT;
    a24e:	9b01      	ldr	r3, [sp, #4]
    a250:	131b      	asrs	r3, r3, #12
    a252:	9304      	str	r3, [sp, #16]
    uint32_t pinName = pin & 0xFF;
    a254:	9b01      	ldr	r3, [sp, #4]
    a256:	b2db      	uxtb	r3, r3
    a258:	9303      	str	r3, [sp, #12]
    PORT_Type *base = port_addrs[instance];
    a25a:	4a1d      	ldr	r2, [pc, #116]	; (a2d0 <pin_mode+0xa0>)
    a25c:	9b04      	ldr	r3, [sp, #16]
    a25e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a262:	9302      	str	r3, [sp, #8]
    uint32_t reg = base->PCR[pinName];
    a264:	9b02      	ldr	r3, [sp, #8]
    a266:	9a03      	ldr	r2, [sp, #12]
    a268:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    a26c:	9305      	str	r3, [sp, #20]

    switch (mode) {
    a26e:	f89d 3003 	ldrb.w	r3, [sp, #3]
    a272:	2b01      	cmp	r3, #1
    a274:	d00b      	beq.n	a28e <pin_mode+0x5e>
    a276:	2b02      	cmp	r3, #2
    a278:	d014      	beq.n	a2a4 <pin_mode+0x74>
    a27a:	2b00      	cmp	r3, #0
    a27c:	d000      	beq.n	a280 <pin_mode+0x50>
            /* Write 0 ISF bit, 1 to the PE & PS bits to enable the pull up configuration */
            reg &= ~(PORT_PCR_ISF_MASK);
            reg |= (PORT_PCR_PE_MASK | PORT_PCR_PS_MASK);
            break;
        default:
            break;
    a27e:	e01a      	b.n	a2b6 <pin_mode+0x86>
            reg &= ~(PORT_PCR_PE_MASK | PORT_PCR_PS_MASK | PORT_PCR_ISF_MASK);
    a280:	9b05      	ldr	r3, [sp, #20]
    a282:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    a286:	f023 0303 	bic.w	r3, r3, #3
    a28a:	9305      	str	r3, [sp, #20]
            break;
    a28c:	e013      	b.n	a2b6 <pin_mode+0x86>
            reg &= ~(PORT_PCR_PS_MASK | PORT_PCR_ISF_MASK);
    a28e:	9b05      	ldr	r3, [sp, #20]
    a290:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    a294:	f023 0301 	bic.w	r3, r3, #1
    a298:	9305      	str	r3, [sp, #20]
            reg |= PORT_PCR_PE_MASK;
    a29a:	9b05      	ldr	r3, [sp, #20]
    a29c:	f043 0302 	orr.w	r3, r3, #2
    a2a0:	9305      	str	r3, [sp, #20]
            break;
    a2a2:	e008      	b.n	a2b6 <pin_mode+0x86>
            reg &= ~(PORT_PCR_ISF_MASK);
    a2a4:	9b05      	ldr	r3, [sp, #20]
    a2a6:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    a2aa:	9305      	str	r3, [sp, #20]
            reg |= (PORT_PCR_PE_MASK | PORT_PCR_PS_MASK);
    a2ac:	9b05      	ldr	r3, [sp, #20]
    a2ae:	f043 0303 	orr.w	r3, r3, #3
    a2b2:	9305      	str	r3, [sp, #20]
            break;
    a2b4:	bf00      	nop
    }

    base->PCR[pinName] = reg;
    a2b6:	9b02      	ldr	r3, [sp, #8]
    a2b8:	9a03      	ldr	r2, [sp, #12]
    a2ba:	9905      	ldr	r1, [sp, #20]
    a2bc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    a2c0:	bf00      	nop
    a2c2:	b007      	add	sp, #28
    a2c4:	f85d fb04 	ldr.w	pc, [sp], #4
    a2c8:	00012458 	.word	0x00012458
    a2cc:	000124a0 	.word	0x000124a0
    a2d0:	00012984 	.word	0x00012984

0000a2d4 <SMC_SetPowerModeProtection>:
 *
 * @param base SMC peripheral base address.
 * @param allowedModes Bitmap of the allowed power modes.
 */
static inline void SMC_SetPowerModeProtection(SMC_Type *base, uint8_t allowedModes)
{
    a2d4:	b082      	sub	sp, #8
    a2d6:	9001      	str	r0, [sp, #4]
    a2d8:	460b      	mov	r3, r1
    a2da:	f88d 3003 	strb.w	r3, [sp, #3]
    base->PMPROT = allowedModes;
    a2de:	9b01      	ldr	r3, [sp, #4]
    a2e0:	f89d 2003 	ldrb.w	r2, [sp, #3]
    a2e4:	701a      	strb	r2, [r3, #0]
}
    a2e6:	bf00      	nop
    a2e8:	b002      	add	sp, #8
    a2ea:	4770      	bx	lr

0000a2ec <hal_sleep>:
#include "cmsis.h"
#include "fsl_smc.h"
#include "fsl_clock_config.h"

void hal_sleep(void)
{
    a2ec:	b508      	push	{r3, lr}
    SMC_SetPowerModeProtection(SMC, kSMC_AllowPowerModeAll);
    a2ee:	212a      	movs	r1, #42	; 0x2a
    a2f0:	4803      	ldr	r0, [pc, #12]	; (a300 <hal_sleep+0x14>)
    a2f2:	f7ff ffef 	bl	a2d4 <SMC_SetPowerModeProtection>

    SMC_SetPowerModeWait(SMC);
    a2f6:	4802      	ldr	r0, [pc, #8]	; (a300 <hal_sleep+0x14>)
    a2f8:	f7fe ff58 	bl	91ac <SMC_SetPowerModeWait>
}
    a2fc:	bf00      	nop
    a2fe:	bd08      	pop	{r3, pc}
    a300:	4007e000 	.word	0x4007e000

0000a304 <__assert_func>:
    a304:	b500      	push	{lr}
    a306:	4c0a      	ldr	r4, [pc, #40]	; (a330 <__assert_func+0x2c>)
    a308:	6826      	ldr	r6, [r4, #0]
    a30a:	4605      	mov	r5, r0
    a30c:	b085      	sub	sp, #20
    a30e:	461c      	mov	r4, r3
    a310:	68f0      	ldr	r0, [r6, #12]
    a312:	b152      	cbz	r2, a32a <__assert_func+0x26>
    a314:	4b07      	ldr	r3, [pc, #28]	; (a334 <__assert_func+0x30>)
    a316:	9202      	str	r2, [sp, #8]
    a318:	e88d 000a 	stmia.w	sp, {r1, r3}
    a31c:	4622      	mov	r2, r4
    a31e:	462b      	mov	r3, r5
    a320:	4905      	ldr	r1, [pc, #20]	; (a338 <__assert_func+0x34>)
    a322:	f000 f9bf 	bl	a6a4 <fiprintf>
    a326:	f004 febd 	bl	f0a4 <abort>
    a32a:	4b04      	ldr	r3, [pc, #16]	; (a33c <__assert_func+0x38>)
    a32c:	461a      	mov	r2, r3
    a32e:	e7f2      	b.n	a316 <__assert_func+0x12>
    a330:	200001c0 	.word	0x200001c0
    a334:	00012998 	.word	0x00012998
    a338:	000129a8 	.word	0x000129a8
    a33c:	000129a4 	.word	0x000129a4

0000a340 <calloc>:
    a340:	4b02      	ldr	r3, [pc, #8]	; (a34c <calloc+0xc>)
    a342:	460a      	mov	r2, r1
    a344:	4601      	mov	r1, r0
    a346:	6818      	ldr	r0, [r3, #0]
    a348:	f7f8 bb2c 	b.w	29a4 <__wrap__calloc_r>
    a34c:	200001c0 	.word	0x200001c0

0000a350 <__errno>:
    a350:	4b01      	ldr	r3, [pc, #4]	; (a358 <__errno+0x8>)
    a352:	6818      	ldr	r0, [r3, #0]
    a354:	4770      	bx	lr
    a356:	bf00      	nop
    a358:	200001c0 	.word	0x200001c0

0000a35c <_fclose_r>:
    a35c:	b570      	push	{r4, r5, r6, lr}
    a35e:	b159      	cbz	r1, a378 <_fclose_r+0x1c>
    a360:	4605      	mov	r5, r0
    a362:	460c      	mov	r4, r1
    a364:	b110      	cbz	r0, a36c <_fclose_r+0x10>
    a366:	6b83      	ldr	r3, [r0, #56]	; 0x38
    a368:	2b00      	cmp	r3, #0
    a36a:	d03c      	beq.n	a3e6 <_fclose_r+0x8a>
    a36c:	6e63      	ldr	r3, [r4, #100]	; 0x64
    a36e:	07d8      	lsls	r0, r3, #31
    a370:	d505      	bpl.n	a37e <_fclose_r+0x22>
    a372:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    a376:	b92b      	cbnz	r3, a384 <_fclose_r+0x28>
    a378:	2600      	movs	r6, #0
    a37a:	4630      	mov	r0, r6
    a37c:	bd70      	pop	{r4, r5, r6, pc}
    a37e:	89a3      	ldrh	r3, [r4, #12]
    a380:	0599      	lsls	r1, r3, #22
    a382:	d53c      	bpl.n	a3fe <_fclose_r+0xa2>
    a384:	4621      	mov	r1, r4
    a386:	4628      	mov	r0, r5
    a388:	f000 f84a 	bl	a420 <__sflush_r>
    a38c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    a38e:	4606      	mov	r6, r0
    a390:	b133      	cbz	r3, a3a0 <_fclose_r+0x44>
    a392:	69e1      	ldr	r1, [r4, #28]
    a394:	4628      	mov	r0, r5
    a396:	4798      	blx	r3
    a398:	2800      	cmp	r0, #0
    a39a:	bfb8      	it	lt
    a39c:	f04f 36ff 	movlt.w	r6, #4294967295	; 0xffffffff
    a3a0:	89a3      	ldrh	r3, [r4, #12]
    a3a2:	061a      	lsls	r2, r3, #24
    a3a4:	d422      	bmi.n	a3ec <_fclose_r+0x90>
    a3a6:	6b21      	ldr	r1, [r4, #48]	; 0x30
    a3a8:	b141      	cbz	r1, a3bc <_fclose_r+0x60>
    a3aa:	f104 0340 	add.w	r3, r4, #64	; 0x40
    a3ae:	4299      	cmp	r1, r3
    a3b0:	d002      	beq.n	a3b8 <_fclose_r+0x5c>
    a3b2:	4628      	mov	r0, r5
    a3b4:	f7f8 faa9 	bl	290a <__wrap__free_r>
    a3b8:	2300      	movs	r3, #0
    a3ba:	6323      	str	r3, [r4, #48]	; 0x30
    a3bc:	6c61      	ldr	r1, [r4, #68]	; 0x44
    a3be:	b121      	cbz	r1, a3ca <_fclose_r+0x6e>
    a3c0:	4628      	mov	r0, r5
    a3c2:	f7f8 faa2 	bl	290a <__wrap__free_r>
    a3c6:	2300      	movs	r3, #0
    a3c8:	6463      	str	r3, [r4, #68]	; 0x44
    a3ca:	f000 f95f 	bl	a68c <__sfp_lock_acquire>
    a3ce:	6e63      	ldr	r3, [r4, #100]	; 0x64
    a3d0:	2200      	movs	r2, #0
    a3d2:	07db      	lsls	r3, r3, #31
    a3d4:	81a2      	strh	r2, [r4, #12]
    a3d6:	d50e      	bpl.n	a3f6 <_fclose_r+0x9a>
    a3d8:	6da0      	ldr	r0, [r4, #88]	; 0x58
    a3da:	f000 fc9b 	bl	ad14 <__retarget_lock_close_recursive>
    a3de:	f000 f95b 	bl	a698 <__sfp_lock_release>
    a3e2:	4630      	mov	r0, r6
    a3e4:	bd70      	pop	{r4, r5, r6, pc}
    a3e6:	f000 f925 	bl	a634 <__sinit>
    a3ea:	e7bf      	b.n	a36c <_fclose_r+0x10>
    a3ec:	6921      	ldr	r1, [r4, #16]
    a3ee:	4628      	mov	r0, r5
    a3f0:	f7f8 fa8b 	bl	290a <__wrap__free_r>
    a3f4:	e7d7      	b.n	a3a6 <_fclose_r+0x4a>
    a3f6:	6da0      	ldr	r0, [r4, #88]	; 0x58
    a3f8:	f000 fc90 	bl	ad1c <__retarget_lock_release_recursive>
    a3fc:	e7ec      	b.n	a3d8 <_fclose_r+0x7c>
    a3fe:	6da0      	ldr	r0, [r4, #88]	; 0x58
    a400:	f000 fc8a 	bl	ad18 <__retarget_lock_acquire_recursive>
    a404:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    a408:	2b00      	cmp	r3, #0
    a40a:	d1bb      	bne.n	a384 <_fclose_r+0x28>
    a40c:	6e66      	ldr	r6, [r4, #100]	; 0x64
    a40e:	f016 0601 	ands.w	r6, r6, #1
    a412:	d1b1      	bne.n	a378 <_fclose_r+0x1c>
    a414:	6da0      	ldr	r0, [r4, #88]	; 0x58
    a416:	f000 fc81 	bl	ad1c <__retarget_lock_release_recursive>
    a41a:	4630      	mov	r0, r6
    a41c:	bd70      	pop	{r4, r5, r6, pc}
    a41e:	bf00      	nop

0000a420 <__sflush_r>:
    a420:	f9b1 300c 	ldrsh.w	r3, [r1, #12]
    a424:	b29a      	uxth	r2, r3
    a426:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a42a:	460d      	mov	r5, r1
    a42c:	0711      	lsls	r1, r2, #28
    a42e:	4680      	mov	r8, r0
    a430:	d43a      	bmi.n	a4a8 <__sflush_r+0x88>
    a432:	686a      	ldr	r2, [r5, #4]
    a434:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
    a438:	2a00      	cmp	r2, #0
    a43a:	81ab      	strh	r3, [r5, #12]
    a43c:	dd6f      	ble.n	a51e <__sflush_r+0xfe>
    a43e:	6aac      	ldr	r4, [r5, #40]	; 0x28
    a440:	2c00      	cmp	r4, #0
    a442:	d049      	beq.n	a4d8 <__sflush_r+0xb8>
    a444:	2200      	movs	r2, #0
    a446:	b29b      	uxth	r3, r3
    a448:	f8d8 6000 	ldr.w	r6, [r8]
    a44c:	f8c8 2000 	str.w	r2, [r8]
    a450:	f413 5280 	ands.w	r2, r3, #4096	; 0x1000
    a454:	d067      	beq.n	a526 <__sflush_r+0x106>
    a456:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    a458:	075f      	lsls	r7, r3, #29
    a45a:	d505      	bpl.n	a468 <__sflush_r+0x48>
    a45c:	6869      	ldr	r1, [r5, #4]
    a45e:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    a460:	1a52      	subs	r2, r2, r1
    a462:	b10b      	cbz	r3, a468 <__sflush_r+0x48>
    a464:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    a466:	1ad2      	subs	r2, r2, r3
    a468:	2300      	movs	r3, #0
    a46a:	69e9      	ldr	r1, [r5, #28]
    a46c:	4640      	mov	r0, r8
    a46e:	47a0      	blx	r4
    a470:	1c44      	adds	r4, r0, #1
    a472:	d03c      	beq.n	a4ee <__sflush_r+0xce>
    a474:	f9b5 300c 	ldrsh.w	r3, [r5, #12]
    a478:	692a      	ldr	r2, [r5, #16]
    a47a:	602a      	str	r2, [r5, #0]
    a47c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    a480:	2200      	movs	r2, #0
    a482:	81ab      	strh	r3, [r5, #12]
    a484:	04db      	lsls	r3, r3, #19
    a486:	606a      	str	r2, [r5, #4]
    a488:	d447      	bmi.n	a51a <__sflush_r+0xfa>
    a48a:	6b29      	ldr	r1, [r5, #48]	; 0x30
    a48c:	f8c8 6000 	str.w	r6, [r8]
    a490:	b311      	cbz	r1, a4d8 <__sflush_r+0xb8>
    a492:	f105 0340 	add.w	r3, r5, #64	; 0x40
    a496:	4299      	cmp	r1, r3
    a498:	d002      	beq.n	a4a0 <__sflush_r+0x80>
    a49a:	4640      	mov	r0, r8
    a49c:	f7f8 fa35 	bl	290a <__wrap__free_r>
    a4a0:	2000      	movs	r0, #0
    a4a2:	6328      	str	r0, [r5, #48]	; 0x30
    a4a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a4a8:	692e      	ldr	r6, [r5, #16]
    a4aa:	b1ae      	cbz	r6, a4d8 <__sflush_r+0xb8>
    a4ac:	682c      	ldr	r4, [r5, #0]
    a4ae:	602e      	str	r6, [r5, #0]
    a4b0:	0791      	lsls	r1, r2, #30
    a4b2:	bf0c      	ite	eq
    a4b4:	696b      	ldreq	r3, [r5, #20]
    a4b6:	2300      	movne	r3, #0
    a4b8:	1ba4      	subs	r4, r4, r6
    a4ba:	60ab      	str	r3, [r5, #8]
    a4bc:	e00a      	b.n	a4d4 <__sflush_r+0xb4>
    a4be:	4623      	mov	r3, r4
    a4c0:	4632      	mov	r2, r6
    a4c2:	6a6f      	ldr	r7, [r5, #36]	; 0x24
    a4c4:	69e9      	ldr	r1, [r5, #28]
    a4c6:	4640      	mov	r0, r8
    a4c8:	47b8      	blx	r7
    a4ca:	2800      	cmp	r0, #0
    a4cc:	eba4 0400 	sub.w	r4, r4, r0
    a4d0:	4406      	add	r6, r0
    a4d2:	dd04      	ble.n	a4de <__sflush_r+0xbe>
    a4d4:	2c00      	cmp	r4, #0
    a4d6:	dcf2      	bgt.n	a4be <__sflush_r+0x9e>
    a4d8:	2000      	movs	r0, #0
    a4da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a4de:	89ab      	ldrh	r3, [r5, #12]
    a4e0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a4e4:	81ab      	strh	r3, [r5, #12]
    a4e6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a4ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a4ee:	f8d8 4000 	ldr.w	r4, [r8]
    a4f2:	2c1d      	cmp	r4, #29
    a4f4:	d8f3      	bhi.n	a4de <__sflush_r+0xbe>
    a4f6:	4b19      	ldr	r3, [pc, #100]	; (a55c <__sflush_r+0x13c>)
    a4f8:	40e3      	lsrs	r3, r4
    a4fa:	43db      	mvns	r3, r3
    a4fc:	f013 0301 	ands.w	r3, r3, #1
    a500:	d1ed      	bne.n	a4de <__sflush_r+0xbe>
    a502:	f9b5 200c 	ldrsh.w	r2, [r5, #12]
    a506:	606b      	str	r3, [r5, #4]
    a508:	f422 6300 	bic.w	r3, r2, #2048	; 0x800
    a50c:	6929      	ldr	r1, [r5, #16]
    a50e:	81ab      	strh	r3, [r5, #12]
    a510:	04da      	lsls	r2, r3, #19
    a512:	6029      	str	r1, [r5, #0]
    a514:	d5b9      	bpl.n	a48a <__sflush_r+0x6a>
    a516:	2c00      	cmp	r4, #0
    a518:	d1b7      	bne.n	a48a <__sflush_r+0x6a>
    a51a:	6528      	str	r0, [r5, #80]	; 0x50
    a51c:	e7b5      	b.n	a48a <__sflush_r+0x6a>
    a51e:	6bea      	ldr	r2, [r5, #60]	; 0x3c
    a520:	2a00      	cmp	r2, #0
    a522:	dc8c      	bgt.n	a43e <__sflush_r+0x1e>
    a524:	e7d8      	b.n	a4d8 <__sflush_r+0xb8>
    a526:	2301      	movs	r3, #1
    a528:	69e9      	ldr	r1, [r5, #28]
    a52a:	4640      	mov	r0, r8
    a52c:	47a0      	blx	r4
    a52e:	1c43      	adds	r3, r0, #1
    a530:	4602      	mov	r2, r0
    a532:	d002      	beq.n	a53a <__sflush_r+0x11a>
    a534:	89ab      	ldrh	r3, [r5, #12]
    a536:	6aac      	ldr	r4, [r5, #40]	; 0x28
    a538:	e78e      	b.n	a458 <__sflush_r+0x38>
    a53a:	f8d8 3000 	ldr.w	r3, [r8]
    a53e:	2b00      	cmp	r3, #0
    a540:	d0f8      	beq.n	a534 <__sflush_r+0x114>
    a542:	2b1d      	cmp	r3, #29
    a544:	d001      	beq.n	a54a <__sflush_r+0x12a>
    a546:	2b16      	cmp	r3, #22
    a548:	d102      	bne.n	a550 <__sflush_r+0x130>
    a54a:	f8c8 6000 	str.w	r6, [r8]
    a54e:	e7c3      	b.n	a4d8 <__sflush_r+0xb8>
    a550:	89ab      	ldrh	r3, [r5, #12]
    a552:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a556:	81ab      	strh	r3, [r5, #12]
    a558:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a55c:	20400001 	.word	0x20400001

0000a560 <_fflush_r>:
    a560:	b538      	push	{r3, r4, r5, lr}
    a562:	460d      	mov	r5, r1
    a564:	4604      	mov	r4, r0
    a566:	b108      	cbz	r0, a56c <_fflush_r+0xc>
    a568:	6b83      	ldr	r3, [r0, #56]	; 0x38
    a56a:	b1bb      	cbz	r3, a59c <_fflush_r+0x3c>
    a56c:	f9b5 000c 	ldrsh.w	r0, [r5, #12]
    a570:	b188      	cbz	r0, a596 <_fflush_r+0x36>
    a572:	6e6b      	ldr	r3, [r5, #100]	; 0x64
    a574:	07db      	lsls	r3, r3, #31
    a576:	d401      	bmi.n	a57c <_fflush_r+0x1c>
    a578:	0581      	lsls	r1, r0, #22
    a57a:	d517      	bpl.n	a5ac <_fflush_r+0x4c>
    a57c:	4620      	mov	r0, r4
    a57e:	4629      	mov	r1, r5
    a580:	f7ff ff4e 	bl	a420 <__sflush_r>
    a584:	6e6b      	ldr	r3, [r5, #100]	; 0x64
    a586:	07da      	lsls	r2, r3, #31
    a588:	4604      	mov	r4, r0
    a58a:	d402      	bmi.n	a592 <_fflush_r+0x32>
    a58c:	89ab      	ldrh	r3, [r5, #12]
    a58e:	059b      	lsls	r3, r3, #22
    a590:	d507      	bpl.n	a5a2 <_fflush_r+0x42>
    a592:	4620      	mov	r0, r4
    a594:	bd38      	pop	{r3, r4, r5, pc}
    a596:	4604      	mov	r4, r0
    a598:	4620      	mov	r0, r4
    a59a:	bd38      	pop	{r3, r4, r5, pc}
    a59c:	f000 f84a 	bl	a634 <__sinit>
    a5a0:	e7e4      	b.n	a56c <_fflush_r+0xc>
    a5a2:	6da8      	ldr	r0, [r5, #88]	; 0x58
    a5a4:	f000 fbba 	bl	ad1c <__retarget_lock_release_recursive>
    a5a8:	4620      	mov	r0, r4
    a5aa:	bd38      	pop	{r3, r4, r5, pc}
    a5ac:	6da8      	ldr	r0, [r5, #88]	; 0x58
    a5ae:	f000 fbb3 	bl	ad18 <__retarget_lock_acquire_recursive>
    a5b2:	e7e3      	b.n	a57c <_fflush_r+0x1c>

0000a5b4 <fflush>:
    a5b4:	b120      	cbz	r0, a5c0 <fflush+0xc>
    a5b6:	4b05      	ldr	r3, [pc, #20]	; (a5cc <fflush+0x18>)
    a5b8:	4601      	mov	r1, r0
    a5ba:	6818      	ldr	r0, [r3, #0]
    a5bc:	f7ff bfd0 	b.w	a560 <_fflush_r>
    a5c0:	4b03      	ldr	r3, [pc, #12]	; (a5d0 <fflush+0x1c>)
    a5c2:	4904      	ldr	r1, [pc, #16]	; (a5d4 <fflush+0x20>)
    a5c4:	6818      	ldr	r0, [r3, #0]
    a5c6:	f000 bb43 	b.w	ac50 <_fwalk_reent>
    a5ca:	bf00      	nop
    a5cc:	200001c0 	.word	0x200001c0
    a5d0:	000129d8 	.word	0x000129d8
    a5d4:	0000a561 	.word	0x0000a561

0000a5d8 <_cleanup_r>:
    a5d8:	4901      	ldr	r1, [pc, #4]	; (a5e0 <_cleanup_r+0x8>)
    a5da:	f000 bb39 	b.w	ac50 <_fwalk_reent>
    a5de:	bf00      	nop
    a5e0:	0000a35d 	.word	0x0000a35d

0000a5e4 <std.isra.0>:
    a5e4:	b510      	push	{r4, lr}
    a5e6:	2300      	movs	r3, #0
    a5e8:	4604      	mov	r4, r0
    a5ea:	8181      	strh	r1, [r0, #12]
    a5ec:	81c2      	strh	r2, [r0, #14]
    a5ee:	6003      	str	r3, [r0, #0]
    a5f0:	6043      	str	r3, [r0, #4]
    a5f2:	6083      	str	r3, [r0, #8]
    a5f4:	6643      	str	r3, [r0, #100]	; 0x64
    a5f6:	6103      	str	r3, [r0, #16]
    a5f8:	6143      	str	r3, [r0, #20]
    a5fa:	6183      	str	r3, [r0, #24]
    a5fc:	4619      	mov	r1, r3
    a5fe:	2208      	movs	r2, #8
    a600:	305c      	adds	r0, #92	; 0x5c
    a602:	f000 ff3f 	bl	b484 <memset>
    a606:	4807      	ldr	r0, [pc, #28]	; (a624 <std.isra.0+0x40>)
    a608:	4907      	ldr	r1, [pc, #28]	; (a628 <std.isra.0+0x44>)
    a60a:	4a08      	ldr	r2, [pc, #32]	; (a62c <std.isra.0+0x48>)
    a60c:	4b08      	ldr	r3, [pc, #32]	; (a630 <std.isra.0+0x4c>)
    a60e:	6220      	str	r0, [r4, #32]
    a610:	61e4      	str	r4, [r4, #28]
    a612:	6261      	str	r1, [r4, #36]	; 0x24
    a614:	62a2      	str	r2, [r4, #40]	; 0x28
    a616:	62e3      	str	r3, [r4, #44]	; 0x2c
    a618:	f104 0058 	add.w	r0, r4, #88	; 0x58
    a61c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    a620:	f000 bb76 	b.w	ad10 <__retarget_lock_init_recursive>
    a624:	0000b56d 	.word	0x0000b56d
    a628:	0000b591 	.word	0x0000b591
    a62c:	0000b5cd 	.word	0x0000b5cd
    a630:	0000b5ed 	.word	0x0000b5ed

0000a634 <__sinit>:
    a634:	b510      	push	{r4, lr}
    a636:	4604      	mov	r4, r0
    a638:	4812      	ldr	r0, [pc, #72]	; (a684 <__sinit+0x50>)
    a63a:	f000 fb6d 	bl	ad18 <__retarget_lock_acquire_recursive>
    a63e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    a640:	b9d2      	cbnz	r2, a678 <__sinit+0x44>
    a642:	f504 733b 	add.w	r3, r4, #748	; 0x2ec
    a646:	4810      	ldr	r0, [pc, #64]	; (a688 <__sinit+0x54>)
    a648:	f8c4 32e8 	str.w	r3, [r4, #744]	; 0x2e8
    a64c:	2103      	movs	r1, #3
    a64e:	f8c4 22e0 	str.w	r2, [r4, #736]	; 0x2e0
    a652:	63e0      	str	r0, [r4, #60]	; 0x3c
    a654:	f8c4 12e4 	str.w	r1, [r4, #740]	; 0x2e4
    a658:	6860      	ldr	r0, [r4, #4]
    a65a:	2104      	movs	r1, #4
    a65c:	f7ff ffc2 	bl	a5e4 <std.isra.0>
    a660:	2201      	movs	r2, #1
    a662:	2109      	movs	r1, #9
    a664:	68a0      	ldr	r0, [r4, #8]
    a666:	f7ff ffbd 	bl	a5e4 <std.isra.0>
    a66a:	2202      	movs	r2, #2
    a66c:	2112      	movs	r1, #18
    a66e:	68e0      	ldr	r0, [r4, #12]
    a670:	f7ff ffb8 	bl	a5e4 <std.isra.0>
    a674:	2301      	movs	r3, #1
    a676:	63a3      	str	r3, [r4, #56]	; 0x38
    a678:	4802      	ldr	r0, [pc, #8]	; (a684 <__sinit+0x50>)
    a67a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    a67e:	f000 bb4d 	b.w	ad1c <__retarget_lock_release_recursive>
    a682:	bf00      	nop
    a684:	20003028 	.word	0x20003028
    a688:	0000a5d9 	.word	0x0000a5d9

0000a68c <__sfp_lock_acquire>:
    a68c:	4801      	ldr	r0, [pc, #4]	; (a694 <__sfp_lock_acquire+0x8>)
    a68e:	f000 bb43 	b.w	ad18 <__retarget_lock_acquire_recursive>
    a692:	bf00      	nop
    a694:	20003034 	.word	0x20003034

0000a698 <__sfp_lock_release>:
    a698:	4801      	ldr	r0, [pc, #4]	; (a6a0 <__sfp_lock_release+0x8>)
    a69a:	f000 bb3f 	b.w	ad1c <__retarget_lock_release_recursive>
    a69e:	bf00      	nop
    a6a0:	20003034 	.word	0x20003034

0000a6a4 <fiprintf>:
    a6a4:	b40e      	push	{r1, r2, r3}
    a6a6:	b510      	push	{r4, lr}
    a6a8:	b083      	sub	sp, #12
    a6aa:	ab05      	add	r3, sp, #20
    a6ac:	4c06      	ldr	r4, [pc, #24]	; (a6c8 <fiprintf+0x24>)
    a6ae:	f853 2b04 	ldr.w	r2, [r3], #4
    a6b2:	9301      	str	r3, [sp, #4]
    a6b4:	4601      	mov	r1, r0
    a6b6:	6820      	ldr	r0, [r4, #0]
    a6b8:	f002 fa34 	bl	cb24 <_vfiprintf_r>
    a6bc:	b003      	add	sp, #12
    a6be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    a6c2:	b003      	add	sp, #12
    a6c4:	4770      	bx	lr
    a6c6:	bf00      	nop
    a6c8:	200001c0 	.word	0x200001c0

0000a6cc <_malloc_trim_r>:
    a6cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a6ce:	4f24      	ldr	r7, [pc, #144]	; (a760 <_malloc_trim_r+0x94>)
    a6d0:	460c      	mov	r4, r1
    a6d2:	4606      	mov	r6, r0
    a6d4:	f7f9 f9e8 	bl	3aa8 <__malloc_lock>
    a6d8:	68bb      	ldr	r3, [r7, #8]
    a6da:	685d      	ldr	r5, [r3, #4]
    a6dc:	f5c4 617e 	rsb	r1, r4, #4064	; 0xfe0
    a6e0:	310f      	adds	r1, #15
    a6e2:	f025 0503 	bic.w	r5, r5, #3
    a6e6:	4429      	add	r1, r5
    a6e8:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
    a6ec:	f021 010f 	bic.w	r1, r1, #15
    a6f0:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
    a6f4:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    a6f8:	db07      	blt.n	a70a <_malloc_trim_r+0x3e>
    a6fa:	2100      	movs	r1, #0
    a6fc:	4630      	mov	r0, r6
    a6fe:	f000 ff23 	bl	b548 <_sbrk_r>
    a702:	68bb      	ldr	r3, [r7, #8]
    a704:	442b      	add	r3, r5
    a706:	4298      	cmp	r0, r3
    a708:	d004      	beq.n	a714 <_malloc_trim_r+0x48>
    a70a:	4630      	mov	r0, r6
    a70c:	f7f9 f9d6 	bl	3abc <__malloc_unlock>
    a710:	2000      	movs	r0, #0
    a712:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a714:	4261      	negs	r1, r4
    a716:	4630      	mov	r0, r6
    a718:	f000 ff16 	bl	b548 <_sbrk_r>
    a71c:	3001      	adds	r0, #1
    a71e:	d00d      	beq.n	a73c <_malloc_trim_r+0x70>
    a720:	4b10      	ldr	r3, [pc, #64]	; (a764 <_malloc_trim_r+0x98>)
    a722:	68ba      	ldr	r2, [r7, #8]
    a724:	6819      	ldr	r1, [r3, #0]
    a726:	1b2d      	subs	r5, r5, r4
    a728:	f045 0501 	orr.w	r5, r5, #1
    a72c:	4630      	mov	r0, r6
    a72e:	1b09      	subs	r1, r1, r4
    a730:	6055      	str	r5, [r2, #4]
    a732:	6019      	str	r1, [r3, #0]
    a734:	f7f9 f9c2 	bl	3abc <__malloc_unlock>
    a738:	2001      	movs	r0, #1
    a73a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a73c:	2100      	movs	r1, #0
    a73e:	4630      	mov	r0, r6
    a740:	f000 ff02 	bl	b548 <_sbrk_r>
    a744:	68ba      	ldr	r2, [r7, #8]
    a746:	1a83      	subs	r3, r0, r2
    a748:	2b0f      	cmp	r3, #15
    a74a:	ddde      	ble.n	a70a <_malloc_trim_r+0x3e>
    a74c:	4c06      	ldr	r4, [pc, #24]	; (a768 <_malloc_trim_r+0x9c>)
    a74e:	4905      	ldr	r1, [pc, #20]	; (a764 <_malloc_trim_r+0x98>)
    a750:	6824      	ldr	r4, [r4, #0]
    a752:	f043 0301 	orr.w	r3, r3, #1
    a756:	1b00      	subs	r0, r0, r4
    a758:	6053      	str	r3, [r2, #4]
    a75a:	6008      	str	r0, [r1, #0]
    a75c:	e7d5      	b.n	a70a <_malloc_trim_r+0x3e>
    a75e:	bf00      	nop
    a760:	2000075c 	.word	0x2000075c
    a764:	20001540 	.word	0x20001540
    a768:	20000b64 	.word	0x20000b64

0000a76c <_free_r>:
    a76c:	2900      	cmp	r1, #0
    a76e:	d044      	beq.n	a7fa <_free_r+0x8e>
    a770:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a774:	460d      	mov	r5, r1
    a776:	4680      	mov	r8, r0
    a778:	f7f9 f996 	bl	3aa8 <__malloc_lock>
    a77c:	f855 7c04 	ldr.w	r7, [r5, #-4]
    a780:	4969      	ldr	r1, [pc, #420]	; (a928 <_free_r+0x1bc>)
    a782:	f027 0301 	bic.w	r3, r7, #1
    a786:	f1a5 0408 	sub.w	r4, r5, #8
    a78a:	18e2      	adds	r2, r4, r3
    a78c:	688e      	ldr	r6, [r1, #8]
    a78e:	6850      	ldr	r0, [r2, #4]
    a790:	42b2      	cmp	r2, r6
    a792:	f020 0003 	bic.w	r0, r0, #3
    a796:	d05e      	beq.n	a856 <_free_r+0xea>
    a798:	07fe      	lsls	r6, r7, #31
    a79a:	6050      	str	r0, [r2, #4]
    a79c:	d40b      	bmi.n	a7b6 <_free_r+0x4a>
    a79e:	f855 7c08 	ldr.w	r7, [r5, #-8]
    a7a2:	1be4      	subs	r4, r4, r7
    a7a4:	f101 0e08 	add.w	lr, r1, #8
    a7a8:	68a5      	ldr	r5, [r4, #8]
    a7aa:	4575      	cmp	r5, lr
    a7ac:	443b      	add	r3, r7
    a7ae:	d06d      	beq.n	a88c <_free_r+0x120>
    a7b0:	68e7      	ldr	r7, [r4, #12]
    a7b2:	60ef      	str	r7, [r5, #12]
    a7b4:	60bd      	str	r5, [r7, #8]
    a7b6:	1815      	adds	r5, r2, r0
    a7b8:	686d      	ldr	r5, [r5, #4]
    a7ba:	07ed      	lsls	r5, r5, #31
    a7bc:	d53e      	bpl.n	a83c <_free_r+0xd0>
    a7be:	f043 0201 	orr.w	r2, r3, #1
    a7c2:	6062      	str	r2, [r4, #4]
    a7c4:	50e3      	str	r3, [r4, r3]
    a7c6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    a7ca:	d217      	bcs.n	a7fc <_free_r+0x90>
    a7cc:	08db      	lsrs	r3, r3, #3
    a7ce:	1c58      	adds	r0, r3, #1
    a7d0:	109a      	asrs	r2, r3, #2
    a7d2:	684d      	ldr	r5, [r1, #4]
    a7d4:	f851 7030 	ldr.w	r7, [r1, r0, lsl #3]
    a7d8:	60a7      	str	r7, [r4, #8]
    a7da:	2301      	movs	r3, #1
    a7dc:	4093      	lsls	r3, r2
    a7de:	eb01 02c0 	add.w	r2, r1, r0, lsl #3
    a7e2:	432b      	orrs	r3, r5
    a7e4:	3a08      	subs	r2, #8
    a7e6:	60e2      	str	r2, [r4, #12]
    a7e8:	604b      	str	r3, [r1, #4]
    a7ea:	f841 4030 	str.w	r4, [r1, r0, lsl #3]
    a7ee:	60fc      	str	r4, [r7, #12]
    a7f0:	4640      	mov	r0, r8
    a7f2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    a7f6:	f7f9 b961 	b.w	3abc <__malloc_unlock>
    a7fa:	4770      	bx	lr
    a7fc:	0a5a      	lsrs	r2, r3, #9
    a7fe:	2a04      	cmp	r2, #4
    a800:	d852      	bhi.n	a8a8 <_free_r+0x13c>
    a802:	099a      	lsrs	r2, r3, #6
    a804:	f102 0739 	add.w	r7, r2, #57	; 0x39
    a808:	00ff      	lsls	r7, r7, #3
    a80a:	f102 0538 	add.w	r5, r2, #56	; 0x38
    a80e:	19c8      	adds	r0, r1, r7
    a810:	59ca      	ldr	r2, [r1, r7]
    a812:	3808      	subs	r0, #8
    a814:	4290      	cmp	r0, r2
    a816:	d04f      	beq.n	a8b8 <_free_r+0x14c>
    a818:	6851      	ldr	r1, [r2, #4]
    a81a:	f021 0103 	bic.w	r1, r1, #3
    a81e:	428b      	cmp	r3, r1
    a820:	d232      	bcs.n	a888 <_free_r+0x11c>
    a822:	6892      	ldr	r2, [r2, #8]
    a824:	4290      	cmp	r0, r2
    a826:	d1f7      	bne.n	a818 <_free_r+0xac>
    a828:	68c3      	ldr	r3, [r0, #12]
    a82a:	60a0      	str	r0, [r4, #8]
    a82c:	60e3      	str	r3, [r4, #12]
    a82e:	609c      	str	r4, [r3, #8]
    a830:	60c4      	str	r4, [r0, #12]
    a832:	4640      	mov	r0, r8
    a834:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    a838:	f7f9 b940 	b.w	3abc <__malloc_unlock>
    a83c:	6895      	ldr	r5, [r2, #8]
    a83e:	4f3b      	ldr	r7, [pc, #236]	; (a92c <_free_r+0x1c0>)
    a840:	42bd      	cmp	r5, r7
    a842:	4403      	add	r3, r0
    a844:	d040      	beq.n	a8c8 <_free_r+0x15c>
    a846:	68d0      	ldr	r0, [r2, #12]
    a848:	60e8      	str	r0, [r5, #12]
    a84a:	f043 0201 	orr.w	r2, r3, #1
    a84e:	6085      	str	r5, [r0, #8]
    a850:	6062      	str	r2, [r4, #4]
    a852:	50e3      	str	r3, [r4, r3]
    a854:	e7b7      	b.n	a7c6 <_free_r+0x5a>
    a856:	07ff      	lsls	r7, r7, #31
    a858:	4403      	add	r3, r0
    a85a:	d407      	bmi.n	a86c <_free_r+0x100>
    a85c:	f855 2c08 	ldr.w	r2, [r5, #-8]
    a860:	1aa4      	subs	r4, r4, r2
    a862:	4413      	add	r3, r2
    a864:	68a0      	ldr	r0, [r4, #8]
    a866:	68e2      	ldr	r2, [r4, #12]
    a868:	60c2      	str	r2, [r0, #12]
    a86a:	6090      	str	r0, [r2, #8]
    a86c:	4a30      	ldr	r2, [pc, #192]	; (a930 <_free_r+0x1c4>)
    a86e:	6812      	ldr	r2, [r2, #0]
    a870:	f043 0001 	orr.w	r0, r3, #1
    a874:	4293      	cmp	r3, r2
    a876:	6060      	str	r0, [r4, #4]
    a878:	608c      	str	r4, [r1, #8]
    a87a:	d3b9      	bcc.n	a7f0 <_free_r+0x84>
    a87c:	4b2d      	ldr	r3, [pc, #180]	; (a934 <_free_r+0x1c8>)
    a87e:	4640      	mov	r0, r8
    a880:	6819      	ldr	r1, [r3, #0]
    a882:	f7ff ff23 	bl	a6cc <_malloc_trim_r>
    a886:	e7b3      	b.n	a7f0 <_free_r+0x84>
    a888:	4610      	mov	r0, r2
    a88a:	e7cd      	b.n	a828 <_free_r+0xbc>
    a88c:	1811      	adds	r1, r2, r0
    a88e:	6849      	ldr	r1, [r1, #4]
    a890:	07c9      	lsls	r1, r1, #31
    a892:	d444      	bmi.n	a91e <_free_r+0x1b2>
    a894:	6891      	ldr	r1, [r2, #8]
    a896:	68d2      	ldr	r2, [r2, #12]
    a898:	60ca      	str	r2, [r1, #12]
    a89a:	4403      	add	r3, r0
    a89c:	f043 0001 	orr.w	r0, r3, #1
    a8a0:	6091      	str	r1, [r2, #8]
    a8a2:	6060      	str	r0, [r4, #4]
    a8a4:	50e3      	str	r3, [r4, r3]
    a8a6:	e7a3      	b.n	a7f0 <_free_r+0x84>
    a8a8:	2a14      	cmp	r2, #20
    a8aa:	d816      	bhi.n	a8da <_free_r+0x16e>
    a8ac:	f102 075c 	add.w	r7, r2, #92	; 0x5c
    a8b0:	00ff      	lsls	r7, r7, #3
    a8b2:	f102 055b 	add.w	r5, r2, #91	; 0x5b
    a8b6:	e7aa      	b.n	a80e <_free_r+0xa2>
    a8b8:	10aa      	asrs	r2, r5, #2
    a8ba:	2301      	movs	r3, #1
    a8bc:	684d      	ldr	r5, [r1, #4]
    a8be:	4093      	lsls	r3, r2
    a8c0:	432b      	orrs	r3, r5
    a8c2:	604b      	str	r3, [r1, #4]
    a8c4:	4603      	mov	r3, r0
    a8c6:	e7b0      	b.n	a82a <_free_r+0xbe>
    a8c8:	f043 0201 	orr.w	r2, r3, #1
    a8cc:	614c      	str	r4, [r1, #20]
    a8ce:	610c      	str	r4, [r1, #16]
    a8d0:	60e5      	str	r5, [r4, #12]
    a8d2:	60a5      	str	r5, [r4, #8]
    a8d4:	6062      	str	r2, [r4, #4]
    a8d6:	50e3      	str	r3, [r4, r3]
    a8d8:	e78a      	b.n	a7f0 <_free_r+0x84>
    a8da:	2a54      	cmp	r2, #84	; 0x54
    a8dc:	d806      	bhi.n	a8ec <_free_r+0x180>
    a8de:	0b1a      	lsrs	r2, r3, #12
    a8e0:	f102 076f 	add.w	r7, r2, #111	; 0x6f
    a8e4:	00ff      	lsls	r7, r7, #3
    a8e6:	f102 056e 	add.w	r5, r2, #110	; 0x6e
    a8ea:	e790      	b.n	a80e <_free_r+0xa2>
    a8ec:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    a8f0:	d806      	bhi.n	a900 <_free_r+0x194>
    a8f2:	0bda      	lsrs	r2, r3, #15
    a8f4:	f102 0778 	add.w	r7, r2, #120	; 0x78
    a8f8:	00ff      	lsls	r7, r7, #3
    a8fa:	f102 0577 	add.w	r5, r2, #119	; 0x77
    a8fe:	e786      	b.n	a80e <_free_r+0xa2>
    a900:	f240 5054 	movw	r0, #1364	; 0x554
    a904:	4282      	cmp	r2, r0
    a906:	d806      	bhi.n	a916 <_free_r+0x1aa>
    a908:	0c9a      	lsrs	r2, r3, #18
    a90a:	f102 077d 	add.w	r7, r2, #125	; 0x7d
    a90e:	00ff      	lsls	r7, r7, #3
    a910:	f102 057c 	add.w	r5, r2, #124	; 0x7c
    a914:	e77b      	b.n	a80e <_free_r+0xa2>
    a916:	f44f 777e 	mov.w	r7, #1016	; 0x3f8
    a91a:	257e      	movs	r5, #126	; 0x7e
    a91c:	e777      	b.n	a80e <_free_r+0xa2>
    a91e:	f043 0101 	orr.w	r1, r3, #1
    a922:	6061      	str	r1, [r4, #4]
    a924:	6013      	str	r3, [r2, #0]
    a926:	e763      	b.n	a7f0 <_free_r+0x84>
    a928:	2000075c 	.word	0x2000075c
    a92c:	20000764 	.word	0x20000764
    a930:	20000b68 	.word	0x20000b68
    a934:	20001570 	.word	0x20001570

0000a938 <_fstat_r>:
    a938:	b538      	push	{r3, r4, r5, lr}
    a93a:	460b      	mov	r3, r1
    a93c:	4c07      	ldr	r4, [pc, #28]	; (a95c <_fstat_r+0x24>)
    a93e:	4605      	mov	r5, r0
    a940:	4611      	mov	r1, r2
    a942:	4618      	mov	r0, r3
    a944:	2300      	movs	r3, #0
    a946:	6023      	str	r3, [r4, #0]
    a948:	f7f8 fff9 	bl	393e <_fstat>
    a94c:	1c43      	adds	r3, r0, #1
    a94e:	d000      	beq.n	a952 <_fstat_r+0x1a>
    a950:	bd38      	pop	{r3, r4, r5, pc}
    a952:	6823      	ldr	r3, [r4, #0]
    a954:	2b00      	cmp	r3, #0
    a956:	d0fb      	beq.n	a950 <_fstat_r+0x18>
    a958:	602b      	str	r3, [r5, #0]
    a95a:	bd38      	pop	{r3, r4, r5, pc}
    a95c:	2000304c 	.word	0x2000304c

0000a960 <__sfvwrite_r>:
    a960:	6893      	ldr	r3, [r2, #8]
    a962:	2b00      	cmp	r3, #0
    a964:	d073      	beq.n	aa4e <__sfvwrite_r+0xee>
    a966:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a96a:	898b      	ldrh	r3, [r1, #12]
    a96c:	b083      	sub	sp, #12
    a96e:	460c      	mov	r4, r1
    a970:	0719      	lsls	r1, r3, #28
    a972:	9000      	str	r0, [sp, #0]
    a974:	4616      	mov	r6, r2
    a976:	d526      	bpl.n	a9c6 <__sfvwrite_r+0x66>
    a978:	6922      	ldr	r2, [r4, #16]
    a97a:	b322      	cbz	r2, a9c6 <__sfvwrite_r+0x66>
    a97c:	f013 0002 	ands.w	r0, r3, #2
    a980:	6835      	ldr	r5, [r6, #0]
    a982:	d02c      	beq.n	a9de <__sfvwrite_r+0x7e>
    a984:	f04f 0900 	mov.w	r9, #0
    a988:	4fb0      	ldr	r7, [pc, #704]	; (ac4c <__sfvwrite_r+0x2ec>)
    a98a:	46c8      	mov	r8, r9
    a98c:	46b2      	mov	sl, r6
    a98e:	45b8      	cmp	r8, r7
    a990:	4643      	mov	r3, r8
    a992:	464a      	mov	r2, r9
    a994:	bf28      	it	cs
    a996:	463b      	movcs	r3, r7
    a998:	9800      	ldr	r0, [sp, #0]
    a99a:	f1b8 0f00 	cmp.w	r8, #0
    a99e:	d050      	beq.n	aa42 <__sfvwrite_r+0xe2>
    a9a0:	69e1      	ldr	r1, [r4, #28]
    a9a2:	6a66      	ldr	r6, [r4, #36]	; 0x24
    a9a4:	47b0      	blx	r6
    a9a6:	2800      	cmp	r0, #0
    a9a8:	dd58      	ble.n	aa5c <__sfvwrite_r+0xfc>
    a9aa:	f8da 3008 	ldr.w	r3, [sl, #8]
    a9ae:	1a1b      	subs	r3, r3, r0
    a9b0:	4481      	add	r9, r0
    a9b2:	eba8 0800 	sub.w	r8, r8, r0
    a9b6:	f8ca 3008 	str.w	r3, [sl, #8]
    a9ba:	2b00      	cmp	r3, #0
    a9bc:	d1e7      	bne.n	a98e <__sfvwrite_r+0x2e>
    a9be:	2000      	movs	r0, #0
    a9c0:	b003      	add	sp, #12
    a9c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a9c6:	4621      	mov	r1, r4
    a9c8:	9800      	ldr	r0, [sp, #0]
    a9ca:	f004 fb07 	bl	efdc <__swsetup_r>
    a9ce:	2800      	cmp	r0, #0
    a9d0:	f040 8133 	bne.w	ac3a <__sfvwrite_r+0x2da>
    a9d4:	89a3      	ldrh	r3, [r4, #12]
    a9d6:	6835      	ldr	r5, [r6, #0]
    a9d8:	f013 0002 	ands.w	r0, r3, #2
    a9dc:	d1d2      	bne.n	a984 <__sfvwrite_r+0x24>
    a9de:	f013 0901 	ands.w	r9, r3, #1
    a9e2:	d145      	bne.n	aa70 <__sfvwrite_r+0x110>
    a9e4:	464f      	mov	r7, r9
    a9e6:	9601      	str	r6, [sp, #4]
    a9e8:	b337      	cbz	r7, aa38 <__sfvwrite_r+0xd8>
    a9ea:	059a      	lsls	r2, r3, #22
    a9ec:	f8d4 8008 	ldr.w	r8, [r4, #8]
    a9f0:	f140 8083 	bpl.w	aafa <__sfvwrite_r+0x19a>
    a9f4:	4547      	cmp	r7, r8
    a9f6:	46c3      	mov	fp, r8
    a9f8:	f0c0 80ab 	bcc.w	ab52 <__sfvwrite_r+0x1f2>
    a9fc:	f413 6f90 	tst.w	r3, #1152	; 0x480
    aa00:	f040 80ac 	bne.w	ab5c <__sfvwrite_r+0x1fc>
    aa04:	6820      	ldr	r0, [r4, #0]
    aa06:	46ba      	mov	sl, r7
    aa08:	465a      	mov	r2, fp
    aa0a:	4649      	mov	r1, r9
    aa0c:	f000 fcd6 	bl	b3bc <memmove>
    aa10:	68a2      	ldr	r2, [r4, #8]
    aa12:	6823      	ldr	r3, [r4, #0]
    aa14:	eba2 0208 	sub.w	r2, r2, r8
    aa18:	445b      	add	r3, fp
    aa1a:	60a2      	str	r2, [r4, #8]
    aa1c:	6023      	str	r3, [r4, #0]
    aa1e:	9a01      	ldr	r2, [sp, #4]
    aa20:	6893      	ldr	r3, [r2, #8]
    aa22:	eba3 030a 	sub.w	r3, r3, sl
    aa26:	44d1      	add	r9, sl
    aa28:	eba7 070a 	sub.w	r7, r7, sl
    aa2c:	6093      	str	r3, [r2, #8]
    aa2e:	2b00      	cmp	r3, #0
    aa30:	d0c5      	beq.n	a9be <__sfvwrite_r+0x5e>
    aa32:	89a3      	ldrh	r3, [r4, #12]
    aa34:	2f00      	cmp	r7, #0
    aa36:	d1d8      	bne.n	a9ea <__sfvwrite_r+0x8a>
    aa38:	f8d5 9000 	ldr.w	r9, [r5]
    aa3c:	686f      	ldr	r7, [r5, #4]
    aa3e:	3508      	adds	r5, #8
    aa40:	e7d2      	b.n	a9e8 <__sfvwrite_r+0x88>
    aa42:	f8d5 9000 	ldr.w	r9, [r5]
    aa46:	f8d5 8004 	ldr.w	r8, [r5, #4]
    aa4a:	3508      	adds	r5, #8
    aa4c:	e79f      	b.n	a98e <__sfvwrite_r+0x2e>
    aa4e:	2000      	movs	r0, #0
    aa50:	4770      	bx	lr
    aa52:	4621      	mov	r1, r4
    aa54:	9800      	ldr	r0, [sp, #0]
    aa56:	f7ff fd83 	bl	a560 <_fflush_r>
    aa5a:	b370      	cbz	r0, aaba <__sfvwrite_r+0x15a>
    aa5c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    aa60:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    aa64:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    aa68:	81a3      	strh	r3, [r4, #12]
    aa6a:	b003      	add	sp, #12
    aa6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    aa70:	4681      	mov	r9, r0
    aa72:	4633      	mov	r3, r6
    aa74:	464e      	mov	r6, r9
    aa76:	46a8      	mov	r8, r5
    aa78:	469a      	mov	sl, r3
    aa7a:	464d      	mov	r5, r9
    aa7c:	b34e      	cbz	r6, aad2 <__sfvwrite_r+0x172>
    aa7e:	b380      	cbz	r0, aae2 <__sfvwrite_r+0x182>
    aa80:	6820      	ldr	r0, [r4, #0]
    aa82:	6923      	ldr	r3, [r4, #16]
    aa84:	6962      	ldr	r2, [r4, #20]
    aa86:	45b1      	cmp	r9, r6
    aa88:	46cb      	mov	fp, r9
    aa8a:	bf28      	it	cs
    aa8c:	46b3      	movcs	fp, r6
    aa8e:	4298      	cmp	r0, r3
    aa90:	465f      	mov	r7, fp
    aa92:	d904      	bls.n	aa9e <__sfvwrite_r+0x13e>
    aa94:	68a3      	ldr	r3, [r4, #8]
    aa96:	4413      	add	r3, r2
    aa98:	459b      	cmp	fp, r3
    aa9a:	f300 80a6 	bgt.w	abea <__sfvwrite_r+0x28a>
    aa9e:	4593      	cmp	fp, r2
    aaa0:	db4b      	blt.n	ab3a <__sfvwrite_r+0x1da>
    aaa2:	4613      	mov	r3, r2
    aaa4:	6a67      	ldr	r7, [r4, #36]	; 0x24
    aaa6:	69e1      	ldr	r1, [r4, #28]
    aaa8:	9800      	ldr	r0, [sp, #0]
    aaaa:	462a      	mov	r2, r5
    aaac:	47b8      	blx	r7
    aaae:	1e07      	subs	r7, r0, #0
    aab0:	ddd4      	ble.n	aa5c <__sfvwrite_r+0xfc>
    aab2:	ebb9 0907 	subs.w	r9, r9, r7
    aab6:	d0cc      	beq.n	aa52 <__sfvwrite_r+0xf2>
    aab8:	2001      	movs	r0, #1
    aaba:	f8da 3008 	ldr.w	r3, [sl, #8]
    aabe:	1bdb      	subs	r3, r3, r7
    aac0:	443d      	add	r5, r7
    aac2:	1bf6      	subs	r6, r6, r7
    aac4:	f8ca 3008 	str.w	r3, [sl, #8]
    aac8:	2b00      	cmp	r3, #0
    aaca:	f43f af78 	beq.w	a9be <__sfvwrite_r+0x5e>
    aace:	2e00      	cmp	r6, #0
    aad0:	d1d5      	bne.n	aa7e <__sfvwrite_r+0x11e>
    aad2:	f108 0308 	add.w	r3, r8, #8
    aad6:	e913 0060 	ldmdb	r3, {r5, r6}
    aada:	4698      	mov	r8, r3
    aadc:	3308      	adds	r3, #8
    aade:	2e00      	cmp	r6, #0
    aae0:	d0f9      	beq.n	aad6 <__sfvwrite_r+0x176>
    aae2:	4632      	mov	r2, r6
    aae4:	210a      	movs	r1, #10
    aae6:	4628      	mov	r0, r5
    aae8:	f7f5 feca 	bl	880 <memchr>
    aaec:	2800      	cmp	r0, #0
    aaee:	f000 80a1 	beq.w	ac34 <__sfvwrite_r+0x2d4>
    aaf2:	3001      	adds	r0, #1
    aaf4:	eba0 0905 	sub.w	r9, r0, r5
    aaf8:	e7c2      	b.n	aa80 <__sfvwrite_r+0x120>
    aafa:	6820      	ldr	r0, [r4, #0]
    aafc:	6923      	ldr	r3, [r4, #16]
    aafe:	4298      	cmp	r0, r3
    ab00:	d802      	bhi.n	ab08 <__sfvwrite_r+0x1a8>
    ab02:	6963      	ldr	r3, [r4, #20]
    ab04:	429f      	cmp	r7, r3
    ab06:	d25d      	bcs.n	abc4 <__sfvwrite_r+0x264>
    ab08:	45b8      	cmp	r8, r7
    ab0a:	bf28      	it	cs
    ab0c:	46b8      	movcs	r8, r7
    ab0e:	4642      	mov	r2, r8
    ab10:	4649      	mov	r1, r9
    ab12:	f000 fc53 	bl	b3bc <memmove>
    ab16:	68a3      	ldr	r3, [r4, #8]
    ab18:	6822      	ldr	r2, [r4, #0]
    ab1a:	eba3 0308 	sub.w	r3, r3, r8
    ab1e:	4442      	add	r2, r8
    ab20:	60a3      	str	r3, [r4, #8]
    ab22:	6022      	str	r2, [r4, #0]
    ab24:	b10b      	cbz	r3, ab2a <__sfvwrite_r+0x1ca>
    ab26:	46c2      	mov	sl, r8
    ab28:	e779      	b.n	aa1e <__sfvwrite_r+0xbe>
    ab2a:	4621      	mov	r1, r4
    ab2c:	9800      	ldr	r0, [sp, #0]
    ab2e:	f7ff fd17 	bl	a560 <_fflush_r>
    ab32:	2800      	cmp	r0, #0
    ab34:	d192      	bne.n	aa5c <__sfvwrite_r+0xfc>
    ab36:	46c2      	mov	sl, r8
    ab38:	e771      	b.n	aa1e <__sfvwrite_r+0xbe>
    ab3a:	465a      	mov	r2, fp
    ab3c:	4629      	mov	r1, r5
    ab3e:	f000 fc3d 	bl	b3bc <memmove>
    ab42:	68a2      	ldr	r2, [r4, #8]
    ab44:	6823      	ldr	r3, [r4, #0]
    ab46:	eba2 020b 	sub.w	r2, r2, fp
    ab4a:	445b      	add	r3, fp
    ab4c:	60a2      	str	r2, [r4, #8]
    ab4e:	6023      	str	r3, [r4, #0]
    ab50:	e7af      	b.n	aab2 <__sfvwrite_r+0x152>
    ab52:	6820      	ldr	r0, [r4, #0]
    ab54:	46b8      	mov	r8, r7
    ab56:	46ba      	mov	sl, r7
    ab58:	46bb      	mov	fp, r7
    ab5a:	e755      	b.n	aa08 <__sfvwrite_r+0xa8>
    ab5c:	6962      	ldr	r2, [r4, #20]
    ab5e:	6820      	ldr	r0, [r4, #0]
    ab60:	6921      	ldr	r1, [r4, #16]
    ab62:	eb02 0842 	add.w	r8, r2, r2, lsl #1
    ab66:	eba0 0a01 	sub.w	sl, r0, r1
    ab6a:	eb08 78d8 	add.w	r8, r8, r8, lsr #31
    ab6e:	f10a 0001 	add.w	r0, sl, #1
    ab72:	ea4f 0868 	mov.w	r8, r8, asr #1
    ab76:	4438      	add	r0, r7
    ab78:	4540      	cmp	r0, r8
    ab7a:	4642      	mov	r2, r8
    ab7c:	bf84      	itt	hi
    ab7e:	4680      	movhi	r8, r0
    ab80:	4642      	movhi	r2, r8
    ab82:	055b      	lsls	r3, r3, #21
    ab84:	d544      	bpl.n	ac10 <__sfvwrite_r+0x2b0>
    ab86:	4611      	mov	r1, r2
    ab88:	9800      	ldr	r0, [sp, #0]
    ab8a:	f7f7 fe19 	bl	27c0 <__wrap__malloc_r>
    ab8e:	4683      	mov	fp, r0
    ab90:	2800      	cmp	r0, #0
    ab92:	d055      	beq.n	ac40 <__sfvwrite_r+0x2e0>
    ab94:	4652      	mov	r2, sl
    ab96:	6921      	ldr	r1, [r4, #16]
    ab98:	f7f5 fec2 	bl	920 <memcpy>
    ab9c:	89a3      	ldrh	r3, [r4, #12]
    ab9e:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
    aba2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    aba6:	81a3      	strh	r3, [r4, #12]
    aba8:	eb0b 000a 	add.w	r0, fp, sl
    abac:	eba8 030a 	sub.w	r3, r8, sl
    abb0:	f8c4 b010 	str.w	fp, [r4, #16]
    abb4:	f8c4 8014 	str.w	r8, [r4, #20]
    abb8:	6020      	str	r0, [r4, #0]
    abba:	60a3      	str	r3, [r4, #8]
    abbc:	46b8      	mov	r8, r7
    abbe:	46ba      	mov	sl, r7
    abc0:	46bb      	mov	fp, r7
    abc2:	e721      	b.n	aa08 <__sfvwrite_r+0xa8>
    abc4:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    abc8:	42b9      	cmp	r1, r7
    abca:	bf28      	it	cs
    abcc:	4639      	movcs	r1, r7
    abce:	464a      	mov	r2, r9
    abd0:	fb91 f1f3 	sdiv	r1, r1, r3
    abd4:	9800      	ldr	r0, [sp, #0]
    abd6:	6a66      	ldr	r6, [r4, #36]	; 0x24
    abd8:	fb03 f301 	mul.w	r3, r3, r1
    abdc:	69e1      	ldr	r1, [r4, #28]
    abde:	47b0      	blx	r6
    abe0:	f1b0 0a00 	subs.w	sl, r0, #0
    abe4:	f73f af1b 	bgt.w	aa1e <__sfvwrite_r+0xbe>
    abe8:	e738      	b.n	aa5c <__sfvwrite_r+0xfc>
    abea:	461a      	mov	r2, r3
    abec:	4629      	mov	r1, r5
    abee:	9301      	str	r3, [sp, #4]
    abf0:	f000 fbe4 	bl	b3bc <memmove>
    abf4:	6822      	ldr	r2, [r4, #0]
    abf6:	9b01      	ldr	r3, [sp, #4]
    abf8:	9800      	ldr	r0, [sp, #0]
    abfa:	441a      	add	r2, r3
    abfc:	6022      	str	r2, [r4, #0]
    abfe:	4621      	mov	r1, r4
    ac00:	f7ff fcae 	bl	a560 <_fflush_r>
    ac04:	9b01      	ldr	r3, [sp, #4]
    ac06:	2800      	cmp	r0, #0
    ac08:	f47f af28 	bne.w	aa5c <__sfvwrite_r+0xfc>
    ac0c:	461f      	mov	r7, r3
    ac0e:	e750      	b.n	aab2 <__sfvwrite_r+0x152>
    ac10:	9800      	ldr	r0, [sp, #0]
    ac12:	f7f7 fe3f 	bl	2894 <__wrap__realloc_r>
    ac16:	4683      	mov	fp, r0
    ac18:	2800      	cmp	r0, #0
    ac1a:	d1c5      	bne.n	aba8 <__sfvwrite_r+0x248>
    ac1c:	9d00      	ldr	r5, [sp, #0]
    ac1e:	6921      	ldr	r1, [r4, #16]
    ac20:	4628      	mov	r0, r5
    ac22:	f7f7 fe72 	bl	290a <__wrap__free_r>
    ac26:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    ac2a:	220c      	movs	r2, #12
    ac2c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    ac30:	602a      	str	r2, [r5, #0]
    ac32:	e715      	b.n	aa60 <__sfvwrite_r+0x100>
    ac34:	f106 0901 	add.w	r9, r6, #1
    ac38:	e722      	b.n	aa80 <__sfvwrite_r+0x120>
    ac3a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    ac3e:	e6bf      	b.n	a9c0 <__sfvwrite_r+0x60>
    ac40:	9a00      	ldr	r2, [sp, #0]
    ac42:	230c      	movs	r3, #12
    ac44:	6013      	str	r3, [r2, #0]
    ac46:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    ac4a:	e709      	b.n	aa60 <__sfvwrite_r+0x100>
    ac4c:	7ffffc00 	.word	0x7ffffc00

0000ac50 <_fwalk_reent>:
    ac50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ac54:	f510 7738 	adds.w	r7, r0, #736	; 0x2e0
    ac58:	d01f      	beq.n	ac9a <_fwalk_reent+0x4a>
    ac5a:	4688      	mov	r8, r1
    ac5c:	4606      	mov	r6, r0
    ac5e:	f04f 0900 	mov.w	r9, #0
    ac62:	687d      	ldr	r5, [r7, #4]
    ac64:	68bc      	ldr	r4, [r7, #8]
    ac66:	3d01      	subs	r5, #1
    ac68:	d411      	bmi.n	ac8e <_fwalk_reent+0x3e>
    ac6a:	89a3      	ldrh	r3, [r4, #12]
    ac6c:	2b01      	cmp	r3, #1
    ac6e:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
    ac72:	d908      	bls.n	ac86 <_fwalk_reent+0x36>
    ac74:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
    ac78:	3301      	adds	r3, #1
    ac7a:	4621      	mov	r1, r4
    ac7c:	4630      	mov	r0, r6
    ac7e:	d002      	beq.n	ac86 <_fwalk_reent+0x36>
    ac80:	47c0      	blx	r8
    ac82:	ea49 0900 	orr.w	r9, r9, r0
    ac86:	1c6b      	adds	r3, r5, #1
    ac88:	f104 0468 	add.w	r4, r4, #104	; 0x68
    ac8c:	d1ed      	bne.n	ac6a <_fwalk_reent+0x1a>
    ac8e:	683f      	ldr	r7, [r7, #0]
    ac90:	2f00      	cmp	r7, #0
    ac92:	d1e6      	bne.n	ac62 <_fwalk_reent+0x12>
    ac94:	4648      	mov	r0, r9
    ac96:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    ac9a:	46b9      	mov	r9, r7
    ac9c:	4648      	mov	r0, r9
    ac9e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    aca2:	bf00      	nop

0000aca4 <__libc_init_array>:
    aca4:	b570      	push	{r4, r5, r6, lr}
    aca6:	4e0f      	ldr	r6, [pc, #60]	; (ace4 <__libc_init_array+0x40>)
    aca8:	4d0f      	ldr	r5, [pc, #60]	; (ace8 <__libc_init_array+0x44>)
    acaa:	1b76      	subs	r6, r6, r5
    acac:	10b6      	asrs	r6, r6, #2
    acae:	bf18      	it	ne
    acb0:	2400      	movne	r4, #0
    acb2:	d005      	beq.n	acc0 <__libc_init_array+0x1c>
    acb4:	3401      	adds	r4, #1
    acb6:	f855 3b04 	ldr.w	r3, [r5], #4
    acba:	4798      	blx	r3
    acbc:	42a6      	cmp	r6, r4
    acbe:	d1f9      	bne.n	acb4 <__libc_init_array+0x10>
    acc0:	4e0a      	ldr	r6, [pc, #40]	; (acec <__libc_init_array+0x48>)
    acc2:	4d0b      	ldr	r5, [pc, #44]	; (acf0 <__libc_init_array+0x4c>)
    acc4:	1b76      	subs	r6, r6, r5
    acc6:	f007 ffed 	bl	12ca4 <_init>
    acca:	10b6      	asrs	r6, r6, #2
    accc:	bf18      	it	ne
    acce:	2400      	movne	r4, #0
    acd0:	d006      	beq.n	ace0 <__libc_init_array+0x3c>
    acd2:	3401      	adds	r4, #1
    acd4:	f855 3b04 	ldr.w	r3, [r5], #4
    acd8:	4798      	blx	r3
    acda:	42a6      	cmp	r6, r4
    acdc:	d1f9      	bne.n	acd2 <__libc_init_array+0x2e>
    acde:	bd70      	pop	{r4, r5, r6, pc}
    ace0:	bd70      	pop	{r4, r5, r6, pc}
    ace2:	bf00      	nop
    ace4:	00012cc4 	.word	0x00012cc4
    ace8:	00012cc4 	.word	0x00012cc4
    acec:	00012cd0 	.word	0x00012cd0
    acf0:	00012cc4 	.word	0x00012cc4

0000acf4 <__locale_mb_cur_max>:
    acf4:	4b04      	ldr	r3, [pc, #16]	; (ad08 <__locale_mb_cur_max+0x14>)
    acf6:	4a05      	ldr	r2, [pc, #20]	; (ad0c <__locale_mb_cur_max+0x18>)
    acf8:	681b      	ldr	r3, [r3, #0]
    acfa:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    acfc:	2b00      	cmp	r3, #0
    acfe:	bf08      	it	eq
    ad00:	4613      	moveq	r3, r2
    ad02:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
    ad06:	4770      	bx	lr
    ad08:	200001c0 	.word	0x200001c0
    ad0c:	200005f0 	.word	0x200005f0

0000ad10 <__retarget_lock_init_recursive>:
    ad10:	4770      	bx	lr
    ad12:	bf00      	nop

0000ad14 <__retarget_lock_close_recursive>:
    ad14:	4770      	bx	lr
    ad16:	bf00      	nop

0000ad18 <__retarget_lock_acquire_recursive>:
    ad18:	4770      	bx	lr
    ad1a:	bf00      	nop

0000ad1c <__retarget_lock_release_recursive>:
    ad1c:	4770      	bx	lr
    ad1e:	bf00      	nop

0000ad20 <__swhatbuf_r>:
    ad20:	b570      	push	{r4, r5, r6, lr}
    ad22:	460c      	mov	r4, r1
    ad24:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    ad28:	2900      	cmp	r1, #0
    ad2a:	b090      	sub	sp, #64	; 0x40
    ad2c:	4615      	mov	r5, r2
    ad2e:	461e      	mov	r6, r3
    ad30:	db14      	blt.n	ad5c <__swhatbuf_r+0x3c>
    ad32:	aa01      	add	r2, sp, #4
    ad34:	f7ff fe00 	bl	a938 <_fstat_r>
    ad38:	2800      	cmp	r0, #0
    ad3a:	db0f      	blt.n	ad5c <__swhatbuf_r+0x3c>
    ad3c:	9a02      	ldr	r2, [sp, #8]
    ad3e:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
    ad42:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
    ad46:	fab2 f282 	clz	r2, r2
    ad4a:	0952      	lsrs	r2, r2, #5
    ad4c:	f44f 6380 	mov.w	r3, #1024	; 0x400
    ad50:	f44f 6000 	mov.w	r0, #2048	; 0x800
    ad54:	6032      	str	r2, [r6, #0]
    ad56:	602b      	str	r3, [r5, #0]
    ad58:	b010      	add	sp, #64	; 0x40
    ad5a:	bd70      	pop	{r4, r5, r6, pc}
    ad5c:	89a2      	ldrh	r2, [r4, #12]
    ad5e:	2300      	movs	r3, #0
    ad60:	f012 0080 	ands.w	r0, r2, #128	; 0x80
    ad64:	6033      	str	r3, [r6, #0]
    ad66:	d004      	beq.n	ad72 <__swhatbuf_r+0x52>
    ad68:	2240      	movs	r2, #64	; 0x40
    ad6a:	4618      	mov	r0, r3
    ad6c:	602a      	str	r2, [r5, #0]
    ad6e:	b010      	add	sp, #64	; 0x40
    ad70:	bd70      	pop	{r4, r5, r6, pc}
    ad72:	f44f 6380 	mov.w	r3, #1024	; 0x400
    ad76:	602b      	str	r3, [r5, #0]
    ad78:	b010      	add	sp, #64	; 0x40
    ad7a:	bd70      	pop	{r4, r5, r6, pc}

0000ad7c <__smakebuf_r>:
    ad7c:	898a      	ldrh	r2, [r1, #12]
    ad7e:	0792      	lsls	r2, r2, #30
    ad80:	460b      	mov	r3, r1
    ad82:	d506      	bpl.n	ad92 <__smakebuf_r+0x16>
    ad84:	f101 0243 	add.w	r2, r1, #67	; 0x43
    ad88:	2101      	movs	r1, #1
    ad8a:	601a      	str	r2, [r3, #0]
    ad8c:	611a      	str	r2, [r3, #16]
    ad8e:	6159      	str	r1, [r3, #20]
    ad90:	4770      	bx	lr
    ad92:	b5f0      	push	{r4, r5, r6, r7, lr}
    ad94:	b083      	sub	sp, #12
    ad96:	ab01      	add	r3, sp, #4
    ad98:	466a      	mov	r2, sp
    ad9a:	460c      	mov	r4, r1
    ad9c:	4606      	mov	r6, r0
    ad9e:	f7ff ffbf 	bl	ad20 <__swhatbuf_r>
    ada2:	9900      	ldr	r1, [sp, #0]
    ada4:	4605      	mov	r5, r0
    ada6:	4630      	mov	r0, r6
    ada8:	f7f7 fd0a 	bl	27c0 <__wrap__malloc_r>
    adac:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    adb0:	b1d8      	cbz	r0, adea <__smakebuf_r+0x6e>
    adb2:	9a01      	ldr	r2, [sp, #4]
    adb4:	4f15      	ldr	r7, [pc, #84]	; (ae0c <__smakebuf_r+0x90>)
    adb6:	9900      	ldr	r1, [sp, #0]
    adb8:	63f7      	str	r7, [r6, #60]	; 0x3c
    adba:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    adbe:	81a3      	strh	r3, [r4, #12]
    adc0:	6020      	str	r0, [r4, #0]
    adc2:	6120      	str	r0, [r4, #16]
    adc4:	6161      	str	r1, [r4, #20]
    adc6:	b91a      	cbnz	r2, add0 <__smakebuf_r+0x54>
    adc8:	432b      	orrs	r3, r5
    adca:	81a3      	strh	r3, [r4, #12]
    adcc:	b003      	add	sp, #12
    adce:	bdf0      	pop	{r4, r5, r6, r7, pc}
    add0:	4630      	mov	r0, r6
    add2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    add6:	f005 f9b1 	bl	1013c <_isatty_r>
    adda:	b1a0      	cbz	r0, ae06 <__smakebuf_r+0x8a>
    addc:	89a3      	ldrh	r3, [r4, #12]
    adde:	f023 0303 	bic.w	r3, r3, #3
    ade2:	f043 0301 	orr.w	r3, r3, #1
    ade6:	b21b      	sxth	r3, r3
    ade8:	e7ee      	b.n	adc8 <__smakebuf_r+0x4c>
    adea:	059a      	lsls	r2, r3, #22
    adec:	d4ee      	bmi.n	adcc <__smakebuf_r+0x50>
    adee:	f023 0303 	bic.w	r3, r3, #3
    adf2:	f104 0243 	add.w	r2, r4, #67	; 0x43
    adf6:	f043 0302 	orr.w	r3, r3, #2
    adfa:	2101      	movs	r1, #1
    adfc:	81a3      	strh	r3, [r4, #12]
    adfe:	6022      	str	r2, [r4, #0]
    ae00:	6122      	str	r2, [r4, #16]
    ae02:	6161      	str	r1, [r4, #20]
    ae04:	e7e2      	b.n	adcc <__smakebuf_r+0x50>
    ae06:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    ae0a:	e7dd      	b.n	adc8 <__smakebuf_r+0x4c>
    ae0c:	0000a5d9 	.word	0x0000a5d9

0000ae10 <malloc>:
    ae10:	4b02      	ldr	r3, [pc, #8]	; (ae1c <malloc+0xc>)
    ae12:	4601      	mov	r1, r0
    ae14:	6818      	ldr	r0, [r3, #0]
    ae16:	f7f7 bcd3 	b.w	27c0 <__wrap__malloc_r>
    ae1a:	bf00      	nop
    ae1c:	200001c0 	.word	0x200001c0

0000ae20 <free>:
    ae20:	4b02      	ldr	r3, [pc, #8]	; (ae2c <free+0xc>)
    ae22:	4601      	mov	r1, r0
    ae24:	6818      	ldr	r0, [r3, #0]
    ae26:	f7f7 bd70 	b.w	290a <__wrap__free_r>
    ae2a:	bf00      	nop
    ae2c:	200001c0 	.word	0x200001c0

0000ae30 <_malloc_r>:
    ae30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ae34:	f101 060b 	add.w	r6, r1, #11
    ae38:	2e16      	cmp	r6, #22
    ae3a:	b083      	sub	sp, #12
    ae3c:	4605      	mov	r5, r0
    ae3e:	f240 809e 	bls.w	af7e <_malloc_r+0x14e>
    ae42:	f036 0607 	bics.w	r6, r6, #7
    ae46:	f100 80bd 	bmi.w	afc4 <_malloc_r+0x194>
    ae4a:	42b1      	cmp	r1, r6
    ae4c:	f200 80ba 	bhi.w	afc4 <_malloc_r+0x194>
    ae50:	f7f8 fe2a 	bl	3aa8 <__malloc_lock>
    ae54:	f5b6 7ffc 	cmp.w	r6, #504	; 0x1f8
    ae58:	f0c0 8293 	bcc.w	b382 <_malloc_r+0x552>
    ae5c:	0a73      	lsrs	r3, r6, #9
    ae5e:	f000 80b8 	beq.w	afd2 <_malloc_r+0x1a2>
    ae62:	2b04      	cmp	r3, #4
    ae64:	f200 8179 	bhi.w	b15a <_malloc_r+0x32a>
    ae68:	09b3      	lsrs	r3, r6, #6
    ae6a:	f103 0039 	add.w	r0, r3, #57	; 0x39
    ae6e:	f103 0e38 	add.w	lr, r3, #56	; 0x38
    ae72:	00c3      	lsls	r3, r0, #3
    ae74:	4fbf      	ldr	r7, [pc, #764]	; (b174 <_malloc_r+0x344>)
    ae76:	443b      	add	r3, r7
    ae78:	f1a3 0108 	sub.w	r1, r3, #8
    ae7c:	685c      	ldr	r4, [r3, #4]
    ae7e:	42a1      	cmp	r1, r4
    ae80:	d106      	bne.n	ae90 <_malloc_r+0x60>
    ae82:	e00c      	b.n	ae9e <_malloc_r+0x6e>
    ae84:	2a00      	cmp	r2, #0
    ae86:	f280 80aa 	bge.w	afde <_malloc_r+0x1ae>
    ae8a:	68e4      	ldr	r4, [r4, #12]
    ae8c:	42a1      	cmp	r1, r4
    ae8e:	d006      	beq.n	ae9e <_malloc_r+0x6e>
    ae90:	6863      	ldr	r3, [r4, #4]
    ae92:	f023 0303 	bic.w	r3, r3, #3
    ae96:	1b9a      	subs	r2, r3, r6
    ae98:	2a0f      	cmp	r2, #15
    ae9a:	ddf3      	ble.n	ae84 <_malloc_r+0x54>
    ae9c:	4670      	mov	r0, lr
    ae9e:	693c      	ldr	r4, [r7, #16]
    aea0:	f8df e2e4 	ldr.w	lr, [pc, #740]	; b188 <_malloc_r+0x358>
    aea4:	4574      	cmp	r4, lr
    aea6:	f000 81ab 	beq.w	b200 <_malloc_r+0x3d0>
    aeaa:	6863      	ldr	r3, [r4, #4]
    aeac:	f023 0303 	bic.w	r3, r3, #3
    aeb0:	1b9a      	subs	r2, r3, r6
    aeb2:	2a0f      	cmp	r2, #15
    aeb4:	f300 8190 	bgt.w	b1d8 <_malloc_r+0x3a8>
    aeb8:	2a00      	cmp	r2, #0
    aeba:	f8c7 e014 	str.w	lr, [r7, #20]
    aebe:	f8c7 e010 	str.w	lr, [r7, #16]
    aec2:	f280 809d 	bge.w	b000 <_malloc_r+0x1d0>
    aec6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    aeca:	f080 8161 	bcs.w	b190 <_malloc_r+0x360>
    aece:	08db      	lsrs	r3, r3, #3
    aed0:	f103 0c01 	add.w	ip, r3, #1
    aed4:	1099      	asrs	r1, r3, #2
    aed6:	687a      	ldr	r2, [r7, #4]
    aed8:	f857 803c 	ldr.w	r8, [r7, ip, lsl #3]
    aedc:	f8c4 8008 	str.w	r8, [r4, #8]
    aee0:	2301      	movs	r3, #1
    aee2:	408b      	lsls	r3, r1
    aee4:	eb07 01cc 	add.w	r1, r7, ip, lsl #3
    aee8:	4313      	orrs	r3, r2
    aeea:	3908      	subs	r1, #8
    aeec:	60e1      	str	r1, [r4, #12]
    aeee:	607b      	str	r3, [r7, #4]
    aef0:	f847 403c 	str.w	r4, [r7, ip, lsl #3]
    aef4:	f8c8 400c 	str.w	r4, [r8, #12]
    aef8:	1082      	asrs	r2, r0, #2
    aefa:	2401      	movs	r4, #1
    aefc:	4094      	lsls	r4, r2
    aefe:	429c      	cmp	r4, r3
    af00:	f200 808b 	bhi.w	b01a <_malloc_r+0x1ea>
    af04:	421c      	tst	r4, r3
    af06:	d106      	bne.n	af16 <_malloc_r+0xe6>
    af08:	f020 0003 	bic.w	r0, r0, #3
    af0c:	0064      	lsls	r4, r4, #1
    af0e:	421c      	tst	r4, r3
    af10:	f100 0004 	add.w	r0, r0, #4
    af14:	d0fa      	beq.n	af0c <_malloc_r+0xdc>
    af16:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    af1a:	46cc      	mov	ip, r9
    af1c:	4680      	mov	r8, r0
    af1e:	f8dc 300c 	ldr.w	r3, [ip, #12]
    af22:	459c      	cmp	ip, r3
    af24:	d107      	bne.n	af36 <_malloc_r+0x106>
    af26:	e16d      	b.n	b204 <_malloc_r+0x3d4>
    af28:	2a00      	cmp	r2, #0
    af2a:	f280 817b 	bge.w	b224 <_malloc_r+0x3f4>
    af2e:	68db      	ldr	r3, [r3, #12]
    af30:	459c      	cmp	ip, r3
    af32:	f000 8167 	beq.w	b204 <_malloc_r+0x3d4>
    af36:	6859      	ldr	r1, [r3, #4]
    af38:	f021 0103 	bic.w	r1, r1, #3
    af3c:	1b8a      	subs	r2, r1, r6
    af3e:	2a0f      	cmp	r2, #15
    af40:	ddf2      	ble.n	af28 <_malloc_r+0xf8>
    af42:	f8d3 c00c 	ldr.w	ip, [r3, #12]
    af46:	f8d3 8008 	ldr.w	r8, [r3, #8]
    af4a:	9300      	str	r3, [sp, #0]
    af4c:	199c      	adds	r4, r3, r6
    af4e:	4628      	mov	r0, r5
    af50:	f046 0601 	orr.w	r6, r6, #1
    af54:	f042 0501 	orr.w	r5, r2, #1
    af58:	605e      	str	r6, [r3, #4]
    af5a:	f8c8 c00c 	str.w	ip, [r8, #12]
    af5e:	f8cc 8008 	str.w	r8, [ip, #8]
    af62:	617c      	str	r4, [r7, #20]
    af64:	613c      	str	r4, [r7, #16]
    af66:	f8c4 e00c 	str.w	lr, [r4, #12]
    af6a:	f8c4 e008 	str.w	lr, [r4, #8]
    af6e:	6065      	str	r5, [r4, #4]
    af70:	505a      	str	r2, [r3, r1]
    af72:	f7f8 fda3 	bl	3abc <__malloc_unlock>
    af76:	9b00      	ldr	r3, [sp, #0]
    af78:	f103 0408 	add.w	r4, r3, #8
    af7c:	e01e      	b.n	afbc <_malloc_r+0x18c>
    af7e:	2910      	cmp	r1, #16
    af80:	d820      	bhi.n	afc4 <_malloc_r+0x194>
    af82:	f7f8 fd91 	bl	3aa8 <__malloc_lock>
    af86:	2610      	movs	r6, #16
    af88:	2318      	movs	r3, #24
    af8a:	2002      	movs	r0, #2
    af8c:	4f79      	ldr	r7, [pc, #484]	; (b174 <_malloc_r+0x344>)
    af8e:	443b      	add	r3, r7
    af90:	f1a3 0208 	sub.w	r2, r3, #8
    af94:	685c      	ldr	r4, [r3, #4]
    af96:	4294      	cmp	r4, r2
    af98:	f000 813d 	beq.w	b216 <_malloc_r+0x3e6>
    af9c:	6863      	ldr	r3, [r4, #4]
    af9e:	68e1      	ldr	r1, [r4, #12]
    afa0:	68a6      	ldr	r6, [r4, #8]
    afa2:	f023 0303 	bic.w	r3, r3, #3
    afa6:	4423      	add	r3, r4
    afa8:	4628      	mov	r0, r5
    afaa:	685a      	ldr	r2, [r3, #4]
    afac:	60f1      	str	r1, [r6, #12]
    afae:	f042 0201 	orr.w	r2, r2, #1
    afb2:	608e      	str	r6, [r1, #8]
    afb4:	605a      	str	r2, [r3, #4]
    afb6:	f7f8 fd81 	bl	3abc <__malloc_unlock>
    afba:	3408      	adds	r4, #8
    afbc:	4620      	mov	r0, r4
    afbe:	b003      	add	sp, #12
    afc0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    afc4:	2400      	movs	r4, #0
    afc6:	230c      	movs	r3, #12
    afc8:	4620      	mov	r0, r4
    afca:	602b      	str	r3, [r5, #0]
    afcc:	b003      	add	sp, #12
    afce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    afd2:	2040      	movs	r0, #64	; 0x40
    afd4:	f44f 7300 	mov.w	r3, #512	; 0x200
    afd8:	f04f 0e3f 	mov.w	lr, #63	; 0x3f
    afdc:	e74a      	b.n	ae74 <_malloc_r+0x44>
    afde:	4423      	add	r3, r4
    afe0:	68e1      	ldr	r1, [r4, #12]
    afe2:	685a      	ldr	r2, [r3, #4]
    afe4:	68a6      	ldr	r6, [r4, #8]
    afe6:	f042 0201 	orr.w	r2, r2, #1
    afea:	60f1      	str	r1, [r6, #12]
    afec:	4628      	mov	r0, r5
    afee:	608e      	str	r6, [r1, #8]
    aff0:	605a      	str	r2, [r3, #4]
    aff2:	f7f8 fd63 	bl	3abc <__malloc_unlock>
    aff6:	3408      	adds	r4, #8
    aff8:	4620      	mov	r0, r4
    affa:	b003      	add	sp, #12
    affc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b000:	4423      	add	r3, r4
    b002:	4628      	mov	r0, r5
    b004:	685a      	ldr	r2, [r3, #4]
    b006:	f042 0201 	orr.w	r2, r2, #1
    b00a:	605a      	str	r2, [r3, #4]
    b00c:	f7f8 fd56 	bl	3abc <__malloc_unlock>
    b010:	3408      	adds	r4, #8
    b012:	4620      	mov	r0, r4
    b014:	b003      	add	sp, #12
    b016:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b01a:	68bc      	ldr	r4, [r7, #8]
    b01c:	6863      	ldr	r3, [r4, #4]
    b01e:	f023 0803 	bic.w	r8, r3, #3
    b022:	45b0      	cmp	r8, r6
    b024:	d304      	bcc.n	b030 <_malloc_r+0x200>
    b026:	eba8 0306 	sub.w	r3, r8, r6
    b02a:	2b0f      	cmp	r3, #15
    b02c:	f300 8085 	bgt.w	b13a <_malloc_r+0x30a>
    b030:	f8df 9158 	ldr.w	r9, [pc, #344]	; b18c <_malloc_r+0x35c>
    b034:	4b50      	ldr	r3, [pc, #320]	; (b178 <_malloc_r+0x348>)
    b036:	f8d9 2000 	ldr.w	r2, [r9]
    b03a:	681b      	ldr	r3, [r3, #0]
    b03c:	3201      	adds	r2, #1
    b03e:	4433      	add	r3, r6
    b040:	eb04 0a08 	add.w	sl, r4, r8
    b044:	f000 8155 	beq.w	b2f2 <_malloc_r+0x4c2>
    b048:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    b04c:	330f      	adds	r3, #15
    b04e:	f423 6b7f 	bic.w	fp, r3, #4080	; 0xff0
    b052:	f02b 0b0f 	bic.w	fp, fp, #15
    b056:	4659      	mov	r1, fp
    b058:	4628      	mov	r0, r5
    b05a:	f000 fa75 	bl	b548 <_sbrk_r>
    b05e:	1c41      	adds	r1, r0, #1
    b060:	4602      	mov	r2, r0
    b062:	f000 80fc 	beq.w	b25e <_malloc_r+0x42e>
    b066:	4582      	cmp	sl, r0
    b068:	f200 80f7 	bhi.w	b25a <_malloc_r+0x42a>
    b06c:	4b43      	ldr	r3, [pc, #268]	; (b17c <_malloc_r+0x34c>)
    b06e:	6819      	ldr	r1, [r3, #0]
    b070:	4459      	add	r1, fp
    b072:	6019      	str	r1, [r3, #0]
    b074:	f000 814d 	beq.w	b312 <_malloc_r+0x4e2>
    b078:	f8d9 0000 	ldr.w	r0, [r9]
    b07c:	3001      	adds	r0, #1
    b07e:	bf1b      	ittet	ne
    b080:	eba2 0a0a 	subne.w	sl, r2, sl
    b084:	4451      	addne	r1, sl
    b086:	f8c9 2000 	streq.w	r2, [r9]
    b08a:	6019      	strne	r1, [r3, #0]
    b08c:	f012 0107 	ands.w	r1, r2, #7
    b090:	f000 8115 	beq.w	b2be <_malloc_r+0x48e>
    b094:	f1c1 0008 	rsb	r0, r1, #8
    b098:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
    b09c:	4402      	add	r2, r0
    b09e:	3108      	adds	r1, #8
    b0a0:	eb02 090b 	add.w	r9, r2, fp
    b0a4:	f3c9 090b 	ubfx	r9, r9, #0, #12
    b0a8:	eba1 0909 	sub.w	r9, r1, r9
    b0ac:	4649      	mov	r1, r9
    b0ae:	4628      	mov	r0, r5
    b0b0:	9301      	str	r3, [sp, #4]
    b0b2:	9200      	str	r2, [sp, #0]
    b0b4:	f000 fa48 	bl	b548 <_sbrk_r>
    b0b8:	1c43      	adds	r3, r0, #1
    b0ba:	e89d 000c 	ldmia.w	sp, {r2, r3}
    b0be:	f000 8143 	beq.w	b348 <_malloc_r+0x518>
    b0c2:	1a80      	subs	r0, r0, r2
    b0c4:	4448      	add	r0, r9
    b0c6:	f040 0001 	orr.w	r0, r0, #1
    b0ca:	6819      	ldr	r1, [r3, #0]
    b0cc:	60ba      	str	r2, [r7, #8]
    b0ce:	4449      	add	r1, r9
    b0d0:	42bc      	cmp	r4, r7
    b0d2:	6050      	str	r0, [r2, #4]
    b0d4:	6019      	str	r1, [r3, #0]
    b0d6:	d017      	beq.n	b108 <_malloc_r+0x2d8>
    b0d8:	f1b8 0f0f 	cmp.w	r8, #15
    b0dc:	f240 80fb 	bls.w	b2d6 <_malloc_r+0x4a6>
    b0e0:	6860      	ldr	r0, [r4, #4]
    b0e2:	f1a8 020c 	sub.w	r2, r8, #12
    b0e6:	f022 0207 	bic.w	r2, r2, #7
    b0ea:	eb04 0e02 	add.w	lr, r4, r2
    b0ee:	f000 0001 	and.w	r0, r0, #1
    b0f2:	f04f 0c05 	mov.w	ip, #5
    b0f6:	4310      	orrs	r0, r2
    b0f8:	2a0f      	cmp	r2, #15
    b0fa:	6060      	str	r0, [r4, #4]
    b0fc:	f8ce c004 	str.w	ip, [lr, #4]
    b100:	f8ce c008 	str.w	ip, [lr, #8]
    b104:	f200 8117 	bhi.w	b336 <_malloc_r+0x506>
    b108:	4b1d      	ldr	r3, [pc, #116]	; (b180 <_malloc_r+0x350>)
    b10a:	68bc      	ldr	r4, [r7, #8]
    b10c:	681a      	ldr	r2, [r3, #0]
    b10e:	4291      	cmp	r1, r2
    b110:	bf88      	it	hi
    b112:	6019      	strhi	r1, [r3, #0]
    b114:	4b1b      	ldr	r3, [pc, #108]	; (b184 <_malloc_r+0x354>)
    b116:	681a      	ldr	r2, [r3, #0]
    b118:	4291      	cmp	r1, r2
    b11a:	6862      	ldr	r2, [r4, #4]
    b11c:	bf88      	it	hi
    b11e:	6019      	strhi	r1, [r3, #0]
    b120:	f022 0203 	bic.w	r2, r2, #3
    b124:	4296      	cmp	r6, r2
    b126:	eba2 0306 	sub.w	r3, r2, r6
    b12a:	d801      	bhi.n	b130 <_malloc_r+0x300>
    b12c:	2b0f      	cmp	r3, #15
    b12e:	dc04      	bgt.n	b13a <_malloc_r+0x30a>
    b130:	4628      	mov	r0, r5
    b132:	f7f8 fcc3 	bl	3abc <__malloc_unlock>
    b136:	2400      	movs	r4, #0
    b138:	e740      	b.n	afbc <_malloc_r+0x18c>
    b13a:	19a2      	adds	r2, r4, r6
    b13c:	f043 0301 	orr.w	r3, r3, #1
    b140:	f046 0601 	orr.w	r6, r6, #1
    b144:	6066      	str	r6, [r4, #4]
    b146:	4628      	mov	r0, r5
    b148:	60ba      	str	r2, [r7, #8]
    b14a:	6053      	str	r3, [r2, #4]
    b14c:	f7f8 fcb6 	bl	3abc <__malloc_unlock>
    b150:	3408      	adds	r4, #8
    b152:	4620      	mov	r0, r4
    b154:	b003      	add	sp, #12
    b156:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b15a:	2b14      	cmp	r3, #20
    b15c:	d971      	bls.n	b242 <_malloc_r+0x412>
    b15e:	2b54      	cmp	r3, #84	; 0x54
    b160:	f200 80a3 	bhi.w	b2aa <_malloc_r+0x47a>
    b164:	0b33      	lsrs	r3, r6, #12
    b166:	f103 006f 	add.w	r0, r3, #111	; 0x6f
    b16a:	f103 0e6e 	add.w	lr, r3, #110	; 0x6e
    b16e:	00c3      	lsls	r3, r0, #3
    b170:	e680      	b.n	ae74 <_malloc_r+0x44>
    b172:	bf00      	nop
    b174:	2000075c 	.word	0x2000075c
    b178:	20001570 	.word	0x20001570
    b17c:	20001540 	.word	0x20001540
    b180:	20001568 	.word	0x20001568
    b184:	2000156c 	.word	0x2000156c
    b188:	20000764 	.word	0x20000764
    b18c:	20000b64 	.word	0x20000b64
    b190:	0a5a      	lsrs	r2, r3, #9
    b192:	2a04      	cmp	r2, #4
    b194:	d95b      	bls.n	b24e <_malloc_r+0x41e>
    b196:	2a14      	cmp	r2, #20
    b198:	f200 80ae 	bhi.w	b2f8 <_malloc_r+0x4c8>
    b19c:	f102 015c 	add.w	r1, r2, #92	; 0x5c
    b1a0:	00c9      	lsls	r1, r1, #3
    b1a2:	325b      	adds	r2, #91	; 0x5b
    b1a4:	eb07 0c01 	add.w	ip, r7, r1
    b1a8:	5879      	ldr	r1, [r7, r1]
    b1aa:	f1ac 0c08 	sub.w	ip, ip, #8
    b1ae:	458c      	cmp	ip, r1
    b1b0:	f000 8088 	beq.w	b2c4 <_malloc_r+0x494>
    b1b4:	684a      	ldr	r2, [r1, #4]
    b1b6:	f022 0203 	bic.w	r2, r2, #3
    b1ba:	4293      	cmp	r3, r2
    b1bc:	d273      	bcs.n	b2a6 <_malloc_r+0x476>
    b1be:	6889      	ldr	r1, [r1, #8]
    b1c0:	458c      	cmp	ip, r1
    b1c2:	d1f7      	bne.n	b1b4 <_malloc_r+0x384>
    b1c4:	f8dc 200c 	ldr.w	r2, [ip, #12]
    b1c8:	687b      	ldr	r3, [r7, #4]
    b1ca:	60e2      	str	r2, [r4, #12]
    b1cc:	f8c4 c008 	str.w	ip, [r4, #8]
    b1d0:	6094      	str	r4, [r2, #8]
    b1d2:	f8cc 400c 	str.w	r4, [ip, #12]
    b1d6:	e68f      	b.n	aef8 <_malloc_r+0xc8>
    b1d8:	19a1      	adds	r1, r4, r6
    b1da:	f046 0c01 	orr.w	ip, r6, #1
    b1de:	f042 0601 	orr.w	r6, r2, #1
    b1e2:	f8c4 c004 	str.w	ip, [r4, #4]
    b1e6:	4628      	mov	r0, r5
    b1e8:	6179      	str	r1, [r7, #20]
    b1ea:	6139      	str	r1, [r7, #16]
    b1ec:	f8c1 e00c 	str.w	lr, [r1, #12]
    b1f0:	f8c1 e008 	str.w	lr, [r1, #8]
    b1f4:	604e      	str	r6, [r1, #4]
    b1f6:	50e2      	str	r2, [r4, r3]
    b1f8:	f7f8 fc60 	bl	3abc <__malloc_unlock>
    b1fc:	3408      	adds	r4, #8
    b1fe:	e6dd      	b.n	afbc <_malloc_r+0x18c>
    b200:	687b      	ldr	r3, [r7, #4]
    b202:	e679      	b.n	aef8 <_malloc_r+0xc8>
    b204:	f108 0801 	add.w	r8, r8, #1
    b208:	f018 0f03 	tst.w	r8, #3
    b20c:	f10c 0c08 	add.w	ip, ip, #8
    b210:	f47f ae85 	bne.w	af1e <_malloc_r+0xee>
    b214:	e02d      	b.n	b272 <_malloc_r+0x442>
    b216:	68dc      	ldr	r4, [r3, #12]
    b218:	42a3      	cmp	r3, r4
    b21a:	bf08      	it	eq
    b21c:	3002      	addeq	r0, #2
    b21e:	f43f ae3e 	beq.w	ae9e <_malloc_r+0x6e>
    b222:	e6bb      	b.n	af9c <_malloc_r+0x16c>
    b224:	4419      	add	r1, r3
    b226:	461c      	mov	r4, r3
    b228:	684a      	ldr	r2, [r1, #4]
    b22a:	68db      	ldr	r3, [r3, #12]
    b22c:	f854 6f08 	ldr.w	r6, [r4, #8]!
    b230:	f042 0201 	orr.w	r2, r2, #1
    b234:	604a      	str	r2, [r1, #4]
    b236:	4628      	mov	r0, r5
    b238:	60f3      	str	r3, [r6, #12]
    b23a:	609e      	str	r6, [r3, #8]
    b23c:	f7f8 fc3e 	bl	3abc <__malloc_unlock>
    b240:	e6bc      	b.n	afbc <_malloc_r+0x18c>
    b242:	f103 005c 	add.w	r0, r3, #92	; 0x5c
    b246:	f103 0e5b 	add.w	lr, r3, #91	; 0x5b
    b24a:	00c3      	lsls	r3, r0, #3
    b24c:	e612      	b.n	ae74 <_malloc_r+0x44>
    b24e:	099a      	lsrs	r2, r3, #6
    b250:	f102 0139 	add.w	r1, r2, #57	; 0x39
    b254:	00c9      	lsls	r1, r1, #3
    b256:	3238      	adds	r2, #56	; 0x38
    b258:	e7a4      	b.n	b1a4 <_malloc_r+0x374>
    b25a:	42bc      	cmp	r4, r7
    b25c:	d054      	beq.n	b308 <_malloc_r+0x4d8>
    b25e:	68bc      	ldr	r4, [r7, #8]
    b260:	6862      	ldr	r2, [r4, #4]
    b262:	f022 0203 	bic.w	r2, r2, #3
    b266:	e75d      	b.n	b124 <_malloc_r+0x2f4>
    b268:	f859 3908 	ldr.w	r3, [r9], #-8
    b26c:	4599      	cmp	r9, r3
    b26e:	f040 8086 	bne.w	b37e <_malloc_r+0x54e>
    b272:	f010 0f03 	tst.w	r0, #3
    b276:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    b27a:	d1f5      	bne.n	b268 <_malloc_r+0x438>
    b27c:	687b      	ldr	r3, [r7, #4]
    b27e:	ea23 0304 	bic.w	r3, r3, r4
    b282:	607b      	str	r3, [r7, #4]
    b284:	0064      	lsls	r4, r4, #1
    b286:	429c      	cmp	r4, r3
    b288:	f63f aec7 	bhi.w	b01a <_malloc_r+0x1ea>
    b28c:	2c00      	cmp	r4, #0
    b28e:	f43f aec4 	beq.w	b01a <_malloc_r+0x1ea>
    b292:	421c      	tst	r4, r3
    b294:	4640      	mov	r0, r8
    b296:	f47f ae3e 	bne.w	af16 <_malloc_r+0xe6>
    b29a:	0064      	lsls	r4, r4, #1
    b29c:	421c      	tst	r4, r3
    b29e:	f100 0004 	add.w	r0, r0, #4
    b2a2:	d0fa      	beq.n	b29a <_malloc_r+0x46a>
    b2a4:	e637      	b.n	af16 <_malloc_r+0xe6>
    b2a6:	468c      	mov	ip, r1
    b2a8:	e78c      	b.n	b1c4 <_malloc_r+0x394>
    b2aa:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    b2ae:	d815      	bhi.n	b2dc <_malloc_r+0x4ac>
    b2b0:	0bf3      	lsrs	r3, r6, #15
    b2b2:	f103 0078 	add.w	r0, r3, #120	; 0x78
    b2b6:	f103 0e77 	add.w	lr, r3, #119	; 0x77
    b2ba:	00c3      	lsls	r3, r0, #3
    b2bc:	e5da      	b.n	ae74 <_malloc_r+0x44>
    b2be:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    b2c2:	e6ed      	b.n	b0a0 <_malloc_r+0x270>
    b2c4:	687b      	ldr	r3, [r7, #4]
    b2c6:	1092      	asrs	r2, r2, #2
    b2c8:	2101      	movs	r1, #1
    b2ca:	fa01 f202 	lsl.w	r2, r1, r2
    b2ce:	4313      	orrs	r3, r2
    b2d0:	607b      	str	r3, [r7, #4]
    b2d2:	4662      	mov	r2, ip
    b2d4:	e779      	b.n	b1ca <_malloc_r+0x39a>
    b2d6:	2301      	movs	r3, #1
    b2d8:	6053      	str	r3, [r2, #4]
    b2da:	e729      	b.n	b130 <_malloc_r+0x300>
    b2dc:	f240 5254 	movw	r2, #1364	; 0x554
    b2e0:	4293      	cmp	r3, r2
    b2e2:	d822      	bhi.n	b32a <_malloc_r+0x4fa>
    b2e4:	0cb3      	lsrs	r3, r6, #18
    b2e6:	f103 007d 	add.w	r0, r3, #125	; 0x7d
    b2ea:	f103 0e7c 	add.w	lr, r3, #124	; 0x7c
    b2ee:	00c3      	lsls	r3, r0, #3
    b2f0:	e5c0      	b.n	ae74 <_malloc_r+0x44>
    b2f2:	f103 0b10 	add.w	fp, r3, #16
    b2f6:	e6ae      	b.n	b056 <_malloc_r+0x226>
    b2f8:	2a54      	cmp	r2, #84	; 0x54
    b2fa:	d829      	bhi.n	b350 <_malloc_r+0x520>
    b2fc:	0b1a      	lsrs	r2, r3, #12
    b2fe:	f102 016f 	add.w	r1, r2, #111	; 0x6f
    b302:	00c9      	lsls	r1, r1, #3
    b304:	326e      	adds	r2, #110	; 0x6e
    b306:	e74d      	b.n	b1a4 <_malloc_r+0x374>
    b308:	4b20      	ldr	r3, [pc, #128]	; (b38c <_malloc_r+0x55c>)
    b30a:	6819      	ldr	r1, [r3, #0]
    b30c:	4459      	add	r1, fp
    b30e:	6019      	str	r1, [r3, #0]
    b310:	e6b2      	b.n	b078 <_malloc_r+0x248>
    b312:	f3ca 000b 	ubfx	r0, sl, #0, #12
    b316:	2800      	cmp	r0, #0
    b318:	f47f aeae 	bne.w	b078 <_malloc_r+0x248>
    b31c:	eb08 030b 	add.w	r3, r8, fp
    b320:	68ba      	ldr	r2, [r7, #8]
    b322:	f043 0301 	orr.w	r3, r3, #1
    b326:	6053      	str	r3, [r2, #4]
    b328:	e6ee      	b.n	b108 <_malloc_r+0x2d8>
    b32a:	207f      	movs	r0, #127	; 0x7f
    b32c:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
    b330:	f04f 0e7e 	mov.w	lr, #126	; 0x7e
    b334:	e59e      	b.n	ae74 <_malloc_r+0x44>
    b336:	f104 0108 	add.w	r1, r4, #8
    b33a:	4628      	mov	r0, r5
    b33c:	9300      	str	r3, [sp, #0]
    b33e:	f7f7 fae4 	bl	290a <__wrap__free_r>
    b342:	9b00      	ldr	r3, [sp, #0]
    b344:	6819      	ldr	r1, [r3, #0]
    b346:	e6df      	b.n	b108 <_malloc_r+0x2d8>
    b348:	2001      	movs	r0, #1
    b34a:	f04f 0900 	mov.w	r9, #0
    b34e:	e6bc      	b.n	b0ca <_malloc_r+0x29a>
    b350:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    b354:	d805      	bhi.n	b362 <_malloc_r+0x532>
    b356:	0bda      	lsrs	r2, r3, #15
    b358:	f102 0178 	add.w	r1, r2, #120	; 0x78
    b35c:	00c9      	lsls	r1, r1, #3
    b35e:	3277      	adds	r2, #119	; 0x77
    b360:	e720      	b.n	b1a4 <_malloc_r+0x374>
    b362:	f240 5154 	movw	r1, #1364	; 0x554
    b366:	428a      	cmp	r2, r1
    b368:	d805      	bhi.n	b376 <_malloc_r+0x546>
    b36a:	0c9a      	lsrs	r2, r3, #18
    b36c:	f102 017d 	add.w	r1, r2, #125	; 0x7d
    b370:	00c9      	lsls	r1, r1, #3
    b372:	327c      	adds	r2, #124	; 0x7c
    b374:	e716      	b.n	b1a4 <_malloc_r+0x374>
    b376:	f44f 717e 	mov.w	r1, #1016	; 0x3f8
    b37a:	227e      	movs	r2, #126	; 0x7e
    b37c:	e712      	b.n	b1a4 <_malloc_r+0x374>
    b37e:	687b      	ldr	r3, [r7, #4]
    b380:	e780      	b.n	b284 <_malloc_r+0x454>
    b382:	08f0      	lsrs	r0, r6, #3
    b384:	f106 0308 	add.w	r3, r6, #8
    b388:	e600      	b.n	af8c <_malloc_r+0x15c>
    b38a:	bf00      	nop
    b38c:	20001540 	.word	0x20001540

0000b390 <__ascii_mbtowc>:
    b390:	b082      	sub	sp, #8
    b392:	b149      	cbz	r1, b3a8 <__ascii_mbtowc+0x18>
    b394:	b15a      	cbz	r2, b3ae <__ascii_mbtowc+0x1e>
    b396:	b16b      	cbz	r3, b3b4 <__ascii_mbtowc+0x24>
    b398:	7813      	ldrb	r3, [r2, #0]
    b39a:	600b      	str	r3, [r1, #0]
    b39c:	7812      	ldrb	r2, [r2, #0]
    b39e:	1c10      	adds	r0, r2, #0
    b3a0:	bf18      	it	ne
    b3a2:	2001      	movne	r0, #1
    b3a4:	b002      	add	sp, #8
    b3a6:	4770      	bx	lr
    b3a8:	a901      	add	r1, sp, #4
    b3aa:	2a00      	cmp	r2, #0
    b3ac:	d1f3      	bne.n	b396 <__ascii_mbtowc+0x6>
    b3ae:	4610      	mov	r0, r2
    b3b0:	b002      	add	sp, #8
    b3b2:	4770      	bx	lr
    b3b4:	f06f 0001 	mvn.w	r0, #1
    b3b8:	e7f4      	b.n	b3a4 <__ascii_mbtowc+0x14>
    b3ba:	bf00      	nop

0000b3bc <memmove>:
    b3bc:	4288      	cmp	r0, r1
    b3be:	b5f0      	push	{r4, r5, r6, r7, lr}
    b3c0:	d90d      	bls.n	b3de <memmove+0x22>
    b3c2:	188b      	adds	r3, r1, r2
    b3c4:	4298      	cmp	r0, r3
    b3c6:	d20a      	bcs.n	b3de <memmove+0x22>
    b3c8:	1884      	adds	r4, r0, r2
    b3ca:	2a00      	cmp	r2, #0
    b3cc:	d051      	beq.n	b472 <memmove+0xb6>
    b3ce:	4622      	mov	r2, r4
    b3d0:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    b3d4:	f802 4d01 	strb.w	r4, [r2, #-1]!
    b3d8:	4299      	cmp	r1, r3
    b3da:	d1f9      	bne.n	b3d0 <memmove+0x14>
    b3dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b3de:	2a0f      	cmp	r2, #15
    b3e0:	d948      	bls.n	b474 <memmove+0xb8>
    b3e2:	ea41 0300 	orr.w	r3, r1, r0
    b3e6:	079b      	lsls	r3, r3, #30
    b3e8:	d146      	bne.n	b478 <memmove+0xbc>
    b3ea:	f100 0410 	add.w	r4, r0, #16
    b3ee:	f101 0310 	add.w	r3, r1, #16
    b3f2:	4615      	mov	r5, r2
    b3f4:	f853 6c10 	ldr.w	r6, [r3, #-16]
    b3f8:	f844 6c10 	str.w	r6, [r4, #-16]
    b3fc:	f853 6c0c 	ldr.w	r6, [r3, #-12]
    b400:	f844 6c0c 	str.w	r6, [r4, #-12]
    b404:	f853 6c08 	ldr.w	r6, [r3, #-8]
    b408:	f844 6c08 	str.w	r6, [r4, #-8]
    b40c:	3d10      	subs	r5, #16
    b40e:	f853 6c04 	ldr.w	r6, [r3, #-4]
    b412:	f844 6c04 	str.w	r6, [r4, #-4]
    b416:	2d0f      	cmp	r5, #15
    b418:	f103 0310 	add.w	r3, r3, #16
    b41c:	f104 0410 	add.w	r4, r4, #16
    b420:	d8e8      	bhi.n	b3f4 <memmove+0x38>
    b422:	f1a2 0310 	sub.w	r3, r2, #16
    b426:	f023 030f 	bic.w	r3, r3, #15
    b42a:	f002 0e0f 	and.w	lr, r2, #15
    b42e:	3310      	adds	r3, #16
    b430:	f1be 0f03 	cmp.w	lr, #3
    b434:	4419      	add	r1, r3
    b436:	4403      	add	r3, r0
    b438:	d921      	bls.n	b47e <memmove+0xc2>
    b43a:	1f1e      	subs	r6, r3, #4
    b43c:	460d      	mov	r5, r1
    b43e:	4674      	mov	r4, lr
    b440:	3c04      	subs	r4, #4
    b442:	f855 7b04 	ldr.w	r7, [r5], #4
    b446:	f846 7f04 	str.w	r7, [r6, #4]!
    b44a:	2c03      	cmp	r4, #3
    b44c:	d8f8      	bhi.n	b440 <memmove+0x84>
    b44e:	f1ae 0404 	sub.w	r4, lr, #4
    b452:	f024 0403 	bic.w	r4, r4, #3
    b456:	3404      	adds	r4, #4
    b458:	4421      	add	r1, r4
    b45a:	4423      	add	r3, r4
    b45c:	f002 0203 	and.w	r2, r2, #3
    b460:	b162      	cbz	r2, b47c <memmove+0xc0>
    b462:	3b01      	subs	r3, #1
    b464:	440a      	add	r2, r1
    b466:	f811 4b01 	ldrb.w	r4, [r1], #1
    b46a:	f803 4f01 	strb.w	r4, [r3, #1]!
    b46e:	428a      	cmp	r2, r1
    b470:	d1f9      	bne.n	b466 <memmove+0xaa>
    b472:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b474:	4603      	mov	r3, r0
    b476:	e7f3      	b.n	b460 <memmove+0xa4>
    b478:	4603      	mov	r3, r0
    b47a:	e7f2      	b.n	b462 <memmove+0xa6>
    b47c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b47e:	4672      	mov	r2, lr
    b480:	e7ee      	b.n	b460 <memmove+0xa4>
    b482:	bf00      	nop

0000b484 <memset>:
    b484:	b470      	push	{r4, r5, r6}
    b486:	0786      	lsls	r6, r0, #30
    b488:	d046      	beq.n	b518 <memset+0x94>
    b48a:	1e54      	subs	r4, r2, #1
    b48c:	2a00      	cmp	r2, #0
    b48e:	d041      	beq.n	b514 <memset+0x90>
    b490:	b2ca      	uxtb	r2, r1
    b492:	4603      	mov	r3, r0
    b494:	e002      	b.n	b49c <memset+0x18>
    b496:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
    b49a:	d33b      	bcc.n	b514 <memset+0x90>
    b49c:	f803 2b01 	strb.w	r2, [r3], #1
    b4a0:	079d      	lsls	r5, r3, #30
    b4a2:	d1f8      	bne.n	b496 <memset+0x12>
    b4a4:	2c03      	cmp	r4, #3
    b4a6:	d92e      	bls.n	b506 <memset+0x82>
    b4a8:	b2cd      	uxtb	r5, r1
    b4aa:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    b4ae:	2c0f      	cmp	r4, #15
    b4b0:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    b4b4:	d919      	bls.n	b4ea <memset+0x66>
    b4b6:	f103 0210 	add.w	r2, r3, #16
    b4ba:	4626      	mov	r6, r4
    b4bc:	3e10      	subs	r6, #16
    b4be:	2e0f      	cmp	r6, #15
    b4c0:	f842 5c10 	str.w	r5, [r2, #-16]
    b4c4:	f842 5c0c 	str.w	r5, [r2, #-12]
    b4c8:	f842 5c08 	str.w	r5, [r2, #-8]
    b4cc:	f842 5c04 	str.w	r5, [r2, #-4]
    b4d0:	f102 0210 	add.w	r2, r2, #16
    b4d4:	d8f2      	bhi.n	b4bc <memset+0x38>
    b4d6:	f1a4 0210 	sub.w	r2, r4, #16
    b4da:	f022 020f 	bic.w	r2, r2, #15
    b4de:	f004 040f 	and.w	r4, r4, #15
    b4e2:	3210      	adds	r2, #16
    b4e4:	2c03      	cmp	r4, #3
    b4e6:	4413      	add	r3, r2
    b4e8:	d90d      	bls.n	b506 <memset+0x82>
    b4ea:	461e      	mov	r6, r3
    b4ec:	4622      	mov	r2, r4
    b4ee:	3a04      	subs	r2, #4
    b4f0:	2a03      	cmp	r2, #3
    b4f2:	f846 5b04 	str.w	r5, [r6], #4
    b4f6:	d8fa      	bhi.n	b4ee <memset+0x6a>
    b4f8:	1f22      	subs	r2, r4, #4
    b4fa:	f022 0203 	bic.w	r2, r2, #3
    b4fe:	3204      	adds	r2, #4
    b500:	4413      	add	r3, r2
    b502:	f004 0403 	and.w	r4, r4, #3
    b506:	b12c      	cbz	r4, b514 <memset+0x90>
    b508:	b2c9      	uxtb	r1, r1
    b50a:	441c      	add	r4, r3
    b50c:	f803 1b01 	strb.w	r1, [r3], #1
    b510:	429c      	cmp	r4, r3
    b512:	d1fb      	bne.n	b50c <memset+0x88>
    b514:	bc70      	pop	{r4, r5, r6}
    b516:	4770      	bx	lr
    b518:	4614      	mov	r4, r2
    b51a:	4603      	mov	r3, r0
    b51c:	e7c2      	b.n	b4a4 <memset+0x20>
    b51e:	bf00      	nop

0000b520 <printf>:
    b520:	b40f      	push	{r0, r1, r2, r3}
    b522:	b500      	push	{lr}
    b524:	4907      	ldr	r1, [pc, #28]	; (b544 <printf+0x24>)
    b526:	b083      	sub	sp, #12
    b528:	ab04      	add	r3, sp, #16
    b52a:	6808      	ldr	r0, [r1, #0]
    b52c:	f853 2b04 	ldr.w	r2, [r3], #4
    b530:	6881      	ldr	r1, [r0, #8]
    b532:	9301      	str	r3, [sp, #4]
    b534:	f002 f980 	bl	d838 <_vfprintf_r>
    b538:	b003      	add	sp, #12
    b53a:	f85d eb04 	ldr.w	lr, [sp], #4
    b53e:	b004      	add	sp, #16
    b540:	4770      	bx	lr
    b542:	bf00      	nop
    b544:	200001c0 	.word	0x200001c0

0000b548 <_sbrk_r>:
    b548:	b538      	push	{r3, r4, r5, lr}
    b54a:	4c07      	ldr	r4, [pc, #28]	; (b568 <_sbrk_r+0x20>)
    b54c:	2300      	movs	r3, #0
    b54e:	4605      	mov	r5, r0
    b550:	4608      	mov	r0, r1
    b552:	6023      	str	r3, [r4, #0]
    b554:	f7f8 fa36 	bl	39c4 <_sbrk>
    b558:	1c43      	adds	r3, r0, #1
    b55a:	d000      	beq.n	b55e <_sbrk_r+0x16>
    b55c:	bd38      	pop	{r3, r4, r5, pc}
    b55e:	6823      	ldr	r3, [r4, #0]
    b560:	2b00      	cmp	r3, #0
    b562:	d0fb      	beq.n	b55c <_sbrk_r+0x14>
    b564:	602b      	str	r3, [r5, #0]
    b566:	bd38      	pop	{r3, r4, r5, pc}
    b568:	2000304c 	.word	0x2000304c

0000b56c <__sread>:
    b56c:	b510      	push	{r4, lr}
    b56e:	460c      	mov	r4, r1
    b570:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    b574:	f005 f912 	bl	1079c <_read_r>
    b578:	2800      	cmp	r0, #0
    b57a:	db03      	blt.n	b584 <__sread+0x18>
    b57c:	6d23      	ldr	r3, [r4, #80]	; 0x50
    b57e:	4403      	add	r3, r0
    b580:	6523      	str	r3, [r4, #80]	; 0x50
    b582:	bd10      	pop	{r4, pc}
    b584:	89a3      	ldrh	r3, [r4, #12]
    b586:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    b58a:	81a3      	strh	r3, [r4, #12]
    b58c:	bd10      	pop	{r4, pc}
    b58e:	bf00      	nop

0000b590 <__swrite>:
    b590:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b594:	4616      	mov	r6, r2
    b596:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
    b59a:	461f      	mov	r7, r3
    b59c:	05d3      	lsls	r3, r2, #23
    b59e:	460c      	mov	r4, r1
    b5a0:	4605      	mov	r5, r0
    b5a2:	d507      	bpl.n	b5b4 <__swrite+0x24>
    b5a4:	2200      	movs	r2, #0
    b5a6:	2302      	movs	r3, #2
    b5a8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    b5ac:	f004 fde6 	bl	1017c <_lseek_r>
    b5b0:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    b5b4:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    b5b8:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
    b5bc:	81a2      	strh	r2, [r4, #12]
    b5be:	463b      	mov	r3, r7
    b5c0:	4632      	mov	r2, r6
    b5c2:	4628      	mov	r0, r5
    b5c4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    b5c8:	f003 bcf2 	b.w	efb0 <_write_r>

0000b5cc <__sseek>:
    b5cc:	b510      	push	{r4, lr}
    b5ce:	460c      	mov	r4, r1
    b5d0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    b5d4:	f004 fdd2 	bl	1017c <_lseek_r>
    b5d8:	89a3      	ldrh	r3, [r4, #12]
    b5da:	1c42      	adds	r2, r0, #1
    b5dc:	bf0e      	itee	eq
    b5de:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
    b5e2:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
    b5e6:	6520      	strne	r0, [r4, #80]	; 0x50
    b5e8:	81a3      	strh	r3, [r4, #12]
    b5ea:	bd10      	pop	{r4, pc}

0000b5ec <__sclose>:
    b5ec:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    b5f0:	f003 bd60 	b.w	f0b4 <_close_r>
    b5f4:	0000      	movs	r0, r0
	...

0000b5f8 <_svfprintf_r>:
    b5f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b5fc:	b0c5      	sub	sp, #276	; 0x114
    b5fe:	460c      	mov	r4, r1
    b600:	910b      	str	r1, [sp, #44]	; 0x2c
    b602:	4692      	mov	sl, r2
    b604:	930f      	str	r3, [sp, #60]	; 0x3c
    b606:	900c      	str	r0, [sp, #48]	; 0x30
    b608:	f004 fdaa 	bl	10160 <_localeconv_r>
    b60c:	6803      	ldr	r3, [r0, #0]
    b60e:	9318      	str	r3, [sp, #96]	; 0x60
    b610:	4618      	mov	r0, r3
    b612:	f7f5 fa35 	bl	a80 <strlen>
    b616:	89a3      	ldrh	r3, [r4, #12]
    b618:	9017      	str	r0, [sp, #92]	; 0x5c
    b61a:	0619      	lsls	r1, r3, #24
    b61c:	d503      	bpl.n	b626 <_svfprintf_r+0x2e>
    b61e:	6923      	ldr	r3, [r4, #16]
    b620:	2b00      	cmp	r3, #0
    b622:	f001 801b 	beq.w	c65c <_svfprintf_r+0x1064>
    b626:	ed9f 7b94 	vldr	d7, [pc, #592]	; b878 <_svfprintf_r+0x280>
    b62a:	ed8d 7b14 	vstr	d7, [sp, #80]	; 0x50
    b62e:	2300      	movs	r3, #0
    b630:	f10d 09d0 	add.w	r9, sp, #208	; 0xd0
    b634:	9313      	str	r3, [sp, #76]	; 0x4c
    b636:	9329      	str	r3, [sp, #164]	; 0xa4
    b638:	9328      	str	r3, [sp, #160]	; 0xa0
    b63a:	9316      	str	r3, [sp, #88]	; 0x58
    b63c:	9319      	str	r3, [sp, #100]	; 0x64
    b63e:	9309      	str	r3, [sp, #36]	; 0x24
    b640:	f8cd 909c 	str.w	r9, [sp, #156]	; 0x9c
    b644:	46c8      	mov	r8, r9
    b646:	f89a 3000 	ldrb.w	r3, [sl]
    b64a:	4654      	mov	r4, sl
    b64c:	b1e3      	cbz	r3, b688 <_svfprintf_r+0x90>
    b64e:	2b25      	cmp	r3, #37	; 0x25
    b650:	d102      	bne.n	b658 <_svfprintf_r+0x60>
    b652:	e019      	b.n	b688 <_svfprintf_r+0x90>
    b654:	2b25      	cmp	r3, #37	; 0x25
    b656:	d003      	beq.n	b660 <_svfprintf_r+0x68>
    b658:	f814 3f01 	ldrb.w	r3, [r4, #1]!
    b65c:	2b00      	cmp	r3, #0
    b65e:	d1f9      	bne.n	b654 <_svfprintf_r+0x5c>
    b660:	eba4 050a 	sub.w	r5, r4, sl
    b664:	b185      	cbz	r5, b688 <_svfprintf_r+0x90>
    b666:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    b668:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    b66a:	f8c8 a000 	str.w	sl, [r8]
    b66e:	3301      	adds	r3, #1
    b670:	442a      	add	r2, r5
    b672:	2b07      	cmp	r3, #7
    b674:	f8c8 5004 	str.w	r5, [r8, #4]
    b678:	9229      	str	r2, [sp, #164]	; 0xa4
    b67a:	9328      	str	r3, [sp, #160]	; 0xa0
    b67c:	dc7f      	bgt.n	b77e <_svfprintf_r+0x186>
    b67e:	f108 0808 	add.w	r8, r8, #8
    b682:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b684:	442b      	add	r3, r5
    b686:	9309      	str	r3, [sp, #36]	; 0x24
    b688:	7823      	ldrb	r3, [r4, #0]
    b68a:	2b00      	cmp	r3, #0
    b68c:	d07f      	beq.n	b78e <_svfprintf_r+0x196>
    b68e:	2300      	movs	r3, #0
    b690:	461a      	mov	r2, r3
    b692:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
    b696:	4619      	mov	r1, r3
    b698:	930d      	str	r3, [sp, #52]	; 0x34
    b69a:	469b      	mov	fp, r3
    b69c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    b6a0:	7863      	ldrb	r3, [r4, #1]
    b6a2:	900a      	str	r0, [sp, #40]	; 0x28
    b6a4:	f104 0a01 	add.w	sl, r4, #1
    b6a8:	f10a 0a01 	add.w	sl, sl, #1
    b6ac:	f1a3 0020 	sub.w	r0, r3, #32
    b6b0:	2858      	cmp	r0, #88	; 0x58
    b6b2:	f200 83d3 	bhi.w	be5c <_svfprintf_r+0x864>
    b6b6:	e8df f010 	tbh	[pc, r0, lsl #1]
    b6ba:	023f      	.short	0x023f
    b6bc:	03d103d1 	.word	0x03d103d1
    b6c0:	03d10247 	.word	0x03d10247
    b6c4:	03d103d1 	.word	0x03d103d1
    b6c8:	03d103d1 	.word	0x03d103d1
    b6cc:	024c03d1 	.word	0x024c03d1
    b6d0:	03d1020a 	.word	0x03d1020a
    b6d4:	0273005d 	.word	0x0273005d
    b6d8:	028e03d1 	.word	0x028e03d1
    b6dc:	03c103c1 	.word	0x03c103c1
    b6e0:	03c103c1 	.word	0x03c103c1
    b6e4:	03c103c1 	.word	0x03c103c1
    b6e8:	03c103c1 	.word	0x03c103c1
    b6ec:	03d103c1 	.word	0x03d103c1
    b6f0:	03d103d1 	.word	0x03d103d1
    b6f4:	03d103d1 	.word	0x03d103d1
    b6f8:	03d103d1 	.word	0x03d103d1
    b6fc:	03d103d1 	.word	0x03d103d1
    b700:	033f03d1 	.word	0x033f03d1
    b704:	03d1035f 	.word	0x03d1035f
    b708:	03d1035f 	.word	0x03d1035f
    b70c:	03d103d1 	.word	0x03d103d1
    b710:	03aa03d1 	.word	0x03aa03d1
    b714:	03d103d1 	.word	0x03d103d1
    b718:	03d103af 	.word	0x03d103af
    b71c:	03d103d1 	.word	0x03d103d1
    b720:	03d103d1 	.word	0x03d103d1
    b724:	03d10261 	.word	0x03d10261
    b728:	032603d1 	.word	0x032603d1
    b72c:	03d103d1 	.word	0x03d103d1
    b730:	03d103d1 	.word	0x03d103d1
    b734:	03d103d1 	.word	0x03d103d1
    b738:	03d103d1 	.word	0x03d103d1
    b73c:	03d103d1 	.word	0x03d103d1
    b740:	02e302ce 	.word	0x02e302ce
    b744:	035f035f 	.word	0x035f035f
    b748:	0293035f 	.word	0x0293035f
    b74c:	03d102e3 	.word	0x03d102e3
    b750:	029803d1 	.word	0x029803d1
    b754:	02a503d1 	.word	0x02a503d1
    b758:	02bc01d3 	.word	0x02bc01d3
    b75c:	03d1020f 	.word	0x03d1020f
    b760:	03d101e8 	.word	0x03d101e8
    b764:	03d1007e 	.word	0x03d1007e
    b768:	021403d1 	.word	0x021403d1
    b76c:	980d      	ldr	r0, [sp, #52]	; 0x34
    b76e:	930f      	str	r3, [sp, #60]	; 0x3c
    b770:	4240      	negs	r0, r0
    b772:	900d      	str	r0, [sp, #52]	; 0x34
    b774:	f04b 0b04 	orr.w	fp, fp, #4
    b778:	f89a 3000 	ldrb.w	r3, [sl]
    b77c:	e794      	b.n	b6a8 <_svfprintf_r+0xb0>
    b77e:	aa27      	add	r2, sp, #156	; 0x9c
    b780:	990b      	ldr	r1, [sp, #44]	; 0x2c
    b782:	980c      	ldr	r0, [sp, #48]	; 0x30
    b784:	f005 f86e 	bl	10864 <__ssprint_r>
    b788:	b940      	cbnz	r0, b79c <_svfprintf_r+0x1a4>
    b78a:	46c8      	mov	r8, r9
    b78c:	e779      	b.n	b682 <_svfprintf_r+0x8a>
    b78e:	9b29      	ldr	r3, [sp, #164]	; 0xa4
    b790:	b123      	cbz	r3, b79c <_svfprintf_r+0x1a4>
    b792:	980c      	ldr	r0, [sp, #48]	; 0x30
    b794:	990b      	ldr	r1, [sp, #44]	; 0x2c
    b796:	aa27      	add	r2, sp, #156	; 0x9c
    b798:	f005 f864 	bl	10864 <__ssprint_r>
    b79c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    b79e:	899b      	ldrh	r3, [r3, #12]
    b7a0:	f013 0f40 	tst.w	r3, #64	; 0x40
    b7a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b7a6:	bf18      	it	ne
    b7a8:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
    b7ac:	9309      	str	r3, [sp, #36]	; 0x24
    b7ae:	9809      	ldr	r0, [sp, #36]	; 0x24
    b7b0:	b045      	add	sp, #276	; 0x114
    b7b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b7b6:	f01b 0f20 	tst.w	fp, #32
    b7ba:	9311      	str	r3, [sp, #68]	; 0x44
    b7bc:	f040 81e5 	bne.w	bb8a <_svfprintf_r+0x592>
    b7c0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    b7c2:	f01b 0f10 	tst.w	fp, #16
    b7c6:	4613      	mov	r3, r2
    b7c8:	f040 8588 	bne.w	c2dc <_svfprintf_r+0xce4>
    b7cc:	f01b 0f40 	tst.w	fp, #64	; 0x40
    b7d0:	f000 8584 	beq.w	c2dc <_svfprintf_r+0xce4>
    b7d4:	8814      	ldrh	r4, [r2, #0]
    b7d6:	3204      	adds	r2, #4
    b7d8:	2500      	movs	r5, #0
    b7da:	2301      	movs	r3, #1
    b7dc:	920f      	str	r2, [sp, #60]	; 0x3c
    b7de:	2700      	movs	r7, #0
    b7e0:	f88d 707f 	strb.w	r7, [sp, #127]	; 0x7f
    b7e4:	990a      	ldr	r1, [sp, #40]	; 0x28
    b7e6:	1c4a      	adds	r2, r1, #1
    b7e8:	f000 826d 	beq.w	bcc6 <_svfprintf_r+0x6ce>
    b7ec:	f02b 0280 	bic.w	r2, fp, #128	; 0x80
    b7f0:	9207      	str	r2, [sp, #28]
    b7f2:	ea54 0205 	orrs.w	r2, r4, r5
    b7f6:	f040 826c 	bne.w	bcd2 <_svfprintf_r+0x6da>
    b7fa:	2900      	cmp	r1, #0
    b7fc:	f040 8451 	bne.w	c0a2 <_svfprintf_r+0xaaa>
    b800:	2b00      	cmp	r3, #0
    b802:	f040 850b 	bne.w	c21c <_svfprintf_r+0xc24>
    b806:	f01b 0301 	ands.w	r3, fp, #1
    b80a:	930e      	str	r3, [sp, #56]	; 0x38
    b80c:	f000 861a 	beq.w	c444 <_svfprintf_r+0xe4c>
    b810:	ae44      	add	r6, sp, #272	; 0x110
    b812:	2330      	movs	r3, #48	; 0x30
    b814:	f806 3d41 	strb.w	r3, [r6, #-65]!
    b818:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    b81a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    b81c:	4293      	cmp	r3, r2
    b81e:	bfb8      	it	lt
    b820:	4613      	movlt	r3, r2
    b822:	9308      	str	r3, [sp, #32]
    b824:	2300      	movs	r3, #0
    b826:	9312      	str	r3, [sp, #72]	; 0x48
    b828:	b117      	cbz	r7, b830 <_svfprintf_r+0x238>
    b82a:	9b08      	ldr	r3, [sp, #32]
    b82c:	3301      	adds	r3, #1
    b82e:	9308      	str	r3, [sp, #32]
    b830:	9b07      	ldr	r3, [sp, #28]
    b832:	f013 0302 	ands.w	r3, r3, #2
    b836:	9310      	str	r3, [sp, #64]	; 0x40
    b838:	d002      	beq.n	b840 <_svfprintf_r+0x248>
    b83a:	9b08      	ldr	r3, [sp, #32]
    b83c:	3302      	adds	r3, #2
    b83e:	9308      	str	r3, [sp, #32]
    b840:	9b07      	ldr	r3, [sp, #28]
    b842:	f013 0584 	ands.w	r5, r3, #132	; 0x84
    b846:	f040 8320 	bne.w	be8a <_svfprintf_r+0x892>
    b84a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    b84c:	9a08      	ldr	r2, [sp, #32]
    b84e:	eba3 0b02 	sub.w	fp, r3, r2
    b852:	f1bb 0f00 	cmp.w	fp, #0
    b856:	f340 8318 	ble.w	be8a <_svfprintf_r+0x892>
    b85a:	f1bb 0f10 	cmp.w	fp, #16
    b85e:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    b860:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    b862:	dd30      	ble.n	b8c6 <_svfprintf_r+0x2ce>
    b864:	4643      	mov	r3, r8
    b866:	4621      	mov	r1, r4
    b868:	46a8      	mov	r8, r5
    b86a:	2710      	movs	r7, #16
    b86c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    b86e:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    b870:	e00d      	b.n	b88e <_svfprintf_r+0x296>
    b872:	bf00      	nop
    b874:	f3af 8000 	nop.w
	...
    b880:	f1ab 0b10 	sub.w	fp, fp, #16
    b884:	f1bb 0f10 	cmp.w	fp, #16
    b888:	f103 0308 	add.w	r3, r3, #8
    b88c:	dd18      	ble.n	b8c0 <_svfprintf_r+0x2c8>
    b88e:	3201      	adds	r2, #1
    b890:	48b7      	ldr	r0, [pc, #732]	; (bb70 <_svfprintf_r+0x578>)
    b892:	9228      	str	r2, [sp, #160]	; 0xa0
    b894:	3110      	adds	r1, #16
    b896:	2a07      	cmp	r2, #7
    b898:	9129      	str	r1, [sp, #164]	; 0xa4
    b89a:	e883 0081 	stmia.w	r3, {r0, r7}
    b89e:	ddef      	ble.n	b880 <_svfprintf_r+0x288>
    b8a0:	aa27      	add	r2, sp, #156	; 0x9c
    b8a2:	4629      	mov	r1, r5
    b8a4:	4620      	mov	r0, r4
    b8a6:	f004 ffdd 	bl	10864 <__ssprint_r>
    b8aa:	2800      	cmp	r0, #0
    b8ac:	f47f af76 	bne.w	b79c <_svfprintf_r+0x1a4>
    b8b0:	f1ab 0b10 	sub.w	fp, fp, #16
    b8b4:	f1bb 0f10 	cmp.w	fp, #16
    b8b8:	9929      	ldr	r1, [sp, #164]	; 0xa4
    b8ba:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    b8bc:	464b      	mov	r3, r9
    b8be:	dce6      	bgt.n	b88e <_svfprintf_r+0x296>
    b8c0:	4645      	mov	r5, r8
    b8c2:	460c      	mov	r4, r1
    b8c4:	4698      	mov	r8, r3
    b8c6:	3201      	adds	r2, #1
    b8c8:	4ba9      	ldr	r3, [pc, #676]	; (bb70 <_svfprintf_r+0x578>)
    b8ca:	9228      	str	r2, [sp, #160]	; 0xa0
    b8cc:	445c      	add	r4, fp
    b8ce:	2a07      	cmp	r2, #7
    b8d0:	9429      	str	r4, [sp, #164]	; 0xa4
    b8d2:	e888 0808 	stmia.w	r8, {r3, fp}
    b8d6:	f300 84a6 	bgt.w	c226 <_svfprintf_r+0xc2e>
    b8da:	f89d 707f 	ldrb.w	r7, [sp, #127]	; 0x7f
    b8de:	f108 0808 	add.w	r8, r8, #8
    b8e2:	b177      	cbz	r7, b902 <_svfprintf_r+0x30a>
    b8e4:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    b8e6:	3301      	adds	r3, #1
    b8e8:	3401      	adds	r4, #1
    b8ea:	f10d 017f 	add.w	r1, sp, #127	; 0x7f
    b8ee:	2201      	movs	r2, #1
    b8f0:	2b07      	cmp	r3, #7
    b8f2:	9429      	str	r4, [sp, #164]	; 0xa4
    b8f4:	9328      	str	r3, [sp, #160]	; 0xa0
    b8f6:	e888 0006 	stmia.w	r8, {r1, r2}
    b8fa:	f300 83f4 	bgt.w	c0e6 <_svfprintf_r+0xaee>
    b8fe:	f108 0808 	add.w	r8, r8, #8
    b902:	9b10      	ldr	r3, [sp, #64]	; 0x40
    b904:	b16b      	cbz	r3, b922 <_svfprintf_r+0x32a>
    b906:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    b908:	3301      	adds	r3, #1
    b90a:	3402      	adds	r4, #2
    b90c:	a920      	add	r1, sp, #128	; 0x80
    b90e:	2202      	movs	r2, #2
    b910:	2b07      	cmp	r3, #7
    b912:	9429      	str	r4, [sp, #164]	; 0xa4
    b914:	9328      	str	r3, [sp, #160]	; 0xa0
    b916:	e888 0006 	stmia.w	r8, {r1, r2}
    b91a:	f300 83d9 	bgt.w	c0d0 <_svfprintf_r+0xad8>
    b91e:	f108 0808 	add.w	r8, r8, #8
    b922:	2d80      	cmp	r5, #128	; 0x80
    b924:	f000 8322 	beq.w	bf6c <_svfprintf_r+0x974>
    b928:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    b92a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    b92c:	1a9f      	subs	r7, r3, r2
    b92e:	2f00      	cmp	r7, #0
    b930:	dd36      	ble.n	b9a0 <_svfprintf_r+0x3a8>
    b932:	2f10      	cmp	r7, #16
    b934:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    b936:	4d8f      	ldr	r5, [pc, #572]	; (bb74 <_svfprintf_r+0x57c>)
    b938:	dd27      	ble.n	b98a <_svfprintf_r+0x392>
    b93a:	4642      	mov	r2, r8
    b93c:	4621      	mov	r1, r4
    b93e:	46b0      	mov	r8, r6
    b940:	f04f 0b10 	mov.w	fp, #16
    b944:	462e      	mov	r6, r5
    b946:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    b948:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    b94a:	e004      	b.n	b956 <_svfprintf_r+0x35e>
    b94c:	3f10      	subs	r7, #16
    b94e:	2f10      	cmp	r7, #16
    b950:	f102 0208 	add.w	r2, r2, #8
    b954:	dd15      	ble.n	b982 <_svfprintf_r+0x38a>
    b956:	3301      	adds	r3, #1
    b958:	3110      	adds	r1, #16
    b95a:	2b07      	cmp	r3, #7
    b95c:	9129      	str	r1, [sp, #164]	; 0xa4
    b95e:	9328      	str	r3, [sp, #160]	; 0xa0
    b960:	e882 0840 	stmia.w	r2, {r6, fp}
    b964:	ddf2      	ble.n	b94c <_svfprintf_r+0x354>
    b966:	aa27      	add	r2, sp, #156	; 0x9c
    b968:	4629      	mov	r1, r5
    b96a:	4620      	mov	r0, r4
    b96c:	f004 ff7a 	bl	10864 <__ssprint_r>
    b970:	2800      	cmp	r0, #0
    b972:	f47f af13 	bne.w	b79c <_svfprintf_r+0x1a4>
    b976:	3f10      	subs	r7, #16
    b978:	2f10      	cmp	r7, #16
    b97a:	9929      	ldr	r1, [sp, #164]	; 0xa4
    b97c:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    b97e:	464a      	mov	r2, r9
    b980:	dce9      	bgt.n	b956 <_svfprintf_r+0x35e>
    b982:	4635      	mov	r5, r6
    b984:	460c      	mov	r4, r1
    b986:	4646      	mov	r6, r8
    b988:	4690      	mov	r8, r2
    b98a:	3301      	adds	r3, #1
    b98c:	443c      	add	r4, r7
    b98e:	2b07      	cmp	r3, #7
    b990:	9429      	str	r4, [sp, #164]	; 0xa4
    b992:	9328      	str	r3, [sp, #160]	; 0xa0
    b994:	e888 00a0 	stmia.w	r8, {r5, r7}
    b998:	f300 838f 	bgt.w	c0ba <_svfprintf_r+0xac2>
    b99c:	f108 0808 	add.w	r8, r8, #8
    b9a0:	9b07      	ldr	r3, [sp, #28]
    b9a2:	05df      	lsls	r7, r3, #23
    b9a4:	f100 8273 	bmi.w	be8e <_svfprintf_r+0x896>
    b9a8:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    b9aa:	990e      	ldr	r1, [sp, #56]	; 0x38
    b9ac:	f8c8 6000 	str.w	r6, [r8]
    b9b0:	3301      	adds	r3, #1
    b9b2:	440c      	add	r4, r1
    b9b4:	2b07      	cmp	r3, #7
    b9b6:	9429      	str	r4, [sp, #164]	; 0xa4
    b9b8:	f8c8 1004 	str.w	r1, [r8, #4]
    b9bc:	9328      	str	r3, [sp, #160]	; 0xa0
    b9be:	f300 835b 	bgt.w	c078 <_svfprintf_r+0xa80>
    b9c2:	f108 0808 	add.w	r8, r8, #8
    b9c6:	9b07      	ldr	r3, [sp, #28]
    b9c8:	075b      	lsls	r3, r3, #29
    b9ca:	d53a      	bpl.n	ba42 <_svfprintf_r+0x44a>
    b9cc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    b9ce:	9a08      	ldr	r2, [sp, #32]
    b9d0:	1a9d      	subs	r5, r3, r2
    b9d2:	2d00      	cmp	r5, #0
    b9d4:	dd35      	ble.n	ba42 <_svfprintf_r+0x44a>
    b9d6:	2d10      	cmp	r5, #16
    b9d8:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    b9da:	dd20      	ble.n	ba1e <_svfprintf_r+0x426>
    b9dc:	2610      	movs	r6, #16
    b9de:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    b9e0:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
    b9e4:	e004      	b.n	b9f0 <_svfprintf_r+0x3f8>
    b9e6:	3d10      	subs	r5, #16
    b9e8:	2d10      	cmp	r5, #16
    b9ea:	f108 0808 	add.w	r8, r8, #8
    b9ee:	dd16      	ble.n	ba1e <_svfprintf_r+0x426>
    b9f0:	3301      	adds	r3, #1
    b9f2:	4a5f      	ldr	r2, [pc, #380]	; (bb70 <_svfprintf_r+0x578>)
    b9f4:	9328      	str	r3, [sp, #160]	; 0xa0
    b9f6:	3410      	adds	r4, #16
    b9f8:	2b07      	cmp	r3, #7
    b9fa:	9429      	str	r4, [sp, #164]	; 0xa4
    b9fc:	e888 0044 	stmia.w	r8, {r2, r6}
    ba00:	ddf1      	ble.n	b9e6 <_svfprintf_r+0x3ee>
    ba02:	aa27      	add	r2, sp, #156	; 0x9c
    ba04:	4659      	mov	r1, fp
    ba06:	4638      	mov	r0, r7
    ba08:	f004 ff2c 	bl	10864 <__ssprint_r>
    ba0c:	2800      	cmp	r0, #0
    ba0e:	f47f aec5 	bne.w	b79c <_svfprintf_r+0x1a4>
    ba12:	3d10      	subs	r5, #16
    ba14:	2d10      	cmp	r5, #16
    ba16:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    ba18:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    ba1a:	46c8      	mov	r8, r9
    ba1c:	dce8      	bgt.n	b9f0 <_svfprintf_r+0x3f8>
    ba1e:	3301      	adds	r3, #1
    ba20:	4a53      	ldr	r2, [pc, #332]	; (bb70 <_svfprintf_r+0x578>)
    ba22:	9328      	str	r3, [sp, #160]	; 0xa0
    ba24:	442c      	add	r4, r5
    ba26:	2b07      	cmp	r3, #7
    ba28:	9429      	str	r4, [sp, #164]	; 0xa4
    ba2a:	e888 0024 	stmia.w	r8, {r2, r5}
    ba2e:	dd08      	ble.n	ba42 <_svfprintf_r+0x44a>
    ba30:	aa27      	add	r2, sp, #156	; 0x9c
    ba32:	990b      	ldr	r1, [sp, #44]	; 0x2c
    ba34:	980c      	ldr	r0, [sp, #48]	; 0x30
    ba36:	f004 ff15 	bl	10864 <__ssprint_r>
    ba3a:	2800      	cmp	r0, #0
    ba3c:	f47f aeae 	bne.w	b79c <_svfprintf_r+0x1a4>
    ba40:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    ba42:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ba44:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    ba46:	9908      	ldr	r1, [sp, #32]
    ba48:	428a      	cmp	r2, r1
    ba4a:	bfac      	ite	ge
    ba4c:	189b      	addge	r3, r3, r2
    ba4e:	185b      	addlt	r3, r3, r1
    ba50:	9309      	str	r3, [sp, #36]	; 0x24
    ba52:	2c00      	cmp	r4, #0
    ba54:	f040 831b 	bne.w	c08e <_svfprintf_r+0xa96>
    ba58:	2300      	movs	r3, #0
    ba5a:	9328      	str	r3, [sp, #160]	; 0xa0
    ba5c:	46c8      	mov	r8, r9
    ba5e:	e5f2      	b.n	b646 <_svfprintf_r+0x4e>
    ba60:	9311      	str	r3, [sp, #68]	; 0x44
    ba62:	f01b 0320 	ands.w	r3, fp, #32
    ba66:	f040 81de 	bne.w	be26 <_svfprintf_r+0x82e>
    ba6a:	f01b 0210 	ands.w	r2, fp, #16
    ba6e:	f040 842d 	bne.w	c2cc <_svfprintf_r+0xcd4>
    ba72:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
    ba76:	f000 8429 	beq.w	c2cc <_svfprintf_r+0xcd4>
    ba7a:	990f      	ldr	r1, [sp, #60]	; 0x3c
    ba7c:	4613      	mov	r3, r2
    ba7e:	460a      	mov	r2, r1
    ba80:	3204      	adds	r2, #4
    ba82:	880c      	ldrh	r4, [r1, #0]
    ba84:	920f      	str	r2, [sp, #60]	; 0x3c
    ba86:	2500      	movs	r5, #0
    ba88:	e6a9      	b.n	b7de <_svfprintf_r+0x1e6>
    ba8a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    ba8c:	9311      	str	r3, [sp, #68]	; 0x44
    ba8e:	6816      	ldr	r6, [r2, #0]
    ba90:	2400      	movs	r4, #0
    ba92:	f88d 407f 	strb.w	r4, [sp, #127]	; 0x7f
    ba96:	1d15      	adds	r5, r2, #4
    ba98:	2e00      	cmp	r6, #0
    ba9a:	f000 86b8 	beq.w	c80e <_svfprintf_r+0x1216>
    ba9e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    baa0:	1c53      	adds	r3, r2, #1
    baa2:	f000 861a 	beq.w	c6da <_svfprintf_r+0x10e2>
    baa6:	4621      	mov	r1, r4
    baa8:	4630      	mov	r0, r6
    baaa:	f7f4 fee9 	bl	880 <memchr>
    baae:	2800      	cmp	r0, #0
    bab0:	f000 870b 	beq.w	c8ca <_svfprintf_r+0x12d2>
    bab4:	1b83      	subs	r3, r0, r6
    bab6:	930e      	str	r3, [sp, #56]	; 0x38
    bab8:	940a      	str	r4, [sp, #40]	; 0x28
    baba:	950f      	str	r5, [sp, #60]	; 0x3c
    babc:	f8cd b01c 	str.w	fp, [sp, #28]
    bac0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    bac4:	9308      	str	r3, [sp, #32]
    bac6:	9412      	str	r4, [sp, #72]	; 0x48
    bac8:	f89d 707f 	ldrb.w	r7, [sp, #127]	; 0x7f
    bacc:	e6ac      	b.n	b828 <_svfprintf_r+0x230>
    bace:	f89a 3000 	ldrb.w	r3, [sl]
    bad2:	2201      	movs	r2, #1
    bad4:	212b      	movs	r1, #43	; 0x2b
    bad6:	e5e7      	b.n	b6a8 <_svfprintf_r+0xb0>
    bad8:	f04b 0b20 	orr.w	fp, fp, #32
    badc:	f89a 3000 	ldrb.w	r3, [sl]
    bae0:	e5e2      	b.n	b6a8 <_svfprintf_r+0xb0>
    bae2:	9311      	str	r3, [sp, #68]	; 0x44
    bae4:	2a00      	cmp	r2, #0
    bae6:	f040 87ac 	bne.w	ca42 <_svfprintf_r+0x144a>
    baea:	4b23      	ldr	r3, [pc, #140]	; (bb78 <_svfprintf_r+0x580>)
    baec:	9316      	str	r3, [sp, #88]	; 0x58
    baee:	f01b 0f20 	tst.w	fp, #32
    baf2:	f040 8112 	bne.w	bd1a <_svfprintf_r+0x722>
    baf6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    baf8:	f01b 0f10 	tst.w	fp, #16
    bafc:	4613      	mov	r3, r2
    bafe:	f040 83e0 	bne.w	c2c2 <_svfprintf_r+0xcca>
    bb02:	f01b 0f40 	tst.w	fp, #64	; 0x40
    bb06:	f000 83dc 	beq.w	c2c2 <_svfprintf_r+0xcca>
    bb0a:	3304      	adds	r3, #4
    bb0c:	8814      	ldrh	r4, [r2, #0]
    bb0e:	930f      	str	r3, [sp, #60]	; 0x3c
    bb10:	2500      	movs	r5, #0
    bb12:	f01b 0f01 	tst.w	fp, #1
    bb16:	f000 810d 	beq.w	bd34 <_svfprintf_r+0x73c>
    bb1a:	ea54 0305 	orrs.w	r3, r4, r5
    bb1e:	f000 8109 	beq.w	bd34 <_svfprintf_r+0x73c>
    bb22:	2330      	movs	r3, #48	; 0x30
    bb24:	f89d 2044 	ldrb.w	r2, [sp, #68]	; 0x44
    bb28:	f88d 3080 	strb.w	r3, [sp, #128]	; 0x80
    bb2c:	f88d 2081 	strb.w	r2, [sp, #129]	; 0x81
    bb30:	f04b 0b02 	orr.w	fp, fp, #2
    bb34:	2302      	movs	r3, #2
    bb36:	e652      	b.n	b7de <_svfprintf_r+0x1e6>
    bb38:	f89a 3000 	ldrb.w	r3, [sl]
    bb3c:	2900      	cmp	r1, #0
    bb3e:	f47f adb3 	bne.w	b6a8 <_svfprintf_r+0xb0>
    bb42:	2201      	movs	r2, #1
    bb44:	2120      	movs	r1, #32
    bb46:	e5af      	b.n	b6a8 <_svfprintf_r+0xb0>
    bb48:	f04b 0b01 	orr.w	fp, fp, #1
    bb4c:	f89a 3000 	ldrb.w	r3, [sl]
    bb50:	e5aa      	b.n	b6a8 <_svfprintf_r+0xb0>
    bb52:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    bb54:	6823      	ldr	r3, [r4, #0]
    bb56:	930d      	str	r3, [sp, #52]	; 0x34
    bb58:	4618      	mov	r0, r3
    bb5a:	2800      	cmp	r0, #0
    bb5c:	4623      	mov	r3, r4
    bb5e:	f103 0304 	add.w	r3, r3, #4
    bb62:	f6ff ae03 	blt.w	b76c <_svfprintf_r+0x174>
    bb66:	930f      	str	r3, [sp, #60]	; 0x3c
    bb68:	f89a 3000 	ldrb.w	r3, [sl]
    bb6c:	e59c      	b.n	b6a8 <_svfprintf_r+0xb0>
    bb6e:	bf00      	nop
    bb70:	00012a30 	.word	0x00012a30
    bb74:	00012a40 	.word	0x00012a40
    bb78:	00012a10 	.word	0x00012a10
    bb7c:	f04b 0b10 	orr.w	fp, fp, #16
    bb80:	f01b 0f20 	tst.w	fp, #32
    bb84:	9311      	str	r3, [sp, #68]	; 0x44
    bb86:	f43f ae1b 	beq.w	b7c0 <_svfprintf_r+0x1c8>
    bb8a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    bb8c:	3507      	adds	r5, #7
    bb8e:	f025 0307 	bic.w	r3, r5, #7
    bb92:	f103 0208 	add.w	r2, r3, #8
    bb96:	e9d3 4500 	ldrd	r4, r5, [r3]
    bb9a:	920f      	str	r2, [sp, #60]	; 0x3c
    bb9c:	2301      	movs	r3, #1
    bb9e:	e61e      	b.n	b7de <_svfprintf_r+0x1e6>
    bba0:	f89a 3000 	ldrb.w	r3, [sl]
    bba4:	2b2a      	cmp	r3, #42	; 0x2a
    bba6:	f10a 0401 	add.w	r4, sl, #1
    bbaa:	f000 873d 	beq.w	ca28 <_svfprintf_r+0x1430>
    bbae:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    bbb2:	2809      	cmp	r0, #9
    bbb4:	46a2      	mov	sl, r4
    bbb6:	f200 8694 	bhi.w	c8e2 <_svfprintf_r+0x12ea>
    bbba:	2300      	movs	r3, #0
    bbbc:	461c      	mov	r4, r3
    bbbe:	f81a 3b01 	ldrb.w	r3, [sl], #1
    bbc2:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    bbc6:	eb00 0444 	add.w	r4, r0, r4, lsl #1
    bbca:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    bbce:	2809      	cmp	r0, #9
    bbd0:	d9f5      	bls.n	bbbe <_svfprintf_r+0x5c6>
    bbd2:	940a      	str	r4, [sp, #40]	; 0x28
    bbd4:	e56a      	b.n	b6ac <_svfprintf_r+0xb4>
    bbd6:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
    bbda:	f89a 3000 	ldrb.w	r3, [sl]
    bbde:	e563      	b.n	b6a8 <_svfprintf_r+0xb0>
    bbe0:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
    bbe4:	f89a 3000 	ldrb.w	r3, [sl]
    bbe8:	e55e      	b.n	b6a8 <_svfprintf_r+0xb0>
    bbea:	f89a 3000 	ldrb.w	r3, [sl]
    bbee:	2b6c      	cmp	r3, #108	; 0x6c
    bbf0:	bf03      	ittte	eq
    bbf2:	f89a 3001 	ldrbeq.w	r3, [sl, #1]
    bbf6:	f04b 0b20 	orreq.w	fp, fp, #32
    bbfa:	f10a 0a01 	addeq.w	sl, sl, #1
    bbfe:	f04b 0b10 	orrne.w	fp, fp, #16
    bc02:	e551      	b.n	b6a8 <_svfprintf_r+0xb0>
    bc04:	2a00      	cmp	r2, #0
    bc06:	f040 8720 	bne.w	ca4a <_svfprintf_r+0x1452>
    bc0a:	f01b 0f20 	tst.w	fp, #32
    bc0e:	f040 850a 	bne.w	c626 <_svfprintf_r+0x102e>
    bc12:	f01b 0f10 	tst.w	fp, #16
    bc16:	f040 84bd 	bne.w	c594 <_svfprintf_r+0xf9c>
    bc1a:	f01b 0f40 	tst.w	fp, #64	; 0x40
    bc1e:	f000 84b9 	beq.w	c594 <_svfprintf_r+0xf9c>
    bc22:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    bc24:	6813      	ldr	r3, [r2, #0]
    bc26:	3204      	adds	r2, #4
    bc28:	920f      	str	r2, [sp, #60]	; 0x3c
    bc2a:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    bc2e:	801a      	strh	r2, [r3, #0]
    bc30:	e509      	b.n	b646 <_svfprintf_r+0x4e>
    bc32:	990f      	ldr	r1, [sp, #60]	; 0x3c
    bc34:	4bb9      	ldr	r3, [pc, #740]	; (bf1c <_svfprintf_r+0x924>)
    bc36:	680c      	ldr	r4, [r1, #0]
    bc38:	9316      	str	r3, [sp, #88]	; 0x58
    bc3a:	2230      	movs	r2, #48	; 0x30
    bc3c:	2378      	movs	r3, #120	; 0x78
    bc3e:	3104      	adds	r1, #4
    bc40:	f88d 3081 	strb.w	r3, [sp, #129]	; 0x81
    bc44:	9311      	str	r3, [sp, #68]	; 0x44
    bc46:	f04b 0b02 	orr.w	fp, fp, #2
    bc4a:	910f      	str	r1, [sp, #60]	; 0x3c
    bc4c:	2500      	movs	r5, #0
    bc4e:	f88d 2080 	strb.w	r2, [sp, #128]	; 0x80
    bc52:	2302      	movs	r3, #2
    bc54:	e5c3      	b.n	b7de <_svfprintf_r+0x1e6>
    bc56:	990f      	ldr	r1, [sp, #60]	; 0x3c
    bc58:	9311      	str	r3, [sp, #68]	; 0x44
    bc5a:	680a      	ldr	r2, [r1, #0]
    bc5c:	f88d 20a8 	strb.w	r2, [sp, #168]	; 0xa8
    bc60:	2300      	movs	r3, #0
    bc62:	460a      	mov	r2, r1
    bc64:	461f      	mov	r7, r3
    bc66:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
    bc6a:	3204      	adds	r2, #4
    bc6c:	2301      	movs	r3, #1
    bc6e:	9308      	str	r3, [sp, #32]
    bc70:	f8cd b01c 	str.w	fp, [sp, #28]
    bc74:	970a      	str	r7, [sp, #40]	; 0x28
    bc76:	9712      	str	r7, [sp, #72]	; 0x48
    bc78:	920f      	str	r2, [sp, #60]	; 0x3c
    bc7a:	930e      	str	r3, [sp, #56]	; 0x38
    bc7c:	ae2a      	add	r6, sp, #168	; 0xa8
    bc7e:	e5d7      	b.n	b830 <_svfprintf_r+0x238>
    bc80:	9311      	str	r3, [sp, #68]	; 0x44
    bc82:	2a00      	cmp	r2, #0
    bc84:	f040 8700 	bne.w	ca88 <_svfprintf_r+0x1490>
    bc88:	f01b 0f20 	tst.w	fp, #32
    bc8c:	d15d      	bne.n	bd4a <_svfprintf_r+0x752>
    bc8e:	f01b 0f10 	tst.w	fp, #16
    bc92:	f040 8335 	bne.w	c300 <_svfprintf_r+0xd08>
    bc96:	f01b 0f40 	tst.w	fp, #64	; 0x40
    bc9a:	f000 8331 	beq.w	c300 <_svfprintf_r+0xd08>
    bc9e:	990f      	ldr	r1, [sp, #60]	; 0x3c
    bca0:	f9b1 4000 	ldrsh.w	r4, [r1]
    bca4:	3104      	adds	r1, #4
    bca6:	17e5      	asrs	r5, r4, #31
    bca8:	4622      	mov	r2, r4
    bcaa:	462b      	mov	r3, r5
    bcac:	910f      	str	r1, [sp, #60]	; 0x3c
    bcae:	2a00      	cmp	r2, #0
    bcb0:	f173 0300 	sbcs.w	r3, r3, #0
    bcb4:	db58      	blt.n	bd68 <_svfprintf_r+0x770>
    bcb6:	990a      	ldr	r1, [sp, #40]	; 0x28
    bcb8:	f89d 707f 	ldrb.w	r7, [sp, #127]	; 0x7f
    bcbc:	1c4a      	adds	r2, r1, #1
    bcbe:	f04f 0301 	mov.w	r3, #1
    bcc2:	f47f ad93 	bne.w	b7ec <_svfprintf_r+0x1f4>
    bcc6:	ea54 0205 	orrs.w	r2, r4, r5
    bcca:	f000 81ec 	beq.w	c0a6 <_svfprintf_r+0xaae>
    bcce:	f8cd b01c 	str.w	fp, [sp, #28]
    bcd2:	2b01      	cmp	r3, #1
    bcd4:	f000 8283 	beq.w	c1de <_svfprintf_r+0xbe6>
    bcd8:	2b02      	cmp	r3, #2
    bcda:	f040 8213 	bne.w	c104 <_svfprintf_r+0xb0c>
    bcde:	9816      	ldr	r0, [sp, #88]	; 0x58
    bce0:	464e      	mov	r6, r9
    bce2:	0923      	lsrs	r3, r4, #4
    bce4:	f004 010f 	and.w	r1, r4, #15
    bce8:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
    bcec:	092a      	lsrs	r2, r5, #4
    bcee:	461c      	mov	r4, r3
    bcf0:	4615      	mov	r5, r2
    bcf2:	5c43      	ldrb	r3, [r0, r1]
    bcf4:	f806 3d01 	strb.w	r3, [r6, #-1]!
    bcf8:	ea54 0305 	orrs.w	r3, r4, r5
    bcfc:	d1f1      	bne.n	bce2 <_svfprintf_r+0x6ea>
    bcfe:	eba9 0306 	sub.w	r3, r9, r6
    bd02:	930e      	str	r3, [sp, #56]	; 0x38
    bd04:	e588      	b.n	b818 <_svfprintf_r+0x220>
    bd06:	9311      	str	r3, [sp, #68]	; 0x44
    bd08:	2a00      	cmp	r2, #0
    bd0a:	f040 86b9 	bne.w	ca80 <_svfprintf_r+0x1488>
    bd0e:	4b84      	ldr	r3, [pc, #528]	; (bf20 <_svfprintf_r+0x928>)
    bd10:	9316      	str	r3, [sp, #88]	; 0x58
    bd12:	f01b 0f20 	tst.w	fp, #32
    bd16:	f43f aeee 	beq.w	baf6 <_svfprintf_r+0x4fe>
    bd1a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    bd1c:	3507      	adds	r5, #7
    bd1e:	f025 0307 	bic.w	r3, r5, #7
    bd22:	f103 0208 	add.w	r2, r3, #8
    bd26:	f01b 0f01 	tst.w	fp, #1
    bd2a:	920f      	str	r2, [sp, #60]	; 0x3c
    bd2c:	e9d3 4500 	ldrd	r4, r5, [r3]
    bd30:	f47f aef3 	bne.w	bb1a <_svfprintf_r+0x522>
    bd34:	2302      	movs	r3, #2
    bd36:	e552      	b.n	b7de <_svfprintf_r+0x1e6>
    bd38:	9311      	str	r3, [sp, #68]	; 0x44
    bd3a:	2a00      	cmp	r2, #0
    bd3c:	f040 869c 	bne.w	ca78 <_svfprintf_r+0x1480>
    bd40:	f04b 0b10 	orr.w	fp, fp, #16
    bd44:	f01b 0f20 	tst.w	fp, #32
    bd48:	d0a1      	beq.n	bc8e <_svfprintf_r+0x696>
    bd4a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    bd4c:	3507      	adds	r5, #7
    bd4e:	f025 0507 	bic.w	r5, r5, #7
    bd52:	e9d5 2300 	ldrd	r2, r3, [r5]
    bd56:	2a00      	cmp	r2, #0
    bd58:	f105 0108 	add.w	r1, r5, #8
    bd5c:	461d      	mov	r5, r3
    bd5e:	f173 0300 	sbcs.w	r3, r3, #0
    bd62:	910f      	str	r1, [sp, #60]	; 0x3c
    bd64:	4614      	mov	r4, r2
    bd66:	daa6      	bge.n	bcb6 <_svfprintf_r+0x6be>
    bd68:	272d      	movs	r7, #45	; 0x2d
    bd6a:	4264      	negs	r4, r4
    bd6c:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
    bd70:	f88d 707f 	strb.w	r7, [sp, #127]	; 0x7f
    bd74:	2301      	movs	r3, #1
    bd76:	e535      	b.n	b7e4 <_svfprintf_r+0x1ec>
    bd78:	9311      	str	r3, [sp, #68]	; 0x44
    bd7a:	2a00      	cmp	r2, #0
    bd7c:	f040 8678 	bne.w	ca70 <_svfprintf_r+0x1478>
    bd80:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    bd82:	f01b 0f08 	tst.w	fp, #8
    bd86:	f105 0507 	add.w	r5, r5, #7
    bd8a:	f000 83e9 	beq.w	c560 <_svfprintf_r+0xf68>
    bd8e:	f025 0307 	bic.w	r3, r5, #7
    bd92:	ed93 7b00 	vldr	d7, [r3]
    bd96:	ed8d 7b14 	vstr	d7, [sp, #80]	; 0x50
    bd9a:	f103 0208 	add.w	r2, r3, #8
    bd9e:	920f      	str	r2, [sp, #60]	; 0x3c
    bda0:	e9dd 1214 	ldrd	r1, r2, [sp, #80]	; 0x50
    bda4:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
    bda8:	911a      	str	r1, [sp, #104]	; 0x68
    bdaa:	931b      	str	r3, [sp, #108]	; 0x6c
    bdac:	e9dd 451a 	ldrd	r4, r5, [sp, #104]	; 0x68
    bdb0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    bdb4:	4620      	mov	r0, r4
    bdb6:	4629      	mov	r1, r5
    bdb8:	4b5a      	ldr	r3, [pc, #360]	; (bf24 <_svfprintf_r+0x92c>)
    bdba:	f7f5 fb21 	bl	1400 <__aeabi_dcmpun>
    bdbe:	2800      	cmp	r0, #0
    bdc0:	f040 834f 	bne.w	c462 <_svfprintf_r+0xe6a>
    bdc4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    bdc8:	4b56      	ldr	r3, [pc, #344]	; (bf24 <_svfprintf_r+0x92c>)
    bdca:	4620      	mov	r0, r4
    bdcc:	4629      	mov	r1, r5
    bdce:	f7f5 faf9 	bl	13c4 <__aeabi_dcmple>
    bdd2:	2800      	cmp	r0, #0
    bdd4:	f040 8345 	bne.w	c462 <_svfprintf_r+0xe6a>
    bdd8:	2200      	movs	r2, #0
    bdda:	2300      	movs	r3, #0
    bddc:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
    bde0:	f7f5 fae6 	bl	13b0 <__aeabi_dcmplt>
    bde4:	2800      	cmp	r0, #0
    bde6:	f040 8536 	bne.w	c856 <_svfprintf_r+0x125e>
    bdea:	f89d 707f 	ldrb.w	r7, [sp, #127]	; 0x7f
    bdee:	4e4e      	ldr	r6, [pc, #312]	; (bf28 <_svfprintf_r+0x930>)
    bdf0:	4b4e      	ldr	r3, [pc, #312]	; (bf2c <_svfprintf_r+0x934>)
    bdf2:	f02b 0080 	bic.w	r0, fp, #128	; 0x80
    bdf6:	9007      	str	r0, [sp, #28]
    bdf8:	9811      	ldr	r0, [sp, #68]	; 0x44
    bdfa:	2203      	movs	r2, #3
    bdfc:	2100      	movs	r1, #0
    bdfe:	9208      	str	r2, [sp, #32]
    be00:	910a      	str	r1, [sp, #40]	; 0x28
    be02:	2847      	cmp	r0, #71	; 0x47
    be04:	bfd8      	it	le
    be06:	461e      	movle	r6, r3
    be08:	920e      	str	r2, [sp, #56]	; 0x38
    be0a:	9112      	str	r1, [sp, #72]	; 0x48
    be0c:	e50c      	b.n	b828 <_svfprintf_r+0x230>
    be0e:	f04b 0b08 	orr.w	fp, fp, #8
    be12:	f89a 3000 	ldrb.w	r3, [sl]
    be16:	e447      	b.n	b6a8 <_svfprintf_r+0xb0>
    be18:	f04b 0b10 	orr.w	fp, fp, #16
    be1c:	9311      	str	r3, [sp, #68]	; 0x44
    be1e:	f01b 0320 	ands.w	r3, fp, #32
    be22:	f43f ae22 	beq.w	ba6a <_svfprintf_r+0x472>
    be26:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    be28:	3507      	adds	r5, #7
    be2a:	f025 0307 	bic.w	r3, r5, #7
    be2e:	f103 0208 	add.w	r2, r3, #8
    be32:	e9d3 4500 	ldrd	r4, r5, [r3]
    be36:	920f      	str	r2, [sp, #60]	; 0x3c
    be38:	2300      	movs	r3, #0
    be3a:	e4d0      	b.n	b7de <_svfprintf_r+0x1e6>
    be3c:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    be40:	2300      	movs	r3, #0
    be42:	461c      	mov	r4, r3
    be44:	f81a 3b01 	ldrb.w	r3, [sl], #1
    be48:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    be4c:	eb00 0444 	add.w	r4, r0, r4, lsl #1
    be50:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    be54:	2809      	cmp	r0, #9
    be56:	d9f5      	bls.n	be44 <_svfprintf_r+0x84c>
    be58:	940d      	str	r4, [sp, #52]	; 0x34
    be5a:	e427      	b.n	b6ac <_svfprintf_r+0xb4>
    be5c:	9311      	str	r3, [sp, #68]	; 0x44
    be5e:	2a00      	cmp	r2, #0
    be60:	f040 85f7 	bne.w	ca52 <_svfprintf_r+0x145a>
    be64:	9a11      	ldr	r2, [sp, #68]	; 0x44
    be66:	2a00      	cmp	r2, #0
    be68:	f43f ac91 	beq.w	b78e <_svfprintf_r+0x196>
    be6c:	2300      	movs	r3, #0
    be6e:	2101      	movs	r1, #1
    be70:	461f      	mov	r7, r3
    be72:	9108      	str	r1, [sp, #32]
    be74:	f88d 20a8 	strb.w	r2, [sp, #168]	; 0xa8
    be78:	f8cd b01c 	str.w	fp, [sp, #28]
    be7c:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
    be80:	930a      	str	r3, [sp, #40]	; 0x28
    be82:	9312      	str	r3, [sp, #72]	; 0x48
    be84:	910e      	str	r1, [sp, #56]	; 0x38
    be86:	ae2a      	add	r6, sp, #168	; 0xa8
    be88:	e4d2      	b.n	b830 <_svfprintf_r+0x238>
    be8a:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    be8c:	e529      	b.n	b8e2 <_svfprintf_r+0x2ea>
    be8e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    be90:	2b65      	cmp	r3, #101	; 0x65
    be92:	f340 80a9 	ble.w	bfe8 <_svfprintf_r+0x9f0>
    be96:	2200      	movs	r2, #0
    be98:	2300      	movs	r3, #0
    be9a:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
    be9e:	f7f5 fa7d 	bl	139c <__aeabi_dcmpeq>
    bea2:	2800      	cmp	r0, #0
    bea4:	f000 8152 	beq.w	c14c <_svfprintf_r+0xb54>
    bea8:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    beaa:	4a21      	ldr	r2, [pc, #132]	; (bf30 <_svfprintf_r+0x938>)
    beac:	f8c8 2000 	str.w	r2, [r8]
    beb0:	3301      	adds	r3, #1
    beb2:	3401      	adds	r4, #1
    beb4:	2201      	movs	r2, #1
    beb6:	2b07      	cmp	r3, #7
    beb8:	9429      	str	r4, [sp, #164]	; 0xa4
    beba:	9328      	str	r3, [sp, #160]	; 0xa0
    bebc:	f8c8 2004 	str.w	r2, [r8, #4]
    bec0:	f300 8370 	bgt.w	c5a4 <_svfprintf_r+0xfac>
    bec4:	f108 0808 	add.w	r8, r8, #8
    bec8:	9b21      	ldr	r3, [sp, #132]	; 0x84
    beca:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    becc:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    bece:	4293      	cmp	r3, r2
    bed0:	db03      	blt.n	beda <_svfprintf_r+0x8e2>
    bed2:	9b07      	ldr	r3, [sp, #28]
    bed4:	07dd      	lsls	r5, r3, #31
    bed6:	f57f ad76 	bpl.w	b9c6 <_svfprintf_r+0x3ce>
    beda:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    bedc:	9917      	ldr	r1, [sp, #92]	; 0x5c
    bede:	9a18      	ldr	r2, [sp, #96]	; 0x60
    bee0:	f8c8 2000 	str.w	r2, [r8]
    bee4:	3301      	adds	r3, #1
    bee6:	440c      	add	r4, r1
    bee8:	2b07      	cmp	r3, #7
    beea:	f8c8 1004 	str.w	r1, [r8, #4]
    beee:	9429      	str	r4, [sp, #164]	; 0xa4
    bef0:	9328      	str	r3, [sp, #160]	; 0xa0
    bef2:	f300 83a4 	bgt.w	c63e <_svfprintf_r+0x1046>
    bef6:	f108 0808 	add.w	r8, r8, #8
    befa:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    befc:	1e5e      	subs	r6, r3, #1
    befe:	2e00      	cmp	r6, #0
    bf00:	f77f ad61 	ble.w	b9c6 <_svfprintf_r+0x3ce>
    bf04:	2e10      	cmp	r6, #16
    bf06:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    bf08:	4d0a      	ldr	r5, [pc, #40]	; (bf34 <_svfprintf_r+0x93c>)
    bf0a:	f340 81ef 	ble.w	c2ec <_svfprintf_r+0xcf4>
    bf0e:	4622      	mov	r2, r4
    bf10:	2710      	movs	r7, #16
    bf12:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
    bf16:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    bf18:	e014      	b.n	bf44 <_svfprintf_r+0x94c>
    bf1a:	bf00      	nop
    bf1c:	00012a10 	.word	0x00012a10
    bf20:	000129fc 	.word	0x000129fc
    bf24:	7fefffff 	.word	0x7fefffff
    bf28:	000129f0 	.word	0x000129f0
    bf2c:	000129ec 	.word	0x000129ec
    bf30:	00012a2c 	.word	0x00012a2c
    bf34:	00012a40 	.word	0x00012a40
    bf38:	f108 0808 	add.w	r8, r8, #8
    bf3c:	3e10      	subs	r6, #16
    bf3e:	2e10      	cmp	r6, #16
    bf40:	f340 81d3 	ble.w	c2ea <_svfprintf_r+0xcf2>
    bf44:	3301      	adds	r3, #1
    bf46:	3210      	adds	r2, #16
    bf48:	2b07      	cmp	r3, #7
    bf4a:	9229      	str	r2, [sp, #164]	; 0xa4
    bf4c:	9328      	str	r3, [sp, #160]	; 0xa0
    bf4e:	e888 00a0 	stmia.w	r8, {r5, r7}
    bf52:	ddf1      	ble.n	bf38 <_svfprintf_r+0x940>
    bf54:	aa27      	add	r2, sp, #156	; 0x9c
    bf56:	4621      	mov	r1, r4
    bf58:	4658      	mov	r0, fp
    bf5a:	f004 fc83 	bl	10864 <__ssprint_r>
    bf5e:	2800      	cmp	r0, #0
    bf60:	f47f ac1c 	bne.w	b79c <_svfprintf_r+0x1a4>
    bf64:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    bf66:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    bf68:	46c8      	mov	r8, r9
    bf6a:	e7e7      	b.n	bf3c <_svfprintf_r+0x944>
    bf6c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    bf6e:	9a08      	ldr	r2, [sp, #32]
    bf70:	1a9f      	subs	r7, r3, r2
    bf72:	2f00      	cmp	r7, #0
    bf74:	f77f acd8 	ble.w	b928 <_svfprintf_r+0x330>
    bf78:	2f10      	cmp	r7, #16
    bf7a:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    bf7c:	4db7      	ldr	r5, [pc, #732]	; (c25c <_svfprintf_r+0xc64>)
    bf7e:	dd27      	ble.n	bfd0 <_svfprintf_r+0x9d8>
    bf80:	4642      	mov	r2, r8
    bf82:	4621      	mov	r1, r4
    bf84:	46b0      	mov	r8, r6
    bf86:	f04f 0b10 	mov.w	fp, #16
    bf8a:	462e      	mov	r6, r5
    bf8c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    bf8e:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    bf90:	e004      	b.n	bf9c <_svfprintf_r+0x9a4>
    bf92:	3f10      	subs	r7, #16
    bf94:	2f10      	cmp	r7, #16
    bf96:	f102 0208 	add.w	r2, r2, #8
    bf9a:	dd15      	ble.n	bfc8 <_svfprintf_r+0x9d0>
    bf9c:	3301      	adds	r3, #1
    bf9e:	3110      	adds	r1, #16
    bfa0:	2b07      	cmp	r3, #7
    bfa2:	9129      	str	r1, [sp, #164]	; 0xa4
    bfa4:	9328      	str	r3, [sp, #160]	; 0xa0
    bfa6:	e882 0840 	stmia.w	r2, {r6, fp}
    bfaa:	ddf2      	ble.n	bf92 <_svfprintf_r+0x99a>
    bfac:	aa27      	add	r2, sp, #156	; 0x9c
    bfae:	4629      	mov	r1, r5
    bfb0:	4620      	mov	r0, r4
    bfb2:	f004 fc57 	bl	10864 <__ssprint_r>
    bfb6:	2800      	cmp	r0, #0
    bfb8:	f47f abf0 	bne.w	b79c <_svfprintf_r+0x1a4>
    bfbc:	3f10      	subs	r7, #16
    bfbe:	2f10      	cmp	r7, #16
    bfc0:	9929      	ldr	r1, [sp, #164]	; 0xa4
    bfc2:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    bfc4:	464a      	mov	r2, r9
    bfc6:	dce9      	bgt.n	bf9c <_svfprintf_r+0x9a4>
    bfc8:	4635      	mov	r5, r6
    bfca:	460c      	mov	r4, r1
    bfcc:	4646      	mov	r6, r8
    bfce:	4690      	mov	r8, r2
    bfd0:	3301      	adds	r3, #1
    bfd2:	443c      	add	r4, r7
    bfd4:	2b07      	cmp	r3, #7
    bfd6:	9429      	str	r4, [sp, #164]	; 0xa4
    bfd8:	9328      	str	r3, [sp, #160]	; 0xa0
    bfda:	e888 00a0 	stmia.w	r8, {r5, r7}
    bfde:	f300 8234 	bgt.w	c44a <_svfprintf_r+0xe52>
    bfe2:	f108 0808 	add.w	r8, r8, #8
    bfe6:	e49f      	b.n	b928 <_svfprintf_r+0x330>
    bfe8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    bfea:	9f28      	ldr	r7, [sp, #160]	; 0xa0
    bfec:	2b01      	cmp	r3, #1
    bfee:	f340 8200 	ble.w	c3f2 <_svfprintf_r+0xdfa>
    bff2:	3701      	adds	r7, #1
    bff4:	3401      	adds	r4, #1
    bff6:	2301      	movs	r3, #1
    bff8:	2f07      	cmp	r7, #7
    bffa:	9429      	str	r4, [sp, #164]	; 0xa4
    bffc:	9728      	str	r7, [sp, #160]	; 0xa0
    bffe:	f8c8 6000 	str.w	r6, [r8]
    c002:	f8c8 3004 	str.w	r3, [r8, #4]
    c006:	f300 8205 	bgt.w	c414 <_svfprintf_r+0xe1c>
    c00a:	f108 0808 	add.w	r8, r8, #8
    c00e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    c010:	9b18      	ldr	r3, [sp, #96]	; 0x60
    c012:	f8c8 3000 	str.w	r3, [r8]
    c016:	3701      	adds	r7, #1
    c018:	4414      	add	r4, r2
    c01a:	2f07      	cmp	r7, #7
    c01c:	9429      	str	r4, [sp, #164]	; 0xa4
    c01e:	9728      	str	r7, [sp, #160]	; 0xa0
    c020:	f8c8 2004 	str.w	r2, [r8, #4]
    c024:	f300 8202 	bgt.w	c42c <_svfprintf_r+0xe34>
    c028:	f108 0808 	add.w	r8, r8, #8
    c02c:	2300      	movs	r3, #0
    c02e:	2200      	movs	r2, #0
    c030:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
    c034:	f7f5 f9b2 	bl	139c <__aeabi_dcmpeq>
    c038:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c03a:	2800      	cmp	r0, #0
    c03c:	f040 8101 	bne.w	c242 <_svfprintf_r+0xc4a>
    c040:	3b01      	subs	r3, #1
    c042:	3701      	adds	r7, #1
    c044:	3601      	adds	r6, #1
    c046:	441c      	add	r4, r3
    c048:	2f07      	cmp	r7, #7
    c04a:	9728      	str	r7, [sp, #160]	; 0xa0
    c04c:	9429      	str	r4, [sp, #164]	; 0xa4
    c04e:	f8c8 6000 	str.w	r6, [r8]
    c052:	f8c8 3004 	str.w	r3, [r8, #4]
    c056:	f300 8128 	bgt.w	c2aa <_svfprintf_r+0xcb2>
    c05a:	f108 0808 	add.w	r8, r8, #8
    c05e:	9a19      	ldr	r2, [sp, #100]	; 0x64
    c060:	f8c8 2004 	str.w	r2, [r8, #4]
    c064:	3701      	adds	r7, #1
    c066:	4414      	add	r4, r2
    c068:	ab23      	add	r3, sp, #140	; 0x8c
    c06a:	2f07      	cmp	r7, #7
    c06c:	9429      	str	r4, [sp, #164]	; 0xa4
    c06e:	9728      	str	r7, [sp, #160]	; 0xa0
    c070:	f8c8 3000 	str.w	r3, [r8]
    c074:	f77f aca5 	ble.w	b9c2 <_svfprintf_r+0x3ca>
    c078:	aa27      	add	r2, sp, #156	; 0x9c
    c07a:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c07c:	980c      	ldr	r0, [sp, #48]	; 0x30
    c07e:	f004 fbf1 	bl	10864 <__ssprint_r>
    c082:	2800      	cmp	r0, #0
    c084:	f47f ab8a 	bne.w	b79c <_svfprintf_r+0x1a4>
    c088:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c08a:	46c8      	mov	r8, r9
    c08c:	e49b      	b.n	b9c6 <_svfprintf_r+0x3ce>
    c08e:	aa27      	add	r2, sp, #156	; 0x9c
    c090:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c092:	980c      	ldr	r0, [sp, #48]	; 0x30
    c094:	f004 fbe6 	bl	10864 <__ssprint_r>
    c098:	2800      	cmp	r0, #0
    c09a:	f43f acdd 	beq.w	ba58 <_svfprintf_r+0x460>
    c09e:	f7ff bb7d 	b.w	b79c <_svfprintf_r+0x1a4>
    c0a2:	f8dd b01c 	ldr.w	fp, [sp, #28]
    c0a6:	2b01      	cmp	r3, #1
    c0a8:	f000 8135 	beq.w	c316 <_svfprintf_r+0xd1e>
    c0ac:	2b02      	cmp	r3, #2
    c0ae:	d125      	bne.n	c0fc <_svfprintf_r+0xb04>
    c0b0:	f8cd b01c 	str.w	fp, [sp, #28]
    c0b4:	2400      	movs	r4, #0
    c0b6:	2500      	movs	r5, #0
    c0b8:	e611      	b.n	bcde <_svfprintf_r+0x6e6>
    c0ba:	aa27      	add	r2, sp, #156	; 0x9c
    c0bc:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c0be:	980c      	ldr	r0, [sp, #48]	; 0x30
    c0c0:	f004 fbd0 	bl	10864 <__ssprint_r>
    c0c4:	2800      	cmp	r0, #0
    c0c6:	f47f ab69 	bne.w	b79c <_svfprintf_r+0x1a4>
    c0ca:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c0cc:	46c8      	mov	r8, r9
    c0ce:	e467      	b.n	b9a0 <_svfprintf_r+0x3a8>
    c0d0:	aa27      	add	r2, sp, #156	; 0x9c
    c0d2:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c0d4:	980c      	ldr	r0, [sp, #48]	; 0x30
    c0d6:	f004 fbc5 	bl	10864 <__ssprint_r>
    c0da:	2800      	cmp	r0, #0
    c0dc:	f47f ab5e 	bne.w	b79c <_svfprintf_r+0x1a4>
    c0e0:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c0e2:	46c8      	mov	r8, r9
    c0e4:	e41d      	b.n	b922 <_svfprintf_r+0x32a>
    c0e6:	aa27      	add	r2, sp, #156	; 0x9c
    c0e8:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c0ea:	980c      	ldr	r0, [sp, #48]	; 0x30
    c0ec:	f004 fbba 	bl	10864 <__ssprint_r>
    c0f0:	2800      	cmp	r0, #0
    c0f2:	f47f ab53 	bne.w	b79c <_svfprintf_r+0x1a4>
    c0f6:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c0f8:	46c8      	mov	r8, r9
    c0fa:	e402      	b.n	b902 <_svfprintf_r+0x30a>
    c0fc:	f8cd b01c 	str.w	fp, [sp, #28]
    c100:	2400      	movs	r4, #0
    c102:	2500      	movs	r5, #0
    c104:	4649      	mov	r1, r9
    c106:	e000      	b.n	c10a <_svfprintf_r+0xb12>
    c108:	4631      	mov	r1, r6
    c10a:	08e2      	lsrs	r2, r4, #3
    c10c:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
    c110:	08e8      	lsrs	r0, r5, #3
    c112:	f004 0307 	and.w	r3, r4, #7
    c116:	4605      	mov	r5, r0
    c118:	4614      	mov	r4, r2
    c11a:	3330      	adds	r3, #48	; 0x30
    c11c:	ea54 0205 	orrs.w	r2, r4, r5
    c120:	f801 3c01 	strb.w	r3, [r1, #-1]
    c124:	f101 36ff 	add.w	r6, r1, #4294967295	; 0xffffffff
    c128:	d1ee      	bne.n	c108 <_svfprintf_r+0xb10>
    c12a:	9a07      	ldr	r2, [sp, #28]
    c12c:	07d2      	lsls	r2, r2, #31
    c12e:	f57f ade6 	bpl.w	bcfe <_svfprintf_r+0x706>
    c132:	2b30      	cmp	r3, #48	; 0x30
    c134:	f43f ade3 	beq.w	bcfe <_svfprintf_r+0x706>
    c138:	3902      	subs	r1, #2
    c13a:	2330      	movs	r3, #48	; 0x30
    c13c:	f806 3c01 	strb.w	r3, [r6, #-1]
    c140:	eba9 0301 	sub.w	r3, r9, r1
    c144:	930e      	str	r3, [sp, #56]	; 0x38
    c146:	460e      	mov	r6, r1
    c148:	f7ff bb66 	b.w	b818 <_svfprintf_r+0x220>
    c14c:	9921      	ldr	r1, [sp, #132]	; 0x84
    c14e:	2900      	cmp	r1, #0
    c150:	f340 8232 	ble.w	c5b8 <_svfprintf_r+0xfc0>
    c154:	9b12      	ldr	r3, [sp, #72]	; 0x48
    c156:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    c158:	4293      	cmp	r3, r2
    c15a:	bfa8      	it	ge
    c15c:	4613      	movge	r3, r2
    c15e:	2b00      	cmp	r3, #0
    c160:	461f      	mov	r7, r3
    c162:	dd0d      	ble.n	c180 <_svfprintf_r+0xb88>
    c164:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c166:	f8c8 6000 	str.w	r6, [r8]
    c16a:	3301      	adds	r3, #1
    c16c:	443c      	add	r4, r7
    c16e:	2b07      	cmp	r3, #7
    c170:	9429      	str	r4, [sp, #164]	; 0xa4
    c172:	f8c8 7004 	str.w	r7, [r8, #4]
    c176:	9328      	str	r3, [sp, #160]	; 0xa0
    c178:	f300 8324 	bgt.w	c7c4 <_svfprintf_r+0x11cc>
    c17c:	f108 0808 	add.w	r8, r8, #8
    c180:	9b12      	ldr	r3, [sp, #72]	; 0x48
    c182:	2f00      	cmp	r7, #0
    c184:	bfa8      	it	ge
    c186:	1bdb      	subge	r3, r3, r7
    c188:	2b00      	cmp	r3, #0
    c18a:	461f      	mov	r7, r3
    c18c:	f340 80d7 	ble.w	c33e <_svfprintf_r+0xd46>
    c190:	2f10      	cmp	r7, #16
    c192:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c194:	4d31      	ldr	r5, [pc, #196]	; (c25c <_svfprintf_r+0xc64>)
    c196:	f340 81f1 	ble.w	c57c <_svfprintf_r+0xf84>
    c19a:	4642      	mov	r2, r8
    c19c:	4621      	mov	r1, r4
    c19e:	46b0      	mov	r8, r6
    c1a0:	f04f 0b10 	mov.w	fp, #16
    c1a4:	462e      	mov	r6, r5
    c1a6:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    c1a8:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    c1aa:	e004      	b.n	c1b6 <_svfprintf_r+0xbbe>
    c1ac:	3208      	adds	r2, #8
    c1ae:	3f10      	subs	r7, #16
    c1b0:	2f10      	cmp	r7, #16
    c1b2:	f340 81df 	ble.w	c574 <_svfprintf_r+0xf7c>
    c1b6:	3301      	adds	r3, #1
    c1b8:	3110      	adds	r1, #16
    c1ba:	2b07      	cmp	r3, #7
    c1bc:	9129      	str	r1, [sp, #164]	; 0xa4
    c1be:	9328      	str	r3, [sp, #160]	; 0xa0
    c1c0:	e882 0840 	stmia.w	r2, {r6, fp}
    c1c4:	ddf2      	ble.n	c1ac <_svfprintf_r+0xbb4>
    c1c6:	aa27      	add	r2, sp, #156	; 0x9c
    c1c8:	4629      	mov	r1, r5
    c1ca:	4620      	mov	r0, r4
    c1cc:	f004 fb4a 	bl	10864 <__ssprint_r>
    c1d0:	2800      	cmp	r0, #0
    c1d2:	f47f aae3 	bne.w	b79c <_svfprintf_r+0x1a4>
    c1d6:	9929      	ldr	r1, [sp, #164]	; 0xa4
    c1d8:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c1da:	464a      	mov	r2, r9
    c1dc:	e7e7      	b.n	c1ae <_svfprintf_r+0xbb6>
    c1de:	2d00      	cmp	r5, #0
    c1e0:	bf08      	it	eq
    c1e2:	2c0a      	cmpeq	r4, #10
    c1e4:	f0c0 8095 	bcc.w	c312 <_svfprintf_r+0xd1a>
    c1e8:	464e      	mov	r6, r9
    c1ea:	4620      	mov	r0, r4
    c1ec:	4629      	mov	r1, r5
    c1ee:	220a      	movs	r2, #10
    c1f0:	2300      	movs	r3, #0
    c1f2:	f7f5 f943 	bl	147c <__aeabi_uldivmod>
    c1f6:	3230      	adds	r2, #48	; 0x30
    c1f8:	f806 2d01 	strb.w	r2, [r6, #-1]!
    c1fc:	4620      	mov	r0, r4
    c1fe:	4629      	mov	r1, r5
    c200:	2300      	movs	r3, #0
    c202:	220a      	movs	r2, #10
    c204:	f7f5 f93a 	bl	147c <__aeabi_uldivmod>
    c208:	4604      	mov	r4, r0
    c20a:	460d      	mov	r5, r1
    c20c:	ea54 0305 	orrs.w	r3, r4, r5
    c210:	d1eb      	bne.n	c1ea <_svfprintf_r+0xbf2>
    c212:	eba9 0306 	sub.w	r3, r9, r6
    c216:	930e      	str	r3, [sp, #56]	; 0x38
    c218:	f7ff bafe 	b.w	b818 <_svfprintf_r+0x220>
    c21c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c21e:	930e      	str	r3, [sp, #56]	; 0x38
    c220:	464e      	mov	r6, r9
    c222:	f7ff baf9 	b.w	b818 <_svfprintf_r+0x220>
    c226:	aa27      	add	r2, sp, #156	; 0x9c
    c228:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c22a:	980c      	ldr	r0, [sp, #48]	; 0x30
    c22c:	f004 fb1a 	bl	10864 <__ssprint_r>
    c230:	2800      	cmp	r0, #0
    c232:	f47f aab3 	bne.w	b79c <_svfprintf_r+0x1a4>
    c236:	f89d 707f 	ldrb.w	r7, [sp, #127]	; 0x7f
    c23a:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c23c:	46c8      	mov	r8, r9
    c23e:	f7ff bb50 	b.w	b8e2 <_svfprintf_r+0x2ea>
    c242:	1e5e      	subs	r6, r3, #1
    c244:	2e00      	cmp	r6, #0
    c246:	f77f af0a 	ble.w	c05e <_svfprintf_r+0xa66>
    c24a:	2e10      	cmp	r6, #16
    c24c:	4d03      	ldr	r5, [pc, #12]	; (c25c <_svfprintf_r+0xc64>)
    c24e:	dd23      	ble.n	c298 <_svfprintf_r+0xca0>
    c250:	4622      	mov	r2, r4
    c252:	f04f 0b10 	mov.w	fp, #16
    c256:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    c258:	e007      	b.n	c26a <_svfprintf_r+0xc72>
    c25a:	bf00      	nop
    c25c:	00012a40 	.word	0x00012a40
    c260:	3e10      	subs	r6, #16
    c262:	2e10      	cmp	r6, #16
    c264:	f108 0808 	add.w	r8, r8, #8
    c268:	dd15      	ble.n	c296 <_svfprintf_r+0xc9e>
    c26a:	3701      	adds	r7, #1
    c26c:	3210      	adds	r2, #16
    c26e:	2f07      	cmp	r7, #7
    c270:	9229      	str	r2, [sp, #164]	; 0xa4
    c272:	9728      	str	r7, [sp, #160]	; 0xa0
    c274:	e888 0820 	stmia.w	r8, {r5, fp}
    c278:	ddf2      	ble.n	c260 <_svfprintf_r+0xc68>
    c27a:	aa27      	add	r2, sp, #156	; 0x9c
    c27c:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c27e:	4620      	mov	r0, r4
    c280:	f004 faf0 	bl	10864 <__ssprint_r>
    c284:	2800      	cmp	r0, #0
    c286:	f47f aa89 	bne.w	b79c <_svfprintf_r+0x1a4>
    c28a:	3e10      	subs	r6, #16
    c28c:	2e10      	cmp	r6, #16
    c28e:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    c290:	9f28      	ldr	r7, [sp, #160]	; 0xa0
    c292:	46c8      	mov	r8, r9
    c294:	dce9      	bgt.n	c26a <_svfprintf_r+0xc72>
    c296:	4614      	mov	r4, r2
    c298:	3701      	adds	r7, #1
    c29a:	4434      	add	r4, r6
    c29c:	2f07      	cmp	r7, #7
    c29e:	9429      	str	r4, [sp, #164]	; 0xa4
    c2a0:	9728      	str	r7, [sp, #160]	; 0xa0
    c2a2:	e888 0060 	stmia.w	r8, {r5, r6}
    c2a6:	f77f aed8 	ble.w	c05a <_svfprintf_r+0xa62>
    c2aa:	aa27      	add	r2, sp, #156	; 0x9c
    c2ac:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c2ae:	980c      	ldr	r0, [sp, #48]	; 0x30
    c2b0:	f004 fad8 	bl	10864 <__ssprint_r>
    c2b4:	2800      	cmp	r0, #0
    c2b6:	f47f aa71 	bne.w	b79c <_svfprintf_r+0x1a4>
    c2ba:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c2bc:	9f28      	ldr	r7, [sp, #160]	; 0xa0
    c2be:	46c8      	mov	r8, r9
    c2c0:	e6cd      	b.n	c05e <_svfprintf_r+0xa66>
    c2c2:	681c      	ldr	r4, [r3, #0]
    c2c4:	3304      	adds	r3, #4
    c2c6:	930f      	str	r3, [sp, #60]	; 0x3c
    c2c8:	2500      	movs	r5, #0
    c2ca:	e422      	b.n	bb12 <_svfprintf_r+0x51a>
    c2cc:	990f      	ldr	r1, [sp, #60]	; 0x3c
    c2ce:	460a      	mov	r2, r1
    c2d0:	3204      	adds	r2, #4
    c2d2:	680c      	ldr	r4, [r1, #0]
    c2d4:	920f      	str	r2, [sp, #60]	; 0x3c
    c2d6:	2500      	movs	r5, #0
    c2d8:	f7ff ba81 	b.w	b7de <_svfprintf_r+0x1e6>
    c2dc:	3204      	adds	r2, #4
    c2de:	681c      	ldr	r4, [r3, #0]
    c2e0:	920f      	str	r2, [sp, #60]	; 0x3c
    c2e2:	2301      	movs	r3, #1
    c2e4:	2500      	movs	r5, #0
    c2e6:	f7ff ba7a 	b.w	b7de <_svfprintf_r+0x1e6>
    c2ea:	4614      	mov	r4, r2
    c2ec:	3301      	adds	r3, #1
    c2ee:	4434      	add	r4, r6
    c2f0:	2b07      	cmp	r3, #7
    c2f2:	9429      	str	r4, [sp, #164]	; 0xa4
    c2f4:	9328      	str	r3, [sp, #160]	; 0xa0
    c2f6:	e888 0060 	stmia.w	r8, {r5, r6}
    c2fa:	f77f ab62 	ble.w	b9c2 <_svfprintf_r+0x3ca>
    c2fe:	e6bb      	b.n	c078 <_svfprintf_r+0xa80>
    c300:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    c302:	6814      	ldr	r4, [r2, #0]
    c304:	4613      	mov	r3, r2
    c306:	3304      	adds	r3, #4
    c308:	17e5      	asrs	r5, r4, #31
    c30a:	930f      	str	r3, [sp, #60]	; 0x3c
    c30c:	4622      	mov	r2, r4
    c30e:	462b      	mov	r3, r5
    c310:	e4cd      	b.n	bcae <_svfprintf_r+0x6b6>
    c312:	f8dd b01c 	ldr.w	fp, [sp, #28]
    c316:	f8cd b01c 	str.w	fp, [sp, #28]
    c31a:	ae44      	add	r6, sp, #272	; 0x110
    c31c:	3430      	adds	r4, #48	; 0x30
    c31e:	2301      	movs	r3, #1
    c320:	f806 4d41 	strb.w	r4, [r6, #-65]!
    c324:	930e      	str	r3, [sp, #56]	; 0x38
    c326:	f7ff ba77 	b.w	b818 <_svfprintf_r+0x220>
    c32a:	aa27      	add	r2, sp, #156	; 0x9c
    c32c:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c32e:	980c      	ldr	r0, [sp, #48]	; 0x30
    c330:	f004 fa98 	bl	10864 <__ssprint_r>
    c334:	2800      	cmp	r0, #0
    c336:	f47f aa31 	bne.w	b79c <_svfprintf_r+0x1a4>
    c33a:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c33c:	46c8      	mov	r8, r9
    c33e:	9a21      	ldr	r2, [sp, #132]	; 0x84
    c340:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c342:	429a      	cmp	r2, r3
    c344:	db44      	blt.n	c3d0 <_svfprintf_r+0xdd8>
    c346:	9b07      	ldr	r3, [sp, #28]
    c348:	07d9      	lsls	r1, r3, #31
    c34a:	d441      	bmi.n	c3d0 <_svfprintf_r+0xdd8>
    c34c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c34e:	9812      	ldr	r0, [sp, #72]	; 0x48
    c350:	1a9a      	subs	r2, r3, r2
    c352:	1a1d      	subs	r5, r3, r0
    c354:	4295      	cmp	r5, r2
    c356:	bfa8      	it	ge
    c358:	4615      	movge	r5, r2
    c35a:	2d00      	cmp	r5, #0
    c35c:	dd0e      	ble.n	c37c <_svfprintf_r+0xd84>
    c35e:	9928      	ldr	r1, [sp, #160]	; 0xa0
    c360:	f8c8 5004 	str.w	r5, [r8, #4]
    c364:	3101      	adds	r1, #1
    c366:	4406      	add	r6, r0
    c368:	442c      	add	r4, r5
    c36a:	2907      	cmp	r1, #7
    c36c:	f8c8 6000 	str.w	r6, [r8]
    c370:	9429      	str	r4, [sp, #164]	; 0xa4
    c372:	9128      	str	r1, [sp, #160]	; 0xa0
    c374:	f300 823d 	bgt.w	c7f2 <_svfprintf_r+0x11fa>
    c378:	f108 0808 	add.w	r8, r8, #8
    c37c:	2d00      	cmp	r5, #0
    c37e:	bfac      	ite	ge
    c380:	1b56      	subge	r6, r2, r5
    c382:	4616      	movlt	r6, r2
    c384:	2e00      	cmp	r6, #0
    c386:	f77f ab1e 	ble.w	b9c6 <_svfprintf_r+0x3ce>
    c38a:	2e10      	cmp	r6, #16
    c38c:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c38e:	4db1      	ldr	r5, [pc, #708]	; (c654 <_svfprintf_r+0x105c>)
    c390:	ddac      	ble.n	c2ec <_svfprintf_r+0xcf4>
    c392:	4622      	mov	r2, r4
    c394:	2710      	movs	r7, #16
    c396:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
    c39a:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    c39c:	e004      	b.n	c3a8 <_svfprintf_r+0xdb0>
    c39e:	f108 0808 	add.w	r8, r8, #8
    c3a2:	3e10      	subs	r6, #16
    c3a4:	2e10      	cmp	r6, #16
    c3a6:	dda0      	ble.n	c2ea <_svfprintf_r+0xcf2>
    c3a8:	3301      	adds	r3, #1
    c3aa:	3210      	adds	r2, #16
    c3ac:	2b07      	cmp	r3, #7
    c3ae:	9229      	str	r2, [sp, #164]	; 0xa4
    c3b0:	9328      	str	r3, [sp, #160]	; 0xa0
    c3b2:	e888 00a0 	stmia.w	r8, {r5, r7}
    c3b6:	ddf2      	ble.n	c39e <_svfprintf_r+0xda6>
    c3b8:	aa27      	add	r2, sp, #156	; 0x9c
    c3ba:	4621      	mov	r1, r4
    c3bc:	4658      	mov	r0, fp
    c3be:	f004 fa51 	bl	10864 <__ssprint_r>
    c3c2:	2800      	cmp	r0, #0
    c3c4:	f47f a9ea 	bne.w	b79c <_svfprintf_r+0x1a4>
    c3c8:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    c3ca:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c3cc:	46c8      	mov	r8, r9
    c3ce:	e7e8      	b.n	c3a2 <_svfprintf_r+0xdaa>
    c3d0:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c3d2:	9817      	ldr	r0, [sp, #92]	; 0x5c
    c3d4:	9918      	ldr	r1, [sp, #96]	; 0x60
    c3d6:	f8c8 1000 	str.w	r1, [r8]
    c3da:	3301      	adds	r3, #1
    c3dc:	4404      	add	r4, r0
    c3de:	2b07      	cmp	r3, #7
    c3e0:	9429      	str	r4, [sp, #164]	; 0xa4
    c3e2:	f8c8 0004 	str.w	r0, [r8, #4]
    c3e6:	9328      	str	r3, [sp, #160]	; 0xa0
    c3e8:	f300 81f7 	bgt.w	c7da <_svfprintf_r+0x11e2>
    c3ec:	f108 0808 	add.w	r8, r8, #8
    c3f0:	e7ac      	b.n	c34c <_svfprintf_r+0xd54>
    c3f2:	9b07      	ldr	r3, [sp, #28]
    c3f4:	07da      	lsls	r2, r3, #31
    c3f6:	f53f adfc 	bmi.w	bff2 <_svfprintf_r+0x9fa>
    c3fa:	3701      	adds	r7, #1
    c3fc:	3401      	adds	r4, #1
    c3fe:	2301      	movs	r3, #1
    c400:	2f07      	cmp	r7, #7
    c402:	9429      	str	r4, [sp, #164]	; 0xa4
    c404:	9728      	str	r7, [sp, #160]	; 0xa0
    c406:	f8c8 6000 	str.w	r6, [r8]
    c40a:	f8c8 3004 	str.w	r3, [r8, #4]
    c40e:	f77f ae24 	ble.w	c05a <_svfprintf_r+0xa62>
    c412:	e74a      	b.n	c2aa <_svfprintf_r+0xcb2>
    c414:	aa27      	add	r2, sp, #156	; 0x9c
    c416:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c418:	980c      	ldr	r0, [sp, #48]	; 0x30
    c41a:	f004 fa23 	bl	10864 <__ssprint_r>
    c41e:	2800      	cmp	r0, #0
    c420:	f47f a9bc 	bne.w	b79c <_svfprintf_r+0x1a4>
    c424:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c426:	9f28      	ldr	r7, [sp, #160]	; 0xa0
    c428:	46c8      	mov	r8, r9
    c42a:	e5f0      	b.n	c00e <_svfprintf_r+0xa16>
    c42c:	aa27      	add	r2, sp, #156	; 0x9c
    c42e:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c430:	980c      	ldr	r0, [sp, #48]	; 0x30
    c432:	f004 fa17 	bl	10864 <__ssprint_r>
    c436:	2800      	cmp	r0, #0
    c438:	f47f a9b0 	bne.w	b79c <_svfprintf_r+0x1a4>
    c43c:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c43e:	9f28      	ldr	r7, [sp, #160]	; 0xa0
    c440:	46c8      	mov	r8, r9
    c442:	e5f3      	b.n	c02c <_svfprintf_r+0xa34>
    c444:	464e      	mov	r6, r9
    c446:	f7ff b9e7 	b.w	b818 <_svfprintf_r+0x220>
    c44a:	aa27      	add	r2, sp, #156	; 0x9c
    c44c:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c44e:	980c      	ldr	r0, [sp, #48]	; 0x30
    c450:	f004 fa08 	bl	10864 <__ssprint_r>
    c454:	2800      	cmp	r0, #0
    c456:	f47f a9a1 	bne.w	b79c <_svfprintf_r+0x1a4>
    c45a:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c45c:	46c8      	mov	r8, r9
    c45e:	f7ff ba63 	b.w	b928 <_svfprintf_r+0x330>
    c462:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
    c466:	4602      	mov	r2, r0
    c468:	460b      	mov	r3, r1
    c46a:	f7f4 ffc9 	bl	1400 <__aeabi_dcmpun>
    c46e:	2800      	cmp	r0, #0
    c470:	f040 829b 	bne.w	c9aa <_svfprintf_r+0x13b2>
    c474:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c476:	3301      	adds	r3, #1
    c478:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c47a:	f023 0720 	bic.w	r7, r3, #32
    c47e:	f000 81d5 	beq.w	c82c <_svfprintf_r+0x1234>
    c482:	2f47      	cmp	r7, #71	; 0x47
    c484:	f000 8123 	beq.w	c6ce <_svfprintf_r+0x10d6>
    c488:	9b15      	ldr	r3, [sp, #84]	; 0x54
    c48a:	f44b 7280 	orr.w	r2, fp, #256	; 0x100
    c48e:	2b00      	cmp	r3, #0
    c490:	9207      	str	r2, [sp, #28]
    c492:	f2c0 81f3 	blt.w	c87c <_svfprintf_r+0x1284>
    c496:	ed9d 7b14 	vldr	d7, [sp, #80]	; 0x50
    c49a:	ed8d 7b1c 	vstr	d7, [sp, #112]	; 0x70
    c49e:	2300      	movs	r3, #0
    c4a0:	9310      	str	r3, [sp, #64]	; 0x40
    c4a2:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c4a4:	2b66      	cmp	r3, #102	; 0x66
    c4a6:	f000 81c4 	beq.w	c832 <_svfprintf_r+0x123a>
    c4aa:	2b46      	cmp	r3, #70	; 0x46
    c4ac:	f000 80f1 	beq.w	c692 <_svfprintf_r+0x109a>
    c4b0:	2f45      	cmp	r7, #69	; 0x45
    c4b2:	bf0a      	itet	eq
    c4b4:	9b0a      	ldreq	r3, [sp, #40]	; 0x28
    c4b6:	9d0a      	ldrne	r5, [sp, #40]	; 0x28
    c4b8:	1c5d      	addeq	r5, r3, #1
    c4ba:	a825      	add	r0, sp, #148	; 0x94
    c4bc:	a922      	add	r1, sp, #136	; 0x88
    c4be:	aa21      	add	r2, sp, #132	; 0x84
    c4c0:	2302      	movs	r3, #2
    c4c2:	9004      	str	r0, [sp, #16]
    c4c4:	9202      	str	r2, [sp, #8]
    c4c6:	9300      	str	r3, [sp, #0]
    c4c8:	9501      	str	r5, [sp, #4]
    c4ca:	e9dd 231c 	ldrd	r2, r3, [sp, #112]	; 0x70
    c4ce:	9103      	str	r1, [sp, #12]
    c4d0:	980c      	ldr	r0, [sp, #48]	; 0x30
    c4d2:	f002 fe95 	bl	f200 <_dtoa_r>
    c4d6:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c4d8:	2b67      	cmp	r3, #103	; 0x67
    c4da:	4606      	mov	r6, r0
    c4dc:	f040 81d7 	bne.w	c88e <_svfprintf_r+0x1296>
    c4e0:	f01b 0f01 	tst.w	fp, #1
    c4e4:	f000 8250 	beq.w	c988 <_svfprintf_r+0x1390>
    c4e8:	1974      	adds	r4, r6, r5
    c4ea:	2200      	movs	r2, #0
    c4ec:	2300      	movs	r3, #0
    c4ee:	e9dd 011c 	ldrd	r0, r1, [sp, #112]	; 0x70
    c4f2:	f7f4 ff53 	bl	139c <__aeabi_dcmpeq>
    c4f6:	2800      	cmp	r0, #0
    c4f8:	f040 8162 	bne.w	c7c0 <_svfprintf_r+0x11c8>
    c4fc:	9b25      	ldr	r3, [sp, #148]	; 0x94
    c4fe:	42a3      	cmp	r3, r4
    c500:	d206      	bcs.n	c510 <_svfprintf_r+0xf18>
    c502:	2130      	movs	r1, #48	; 0x30
    c504:	1c5a      	adds	r2, r3, #1
    c506:	9225      	str	r2, [sp, #148]	; 0x94
    c508:	7019      	strb	r1, [r3, #0]
    c50a:	9b25      	ldr	r3, [sp, #148]	; 0x94
    c50c:	429c      	cmp	r4, r3
    c50e:	d8f9      	bhi.n	c504 <_svfprintf_r+0xf0c>
    c510:	1b9b      	subs	r3, r3, r6
    c512:	2f47      	cmp	r7, #71	; 0x47
    c514:	9313      	str	r3, [sp, #76]	; 0x4c
    c516:	f000 80f2 	beq.w	c6fe <_svfprintf_r+0x1106>
    c51a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c51c:	2b65      	cmp	r3, #101	; 0x65
    c51e:	f340 81c5 	ble.w	c8ac <_svfprintf_r+0x12b4>
    c522:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c524:	2b66      	cmp	r3, #102	; 0x66
    c526:	9b21      	ldr	r3, [sp, #132]	; 0x84
    c528:	9312      	str	r3, [sp, #72]	; 0x48
    c52a:	f000 81c2 	beq.w	c8b2 <_svfprintf_r+0x12ba>
    c52e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c530:	9a12      	ldr	r2, [sp, #72]	; 0x48
    c532:	4619      	mov	r1, r3
    c534:	4291      	cmp	r1, r2
    c536:	f300 8193 	bgt.w	c860 <_svfprintf_r+0x1268>
    c53a:	f01b 0f01 	tst.w	fp, #1
    c53e:	f040 8225 	bne.w	c98c <_svfprintf_r+0x1394>
    c542:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    c546:	9308      	str	r3, [sp, #32]
    c548:	2367      	movs	r3, #103	; 0x67
    c54a:	920e      	str	r2, [sp, #56]	; 0x38
    c54c:	9311      	str	r3, [sp, #68]	; 0x44
    c54e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    c550:	2b00      	cmp	r3, #0
    c552:	f040 80cd 	bne.w	c6f0 <_svfprintf_r+0x10f8>
    c556:	930a      	str	r3, [sp, #40]	; 0x28
    c558:	f89d 707f 	ldrb.w	r7, [sp, #127]	; 0x7f
    c55c:	f7ff b964 	b.w	b828 <_svfprintf_r+0x230>
    c560:	f025 0507 	bic.w	r5, r5, #7
    c564:	ed95 7b00 	vldr	d7, [r5]
    c568:	f105 0308 	add.w	r3, r5, #8
    c56c:	ed8d 7b14 	vstr	d7, [sp, #80]	; 0x50
    c570:	930f      	str	r3, [sp, #60]	; 0x3c
    c572:	e415      	b.n	bda0 <_svfprintf_r+0x7a8>
    c574:	4635      	mov	r5, r6
    c576:	460c      	mov	r4, r1
    c578:	4646      	mov	r6, r8
    c57a:	4690      	mov	r8, r2
    c57c:	3301      	adds	r3, #1
    c57e:	443c      	add	r4, r7
    c580:	2b07      	cmp	r3, #7
    c582:	9429      	str	r4, [sp, #164]	; 0xa4
    c584:	9328      	str	r3, [sp, #160]	; 0xa0
    c586:	e888 00a0 	stmia.w	r8, {r5, r7}
    c58a:	f73f aece 	bgt.w	c32a <_svfprintf_r+0xd32>
    c58e:	f108 0808 	add.w	r8, r8, #8
    c592:	e6d4      	b.n	c33e <_svfprintf_r+0xd46>
    c594:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    c596:	6813      	ldr	r3, [r2, #0]
    c598:	3204      	adds	r2, #4
    c59a:	920f      	str	r2, [sp, #60]	; 0x3c
    c59c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    c59e:	601a      	str	r2, [r3, #0]
    c5a0:	f7ff b851 	b.w	b646 <_svfprintf_r+0x4e>
    c5a4:	aa27      	add	r2, sp, #156	; 0x9c
    c5a6:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c5a8:	980c      	ldr	r0, [sp, #48]	; 0x30
    c5aa:	f004 f95b 	bl	10864 <__ssprint_r>
    c5ae:	2800      	cmp	r0, #0
    c5b0:	f47f a8f4 	bne.w	b79c <_svfprintf_r+0x1a4>
    c5b4:	46c8      	mov	r8, r9
    c5b6:	e487      	b.n	bec8 <_svfprintf_r+0x8d0>
    c5b8:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c5ba:	4a27      	ldr	r2, [pc, #156]	; (c658 <_svfprintf_r+0x1060>)
    c5bc:	f8c8 2000 	str.w	r2, [r8]
    c5c0:	3301      	adds	r3, #1
    c5c2:	3401      	adds	r4, #1
    c5c4:	2201      	movs	r2, #1
    c5c6:	2b07      	cmp	r3, #7
    c5c8:	9429      	str	r4, [sp, #164]	; 0xa4
    c5ca:	9328      	str	r3, [sp, #160]	; 0xa0
    c5cc:	f8c8 2004 	str.w	r2, [r8, #4]
    c5d0:	dc53      	bgt.n	c67a <_svfprintf_r+0x1082>
    c5d2:	f108 0808 	add.w	r8, r8, #8
    c5d6:	b929      	cbnz	r1, c5e4 <_svfprintf_r+0xfec>
    c5d8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c5da:	b91b      	cbnz	r3, c5e4 <_svfprintf_r+0xfec>
    c5dc:	9b07      	ldr	r3, [sp, #28]
    c5de:	07d8      	lsls	r0, r3, #31
    c5e0:	f57f a9f1 	bpl.w	b9c6 <_svfprintf_r+0x3ce>
    c5e4:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c5e6:	9817      	ldr	r0, [sp, #92]	; 0x5c
    c5e8:	9a18      	ldr	r2, [sp, #96]	; 0x60
    c5ea:	f8c8 2000 	str.w	r2, [r8]
    c5ee:	3301      	adds	r3, #1
    c5f0:	4602      	mov	r2, r0
    c5f2:	4422      	add	r2, r4
    c5f4:	2b07      	cmp	r3, #7
    c5f6:	9229      	str	r2, [sp, #164]	; 0xa4
    c5f8:	f8c8 0004 	str.w	r0, [r8, #4]
    c5fc:	9328      	str	r3, [sp, #160]	; 0xa0
    c5fe:	f300 8197 	bgt.w	c930 <_svfprintf_r+0x1338>
    c602:	f108 0808 	add.w	r8, r8, #8
    c606:	2900      	cmp	r1, #0
    c608:	f2c0 816f 	blt.w	c8ea <_svfprintf_r+0x12f2>
    c60c:	9913      	ldr	r1, [sp, #76]	; 0x4c
    c60e:	f8c8 6000 	str.w	r6, [r8]
    c612:	3301      	adds	r3, #1
    c614:	188c      	adds	r4, r1, r2
    c616:	2b07      	cmp	r3, #7
    c618:	9429      	str	r4, [sp, #164]	; 0xa4
    c61a:	9328      	str	r3, [sp, #160]	; 0xa0
    c61c:	f8c8 1004 	str.w	r1, [r8, #4]
    c620:	f77f a9cf 	ble.w	b9c2 <_svfprintf_r+0x3ca>
    c624:	e528      	b.n	c078 <_svfprintf_r+0xa80>
    c626:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    c628:	9909      	ldr	r1, [sp, #36]	; 0x24
    c62a:	6813      	ldr	r3, [r2, #0]
    c62c:	17cd      	asrs	r5, r1, #31
    c62e:	4608      	mov	r0, r1
    c630:	3204      	adds	r2, #4
    c632:	4629      	mov	r1, r5
    c634:	920f      	str	r2, [sp, #60]	; 0x3c
    c636:	e9c3 0100 	strd	r0, r1, [r3]
    c63a:	f7ff b804 	b.w	b646 <_svfprintf_r+0x4e>
    c63e:	aa27      	add	r2, sp, #156	; 0x9c
    c640:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c642:	980c      	ldr	r0, [sp, #48]	; 0x30
    c644:	f004 f90e 	bl	10864 <__ssprint_r>
    c648:	2800      	cmp	r0, #0
    c64a:	f47f a8a7 	bne.w	b79c <_svfprintf_r+0x1a4>
    c64e:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c650:	46c8      	mov	r8, r9
    c652:	e452      	b.n	befa <_svfprintf_r+0x902>
    c654:	00012a40 	.word	0x00012a40
    c658:	00012a2c 	.word	0x00012a2c
    c65c:	2140      	movs	r1, #64	; 0x40
    c65e:	980c      	ldr	r0, [sp, #48]	; 0x30
    c660:	f7f6 f8ae 	bl	27c0 <__wrap__malloc_r>
    c664:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    c666:	6010      	str	r0, [r2, #0]
    c668:	6110      	str	r0, [r2, #16]
    c66a:	2800      	cmp	r0, #0
    c66c:	f000 81f8 	beq.w	ca60 <_svfprintf_r+0x1468>
    c670:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    c672:	2340      	movs	r3, #64	; 0x40
    c674:	6153      	str	r3, [r2, #20]
    c676:	f7fe bfd6 	b.w	b626 <_svfprintf_r+0x2e>
    c67a:	aa27      	add	r2, sp, #156	; 0x9c
    c67c:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c67e:	980c      	ldr	r0, [sp, #48]	; 0x30
    c680:	f004 f8f0 	bl	10864 <__ssprint_r>
    c684:	2800      	cmp	r0, #0
    c686:	f47f a889 	bne.w	b79c <_svfprintf_r+0x1a4>
    c68a:	9921      	ldr	r1, [sp, #132]	; 0x84
    c68c:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c68e:	46c8      	mov	r8, r9
    c690:	e7a1      	b.n	c5d6 <_svfprintf_r+0xfde>
    c692:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    c694:	9401      	str	r4, [sp, #4]
    c696:	a825      	add	r0, sp, #148	; 0x94
    c698:	a922      	add	r1, sp, #136	; 0x88
    c69a:	aa21      	add	r2, sp, #132	; 0x84
    c69c:	2303      	movs	r3, #3
    c69e:	9004      	str	r0, [sp, #16]
    c6a0:	9202      	str	r2, [sp, #8]
    c6a2:	9300      	str	r3, [sp, #0]
    c6a4:	9103      	str	r1, [sp, #12]
    c6a6:	e9dd 231c 	ldrd	r2, r3, [sp, #112]	; 0x70
    c6aa:	980c      	ldr	r0, [sp, #48]	; 0x30
    c6ac:	f002 fda8 	bl	f200 <_dtoa_r>
    c6b0:	4625      	mov	r5, r4
    c6b2:	4606      	mov	r6, r0
    c6b4:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c6b6:	2b46      	cmp	r3, #70	; 0x46
    c6b8:	eb06 0405 	add.w	r4, r6, r5
    c6bc:	f47f af15 	bne.w	c4ea <_svfprintf_r+0xef2>
    c6c0:	7833      	ldrb	r3, [r6, #0]
    c6c2:	2b30      	cmp	r3, #48	; 0x30
    c6c4:	f000 817d 	beq.w	c9c2 <_svfprintf_r+0x13ca>
    c6c8:	9d21      	ldr	r5, [sp, #132]	; 0x84
    c6ca:	442c      	add	r4, r5
    c6cc:	e70d      	b.n	c4ea <_svfprintf_r+0xef2>
    c6ce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c6d0:	2b00      	cmp	r3, #0
    c6d2:	bf08      	it	eq
    c6d4:	2301      	moveq	r3, #1
    c6d6:	930a      	str	r3, [sp, #40]	; 0x28
    c6d8:	e6d6      	b.n	c488 <_svfprintf_r+0xe90>
    c6da:	4630      	mov	r0, r6
    c6dc:	940a      	str	r4, [sp, #40]	; 0x28
    c6de:	f7f4 f9cf 	bl	a80 <strlen>
    c6e2:	950f      	str	r5, [sp, #60]	; 0x3c
    c6e4:	900e      	str	r0, [sp, #56]	; 0x38
    c6e6:	f8cd b01c 	str.w	fp, [sp, #28]
    c6ea:	4603      	mov	r3, r0
    c6ec:	f7ff b9e8 	b.w	bac0 <_svfprintf_r+0x4c8>
    c6f0:	272d      	movs	r7, #45	; 0x2d
    c6f2:	2300      	movs	r3, #0
    c6f4:	f88d 707f 	strb.w	r7, [sp, #127]	; 0x7f
    c6f8:	930a      	str	r3, [sp, #40]	; 0x28
    c6fa:	f7ff b896 	b.w	b82a <_svfprintf_r+0x232>
    c6fe:	9b21      	ldr	r3, [sp, #132]	; 0x84
    c700:	9312      	str	r3, [sp, #72]	; 0x48
    c702:	461a      	mov	r2, r3
    c704:	3303      	adds	r3, #3
    c706:	db04      	blt.n	c712 <_svfprintf_r+0x111a>
    c708:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c70a:	4619      	mov	r1, r3
    c70c:	4291      	cmp	r1, r2
    c70e:	f6bf af0e 	bge.w	c52e <_svfprintf_r+0xf36>
    c712:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c714:	3b02      	subs	r3, #2
    c716:	9311      	str	r3, [sp, #68]	; 0x44
    c718:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
    c71c:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
    c720:	9b12      	ldr	r3, [sp, #72]	; 0x48
    c722:	3b01      	subs	r3, #1
    c724:	2b00      	cmp	r3, #0
    c726:	9321      	str	r3, [sp, #132]	; 0x84
    c728:	bfbd      	ittte	lt
    c72a:	9b12      	ldrlt	r3, [sp, #72]	; 0x48
    c72c:	f1c3 0301 	rsblt	r3, r3, #1
    c730:	222d      	movlt	r2, #45	; 0x2d
    c732:	222b      	movge	r2, #43	; 0x2b
    c734:	2b09      	cmp	r3, #9
    c736:	f88d 208d 	strb.w	r2, [sp, #141]	; 0x8d
    c73a:	f340 811d 	ble.w	c978 <_svfprintf_r+0x1380>
    c73e:	f10d 049b 	add.w	r4, sp, #155	; 0x9b
    c742:	4620      	mov	r0, r4
    c744:	4da9      	ldr	r5, [pc, #676]	; (c9ec <_svfprintf_r+0x13f4>)
    c746:	e000      	b.n	c74a <_svfprintf_r+0x1152>
    c748:	4610      	mov	r0, r2
    c74a:	fb85 1203 	smull	r1, r2, r5, r3
    c74e:	17d9      	asrs	r1, r3, #31
    c750:	ebc1 01a2 	rsb	r1, r1, r2, asr #2
    c754:	eb01 0281 	add.w	r2, r1, r1, lsl #2
    c758:	eba3 0242 	sub.w	r2, r3, r2, lsl #1
    c75c:	3230      	adds	r2, #48	; 0x30
    c75e:	2909      	cmp	r1, #9
    c760:	f800 2c01 	strb.w	r2, [r0, #-1]
    c764:	460b      	mov	r3, r1
    c766:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    c76a:	dced      	bgt.n	c748 <_svfprintf_r+0x1150>
    c76c:	3330      	adds	r3, #48	; 0x30
    c76e:	3802      	subs	r0, #2
    c770:	b2d9      	uxtb	r1, r3
    c772:	4284      	cmp	r4, r0
    c774:	f802 1c01 	strb.w	r1, [r2, #-1]
    c778:	f240 816f 	bls.w	ca5a <_svfprintf_r+0x1462>
    c77c:	f10d 008e 	add.w	r0, sp, #142	; 0x8e
    c780:	4613      	mov	r3, r2
    c782:	e001      	b.n	c788 <_svfprintf_r+0x1190>
    c784:	f813 1b01 	ldrb.w	r1, [r3], #1
    c788:	f800 1b01 	strb.w	r1, [r0], #1
    c78c:	42a3      	cmp	r3, r4
    c78e:	d1f9      	bne.n	c784 <_svfprintf_r+0x118c>
    c790:	3301      	adds	r3, #1
    c792:	1a9b      	subs	r3, r3, r2
    c794:	f10d 028e 	add.w	r2, sp, #142	; 0x8e
    c798:	4413      	add	r3, r2
    c79a:	aa23      	add	r2, sp, #140	; 0x8c
    c79c:	1a9b      	subs	r3, r3, r2
    c79e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    c7a0:	9319      	str	r3, [sp, #100]	; 0x64
    c7a2:	2a01      	cmp	r2, #1
    c7a4:	4413      	add	r3, r2
    c7a6:	930e      	str	r3, [sp, #56]	; 0x38
    c7a8:	f340 812a 	ble.w	ca00 <_svfprintf_r+0x1408>
    c7ac:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    c7ae:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    c7b0:	4413      	add	r3, r2
    c7b2:	930e      	str	r3, [sp, #56]	; 0x38
    c7b4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    c7b8:	9308      	str	r3, [sp, #32]
    c7ba:	2300      	movs	r3, #0
    c7bc:	9312      	str	r3, [sp, #72]	; 0x48
    c7be:	e6c6      	b.n	c54e <_svfprintf_r+0xf56>
    c7c0:	4623      	mov	r3, r4
    c7c2:	e6a5      	b.n	c510 <_svfprintf_r+0xf18>
    c7c4:	aa27      	add	r2, sp, #156	; 0x9c
    c7c6:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c7c8:	980c      	ldr	r0, [sp, #48]	; 0x30
    c7ca:	f004 f84b 	bl	10864 <__ssprint_r>
    c7ce:	2800      	cmp	r0, #0
    c7d0:	f47e afe4 	bne.w	b79c <_svfprintf_r+0x1a4>
    c7d4:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c7d6:	46c8      	mov	r8, r9
    c7d8:	e4d2      	b.n	c180 <_svfprintf_r+0xb88>
    c7da:	aa27      	add	r2, sp, #156	; 0x9c
    c7dc:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c7de:	980c      	ldr	r0, [sp, #48]	; 0x30
    c7e0:	f004 f840 	bl	10864 <__ssprint_r>
    c7e4:	2800      	cmp	r0, #0
    c7e6:	f47e afd9 	bne.w	b79c <_svfprintf_r+0x1a4>
    c7ea:	9a21      	ldr	r2, [sp, #132]	; 0x84
    c7ec:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c7ee:	46c8      	mov	r8, r9
    c7f0:	e5ac      	b.n	c34c <_svfprintf_r+0xd54>
    c7f2:	aa27      	add	r2, sp, #156	; 0x9c
    c7f4:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c7f6:	980c      	ldr	r0, [sp, #48]	; 0x30
    c7f8:	f004 f834 	bl	10864 <__ssprint_r>
    c7fc:	2800      	cmp	r0, #0
    c7fe:	f47e afcd 	bne.w	b79c <_svfprintf_r+0x1a4>
    c802:	9a21      	ldr	r2, [sp, #132]	; 0x84
    c804:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c806:	9c29      	ldr	r4, [sp, #164]	; 0xa4
    c808:	1a9a      	subs	r2, r3, r2
    c80a:	46c8      	mov	r8, r9
    c80c:	e5b6      	b.n	c37c <_svfprintf_r+0xd84>
    c80e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c810:	9612      	str	r6, [sp, #72]	; 0x48
    c812:	2b06      	cmp	r3, #6
    c814:	bf28      	it	cs
    c816:	2306      	movcs	r3, #6
    c818:	960a      	str	r6, [sp, #40]	; 0x28
    c81a:	4637      	mov	r7, r6
    c81c:	9308      	str	r3, [sp, #32]
    c81e:	950f      	str	r5, [sp, #60]	; 0x3c
    c820:	f8cd b01c 	str.w	fp, [sp, #28]
    c824:	930e      	str	r3, [sp, #56]	; 0x38
    c826:	4e72      	ldr	r6, [pc, #456]	; (c9f0 <_svfprintf_r+0x13f8>)
    c828:	f7fe bffe 	b.w	b828 <_svfprintf_r+0x230>
    c82c:	2306      	movs	r3, #6
    c82e:	930a      	str	r3, [sp, #40]	; 0x28
    c830:	e62a      	b.n	c488 <_svfprintf_r+0xe90>
    c832:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    c834:	9501      	str	r5, [sp, #4]
    c836:	a825      	add	r0, sp, #148	; 0x94
    c838:	a922      	add	r1, sp, #136	; 0x88
    c83a:	aa21      	add	r2, sp, #132	; 0x84
    c83c:	2303      	movs	r3, #3
    c83e:	9004      	str	r0, [sp, #16]
    c840:	9202      	str	r2, [sp, #8]
    c842:	9300      	str	r3, [sp, #0]
    c844:	9103      	str	r1, [sp, #12]
    c846:	e9dd 231c 	ldrd	r2, r3, [sp, #112]	; 0x70
    c84a:	980c      	ldr	r0, [sp, #48]	; 0x30
    c84c:	f002 fcd8 	bl	f200 <_dtoa_r>
    c850:	4606      	mov	r6, r0
    c852:	1944      	adds	r4, r0, r5
    c854:	e734      	b.n	c6c0 <_svfprintf_r+0x10c8>
    c856:	272d      	movs	r7, #45	; 0x2d
    c858:	f88d 707f 	strb.w	r7, [sp, #127]	; 0x7f
    c85c:	f7ff bac7 	b.w	bdee <_svfprintf_r+0x7f6>
    c860:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    c862:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    c864:	4413      	add	r3, r2
    c866:	9a12      	ldr	r2, [sp, #72]	; 0x48
    c868:	930e      	str	r3, [sp, #56]	; 0x38
    c86a:	2a00      	cmp	r2, #0
    c86c:	f340 80b7 	ble.w	c9de <_svfprintf_r+0x13e6>
    c870:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    c874:	9308      	str	r3, [sp, #32]
    c876:	2367      	movs	r3, #103	; 0x67
    c878:	9311      	str	r3, [sp, #68]	; 0x44
    c87a:	e668      	b.n	c54e <_svfprintf_r+0xf56>
    c87c:	e9dd 1214 	ldrd	r1, r2, [sp, #80]	; 0x50
    c880:	f102 4300 	add.w	r3, r2, #2147483648	; 0x80000000
    c884:	931d      	str	r3, [sp, #116]	; 0x74
    c886:	232d      	movs	r3, #45	; 0x2d
    c888:	911c      	str	r1, [sp, #112]	; 0x70
    c88a:	9310      	str	r3, [sp, #64]	; 0x40
    c88c:	e609      	b.n	c4a2 <_svfprintf_r+0xeaa>
    c88e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    c890:	2b47      	cmp	r3, #71	; 0x47
    c892:	f47f ae29 	bne.w	c4e8 <_svfprintf_r+0xef0>
    c896:	f01b 0f01 	tst.w	fp, #1
    c89a:	f47f af0b 	bne.w	c6b4 <_svfprintf_r+0x10bc>
    c89e:	9b25      	ldr	r3, [sp, #148]	; 0x94
    c8a0:	2f47      	cmp	r7, #71	; 0x47
    c8a2:	eba3 0306 	sub.w	r3, r3, r6
    c8a6:	9313      	str	r3, [sp, #76]	; 0x4c
    c8a8:	f43f af29 	beq.w	c6fe <_svfprintf_r+0x1106>
    c8ac:	9b21      	ldr	r3, [sp, #132]	; 0x84
    c8ae:	9312      	str	r3, [sp, #72]	; 0x48
    c8b0:	e732      	b.n	c718 <_svfprintf_r+0x1120>
    c8b2:	2b00      	cmp	r3, #0
    c8b4:	f340 80ae 	ble.w	ca14 <_svfprintf_r+0x141c>
    c8b8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    c8ba:	2a00      	cmp	r2, #0
    c8bc:	d16b      	bne.n	c996 <_svfprintf_r+0x139e>
    c8be:	f01b 0f01 	tst.w	fp, #1
    c8c2:	d168      	bne.n	c996 <_svfprintf_r+0x139e>
    c8c4:	9308      	str	r3, [sp, #32]
    c8c6:	930e      	str	r3, [sp, #56]	; 0x38
    c8c8:	e641      	b.n	c54e <_svfprintf_r+0xf56>
    c8ca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c8cc:	9308      	str	r3, [sp, #32]
    c8ce:	930e      	str	r3, [sp, #56]	; 0x38
    c8d0:	900a      	str	r0, [sp, #40]	; 0x28
    c8d2:	950f      	str	r5, [sp, #60]	; 0x3c
    c8d4:	f8cd b01c 	str.w	fp, [sp, #28]
    c8d8:	9012      	str	r0, [sp, #72]	; 0x48
    c8da:	f89d 707f 	ldrb.w	r7, [sp, #127]	; 0x7f
    c8de:	f7fe bfa3 	b.w	b828 <_svfprintf_r+0x230>
    c8e2:	2000      	movs	r0, #0
    c8e4:	900a      	str	r0, [sp, #40]	; 0x28
    c8e6:	f7fe bee1 	b.w	b6ac <_svfprintf_r+0xb4>
    c8ea:	424f      	negs	r7, r1
    c8ec:	3110      	adds	r1, #16
    c8ee:	4d41      	ldr	r5, [pc, #260]	; (c9f4 <_svfprintf_r+0x13fc>)
    c8f0:	da2b      	bge.n	c94a <_svfprintf_r+0x1352>
    c8f2:	2410      	movs	r4, #16
    c8f4:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
    c8f8:	e004      	b.n	c904 <_svfprintf_r+0x130c>
    c8fa:	f108 0808 	add.w	r8, r8, #8
    c8fe:	3f10      	subs	r7, #16
    c900:	2f10      	cmp	r7, #16
    c902:	dd22      	ble.n	c94a <_svfprintf_r+0x1352>
    c904:	3301      	adds	r3, #1
    c906:	3210      	adds	r2, #16
    c908:	2b07      	cmp	r3, #7
    c90a:	9229      	str	r2, [sp, #164]	; 0xa4
    c90c:	9328      	str	r3, [sp, #160]	; 0xa0
    c90e:	f8c8 5000 	str.w	r5, [r8]
    c912:	f8c8 4004 	str.w	r4, [r8, #4]
    c916:	ddf0      	ble.n	c8fa <_svfprintf_r+0x1302>
    c918:	aa27      	add	r2, sp, #156	; 0x9c
    c91a:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c91c:	4658      	mov	r0, fp
    c91e:	f003 ffa1 	bl	10864 <__ssprint_r>
    c922:	2800      	cmp	r0, #0
    c924:	f47e af3a 	bne.w	b79c <_svfprintf_r+0x1a4>
    c928:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    c92a:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c92c:	46c8      	mov	r8, r9
    c92e:	e7e6      	b.n	c8fe <_svfprintf_r+0x1306>
    c930:	aa27      	add	r2, sp, #156	; 0x9c
    c932:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c934:	980c      	ldr	r0, [sp, #48]	; 0x30
    c936:	f003 ff95 	bl	10864 <__ssprint_r>
    c93a:	2800      	cmp	r0, #0
    c93c:	f47e af2e 	bne.w	b79c <_svfprintf_r+0x1a4>
    c940:	9921      	ldr	r1, [sp, #132]	; 0x84
    c942:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    c944:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c946:	46c8      	mov	r8, r9
    c948:	e65d      	b.n	c606 <_svfprintf_r+0x100e>
    c94a:	3301      	adds	r3, #1
    c94c:	443a      	add	r2, r7
    c94e:	2b07      	cmp	r3, #7
    c950:	e888 00a0 	stmia.w	r8, {r5, r7}
    c954:	9229      	str	r2, [sp, #164]	; 0xa4
    c956:	9328      	str	r3, [sp, #160]	; 0xa0
    c958:	f108 0808 	add.w	r8, r8, #8
    c95c:	f77f ae56 	ble.w	c60c <_svfprintf_r+0x1014>
    c960:	aa27      	add	r2, sp, #156	; 0x9c
    c962:	990b      	ldr	r1, [sp, #44]	; 0x2c
    c964:	980c      	ldr	r0, [sp, #48]	; 0x30
    c966:	f003 ff7d 	bl	10864 <__ssprint_r>
    c96a:	2800      	cmp	r0, #0
    c96c:	f47e af16 	bne.w	b79c <_svfprintf_r+0x1a4>
    c970:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    c972:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    c974:	46c8      	mov	r8, r9
    c976:	e649      	b.n	c60c <_svfprintf_r+0x1014>
    c978:	3330      	adds	r3, #48	; 0x30
    c97a:	2230      	movs	r2, #48	; 0x30
    c97c:	f88d 308f 	strb.w	r3, [sp, #143]	; 0x8f
    c980:	f88d 208e 	strb.w	r2, [sp, #142]	; 0x8e
    c984:	ab24      	add	r3, sp, #144	; 0x90
    c986:	e708      	b.n	c79a <_svfprintf_r+0x11a2>
    c988:	9b25      	ldr	r3, [sp, #148]	; 0x94
    c98a:	e5c1      	b.n	c510 <_svfprintf_r+0xf18>
    c98c:	9b12      	ldr	r3, [sp, #72]	; 0x48
    c98e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    c990:	4413      	add	r3, r2
    c992:	930e      	str	r3, [sp, #56]	; 0x38
    c994:	e76c      	b.n	c870 <_svfprintf_r+0x1278>
    c996:	9b12      	ldr	r3, [sp, #72]	; 0x48
    c998:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    c99a:	4413      	add	r3, r2
    c99c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    c99e:	441a      	add	r2, r3
    c9a0:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    c9a4:	920e      	str	r2, [sp, #56]	; 0x38
    c9a6:	9308      	str	r3, [sp, #32]
    c9a8:	e5d1      	b.n	c54e <_svfprintf_r+0xf56>
    c9aa:	9b15      	ldr	r3, [sp, #84]	; 0x54
    c9ac:	4e12      	ldr	r6, [pc, #72]	; (c9f8 <_svfprintf_r+0x1400>)
    c9ae:	2b00      	cmp	r3, #0
    c9b0:	bfb6      	itet	lt
    c9b2:	272d      	movlt	r7, #45	; 0x2d
    c9b4:	f89d 707f 	ldrbge.w	r7, [sp, #127]	; 0x7f
    c9b8:	f88d 707f 	strblt.w	r7, [sp, #127]	; 0x7f
    c9bc:	4b0f      	ldr	r3, [pc, #60]	; (c9fc <_svfprintf_r+0x1404>)
    c9be:	f7ff ba18 	b.w	bdf2 <_svfprintf_r+0x7fa>
    c9c2:	2200      	movs	r2, #0
    c9c4:	2300      	movs	r3, #0
    c9c6:	e9dd 011c 	ldrd	r0, r1, [sp, #112]	; 0x70
    c9ca:	f7f4 fce7 	bl	139c <__aeabi_dcmpeq>
    c9ce:	2800      	cmp	r0, #0
    c9d0:	f47f ae7a 	bne.w	c6c8 <_svfprintf_r+0x10d0>
    c9d4:	f1c5 0501 	rsb	r5, r5, #1
    c9d8:	9521      	str	r5, [sp, #132]	; 0x84
    c9da:	442c      	add	r4, r5
    c9dc:	e585      	b.n	c4ea <_svfprintf_r+0xef2>
    c9de:	9b12      	ldr	r3, [sp, #72]	; 0x48
    c9e0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    c9e2:	f1c3 0301 	rsb	r3, r3, #1
    c9e6:	441a      	add	r2, r3
    c9e8:	4613      	mov	r3, r2
    c9ea:	e7d2      	b.n	c992 <_svfprintf_r+0x139a>
    c9ec:	66666667 	.word	0x66666667
    c9f0:	00012a24 	.word	0x00012a24
    c9f4:	00012a40 	.word	0x00012a40
    c9f8:	000129f8 	.word	0x000129f8
    c9fc:	000129f4 	.word	0x000129f4
    ca00:	f01b 0301 	ands.w	r3, fp, #1
    ca04:	9312      	str	r3, [sp, #72]	; 0x48
    ca06:	f47f aed1 	bne.w	c7ac <_svfprintf_r+0x11b4>
    ca0a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    ca0c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    ca10:	9308      	str	r3, [sp, #32]
    ca12:	e59c      	b.n	c54e <_svfprintf_r+0xf56>
    ca14:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ca16:	b913      	cbnz	r3, ca1e <_svfprintf_r+0x1426>
    ca18:	f01b 0f01 	tst.w	fp, #1
    ca1c:	d002      	beq.n	ca24 <_svfprintf_r+0x142c>
    ca1e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    ca20:	3301      	adds	r3, #1
    ca22:	e7bb      	b.n	c99c <_svfprintf_r+0x13a4>
    ca24:	2301      	movs	r3, #1
    ca26:	e74d      	b.n	c8c4 <_svfprintf_r+0x12cc>
    ca28:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    ca2a:	f89a 3001 	ldrb.w	r3, [sl, #1]
    ca2e:	6828      	ldr	r0, [r5, #0]
    ca30:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
    ca34:	900a      	str	r0, [sp, #40]	; 0x28
    ca36:	4628      	mov	r0, r5
    ca38:	3004      	adds	r0, #4
    ca3a:	46a2      	mov	sl, r4
    ca3c:	900f      	str	r0, [sp, #60]	; 0x3c
    ca3e:	f7fe be33 	b.w	b6a8 <_svfprintf_r+0xb0>
    ca42:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    ca46:	f7ff b850 	b.w	baea <_svfprintf_r+0x4f2>
    ca4a:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    ca4e:	f7ff b8dc 	b.w	bc0a <_svfprintf_r+0x612>
    ca52:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    ca56:	f7ff ba05 	b.w	be64 <_svfprintf_r+0x86c>
    ca5a:	f10d 038e 	add.w	r3, sp, #142	; 0x8e
    ca5e:	e69c      	b.n	c79a <_svfprintf_r+0x11a2>
    ca60:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    ca62:	230c      	movs	r3, #12
    ca64:	6013      	str	r3, [r2, #0]
    ca66:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    ca6a:	9309      	str	r3, [sp, #36]	; 0x24
    ca6c:	f7fe be9f 	b.w	b7ae <_svfprintf_r+0x1b6>
    ca70:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    ca74:	f7ff b984 	b.w	bd80 <_svfprintf_r+0x788>
    ca78:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    ca7c:	f7ff b960 	b.w	bd40 <_svfprintf_r+0x748>
    ca80:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    ca84:	f7ff b943 	b.w	bd0e <_svfprintf_r+0x716>
    ca88:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
    ca8c:	f7ff b8fc 	b.w	bc88 <_svfprintf_r+0x690>

0000ca90 <__sprint_r.part.0>:
    ca90:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ca94:	6e4b      	ldr	r3, [r1, #100]	; 0x64
    ca96:	049c      	lsls	r4, r3, #18
    ca98:	4693      	mov	fp, r2
    ca9a:	d52f      	bpl.n	cafc <__sprint_r.part.0+0x6c>
    ca9c:	6893      	ldr	r3, [r2, #8]
    ca9e:	6812      	ldr	r2, [r2, #0]
    caa0:	b353      	cbz	r3, caf8 <__sprint_r.part.0+0x68>
    caa2:	460e      	mov	r6, r1
    caa4:	4607      	mov	r7, r0
    caa6:	f102 0908 	add.w	r9, r2, #8
    caaa:	e919 0420 	ldmdb	r9, {r5, sl}
    caae:	ea5f 089a 	movs.w	r8, sl, lsr #2
    cab2:	d017      	beq.n	cae4 <__sprint_r.part.0+0x54>
    cab4:	3d04      	subs	r5, #4
    cab6:	2400      	movs	r4, #0
    cab8:	e001      	b.n	cabe <__sprint_r.part.0+0x2e>
    caba:	45a0      	cmp	r8, r4
    cabc:	d010      	beq.n	cae0 <__sprint_r.part.0+0x50>
    cabe:	4632      	mov	r2, r6
    cac0:	f855 1f04 	ldr.w	r1, [r5, #4]!
    cac4:	4638      	mov	r0, r7
    cac6:	f003 fb05 	bl	100d4 <_fputwc_r>
    caca:	1c43      	adds	r3, r0, #1
    cacc:	f104 0401 	add.w	r4, r4, #1
    cad0:	d1f3      	bne.n	caba <__sprint_r.part.0+0x2a>
    cad2:	2300      	movs	r3, #0
    cad4:	f8cb 3008 	str.w	r3, [fp, #8]
    cad8:	f8cb 3004 	str.w	r3, [fp, #4]
    cadc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cae0:	f8db 3008 	ldr.w	r3, [fp, #8]
    cae4:	f02a 0a03 	bic.w	sl, sl, #3
    cae8:	eba3 030a 	sub.w	r3, r3, sl
    caec:	f8cb 3008 	str.w	r3, [fp, #8]
    caf0:	f109 0908 	add.w	r9, r9, #8
    caf4:	2b00      	cmp	r3, #0
    caf6:	d1d8      	bne.n	caaa <__sprint_r.part.0+0x1a>
    caf8:	2000      	movs	r0, #0
    cafa:	e7ea      	b.n	cad2 <__sprint_r.part.0+0x42>
    cafc:	f7fd ff30 	bl	a960 <__sfvwrite_r>
    cb00:	2300      	movs	r3, #0
    cb02:	f8cb 3008 	str.w	r3, [fp, #8]
    cb06:	f8cb 3004 	str.w	r3, [fp, #4]
    cb0a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cb0e:	bf00      	nop

0000cb10 <__sprint_r>:
    cb10:	6893      	ldr	r3, [r2, #8]
    cb12:	b10b      	cbz	r3, cb18 <__sprint_r+0x8>
    cb14:	f7ff bfbc 	b.w	ca90 <__sprint_r.part.0>
    cb18:	b410      	push	{r4}
    cb1a:	4618      	mov	r0, r3
    cb1c:	6053      	str	r3, [r2, #4]
    cb1e:	f85d 4b04 	ldr.w	r4, [sp], #4
    cb22:	4770      	bx	lr

0000cb24 <_vfiprintf_r>:
    cb24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cb28:	b0ad      	sub	sp, #180	; 0xb4
    cb2a:	461d      	mov	r5, r3
    cb2c:	468b      	mov	fp, r1
    cb2e:	4690      	mov	r8, r2
    cb30:	9307      	str	r3, [sp, #28]
    cb32:	9006      	str	r0, [sp, #24]
    cb34:	b118      	cbz	r0, cb3e <_vfiprintf_r+0x1a>
    cb36:	6b83      	ldr	r3, [r0, #56]	; 0x38
    cb38:	2b00      	cmp	r3, #0
    cb3a:	f000 80f3 	beq.w	cd24 <_vfiprintf_r+0x200>
    cb3e:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
    cb42:	f9bb 000c 	ldrsh.w	r0, [fp, #12]
    cb46:	07df      	lsls	r7, r3, #31
    cb48:	b281      	uxth	r1, r0
    cb4a:	d402      	bmi.n	cb52 <_vfiprintf_r+0x2e>
    cb4c:	058e      	lsls	r6, r1, #22
    cb4e:	f140 80fc 	bpl.w	cd4a <_vfiprintf_r+0x226>
    cb52:	048c      	lsls	r4, r1, #18
    cb54:	d40a      	bmi.n	cb6c <_vfiprintf_r+0x48>
    cb56:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
    cb5a:	f440 5100 	orr.w	r1, r0, #8192	; 0x2000
    cb5e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    cb62:	f8ab 100c 	strh.w	r1, [fp, #12]
    cb66:	f8cb 3064 	str.w	r3, [fp, #100]	; 0x64
    cb6a:	b289      	uxth	r1, r1
    cb6c:	0708      	lsls	r0, r1, #28
    cb6e:	f140 80b3 	bpl.w	ccd8 <_vfiprintf_r+0x1b4>
    cb72:	f8db 3010 	ldr.w	r3, [fp, #16]
    cb76:	2b00      	cmp	r3, #0
    cb78:	f000 80ae 	beq.w	ccd8 <_vfiprintf_r+0x1b4>
    cb7c:	f001 031a 	and.w	r3, r1, #26
    cb80:	2b0a      	cmp	r3, #10
    cb82:	f000 80b5 	beq.w	ccf0 <_vfiprintf_r+0x1cc>
    cb86:	2300      	movs	r3, #0
    cb88:	f10d 0970 	add.w	r9, sp, #112	; 0x70
    cb8c:	930b      	str	r3, [sp, #44]	; 0x2c
    cb8e:	9311      	str	r3, [sp, #68]	; 0x44
    cb90:	9310      	str	r3, [sp, #64]	; 0x40
    cb92:	9303      	str	r3, [sp, #12]
    cb94:	f8cd 903c 	str.w	r9, [sp, #60]	; 0x3c
    cb98:	46ca      	mov	sl, r9
    cb9a:	f8cd b010 	str.w	fp, [sp, #16]
    cb9e:	f898 3000 	ldrb.w	r3, [r8]
    cba2:	4644      	mov	r4, r8
    cba4:	b1fb      	cbz	r3, cbe6 <_vfiprintf_r+0xc2>
    cba6:	2b25      	cmp	r3, #37	; 0x25
    cba8:	d102      	bne.n	cbb0 <_vfiprintf_r+0x8c>
    cbaa:	e01c      	b.n	cbe6 <_vfiprintf_r+0xc2>
    cbac:	2b25      	cmp	r3, #37	; 0x25
    cbae:	d003      	beq.n	cbb8 <_vfiprintf_r+0x94>
    cbb0:	f814 3f01 	ldrb.w	r3, [r4, #1]!
    cbb4:	2b00      	cmp	r3, #0
    cbb6:	d1f9      	bne.n	cbac <_vfiprintf_r+0x88>
    cbb8:	eba4 0508 	sub.w	r5, r4, r8
    cbbc:	b19d      	cbz	r5, cbe6 <_vfiprintf_r+0xc2>
    cbbe:	9b10      	ldr	r3, [sp, #64]	; 0x40
    cbc0:	9a11      	ldr	r2, [sp, #68]	; 0x44
    cbc2:	f8ca 8000 	str.w	r8, [sl]
    cbc6:	3301      	adds	r3, #1
    cbc8:	442a      	add	r2, r5
    cbca:	2b07      	cmp	r3, #7
    cbcc:	f8ca 5004 	str.w	r5, [sl, #4]
    cbd0:	9211      	str	r2, [sp, #68]	; 0x44
    cbd2:	9310      	str	r3, [sp, #64]	; 0x40
    cbd4:	dd7a      	ble.n	cccc <_vfiprintf_r+0x1a8>
    cbd6:	2a00      	cmp	r2, #0
    cbd8:	f040 84b0 	bne.w	d53c <_vfiprintf_r+0xa18>
    cbdc:	9b03      	ldr	r3, [sp, #12]
    cbde:	9210      	str	r2, [sp, #64]	; 0x40
    cbe0:	442b      	add	r3, r5
    cbe2:	46ca      	mov	sl, r9
    cbe4:	9303      	str	r3, [sp, #12]
    cbe6:	7823      	ldrb	r3, [r4, #0]
    cbe8:	2b00      	cmp	r3, #0
    cbea:	f000 83e0 	beq.w	d3ae <_vfiprintf_r+0x88a>
    cbee:	2000      	movs	r0, #0
    cbf0:	f04f 0300 	mov.w	r3, #0
    cbf4:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    cbf8:	f104 0801 	add.w	r8, r4, #1
    cbfc:	7862      	ldrb	r2, [r4, #1]
    cbfe:	4605      	mov	r5, r0
    cc00:	4606      	mov	r6, r0
    cc02:	4603      	mov	r3, r0
    cc04:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    cc08:	f108 0801 	add.w	r8, r8, #1
    cc0c:	f1a2 0120 	sub.w	r1, r2, #32
    cc10:	2958      	cmp	r1, #88	; 0x58
    cc12:	f200 82de 	bhi.w	d1d2 <_vfiprintf_r+0x6ae>
    cc16:	e8df f011 	tbh	[pc, r1, lsl #1]
    cc1a:	0221      	.short	0x0221
    cc1c:	02dc02dc 	.word	0x02dc02dc
    cc20:	02dc0229 	.word	0x02dc0229
    cc24:	02dc02dc 	.word	0x02dc02dc
    cc28:	02dc02dc 	.word	0x02dc02dc
    cc2c:	028902dc 	.word	0x028902dc
    cc30:	02dc0295 	.word	0x02dc0295
    cc34:	02bd00a2 	.word	0x02bd00a2
    cc38:	019f02dc 	.word	0x019f02dc
    cc3c:	01a401a4 	.word	0x01a401a4
    cc40:	01a401a4 	.word	0x01a401a4
    cc44:	01a401a4 	.word	0x01a401a4
    cc48:	01a401a4 	.word	0x01a401a4
    cc4c:	02dc01a4 	.word	0x02dc01a4
    cc50:	02dc02dc 	.word	0x02dc02dc
    cc54:	02dc02dc 	.word	0x02dc02dc
    cc58:	02dc02dc 	.word	0x02dc02dc
    cc5c:	02dc02dc 	.word	0x02dc02dc
    cc60:	01b202dc 	.word	0x01b202dc
    cc64:	02dc02dc 	.word	0x02dc02dc
    cc68:	02dc02dc 	.word	0x02dc02dc
    cc6c:	02dc02dc 	.word	0x02dc02dc
    cc70:	02dc02dc 	.word	0x02dc02dc
    cc74:	02dc02dc 	.word	0x02dc02dc
    cc78:	02dc0197 	.word	0x02dc0197
    cc7c:	02dc02dc 	.word	0x02dc02dc
    cc80:	02dc02dc 	.word	0x02dc02dc
    cc84:	02dc019b 	.word	0x02dc019b
    cc88:	025302dc 	.word	0x025302dc
    cc8c:	02dc02dc 	.word	0x02dc02dc
    cc90:	02dc02dc 	.word	0x02dc02dc
    cc94:	02dc02dc 	.word	0x02dc02dc
    cc98:	02dc02dc 	.word	0x02dc02dc
    cc9c:	02dc02dc 	.word	0x02dc02dc
    cca0:	021b025a 	.word	0x021b025a
    cca4:	02dc02dc 	.word	0x02dc02dc
    cca8:	026e02dc 	.word	0x026e02dc
    ccac:	02dc021b 	.word	0x02dc021b
    ccb0:	027302dc 	.word	0x027302dc
    ccb4:	01f502dc 	.word	0x01f502dc
    ccb8:	02090182 	.word	0x02090182
    ccbc:	02dc02d7 	.word	0x02dc02d7
    ccc0:	02dc029a 	.word	0x02dc029a
    ccc4:	02dc00a7 	.word	0x02dc00a7
    ccc8:	022e02dc 	.word	0x022e02dc
    cccc:	f10a 0a08 	add.w	sl, sl, #8
    ccd0:	9b03      	ldr	r3, [sp, #12]
    ccd2:	442b      	add	r3, r5
    ccd4:	9303      	str	r3, [sp, #12]
    ccd6:	e786      	b.n	cbe6 <_vfiprintf_r+0xc2>
    ccd8:	4659      	mov	r1, fp
    ccda:	9806      	ldr	r0, [sp, #24]
    ccdc:	f002 f97e 	bl	efdc <__swsetup_r>
    cce0:	bb18      	cbnz	r0, cd2a <_vfiprintf_r+0x206>
    cce2:	f8bb 100c 	ldrh.w	r1, [fp, #12]
    cce6:	f001 031a 	and.w	r3, r1, #26
    ccea:	2b0a      	cmp	r3, #10
    ccec:	f47f af4b 	bne.w	cb86 <_vfiprintf_r+0x62>
    ccf0:	f9bb 300e 	ldrsh.w	r3, [fp, #14]
    ccf4:	2b00      	cmp	r3, #0
    ccf6:	f6ff af46 	blt.w	cb86 <_vfiprintf_r+0x62>
    ccfa:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
    ccfe:	07db      	lsls	r3, r3, #31
    cd00:	d405      	bmi.n	cd0e <_vfiprintf_r+0x1ea>
    cd02:	058f      	lsls	r7, r1, #22
    cd04:	d403      	bmi.n	cd0e <_vfiprintf_r+0x1ea>
    cd06:	f8db 0058 	ldr.w	r0, [fp, #88]	; 0x58
    cd0a:	f7fe f807 	bl	ad1c <__retarget_lock_release_recursive>
    cd0e:	462b      	mov	r3, r5
    cd10:	4642      	mov	r2, r8
    cd12:	4659      	mov	r1, fp
    cd14:	9806      	ldr	r0, [sp, #24]
    cd16:	f000 fd4d 	bl	d7b4 <__sbprintf>
    cd1a:	9003      	str	r0, [sp, #12]
    cd1c:	9803      	ldr	r0, [sp, #12]
    cd1e:	b02d      	add	sp, #180	; 0xb4
    cd20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cd24:	f7fd fc86 	bl	a634 <__sinit>
    cd28:	e709      	b.n	cb3e <_vfiprintf_r+0x1a>
    cd2a:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
    cd2e:	07d9      	lsls	r1, r3, #31
    cd30:	d404      	bmi.n	cd3c <_vfiprintf_r+0x218>
    cd32:	f8bb 300c 	ldrh.w	r3, [fp, #12]
    cd36:	059a      	lsls	r2, r3, #22
    cd38:	f140 84aa 	bpl.w	d690 <_vfiprintf_r+0xb6c>
    cd3c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    cd40:	9303      	str	r3, [sp, #12]
    cd42:	9803      	ldr	r0, [sp, #12]
    cd44:	b02d      	add	sp, #180	; 0xb4
    cd46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cd4a:	f8db 0058 	ldr.w	r0, [fp, #88]	; 0x58
    cd4e:	f7fd ffe3 	bl	ad18 <__retarget_lock_acquire_recursive>
    cd52:	f9bb 000c 	ldrsh.w	r0, [fp, #12]
    cd56:	b281      	uxth	r1, r0
    cd58:	e6fb      	b.n	cb52 <_vfiprintf_r+0x2e>
    cd5a:	4276      	negs	r6, r6
    cd5c:	9207      	str	r2, [sp, #28]
    cd5e:	f043 0304 	orr.w	r3, r3, #4
    cd62:	f898 2000 	ldrb.w	r2, [r8]
    cd66:	e74f      	b.n	cc08 <_vfiprintf_r+0xe4>
    cd68:	9608      	str	r6, [sp, #32]
    cd6a:	069e      	lsls	r6, r3, #26
    cd6c:	f100 8450 	bmi.w	d610 <_vfiprintf_r+0xaec>
    cd70:	9907      	ldr	r1, [sp, #28]
    cd72:	06dd      	lsls	r5, r3, #27
    cd74:	460a      	mov	r2, r1
    cd76:	f100 83ef 	bmi.w	d558 <_vfiprintf_r+0xa34>
    cd7a:	0658      	lsls	r0, r3, #25
    cd7c:	f140 83ec 	bpl.w	d558 <_vfiprintf_r+0xa34>
    cd80:	880e      	ldrh	r6, [r1, #0]
    cd82:	3104      	adds	r1, #4
    cd84:	2700      	movs	r7, #0
    cd86:	2201      	movs	r2, #1
    cd88:	9107      	str	r1, [sp, #28]
    cd8a:	f04f 0100 	mov.w	r1, #0
    cd8e:	f88d 1037 	strb.w	r1, [sp, #55]	; 0x37
    cd92:	2500      	movs	r5, #0
    cd94:	1c61      	adds	r1, r4, #1
    cd96:	f000 8116 	beq.w	cfc6 <_vfiprintf_r+0x4a2>
    cd9a:	f023 0180 	bic.w	r1, r3, #128	; 0x80
    cd9e:	9102      	str	r1, [sp, #8]
    cda0:	ea56 0107 	orrs.w	r1, r6, r7
    cda4:	f040 8114 	bne.w	cfd0 <_vfiprintf_r+0x4ac>
    cda8:	2c00      	cmp	r4, #0
    cdaa:	f040 835c 	bne.w	d466 <_vfiprintf_r+0x942>
    cdae:	2a00      	cmp	r2, #0
    cdb0:	f040 83b7 	bne.w	d522 <_vfiprintf_r+0x9fe>
    cdb4:	f013 0301 	ands.w	r3, r3, #1
    cdb8:	9305      	str	r3, [sp, #20]
    cdba:	f000 8457 	beq.w	d66c <_vfiprintf_r+0xb48>
    cdbe:	f10d 0bb0 	add.w	fp, sp, #176	; 0xb0
    cdc2:	2330      	movs	r3, #48	; 0x30
    cdc4:	f80b 3d41 	strb.w	r3, [fp, #-65]!
    cdc8:	9b05      	ldr	r3, [sp, #20]
    cdca:	42a3      	cmp	r3, r4
    cdcc:	bfb8      	it	lt
    cdce:	4623      	movlt	r3, r4
    cdd0:	9301      	str	r3, [sp, #4]
    cdd2:	b10d      	cbz	r5, cdd8 <_vfiprintf_r+0x2b4>
    cdd4:	3301      	adds	r3, #1
    cdd6:	9301      	str	r3, [sp, #4]
    cdd8:	9b02      	ldr	r3, [sp, #8]
    cdda:	f013 0302 	ands.w	r3, r3, #2
    cdde:	9309      	str	r3, [sp, #36]	; 0x24
    cde0:	d002      	beq.n	cde8 <_vfiprintf_r+0x2c4>
    cde2:	9b01      	ldr	r3, [sp, #4]
    cde4:	3302      	adds	r3, #2
    cde6:	9301      	str	r3, [sp, #4]
    cde8:	9b02      	ldr	r3, [sp, #8]
    cdea:	f013 0384 	ands.w	r3, r3, #132	; 0x84
    cdee:	930a      	str	r3, [sp, #40]	; 0x28
    cdf0:	f040 8217 	bne.w	d222 <_vfiprintf_r+0x6fe>
    cdf4:	9b08      	ldr	r3, [sp, #32]
    cdf6:	9a01      	ldr	r2, [sp, #4]
    cdf8:	1a9d      	subs	r5, r3, r2
    cdfa:	2d00      	cmp	r5, #0
    cdfc:	f340 8211 	ble.w	d222 <_vfiprintf_r+0x6fe>
    ce00:	2d10      	cmp	r5, #16
    ce02:	f340 8490 	ble.w	d726 <_vfiprintf_r+0xc02>
    ce06:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ce08:	9a11      	ldr	r2, [sp, #68]	; 0x44
    ce0a:	4ec4      	ldr	r6, [pc, #784]	; (d11c <_vfiprintf_r+0x5f8>)
    ce0c:	46d6      	mov	lr, sl
    ce0e:	2710      	movs	r7, #16
    ce10:	46a2      	mov	sl, r4
    ce12:	4619      	mov	r1, r3
    ce14:	9c06      	ldr	r4, [sp, #24]
    ce16:	e007      	b.n	ce28 <_vfiprintf_r+0x304>
    ce18:	f101 0c02 	add.w	ip, r1, #2
    ce1c:	f10e 0e08 	add.w	lr, lr, #8
    ce20:	4601      	mov	r1, r0
    ce22:	3d10      	subs	r5, #16
    ce24:	2d10      	cmp	r5, #16
    ce26:	dd11      	ble.n	ce4c <_vfiprintf_r+0x328>
    ce28:	1c48      	adds	r0, r1, #1
    ce2a:	3210      	adds	r2, #16
    ce2c:	2807      	cmp	r0, #7
    ce2e:	9211      	str	r2, [sp, #68]	; 0x44
    ce30:	e88e 00c0 	stmia.w	lr, {r6, r7}
    ce34:	9010      	str	r0, [sp, #64]	; 0x40
    ce36:	ddef      	ble.n	ce18 <_vfiprintf_r+0x2f4>
    ce38:	2a00      	cmp	r2, #0
    ce3a:	f040 81e4 	bne.w	d206 <_vfiprintf_r+0x6e2>
    ce3e:	3d10      	subs	r5, #16
    ce40:	2d10      	cmp	r5, #16
    ce42:	4611      	mov	r1, r2
    ce44:	f04f 0c01 	mov.w	ip, #1
    ce48:	46ce      	mov	lr, r9
    ce4a:	dced      	bgt.n	ce28 <_vfiprintf_r+0x304>
    ce4c:	4654      	mov	r4, sl
    ce4e:	4661      	mov	r1, ip
    ce50:	46f2      	mov	sl, lr
    ce52:	442a      	add	r2, r5
    ce54:	2907      	cmp	r1, #7
    ce56:	9211      	str	r2, [sp, #68]	; 0x44
    ce58:	f8ca 6000 	str.w	r6, [sl]
    ce5c:	f8ca 5004 	str.w	r5, [sl, #4]
    ce60:	9110      	str	r1, [sp, #64]	; 0x40
    ce62:	f300 82ec 	bgt.w	d43e <_vfiprintf_r+0x91a>
    ce66:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
    ce6a:	f10a 0a08 	add.w	sl, sl, #8
    ce6e:	1c48      	adds	r0, r1, #1
    ce70:	2d00      	cmp	r5, #0
    ce72:	f040 81de 	bne.w	d232 <_vfiprintf_r+0x70e>
    ce76:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ce78:	2b00      	cmp	r3, #0
    ce7a:	f000 81f8 	beq.w	d26e <_vfiprintf_r+0x74a>
    ce7e:	3202      	adds	r2, #2
    ce80:	a90e      	add	r1, sp, #56	; 0x38
    ce82:	2302      	movs	r3, #2
    ce84:	2807      	cmp	r0, #7
    ce86:	9211      	str	r2, [sp, #68]	; 0x44
    ce88:	9010      	str	r0, [sp, #64]	; 0x40
    ce8a:	e88a 000a 	stmia.w	sl, {r1, r3}
    ce8e:	f340 81ea 	ble.w	d266 <_vfiprintf_r+0x742>
    ce92:	2a00      	cmp	r2, #0
    ce94:	f040 838c 	bne.w	d5b0 <_vfiprintf_r+0xa8c>
    ce98:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ce9a:	2b80      	cmp	r3, #128	; 0x80
    ce9c:	f04f 0001 	mov.w	r0, #1
    cea0:	4611      	mov	r1, r2
    cea2:	46ca      	mov	sl, r9
    cea4:	f040 81e7 	bne.w	d276 <_vfiprintf_r+0x752>
    cea8:	9b08      	ldr	r3, [sp, #32]
    ceaa:	9d01      	ldr	r5, [sp, #4]
    ceac:	1b5e      	subs	r6, r3, r5
    ceae:	2e00      	cmp	r6, #0
    ceb0:	f340 81e1 	ble.w	d276 <_vfiprintf_r+0x752>
    ceb4:	2e10      	cmp	r6, #16
    ceb6:	4d9a      	ldr	r5, [pc, #616]	; (d120 <_vfiprintf_r+0x5fc>)
    ceb8:	f340 8450 	ble.w	d75c <_vfiprintf_r+0xc38>
    cebc:	46d4      	mov	ip, sl
    cebe:	2710      	movs	r7, #16
    cec0:	46a2      	mov	sl, r4
    cec2:	9c06      	ldr	r4, [sp, #24]
    cec4:	e007      	b.n	ced6 <_vfiprintf_r+0x3b2>
    cec6:	f101 0e02 	add.w	lr, r1, #2
    ceca:	f10c 0c08 	add.w	ip, ip, #8
    cece:	4601      	mov	r1, r0
    ced0:	3e10      	subs	r6, #16
    ced2:	2e10      	cmp	r6, #16
    ced4:	dd11      	ble.n	cefa <_vfiprintf_r+0x3d6>
    ced6:	1c48      	adds	r0, r1, #1
    ced8:	3210      	adds	r2, #16
    ceda:	2807      	cmp	r0, #7
    cedc:	9211      	str	r2, [sp, #68]	; 0x44
    cede:	e88c 00a0 	stmia.w	ip, {r5, r7}
    cee2:	9010      	str	r0, [sp, #64]	; 0x40
    cee4:	ddef      	ble.n	cec6 <_vfiprintf_r+0x3a2>
    cee6:	2a00      	cmp	r2, #0
    cee8:	f040 829d 	bne.w	d426 <_vfiprintf_r+0x902>
    ceec:	3e10      	subs	r6, #16
    ceee:	2e10      	cmp	r6, #16
    cef0:	f04f 0e01 	mov.w	lr, #1
    cef4:	4611      	mov	r1, r2
    cef6:	46cc      	mov	ip, r9
    cef8:	dced      	bgt.n	ced6 <_vfiprintf_r+0x3b2>
    cefa:	4654      	mov	r4, sl
    cefc:	46e2      	mov	sl, ip
    cefe:	4432      	add	r2, r6
    cf00:	f1be 0f07 	cmp.w	lr, #7
    cf04:	9211      	str	r2, [sp, #68]	; 0x44
    cf06:	e88a 0060 	stmia.w	sl, {r5, r6}
    cf0a:	f8cd e040 	str.w	lr, [sp, #64]	; 0x40
    cf0e:	f300 8369 	bgt.w	d5e4 <_vfiprintf_r+0xac0>
    cf12:	f10a 0a08 	add.w	sl, sl, #8
    cf16:	f10e 0001 	add.w	r0, lr, #1
    cf1a:	4671      	mov	r1, lr
    cf1c:	e1ab      	b.n	d276 <_vfiprintf_r+0x752>
    cf1e:	9608      	str	r6, [sp, #32]
    cf20:	f013 0220 	ands.w	r2, r3, #32
    cf24:	f040 838c 	bne.w	d640 <_vfiprintf_r+0xb1c>
    cf28:	f013 0110 	ands.w	r1, r3, #16
    cf2c:	f040 831a 	bne.w	d564 <_vfiprintf_r+0xa40>
    cf30:	f013 0240 	ands.w	r2, r3, #64	; 0x40
    cf34:	f000 8316 	beq.w	d564 <_vfiprintf_r+0xa40>
    cf38:	9807      	ldr	r0, [sp, #28]
    cf3a:	460a      	mov	r2, r1
    cf3c:	4601      	mov	r1, r0
    cf3e:	3104      	adds	r1, #4
    cf40:	8806      	ldrh	r6, [r0, #0]
    cf42:	9107      	str	r1, [sp, #28]
    cf44:	2700      	movs	r7, #0
    cf46:	e720      	b.n	cd8a <_vfiprintf_r+0x266>
    cf48:	9608      	str	r6, [sp, #32]
    cf4a:	f043 0310 	orr.w	r3, r3, #16
    cf4e:	e7e7      	b.n	cf20 <_vfiprintf_r+0x3fc>
    cf50:	9608      	str	r6, [sp, #32]
    cf52:	f043 0310 	orr.w	r3, r3, #16
    cf56:	e708      	b.n	cd6a <_vfiprintf_r+0x246>
    cf58:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    cf5c:	f898 2000 	ldrb.w	r2, [r8]
    cf60:	e652      	b.n	cc08 <_vfiprintf_r+0xe4>
    cf62:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
    cf66:	2600      	movs	r6, #0
    cf68:	f818 2b01 	ldrb.w	r2, [r8], #1
    cf6c:	eb06 0686 	add.w	r6, r6, r6, lsl #2
    cf70:	eb01 0646 	add.w	r6, r1, r6, lsl #1
    cf74:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
    cf78:	2909      	cmp	r1, #9
    cf7a:	d9f5      	bls.n	cf68 <_vfiprintf_r+0x444>
    cf7c:	e646      	b.n	cc0c <_vfiprintf_r+0xe8>
    cf7e:	9608      	str	r6, [sp, #32]
    cf80:	2800      	cmp	r0, #0
    cf82:	f040 8408 	bne.w	d796 <_vfiprintf_r+0xc72>
    cf86:	f043 0310 	orr.w	r3, r3, #16
    cf8a:	069e      	lsls	r6, r3, #26
    cf8c:	f100 834c 	bmi.w	d628 <_vfiprintf_r+0xb04>
    cf90:	06dd      	lsls	r5, r3, #27
    cf92:	f100 82f3 	bmi.w	d57c <_vfiprintf_r+0xa58>
    cf96:	0658      	lsls	r0, r3, #25
    cf98:	f140 82f0 	bpl.w	d57c <_vfiprintf_r+0xa58>
    cf9c:	9d07      	ldr	r5, [sp, #28]
    cf9e:	f9b5 6000 	ldrsh.w	r6, [r5]
    cfa2:	462a      	mov	r2, r5
    cfa4:	17f7      	asrs	r7, r6, #31
    cfa6:	3204      	adds	r2, #4
    cfa8:	4630      	mov	r0, r6
    cfaa:	4639      	mov	r1, r7
    cfac:	9207      	str	r2, [sp, #28]
    cfae:	2800      	cmp	r0, #0
    cfb0:	f171 0200 	sbcs.w	r2, r1, #0
    cfb4:	f2c0 835d 	blt.w	d672 <_vfiprintf_r+0xb4e>
    cfb8:	1c61      	adds	r1, r4, #1
    cfba:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
    cfbe:	f04f 0201 	mov.w	r2, #1
    cfc2:	f47f aeea 	bne.w	cd9a <_vfiprintf_r+0x276>
    cfc6:	ea56 0107 	orrs.w	r1, r6, r7
    cfca:	f000 824d 	beq.w	d468 <_vfiprintf_r+0x944>
    cfce:	9302      	str	r3, [sp, #8]
    cfd0:	2a01      	cmp	r2, #1
    cfd2:	f000 828c 	beq.w	d4ee <_vfiprintf_r+0x9ca>
    cfd6:	2a02      	cmp	r2, #2
    cfd8:	f040 825c 	bne.w	d494 <_vfiprintf_r+0x970>
    cfdc:	980b      	ldr	r0, [sp, #44]	; 0x2c
    cfde:	46cb      	mov	fp, r9
    cfe0:	0933      	lsrs	r3, r6, #4
    cfe2:	f006 010f 	and.w	r1, r6, #15
    cfe6:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
    cfea:	093a      	lsrs	r2, r7, #4
    cfec:	461e      	mov	r6, r3
    cfee:	4617      	mov	r7, r2
    cff0:	5c43      	ldrb	r3, [r0, r1]
    cff2:	f80b 3d01 	strb.w	r3, [fp, #-1]!
    cff6:	ea56 0307 	orrs.w	r3, r6, r7
    cffa:	d1f1      	bne.n	cfe0 <_vfiprintf_r+0x4bc>
    cffc:	eba9 030b 	sub.w	r3, r9, fp
    d000:	9305      	str	r3, [sp, #20]
    d002:	e6e1      	b.n	cdc8 <_vfiprintf_r+0x2a4>
    d004:	2800      	cmp	r0, #0
    d006:	f040 83c0 	bne.w	d78a <_vfiprintf_r+0xc66>
    d00a:	0699      	lsls	r1, r3, #26
    d00c:	f100 8367 	bmi.w	d6de <_vfiprintf_r+0xbba>
    d010:	06da      	lsls	r2, r3, #27
    d012:	f100 80f1 	bmi.w	d1f8 <_vfiprintf_r+0x6d4>
    d016:	065b      	lsls	r3, r3, #25
    d018:	f140 80ee 	bpl.w	d1f8 <_vfiprintf_r+0x6d4>
    d01c:	9a07      	ldr	r2, [sp, #28]
    d01e:	6813      	ldr	r3, [r2, #0]
    d020:	3204      	adds	r2, #4
    d022:	9207      	str	r2, [sp, #28]
    d024:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    d028:	801a      	strh	r2, [r3, #0]
    d02a:	e5b8      	b.n	cb9e <_vfiprintf_r+0x7a>
    d02c:	9807      	ldr	r0, [sp, #28]
    d02e:	4a3d      	ldr	r2, [pc, #244]	; (d124 <_vfiprintf_r+0x600>)
    d030:	9608      	str	r6, [sp, #32]
    d032:	920b      	str	r2, [sp, #44]	; 0x2c
    d034:	6806      	ldr	r6, [r0, #0]
    d036:	2278      	movs	r2, #120	; 0x78
    d038:	2130      	movs	r1, #48	; 0x30
    d03a:	3004      	adds	r0, #4
    d03c:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
    d040:	f043 0302 	orr.w	r3, r3, #2
    d044:	9007      	str	r0, [sp, #28]
    d046:	2700      	movs	r7, #0
    d048:	f88d 1038 	strb.w	r1, [sp, #56]	; 0x38
    d04c:	2202      	movs	r2, #2
    d04e:	e69c      	b.n	cd8a <_vfiprintf_r+0x266>
    d050:	9608      	str	r6, [sp, #32]
    d052:	2800      	cmp	r0, #0
    d054:	d099      	beq.n	cf8a <_vfiprintf_r+0x466>
    d056:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
    d05a:	e796      	b.n	cf8a <_vfiprintf_r+0x466>
    d05c:	f898 2000 	ldrb.w	r2, [r8]
    d060:	2d00      	cmp	r5, #0
    d062:	f47f add1 	bne.w	cc08 <_vfiprintf_r+0xe4>
    d066:	2001      	movs	r0, #1
    d068:	2520      	movs	r5, #32
    d06a:	e5cd      	b.n	cc08 <_vfiprintf_r+0xe4>
    d06c:	f043 0301 	orr.w	r3, r3, #1
    d070:	f898 2000 	ldrb.w	r2, [r8]
    d074:	e5c8      	b.n	cc08 <_vfiprintf_r+0xe4>
    d076:	9608      	str	r6, [sp, #32]
    d078:	2800      	cmp	r0, #0
    d07a:	f040 8393 	bne.w	d7a4 <_vfiprintf_r+0xc80>
    d07e:	4929      	ldr	r1, [pc, #164]	; (d124 <_vfiprintf_r+0x600>)
    d080:	910b      	str	r1, [sp, #44]	; 0x2c
    d082:	069f      	lsls	r7, r3, #26
    d084:	f100 82e8 	bmi.w	d658 <_vfiprintf_r+0xb34>
    d088:	9807      	ldr	r0, [sp, #28]
    d08a:	06de      	lsls	r6, r3, #27
    d08c:	4601      	mov	r1, r0
    d08e:	f100 8270 	bmi.w	d572 <_vfiprintf_r+0xa4e>
    d092:	065d      	lsls	r5, r3, #25
    d094:	f140 826d 	bpl.w	d572 <_vfiprintf_r+0xa4e>
    d098:	3104      	adds	r1, #4
    d09a:	8806      	ldrh	r6, [r0, #0]
    d09c:	9107      	str	r1, [sp, #28]
    d09e:	2700      	movs	r7, #0
    d0a0:	07d8      	lsls	r0, r3, #31
    d0a2:	f140 8222 	bpl.w	d4ea <_vfiprintf_r+0x9c6>
    d0a6:	ea56 0107 	orrs.w	r1, r6, r7
    d0aa:	f000 821e 	beq.w	d4ea <_vfiprintf_r+0x9c6>
    d0ae:	2130      	movs	r1, #48	; 0x30
    d0b0:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
    d0b4:	f043 0302 	orr.w	r3, r3, #2
    d0b8:	f88d 1038 	strb.w	r1, [sp, #56]	; 0x38
    d0bc:	2202      	movs	r2, #2
    d0be:	e664      	b.n	cd8a <_vfiprintf_r+0x266>
    d0c0:	9608      	str	r6, [sp, #32]
    d0c2:	2800      	cmp	r0, #0
    d0c4:	f040 836b 	bne.w	d79e <_vfiprintf_r+0xc7a>
    d0c8:	4917      	ldr	r1, [pc, #92]	; (d128 <_vfiprintf_r+0x604>)
    d0ca:	910b      	str	r1, [sp, #44]	; 0x2c
    d0cc:	e7d9      	b.n	d082 <_vfiprintf_r+0x55e>
    d0ce:	9907      	ldr	r1, [sp, #28]
    d0d0:	9608      	str	r6, [sp, #32]
    d0d2:	680a      	ldr	r2, [r1, #0]
    d0d4:	f88d 2048 	strb.w	r2, [sp, #72]	; 0x48
    d0d8:	f04f 0000 	mov.w	r0, #0
    d0dc:	460a      	mov	r2, r1
    d0de:	f88d 0037 	strb.w	r0, [sp, #55]	; 0x37
    d0e2:	3204      	adds	r2, #4
    d0e4:	2001      	movs	r0, #1
    d0e6:	9001      	str	r0, [sp, #4]
    d0e8:	9207      	str	r2, [sp, #28]
    d0ea:	9005      	str	r0, [sp, #20]
    d0ec:	f10d 0b48 	add.w	fp, sp, #72	; 0x48
    d0f0:	9302      	str	r3, [sp, #8]
    d0f2:	2400      	movs	r4, #0
    d0f4:	e670      	b.n	cdd8 <_vfiprintf_r+0x2b4>
    d0f6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d0fa:	f898 2000 	ldrb.w	r2, [r8]
    d0fe:	e583      	b.n	cc08 <_vfiprintf_r+0xe4>
    d100:	f898 2000 	ldrb.w	r2, [r8]
    d104:	2a6c      	cmp	r2, #108	; 0x6c
    d106:	bf03      	ittte	eq
    d108:	f898 2001 	ldrbeq.w	r2, [r8, #1]
    d10c:	f043 0320 	orreq.w	r3, r3, #32
    d110:	f108 0801 	addeq.w	r8, r8, #1
    d114:	f043 0310 	orrne.w	r3, r3, #16
    d118:	e576      	b.n	cc08 <_vfiprintf_r+0xe4>
    d11a:	bf00      	nop
    d11c:	00012a50 	.word	0x00012a50
    d120:	00012a60 	.word	0x00012a60
    d124:	00012a10 	.word	0x00012a10
    d128:	000129fc 	.word	0x000129fc
    d12c:	9907      	ldr	r1, [sp, #28]
    d12e:	680e      	ldr	r6, [r1, #0]
    d130:	460a      	mov	r2, r1
    d132:	2e00      	cmp	r6, #0
    d134:	f102 0204 	add.w	r2, r2, #4
    d138:	f6ff ae0f 	blt.w	cd5a <_vfiprintf_r+0x236>
    d13c:	9207      	str	r2, [sp, #28]
    d13e:	f898 2000 	ldrb.w	r2, [r8]
    d142:	e561      	b.n	cc08 <_vfiprintf_r+0xe4>
    d144:	f898 2000 	ldrb.w	r2, [r8]
    d148:	2001      	movs	r0, #1
    d14a:	252b      	movs	r5, #43	; 0x2b
    d14c:	e55c      	b.n	cc08 <_vfiprintf_r+0xe4>
    d14e:	9907      	ldr	r1, [sp, #28]
    d150:	9608      	str	r6, [sp, #32]
    d152:	f8d1 b000 	ldr.w	fp, [r1]
    d156:	f04f 0200 	mov.w	r2, #0
    d15a:	f88d 2037 	strb.w	r2, [sp, #55]	; 0x37
    d15e:	1d0e      	adds	r6, r1, #4
    d160:	f1bb 0f00 	cmp.w	fp, #0
    d164:	f000 82e5 	beq.w	d732 <_vfiprintf_r+0xc0e>
    d168:	1c67      	adds	r7, r4, #1
    d16a:	f000 82c4 	beq.w	d6f6 <_vfiprintf_r+0xbd2>
    d16e:	4622      	mov	r2, r4
    d170:	2100      	movs	r1, #0
    d172:	4658      	mov	r0, fp
    d174:	9301      	str	r3, [sp, #4]
    d176:	f7f3 fb83 	bl	880 <memchr>
    d17a:	9b01      	ldr	r3, [sp, #4]
    d17c:	2800      	cmp	r0, #0
    d17e:	f000 82e5 	beq.w	d74c <_vfiprintf_r+0xc28>
    d182:	eba0 020b 	sub.w	r2, r0, fp
    d186:	9205      	str	r2, [sp, #20]
    d188:	9607      	str	r6, [sp, #28]
    d18a:	9302      	str	r3, [sp, #8]
    d18c:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
    d190:	2400      	movs	r4, #0
    d192:	e619      	b.n	cdc8 <_vfiprintf_r+0x2a4>
    d194:	f898 2000 	ldrb.w	r2, [r8]
    d198:	2a2a      	cmp	r2, #42	; 0x2a
    d19a:	f108 0701 	add.w	r7, r8, #1
    d19e:	f000 82e9 	beq.w	d774 <_vfiprintf_r+0xc50>
    d1a2:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
    d1a6:	2909      	cmp	r1, #9
    d1a8:	46b8      	mov	r8, r7
    d1aa:	f04f 0400 	mov.w	r4, #0
    d1ae:	f63f ad2d 	bhi.w	cc0c <_vfiprintf_r+0xe8>
    d1b2:	f818 2b01 	ldrb.w	r2, [r8], #1
    d1b6:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    d1ba:	eb01 0444 	add.w	r4, r1, r4, lsl #1
    d1be:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
    d1c2:	2909      	cmp	r1, #9
    d1c4:	d9f5      	bls.n	d1b2 <_vfiprintf_r+0x68e>
    d1c6:	e521      	b.n	cc0c <_vfiprintf_r+0xe8>
    d1c8:	f043 0320 	orr.w	r3, r3, #32
    d1cc:	f898 2000 	ldrb.w	r2, [r8]
    d1d0:	e51a      	b.n	cc08 <_vfiprintf_r+0xe4>
    d1d2:	9608      	str	r6, [sp, #32]
    d1d4:	2800      	cmp	r0, #0
    d1d6:	f040 82db 	bne.w	d790 <_vfiprintf_r+0xc6c>
    d1da:	2a00      	cmp	r2, #0
    d1dc:	f000 80e7 	beq.w	d3ae <_vfiprintf_r+0x88a>
    d1e0:	2101      	movs	r1, #1
    d1e2:	f88d 2048 	strb.w	r2, [sp, #72]	; 0x48
    d1e6:	f04f 0200 	mov.w	r2, #0
    d1ea:	9101      	str	r1, [sp, #4]
    d1ec:	f88d 2037 	strb.w	r2, [sp, #55]	; 0x37
    d1f0:	9105      	str	r1, [sp, #20]
    d1f2:	f10d 0b48 	add.w	fp, sp, #72	; 0x48
    d1f6:	e77b      	b.n	d0f0 <_vfiprintf_r+0x5cc>
    d1f8:	9a07      	ldr	r2, [sp, #28]
    d1fa:	6813      	ldr	r3, [r2, #0]
    d1fc:	3204      	adds	r2, #4
    d1fe:	9207      	str	r2, [sp, #28]
    d200:	9a03      	ldr	r2, [sp, #12]
    d202:	601a      	str	r2, [r3, #0]
    d204:	e4cb      	b.n	cb9e <_vfiprintf_r+0x7a>
    d206:	aa0f      	add	r2, sp, #60	; 0x3c
    d208:	9904      	ldr	r1, [sp, #16]
    d20a:	4620      	mov	r0, r4
    d20c:	f7ff fc40 	bl	ca90 <__sprint_r.part.0>
    d210:	2800      	cmp	r0, #0
    d212:	f040 8139 	bne.w	d488 <_vfiprintf_r+0x964>
    d216:	9910      	ldr	r1, [sp, #64]	; 0x40
    d218:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d21a:	f101 0c01 	add.w	ip, r1, #1
    d21e:	46ce      	mov	lr, r9
    d220:	e5ff      	b.n	ce22 <_vfiprintf_r+0x2fe>
    d222:	9910      	ldr	r1, [sp, #64]	; 0x40
    d224:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d226:	1c48      	adds	r0, r1, #1
    d228:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
    d22c:	2d00      	cmp	r5, #0
    d22e:	f43f ae22 	beq.w	ce76 <_vfiprintf_r+0x352>
    d232:	3201      	adds	r2, #1
    d234:	f10d 0537 	add.w	r5, sp, #55	; 0x37
    d238:	2101      	movs	r1, #1
    d23a:	2807      	cmp	r0, #7
    d23c:	9211      	str	r2, [sp, #68]	; 0x44
    d23e:	9010      	str	r0, [sp, #64]	; 0x40
    d240:	f8ca 5000 	str.w	r5, [sl]
    d244:	f8ca 1004 	str.w	r1, [sl, #4]
    d248:	f340 8108 	ble.w	d45c <_vfiprintf_r+0x938>
    d24c:	2a00      	cmp	r2, #0
    d24e:	f040 81bc 	bne.w	d5ca <_vfiprintf_r+0xaa6>
    d252:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d254:	2b00      	cmp	r3, #0
    d256:	f43f ae1f 	beq.w	ce98 <_vfiprintf_r+0x374>
    d25a:	ab0e      	add	r3, sp, #56	; 0x38
    d25c:	2202      	movs	r2, #2
    d25e:	4608      	mov	r0, r1
    d260:	931c      	str	r3, [sp, #112]	; 0x70
    d262:	921d      	str	r2, [sp, #116]	; 0x74
    d264:	46ca      	mov	sl, r9
    d266:	4601      	mov	r1, r0
    d268:	f10a 0a08 	add.w	sl, sl, #8
    d26c:	3001      	adds	r0, #1
    d26e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d270:	2b80      	cmp	r3, #128	; 0x80
    d272:	f43f ae19 	beq.w	cea8 <_vfiprintf_r+0x384>
    d276:	9b05      	ldr	r3, [sp, #20]
    d278:	1ae4      	subs	r4, r4, r3
    d27a:	2c00      	cmp	r4, #0
    d27c:	dd2e      	ble.n	d2dc <_vfiprintf_r+0x7b8>
    d27e:	2c10      	cmp	r4, #16
    d280:	4db3      	ldr	r5, [pc, #716]	; (d550 <_vfiprintf_r+0xa2c>)
    d282:	dd1e      	ble.n	d2c2 <_vfiprintf_r+0x79e>
    d284:	46d6      	mov	lr, sl
    d286:	2610      	movs	r6, #16
    d288:	9f06      	ldr	r7, [sp, #24]
    d28a:	f8dd a010 	ldr.w	sl, [sp, #16]
    d28e:	e006      	b.n	d29e <_vfiprintf_r+0x77a>
    d290:	1c88      	adds	r0, r1, #2
    d292:	f10e 0e08 	add.w	lr, lr, #8
    d296:	4619      	mov	r1, r3
    d298:	3c10      	subs	r4, #16
    d29a:	2c10      	cmp	r4, #16
    d29c:	dd10      	ble.n	d2c0 <_vfiprintf_r+0x79c>
    d29e:	1c4b      	adds	r3, r1, #1
    d2a0:	3210      	adds	r2, #16
    d2a2:	2b07      	cmp	r3, #7
    d2a4:	9211      	str	r2, [sp, #68]	; 0x44
    d2a6:	e88e 0060 	stmia.w	lr, {r5, r6}
    d2aa:	9310      	str	r3, [sp, #64]	; 0x40
    d2ac:	ddf0      	ble.n	d290 <_vfiprintf_r+0x76c>
    d2ae:	2a00      	cmp	r2, #0
    d2b0:	d165      	bne.n	d37e <_vfiprintf_r+0x85a>
    d2b2:	3c10      	subs	r4, #16
    d2b4:	2c10      	cmp	r4, #16
    d2b6:	f04f 0001 	mov.w	r0, #1
    d2ba:	4611      	mov	r1, r2
    d2bc:	46ce      	mov	lr, r9
    d2be:	dcee      	bgt.n	d29e <_vfiprintf_r+0x77a>
    d2c0:	46f2      	mov	sl, lr
    d2c2:	4422      	add	r2, r4
    d2c4:	2807      	cmp	r0, #7
    d2c6:	9211      	str	r2, [sp, #68]	; 0x44
    d2c8:	f8ca 5000 	str.w	r5, [sl]
    d2cc:	f8ca 4004 	str.w	r4, [sl, #4]
    d2d0:	9010      	str	r0, [sp, #64]	; 0x40
    d2d2:	f300 8085 	bgt.w	d3e0 <_vfiprintf_r+0x8bc>
    d2d6:	f10a 0a08 	add.w	sl, sl, #8
    d2da:	3001      	adds	r0, #1
    d2dc:	9905      	ldr	r1, [sp, #20]
    d2de:	f8ca b000 	str.w	fp, [sl]
    d2e2:	440a      	add	r2, r1
    d2e4:	2807      	cmp	r0, #7
    d2e6:	9211      	str	r2, [sp, #68]	; 0x44
    d2e8:	f8ca 1004 	str.w	r1, [sl, #4]
    d2ec:	9010      	str	r0, [sp, #64]	; 0x40
    d2ee:	f340 8082 	ble.w	d3f6 <_vfiprintf_r+0x8d2>
    d2f2:	2a00      	cmp	r2, #0
    d2f4:	f040 8118 	bne.w	d528 <_vfiprintf_r+0xa04>
    d2f8:	9b02      	ldr	r3, [sp, #8]
    d2fa:	9210      	str	r2, [sp, #64]	; 0x40
    d2fc:	0758      	lsls	r0, r3, #29
    d2fe:	d535      	bpl.n	d36c <_vfiprintf_r+0x848>
    d300:	9b08      	ldr	r3, [sp, #32]
    d302:	9901      	ldr	r1, [sp, #4]
    d304:	1a5c      	subs	r4, r3, r1
    d306:	2c00      	cmp	r4, #0
    d308:	f340 80e7 	ble.w	d4da <_vfiprintf_r+0x9b6>
    d30c:	46ca      	mov	sl, r9
    d30e:	2c10      	cmp	r4, #16
    d310:	f340 8218 	ble.w	d744 <_vfiprintf_r+0xc20>
    d314:	9910      	ldr	r1, [sp, #64]	; 0x40
    d316:	4e8f      	ldr	r6, [pc, #572]	; (d554 <_vfiprintf_r+0xa30>)
    d318:	9f06      	ldr	r7, [sp, #24]
    d31a:	f8dd b010 	ldr.w	fp, [sp, #16]
    d31e:	2510      	movs	r5, #16
    d320:	e006      	b.n	d330 <_vfiprintf_r+0x80c>
    d322:	1c88      	adds	r0, r1, #2
    d324:	f10a 0a08 	add.w	sl, sl, #8
    d328:	4619      	mov	r1, r3
    d32a:	3c10      	subs	r4, #16
    d32c:	2c10      	cmp	r4, #16
    d32e:	dd11      	ble.n	d354 <_vfiprintf_r+0x830>
    d330:	1c4b      	adds	r3, r1, #1
    d332:	3210      	adds	r2, #16
    d334:	2b07      	cmp	r3, #7
    d336:	9211      	str	r2, [sp, #68]	; 0x44
    d338:	f8ca 6000 	str.w	r6, [sl]
    d33c:	f8ca 5004 	str.w	r5, [sl, #4]
    d340:	9310      	str	r3, [sp, #64]	; 0x40
    d342:	ddee      	ble.n	d322 <_vfiprintf_r+0x7fe>
    d344:	bb42      	cbnz	r2, d398 <_vfiprintf_r+0x874>
    d346:	3c10      	subs	r4, #16
    d348:	2c10      	cmp	r4, #16
    d34a:	f04f 0001 	mov.w	r0, #1
    d34e:	4611      	mov	r1, r2
    d350:	46ca      	mov	sl, r9
    d352:	dced      	bgt.n	d330 <_vfiprintf_r+0x80c>
    d354:	4422      	add	r2, r4
    d356:	2807      	cmp	r0, #7
    d358:	9211      	str	r2, [sp, #68]	; 0x44
    d35a:	f8ca 6000 	str.w	r6, [sl]
    d35e:	f8ca 4004 	str.w	r4, [sl, #4]
    d362:	9010      	str	r0, [sp, #64]	; 0x40
    d364:	dd51      	ble.n	d40a <_vfiprintf_r+0x8e6>
    d366:	2a00      	cmp	r2, #0
    d368:	f040 819b 	bne.w	d6a2 <_vfiprintf_r+0xb7e>
    d36c:	9b03      	ldr	r3, [sp, #12]
    d36e:	9a08      	ldr	r2, [sp, #32]
    d370:	9901      	ldr	r1, [sp, #4]
    d372:	428a      	cmp	r2, r1
    d374:	bfac      	ite	ge
    d376:	189b      	addge	r3, r3, r2
    d378:	185b      	addlt	r3, r3, r1
    d37a:	9303      	str	r3, [sp, #12]
    d37c:	e04e      	b.n	d41c <_vfiprintf_r+0x8f8>
    d37e:	aa0f      	add	r2, sp, #60	; 0x3c
    d380:	4651      	mov	r1, sl
    d382:	4638      	mov	r0, r7
    d384:	f7ff fb84 	bl	ca90 <__sprint_r.part.0>
    d388:	2800      	cmp	r0, #0
    d38a:	f040 813f 	bne.w	d60c <_vfiprintf_r+0xae8>
    d38e:	9910      	ldr	r1, [sp, #64]	; 0x40
    d390:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d392:	1c48      	adds	r0, r1, #1
    d394:	46ce      	mov	lr, r9
    d396:	e77f      	b.n	d298 <_vfiprintf_r+0x774>
    d398:	aa0f      	add	r2, sp, #60	; 0x3c
    d39a:	4659      	mov	r1, fp
    d39c:	4638      	mov	r0, r7
    d39e:	f7ff fb77 	bl	ca90 <__sprint_r.part.0>
    d3a2:	b960      	cbnz	r0, d3be <_vfiprintf_r+0x89a>
    d3a4:	9910      	ldr	r1, [sp, #64]	; 0x40
    d3a6:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d3a8:	1c48      	adds	r0, r1, #1
    d3aa:	46ca      	mov	sl, r9
    d3ac:	e7bd      	b.n	d32a <_vfiprintf_r+0x806>
    d3ae:	9b11      	ldr	r3, [sp, #68]	; 0x44
    d3b0:	f8dd b010 	ldr.w	fp, [sp, #16]
    d3b4:	2b00      	cmp	r3, #0
    d3b6:	f040 81d4 	bne.w	d762 <_vfiprintf_r+0xc3e>
    d3ba:	2300      	movs	r3, #0
    d3bc:	9310      	str	r3, [sp, #64]	; 0x40
    d3be:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
    d3c2:	f013 0f01 	tst.w	r3, #1
    d3c6:	f8bb 300c 	ldrh.w	r3, [fp, #12]
    d3ca:	d102      	bne.n	d3d2 <_vfiprintf_r+0x8ae>
    d3cc:	059a      	lsls	r2, r3, #22
    d3ce:	f140 80de 	bpl.w	d58e <_vfiprintf_r+0xa6a>
    d3d2:	065b      	lsls	r3, r3, #25
    d3d4:	f53f acb2 	bmi.w	cd3c <_vfiprintf_r+0x218>
    d3d8:	9803      	ldr	r0, [sp, #12]
    d3da:	b02d      	add	sp, #180	; 0xb4
    d3dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d3e0:	2a00      	cmp	r2, #0
    d3e2:	f040 8106 	bne.w	d5f2 <_vfiprintf_r+0xace>
    d3e6:	9a05      	ldr	r2, [sp, #20]
    d3e8:	921d      	str	r2, [sp, #116]	; 0x74
    d3ea:	2301      	movs	r3, #1
    d3ec:	9211      	str	r2, [sp, #68]	; 0x44
    d3ee:	f8cd b070 	str.w	fp, [sp, #112]	; 0x70
    d3f2:	9310      	str	r3, [sp, #64]	; 0x40
    d3f4:	46ca      	mov	sl, r9
    d3f6:	f10a 0a08 	add.w	sl, sl, #8
    d3fa:	9b02      	ldr	r3, [sp, #8]
    d3fc:	0759      	lsls	r1, r3, #29
    d3fe:	d504      	bpl.n	d40a <_vfiprintf_r+0x8e6>
    d400:	9b08      	ldr	r3, [sp, #32]
    d402:	9901      	ldr	r1, [sp, #4]
    d404:	1a5c      	subs	r4, r3, r1
    d406:	2c00      	cmp	r4, #0
    d408:	dc81      	bgt.n	d30e <_vfiprintf_r+0x7ea>
    d40a:	9b03      	ldr	r3, [sp, #12]
    d40c:	9908      	ldr	r1, [sp, #32]
    d40e:	9801      	ldr	r0, [sp, #4]
    d410:	4281      	cmp	r1, r0
    d412:	bfac      	ite	ge
    d414:	185b      	addge	r3, r3, r1
    d416:	181b      	addlt	r3, r3, r0
    d418:	9303      	str	r3, [sp, #12]
    d41a:	bb72      	cbnz	r2, d47a <_vfiprintf_r+0x956>
    d41c:	2300      	movs	r3, #0
    d41e:	9310      	str	r3, [sp, #64]	; 0x40
    d420:	46ca      	mov	sl, r9
    d422:	f7ff bbbc 	b.w	cb9e <_vfiprintf_r+0x7a>
    d426:	aa0f      	add	r2, sp, #60	; 0x3c
    d428:	9904      	ldr	r1, [sp, #16]
    d42a:	4620      	mov	r0, r4
    d42c:	f7ff fb30 	bl	ca90 <__sprint_r.part.0>
    d430:	bb50      	cbnz	r0, d488 <_vfiprintf_r+0x964>
    d432:	9910      	ldr	r1, [sp, #64]	; 0x40
    d434:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d436:	f101 0e01 	add.w	lr, r1, #1
    d43a:	46cc      	mov	ip, r9
    d43c:	e548      	b.n	ced0 <_vfiprintf_r+0x3ac>
    d43e:	2a00      	cmp	r2, #0
    d440:	f040 8140 	bne.w	d6c4 <_vfiprintf_r+0xba0>
    d444:	f89d 1037 	ldrb.w	r1, [sp, #55]	; 0x37
    d448:	2900      	cmp	r1, #0
    d44a:	f000 811b 	beq.w	d684 <_vfiprintf_r+0xb60>
    d44e:	2201      	movs	r2, #1
    d450:	f10d 0137 	add.w	r1, sp, #55	; 0x37
    d454:	4610      	mov	r0, r2
    d456:	921d      	str	r2, [sp, #116]	; 0x74
    d458:	911c      	str	r1, [sp, #112]	; 0x70
    d45a:	46ca      	mov	sl, r9
    d45c:	4601      	mov	r1, r0
    d45e:	f10a 0a08 	add.w	sl, sl, #8
    d462:	3001      	adds	r0, #1
    d464:	e507      	b.n	ce76 <_vfiprintf_r+0x352>
    d466:	9b02      	ldr	r3, [sp, #8]
    d468:	2a01      	cmp	r2, #1
    d46a:	f000 8098 	beq.w	d59e <_vfiprintf_r+0xa7a>
    d46e:	2a02      	cmp	r2, #2
    d470:	d10d      	bne.n	d48e <_vfiprintf_r+0x96a>
    d472:	9302      	str	r3, [sp, #8]
    d474:	2600      	movs	r6, #0
    d476:	2700      	movs	r7, #0
    d478:	e5b0      	b.n	cfdc <_vfiprintf_r+0x4b8>
    d47a:	aa0f      	add	r2, sp, #60	; 0x3c
    d47c:	9904      	ldr	r1, [sp, #16]
    d47e:	9806      	ldr	r0, [sp, #24]
    d480:	f7ff fb06 	bl	ca90 <__sprint_r.part.0>
    d484:	2800      	cmp	r0, #0
    d486:	d0c9      	beq.n	d41c <_vfiprintf_r+0x8f8>
    d488:	f8dd b010 	ldr.w	fp, [sp, #16]
    d48c:	e797      	b.n	d3be <_vfiprintf_r+0x89a>
    d48e:	9302      	str	r3, [sp, #8]
    d490:	2600      	movs	r6, #0
    d492:	2700      	movs	r7, #0
    d494:	4649      	mov	r1, r9
    d496:	e000      	b.n	d49a <_vfiprintf_r+0x976>
    d498:	4659      	mov	r1, fp
    d49a:	08f2      	lsrs	r2, r6, #3
    d49c:	ea42 7247 	orr.w	r2, r2, r7, lsl #29
    d4a0:	08f8      	lsrs	r0, r7, #3
    d4a2:	f006 0307 	and.w	r3, r6, #7
    d4a6:	4607      	mov	r7, r0
    d4a8:	4616      	mov	r6, r2
    d4aa:	3330      	adds	r3, #48	; 0x30
    d4ac:	ea56 0207 	orrs.w	r2, r6, r7
    d4b0:	f801 3c01 	strb.w	r3, [r1, #-1]
    d4b4:	f101 3bff 	add.w	fp, r1, #4294967295	; 0xffffffff
    d4b8:	d1ee      	bne.n	d498 <_vfiprintf_r+0x974>
    d4ba:	9a02      	ldr	r2, [sp, #8]
    d4bc:	07d6      	lsls	r6, r2, #31
    d4be:	f57f ad9d 	bpl.w	cffc <_vfiprintf_r+0x4d8>
    d4c2:	2b30      	cmp	r3, #48	; 0x30
    d4c4:	f43f ad9a 	beq.w	cffc <_vfiprintf_r+0x4d8>
    d4c8:	3902      	subs	r1, #2
    d4ca:	2330      	movs	r3, #48	; 0x30
    d4cc:	f80b 3c01 	strb.w	r3, [fp, #-1]
    d4d0:	eba9 0301 	sub.w	r3, r9, r1
    d4d4:	9305      	str	r3, [sp, #20]
    d4d6:	468b      	mov	fp, r1
    d4d8:	e476      	b.n	cdc8 <_vfiprintf_r+0x2a4>
    d4da:	9b03      	ldr	r3, [sp, #12]
    d4dc:	9a08      	ldr	r2, [sp, #32]
    d4de:	428a      	cmp	r2, r1
    d4e0:	bfac      	ite	ge
    d4e2:	189b      	addge	r3, r3, r2
    d4e4:	185b      	addlt	r3, r3, r1
    d4e6:	9303      	str	r3, [sp, #12]
    d4e8:	e798      	b.n	d41c <_vfiprintf_r+0x8f8>
    d4ea:	2202      	movs	r2, #2
    d4ec:	e44d      	b.n	cd8a <_vfiprintf_r+0x266>
    d4ee:	2f00      	cmp	r7, #0
    d4f0:	bf08      	it	eq
    d4f2:	2e0a      	cmpeq	r6, #10
    d4f4:	d352      	bcc.n	d59c <_vfiprintf_r+0xa78>
    d4f6:	46cb      	mov	fp, r9
    d4f8:	4630      	mov	r0, r6
    d4fa:	4639      	mov	r1, r7
    d4fc:	220a      	movs	r2, #10
    d4fe:	2300      	movs	r3, #0
    d500:	f7f3 ffbc 	bl	147c <__aeabi_uldivmod>
    d504:	3230      	adds	r2, #48	; 0x30
    d506:	f80b 2d01 	strb.w	r2, [fp, #-1]!
    d50a:	4630      	mov	r0, r6
    d50c:	4639      	mov	r1, r7
    d50e:	2300      	movs	r3, #0
    d510:	220a      	movs	r2, #10
    d512:	f7f3 ffb3 	bl	147c <__aeabi_uldivmod>
    d516:	4606      	mov	r6, r0
    d518:	460f      	mov	r7, r1
    d51a:	ea56 0307 	orrs.w	r3, r6, r7
    d51e:	d1eb      	bne.n	d4f8 <_vfiprintf_r+0x9d4>
    d520:	e56c      	b.n	cffc <_vfiprintf_r+0x4d8>
    d522:	9405      	str	r4, [sp, #20]
    d524:	46cb      	mov	fp, r9
    d526:	e44f      	b.n	cdc8 <_vfiprintf_r+0x2a4>
    d528:	aa0f      	add	r2, sp, #60	; 0x3c
    d52a:	9904      	ldr	r1, [sp, #16]
    d52c:	9806      	ldr	r0, [sp, #24]
    d52e:	f7ff faaf 	bl	ca90 <__sprint_r.part.0>
    d532:	2800      	cmp	r0, #0
    d534:	d1a8      	bne.n	d488 <_vfiprintf_r+0x964>
    d536:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d538:	46ca      	mov	sl, r9
    d53a:	e75e      	b.n	d3fa <_vfiprintf_r+0x8d6>
    d53c:	aa0f      	add	r2, sp, #60	; 0x3c
    d53e:	9904      	ldr	r1, [sp, #16]
    d540:	9806      	ldr	r0, [sp, #24]
    d542:	f7ff faa5 	bl	ca90 <__sprint_r.part.0>
    d546:	2800      	cmp	r0, #0
    d548:	d19e      	bne.n	d488 <_vfiprintf_r+0x964>
    d54a:	46ca      	mov	sl, r9
    d54c:	f7ff bbc0 	b.w	ccd0 <_vfiprintf_r+0x1ac>
    d550:	00012a60 	.word	0x00012a60
    d554:	00012a50 	.word	0x00012a50
    d558:	3104      	adds	r1, #4
    d55a:	6816      	ldr	r6, [r2, #0]
    d55c:	9107      	str	r1, [sp, #28]
    d55e:	2201      	movs	r2, #1
    d560:	2700      	movs	r7, #0
    d562:	e412      	b.n	cd8a <_vfiprintf_r+0x266>
    d564:	9807      	ldr	r0, [sp, #28]
    d566:	4601      	mov	r1, r0
    d568:	3104      	adds	r1, #4
    d56a:	6806      	ldr	r6, [r0, #0]
    d56c:	9107      	str	r1, [sp, #28]
    d56e:	2700      	movs	r7, #0
    d570:	e40b      	b.n	cd8a <_vfiprintf_r+0x266>
    d572:	680e      	ldr	r6, [r1, #0]
    d574:	3104      	adds	r1, #4
    d576:	9107      	str	r1, [sp, #28]
    d578:	2700      	movs	r7, #0
    d57a:	e591      	b.n	d0a0 <_vfiprintf_r+0x57c>
    d57c:	9907      	ldr	r1, [sp, #28]
    d57e:	680e      	ldr	r6, [r1, #0]
    d580:	460a      	mov	r2, r1
    d582:	17f7      	asrs	r7, r6, #31
    d584:	3204      	adds	r2, #4
    d586:	9207      	str	r2, [sp, #28]
    d588:	4630      	mov	r0, r6
    d58a:	4639      	mov	r1, r7
    d58c:	e50f      	b.n	cfae <_vfiprintf_r+0x48a>
    d58e:	f8db 0058 	ldr.w	r0, [fp, #88]	; 0x58
    d592:	f7fd fbc3 	bl	ad1c <__retarget_lock_release_recursive>
    d596:	f8bb 300c 	ldrh.w	r3, [fp, #12]
    d59a:	e71a      	b.n	d3d2 <_vfiprintf_r+0x8ae>
    d59c:	9b02      	ldr	r3, [sp, #8]
    d59e:	9302      	str	r3, [sp, #8]
    d5a0:	f10d 0bb0 	add.w	fp, sp, #176	; 0xb0
    d5a4:	3630      	adds	r6, #48	; 0x30
    d5a6:	2301      	movs	r3, #1
    d5a8:	f80b 6d41 	strb.w	r6, [fp, #-65]!
    d5ac:	9305      	str	r3, [sp, #20]
    d5ae:	e40b      	b.n	cdc8 <_vfiprintf_r+0x2a4>
    d5b0:	aa0f      	add	r2, sp, #60	; 0x3c
    d5b2:	9904      	ldr	r1, [sp, #16]
    d5b4:	9806      	ldr	r0, [sp, #24]
    d5b6:	f7ff fa6b 	bl	ca90 <__sprint_r.part.0>
    d5ba:	2800      	cmp	r0, #0
    d5bc:	f47f af64 	bne.w	d488 <_vfiprintf_r+0x964>
    d5c0:	9910      	ldr	r1, [sp, #64]	; 0x40
    d5c2:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d5c4:	1c48      	adds	r0, r1, #1
    d5c6:	46ca      	mov	sl, r9
    d5c8:	e651      	b.n	d26e <_vfiprintf_r+0x74a>
    d5ca:	aa0f      	add	r2, sp, #60	; 0x3c
    d5cc:	9904      	ldr	r1, [sp, #16]
    d5ce:	9806      	ldr	r0, [sp, #24]
    d5d0:	f7ff fa5e 	bl	ca90 <__sprint_r.part.0>
    d5d4:	2800      	cmp	r0, #0
    d5d6:	f47f af57 	bne.w	d488 <_vfiprintf_r+0x964>
    d5da:	9910      	ldr	r1, [sp, #64]	; 0x40
    d5dc:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d5de:	1c48      	adds	r0, r1, #1
    d5e0:	46ca      	mov	sl, r9
    d5e2:	e448      	b.n	ce76 <_vfiprintf_r+0x352>
    d5e4:	2a00      	cmp	r2, #0
    d5e6:	f040 8091 	bne.w	d70c <_vfiprintf_r+0xbe8>
    d5ea:	2001      	movs	r0, #1
    d5ec:	4611      	mov	r1, r2
    d5ee:	46ca      	mov	sl, r9
    d5f0:	e641      	b.n	d276 <_vfiprintf_r+0x752>
    d5f2:	aa0f      	add	r2, sp, #60	; 0x3c
    d5f4:	9904      	ldr	r1, [sp, #16]
    d5f6:	9806      	ldr	r0, [sp, #24]
    d5f8:	f7ff fa4a 	bl	ca90 <__sprint_r.part.0>
    d5fc:	2800      	cmp	r0, #0
    d5fe:	f47f af43 	bne.w	d488 <_vfiprintf_r+0x964>
    d602:	9810      	ldr	r0, [sp, #64]	; 0x40
    d604:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d606:	3001      	adds	r0, #1
    d608:	46ca      	mov	sl, r9
    d60a:	e667      	b.n	d2dc <_vfiprintf_r+0x7b8>
    d60c:	46d3      	mov	fp, sl
    d60e:	e6d6      	b.n	d3be <_vfiprintf_r+0x89a>
    d610:	9e07      	ldr	r6, [sp, #28]
    d612:	3607      	adds	r6, #7
    d614:	f026 0207 	bic.w	r2, r6, #7
    d618:	f102 0108 	add.w	r1, r2, #8
    d61c:	e9d2 6700 	ldrd	r6, r7, [r2]
    d620:	9107      	str	r1, [sp, #28]
    d622:	2201      	movs	r2, #1
    d624:	f7ff bbb1 	b.w	cd8a <_vfiprintf_r+0x266>
    d628:	9e07      	ldr	r6, [sp, #28]
    d62a:	3607      	adds	r6, #7
    d62c:	f026 0607 	bic.w	r6, r6, #7
    d630:	e9d6 0100 	ldrd	r0, r1, [r6]
    d634:	f106 0208 	add.w	r2, r6, #8
    d638:	9207      	str	r2, [sp, #28]
    d63a:	4606      	mov	r6, r0
    d63c:	460f      	mov	r7, r1
    d63e:	e4b6      	b.n	cfae <_vfiprintf_r+0x48a>
    d640:	9e07      	ldr	r6, [sp, #28]
    d642:	3607      	adds	r6, #7
    d644:	f026 0207 	bic.w	r2, r6, #7
    d648:	f102 0108 	add.w	r1, r2, #8
    d64c:	e9d2 6700 	ldrd	r6, r7, [r2]
    d650:	9107      	str	r1, [sp, #28]
    d652:	2200      	movs	r2, #0
    d654:	f7ff bb99 	b.w	cd8a <_vfiprintf_r+0x266>
    d658:	9e07      	ldr	r6, [sp, #28]
    d65a:	3607      	adds	r6, #7
    d65c:	f026 0107 	bic.w	r1, r6, #7
    d660:	f101 0008 	add.w	r0, r1, #8
    d664:	9007      	str	r0, [sp, #28]
    d666:	e9d1 6700 	ldrd	r6, r7, [r1]
    d66a:	e519      	b.n	d0a0 <_vfiprintf_r+0x57c>
    d66c:	46cb      	mov	fp, r9
    d66e:	f7ff bbab 	b.w	cdc8 <_vfiprintf_r+0x2a4>
    d672:	252d      	movs	r5, #45	; 0x2d
    d674:	4276      	negs	r6, r6
    d676:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
    d67a:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
    d67e:	2201      	movs	r2, #1
    d680:	f7ff bb88 	b.w	cd94 <_vfiprintf_r+0x270>
    d684:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d686:	b9b3      	cbnz	r3, d6b6 <_vfiprintf_r+0xb92>
    d688:	4611      	mov	r1, r2
    d68a:	2001      	movs	r0, #1
    d68c:	46ca      	mov	sl, r9
    d68e:	e5f2      	b.n	d276 <_vfiprintf_r+0x752>
    d690:	f8db 0058 	ldr.w	r0, [fp, #88]	; 0x58
    d694:	f7fd fb42 	bl	ad1c <__retarget_lock_release_recursive>
    d698:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d69c:	9303      	str	r3, [sp, #12]
    d69e:	f7ff bb50 	b.w	cd42 <_vfiprintf_r+0x21e>
    d6a2:	aa0f      	add	r2, sp, #60	; 0x3c
    d6a4:	9904      	ldr	r1, [sp, #16]
    d6a6:	9806      	ldr	r0, [sp, #24]
    d6a8:	f7ff f9f2 	bl	ca90 <__sprint_r.part.0>
    d6ac:	2800      	cmp	r0, #0
    d6ae:	f47f aeeb 	bne.w	d488 <_vfiprintf_r+0x964>
    d6b2:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d6b4:	e6a9      	b.n	d40a <_vfiprintf_r+0x8e6>
    d6b6:	ab0e      	add	r3, sp, #56	; 0x38
    d6b8:	2202      	movs	r2, #2
    d6ba:	931c      	str	r3, [sp, #112]	; 0x70
    d6bc:	921d      	str	r2, [sp, #116]	; 0x74
    d6be:	2001      	movs	r0, #1
    d6c0:	46ca      	mov	sl, r9
    d6c2:	e5d0      	b.n	d266 <_vfiprintf_r+0x742>
    d6c4:	aa0f      	add	r2, sp, #60	; 0x3c
    d6c6:	9904      	ldr	r1, [sp, #16]
    d6c8:	9806      	ldr	r0, [sp, #24]
    d6ca:	f7ff f9e1 	bl	ca90 <__sprint_r.part.0>
    d6ce:	2800      	cmp	r0, #0
    d6d0:	f47f aeda 	bne.w	d488 <_vfiprintf_r+0x964>
    d6d4:	9910      	ldr	r1, [sp, #64]	; 0x40
    d6d6:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d6d8:	1c48      	adds	r0, r1, #1
    d6da:	46ca      	mov	sl, r9
    d6dc:	e5a4      	b.n	d228 <_vfiprintf_r+0x704>
    d6de:	9a07      	ldr	r2, [sp, #28]
    d6e0:	9903      	ldr	r1, [sp, #12]
    d6e2:	6813      	ldr	r3, [r2, #0]
    d6e4:	17cd      	asrs	r5, r1, #31
    d6e6:	4608      	mov	r0, r1
    d6e8:	3204      	adds	r2, #4
    d6ea:	4629      	mov	r1, r5
    d6ec:	9207      	str	r2, [sp, #28]
    d6ee:	e9c3 0100 	strd	r0, r1, [r3]
    d6f2:	f7ff ba54 	b.w	cb9e <_vfiprintf_r+0x7a>
    d6f6:	4658      	mov	r0, fp
    d6f8:	9607      	str	r6, [sp, #28]
    d6fa:	9302      	str	r3, [sp, #8]
    d6fc:	f7f3 f9c0 	bl	a80 <strlen>
    d700:	2400      	movs	r4, #0
    d702:	9005      	str	r0, [sp, #20]
    d704:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
    d708:	f7ff bb5e 	b.w	cdc8 <_vfiprintf_r+0x2a4>
    d70c:	aa0f      	add	r2, sp, #60	; 0x3c
    d70e:	9904      	ldr	r1, [sp, #16]
    d710:	9806      	ldr	r0, [sp, #24]
    d712:	f7ff f9bd 	bl	ca90 <__sprint_r.part.0>
    d716:	2800      	cmp	r0, #0
    d718:	f47f aeb6 	bne.w	d488 <_vfiprintf_r+0x964>
    d71c:	9910      	ldr	r1, [sp, #64]	; 0x40
    d71e:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d720:	1c48      	adds	r0, r1, #1
    d722:	46ca      	mov	sl, r9
    d724:	e5a7      	b.n	d276 <_vfiprintf_r+0x752>
    d726:	9910      	ldr	r1, [sp, #64]	; 0x40
    d728:	9a11      	ldr	r2, [sp, #68]	; 0x44
    d72a:	4e20      	ldr	r6, [pc, #128]	; (d7ac <_vfiprintf_r+0xc88>)
    d72c:	3101      	adds	r1, #1
    d72e:	f7ff bb90 	b.w	ce52 <_vfiprintf_r+0x32e>
    d732:	2c06      	cmp	r4, #6
    d734:	bf28      	it	cs
    d736:	2406      	movcs	r4, #6
    d738:	9405      	str	r4, [sp, #20]
    d73a:	9607      	str	r6, [sp, #28]
    d73c:	9401      	str	r4, [sp, #4]
    d73e:	f8df b070 	ldr.w	fp, [pc, #112]	; d7b0 <_vfiprintf_r+0xc8c>
    d742:	e4d5      	b.n	d0f0 <_vfiprintf_r+0x5cc>
    d744:	9810      	ldr	r0, [sp, #64]	; 0x40
    d746:	4e19      	ldr	r6, [pc, #100]	; (d7ac <_vfiprintf_r+0xc88>)
    d748:	3001      	adds	r0, #1
    d74a:	e603      	b.n	d354 <_vfiprintf_r+0x830>
    d74c:	9405      	str	r4, [sp, #20]
    d74e:	f89d 5037 	ldrb.w	r5, [sp, #55]	; 0x37
    d752:	9607      	str	r6, [sp, #28]
    d754:	9302      	str	r3, [sp, #8]
    d756:	4604      	mov	r4, r0
    d758:	f7ff bb36 	b.w	cdc8 <_vfiprintf_r+0x2a4>
    d75c:	4686      	mov	lr, r0
    d75e:	f7ff bbce 	b.w	cefe <_vfiprintf_r+0x3da>
    d762:	9806      	ldr	r0, [sp, #24]
    d764:	aa0f      	add	r2, sp, #60	; 0x3c
    d766:	4659      	mov	r1, fp
    d768:	f7ff f992 	bl	ca90 <__sprint_r.part.0>
    d76c:	2800      	cmp	r0, #0
    d76e:	f43f ae24 	beq.w	d3ba <_vfiprintf_r+0x896>
    d772:	e624      	b.n	d3be <_vfiprintf_r+0x89a>
    d774:	9907      	ldr	r1, [sp, #28]
    d776:	f898 2001 	ldrb.w	r2, [r8, #1]
    d77a:	680c      	ldr	r4, [r1, #0]
    d77c:	3104      	adds	r1, #4
    d77e:	ea44 74e4 	orr.w	r4, r4, r4, asr #31
    d782:	46b8      	mov	r8, r7
    d784:	9107      	str	r1, [sp, #28]
    d786:	f7ff ba3f 	b.w	cc08 <_vfiprintf_r+0xe4>
    d78a:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
    d78e:	e43c      	b.n	d00a <_vfiprintf_r+0x4e6>
    d790:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
    d794:	e521      	b.n	d1da <_vfiprintf_r+0x6b6>
    d796:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
    d79a:	f7ff bbf4 	b.w	cf86 <_vfiprintf_r+0x462>
    d79e:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
    d7a2:	e491      	b.n	d0c8 <_vfiprintf_r+0x5a4>
    d7a4:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
    d7a8:	e469      	b.n	d07e <_vfiprintf_r+0x55a>
    d7aa:	bf00      	nop
    d7ac:	00012a50 	.word	0x00012a50
    d7b0:	00012a24 	.word	0x00012a24

0000d7b4 <__sbprintf>:
    d7b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    d7b8:	460c      	mov	r4, r1
    d7ba:	f5ad 6d8d 	sub.w	sp, sp, #1128	; 0x468
    d7be:	8989      	ldrh	r1, [r1, #12]
    d7c0:	6e66      	ldr	r6, [r4, #100]	; 0x64
    d7c2:	89e5      	ldrh	r5, [r4, #14]
    d7c4:	9619      	str	r6, [sp, #100]	; 0x64
    d7c6:	f021 0102 	bic.w	r1, r1, #2
    d7ca:	4606      	mov	r6, r0
    d7cc:	69e0      	ldr	r0, [r4, #28]
    d7ce:	f8ad 100c 	strh.w	r1, [sp, #12]
    d7d2:	4617      	mov	r7, r2
    d7d4:	f44f 6180 	mov.w	r1, #1024	; 0x400
    d7d8:	6a62      	ldr	r2, [r4, #36]	; 0x24
    d7da:	f8ad 500e 	strh.w	r5, [sp, #14]
    d7de:	4698      	mov	r8, r3
    d7e0:	ad1a      	add	r5, sp, #104	; 0x68
    d7e2:	2300      	movs	r3, #0
    d7e4:	9007      	str	r0, [sp, #28]
    d7e6:	a816      	add	r0, sp, #88	; 0x58
    d7e8:	9209      	str	r2, [sp, #36]	; 0x24
    d7ea:	9306      	str	r3, [sp, #24]
    d7ec:	9500      	str	r5, [sp, #0]
    d7ee:	9504      	str	r5, [sp, #16]
    d7f0:	9102      	str	r1, [sp, #8]
    d7f2:	9105      	str	r1, [sp, #20]
    d7f4:	f7fd fa8c 	bl	ad10 <__retarget_lock_init_recursive>
    d7f8:	4643      	mov	r3, r8
    d7fa:	463a      	mov	r2, r7
    d7fc:	4669      	mov	r1, sp
    d7fe:	4630      	mov	r0, r6
    d800:	f7ff f990 	bl	cb24 <_vfiprintf_r>
    d804:	1e05      	subs	r5, r0, #0
    d806:	db07      	blt.n	d818 <__sbprintf+0x64>
    d808:	4630      	mov	r0, r6
    d80a:	4669      	mov	r1, sp
    d80c:	f7fc fea8 	bl	a560 <_fflush_r>
    d810:	2800      	cmp	r0, #0
    d812:	bf18      	it	ne
    d814:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
    d818:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    d81c:	065b      	lsls	r3, r3, #25
    d81e:	d503      	bpl.n	d828 <__sbprintf+0x74>
    d820:	89a3      	ldrh	r3, [r4, #12]
    d822:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d826:	81a3      	strh	r3, [r4, #12]
    d828:	9816      	ldr	r0, [sp, #88]	; 0x58
    d82a:	f7fd fa73 	bl	ad14 <__retarget_lock_close_recursive>
    d82e:	4628      	mov	r0, r5
    d830:	f50d 6d8d 	add.w	sp, sp, #1128	; 0x468
    d834:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000d838 <_vfprintf_r>:
    d838:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d83c:	b0c3      	sub	sp, #268	; 0x10c
    d83e:	461d      	mov	r5, r3
    d840:	468a      	mov	sl, r1
    d842:	4691      	mov	r9, r2
    d844:	4604      	mov	r4, r0
    d846:	9008      	str	r0, [sp, #32]
    d848:	f002 fc8a 	bl	10160 <_localeconv_r>
    d84c:	6803      	ldr	r3, [r0, #0]
    d84e:	9315      	str	r3, [sp, #84]	; 0x54
    d850:	4618      	mov	r0, r3
    d852:	f7f3 f915 	bl	a80 <strlen>
    d856:	950e      	str	r5, [sp, #56]	; 0x38
    d858:	9014      	str	r0, [sp, #80]	; 0x50
    d85a:	b11c      	cbz	r4, d864 <_vfprintf_r+0x2c>
    d85c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    d85e:	2b00      	cmp	r3, #0
    d860:	f000 8262 	beq.w	dd28 <_vfprintf_r+0x4f0>
    d864:	f8da 3064 	ldr.w	r3, [sl, #100]	; 0x64
    d868:	f9ba 200c 	ldrsh.w	r2, [sl, #12]
    d86c:	f013 0f01 	tst.w	r3, #1
    d870:	b293      	uxth	r3, r2
    d872:	d102      	bne.n	d87a <_vfprintf_r+0x42>
    d874:	0599      	lsls	r1, r3, #22
    d876:	f140 8278 	bpl.w	dd6a <_vfprintf_r+0x532>
    d87a:	049f      	lsls	r7, r3, #18
    d87c:	d40a      	bmi.n	d894 <_vfprintf_r+0x5c>
    d87e:	f8da 1064 	ldr.w	r1, [sl, #100]	; 0x64
    d882:	f442 5300 	orr.w	r3, r2, #8192	; 0x2000
    d886:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
    d88a:	f8aa 300c 	strh.w	r3, [sl, #12]
    d88e:	f8ca 1064 	str.w	r1, [sl, #100]	; 0x64
    d892:	b29b      	uxth	r3, r3
    d894:	071e      	lsls	r6, r3, #28
    d896:	f140 8226 	bpl.w	dce6 <_vfprintf_r+0x4ae>
    d89a:	f8da 2010 	ldr.w	r2, [sl, #16]
    d89e:	2a00      	cmp	r2, #0
    d8a0:	f000 8221 	beq.w	dce6 <_vfprintf_r+0x4ae>
    d8a4:	f003 021a 	and.w	r2, r3, #26
    d8a8:	2a0a      	cmp	r2, #10
    d8aa:	f000 8241 	beq.w	dd30 <_vfprintf_r+0x4f8>
    d8ae:	ed9f 7b8e 	vldr	d7, [pc, #568]	; dae8 <_vfprintf_r+0x2b0>
    d8b2:	2300      	movs	r3, #0
    d8b4:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
    d8b8:	9311      	str	r3, [sp, #68]	; 0x44
    d8ba:	9327      	str	r3, [sp, #156]	; 0x9c
    d8bc:	9326      	str	r3, [sp, #152]	; 0x98
    d8be:	9316      	str	r3, [sp, #88]	; 0x58
    d8c0:	9317      	str	r3, [sp, #92]	; 0x5c
    d8c2:	930b      	str	r3, [sp, #44]	; 0x2c
    d8c4:	ab32      	add	r3, sp, #200	; 0xc8
    d8c6:	9325      	str	r3, [sp, #148]	; 0x94
    d8c8:	4698      	mov	r8, r3
    d8ca:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
    d8ce:	f899 3000 	ldrb.w	r3, [r9]
    d8d2:	464c      	mov	r4, r9
    d8d4:	b1eb      	cbz	r3, d912 <_vfprintf_r+0xda>
    d8d6:	2b25      	cmp	r3, #37	; 0x25
    d8d8:	d102      	bne.n	d8e0 <_vfprintf_r+0xa8>
    d8da:	e01a      	b.n	d912 <_vfprintf_r+0xda>
    d8dc:	2b25      	cmp	r3, #37	; 0x25
    d8de:	d003      	beq.n	d8e8 <_vfprintf_r+0xb0>
    d8e0:	f814 3f01 	ldrb.w	r3, [r4, #1]!
    d8e4:	2b00      	cmp	r3, #0
    d8e6:	d1f9      	bne.n	d8dc <_vfprintf_r+0xa4>
    d8e8:	eba4 0509 	sub.w	r5, r4, r9
    d8ec:	b18d      	cbz	r5, d912 <_vfprintf_r+0xda>
    d8ee:	9b26      	ldr	r3, [sp, #152]	; 0x98
    d8f0:	9a27      	ldr	r2, [sp, #156]	; 0x9c
    d8f2:	f8c8 9000 	str.w	r9, [r8]
    d8f6:	3301      	adds	r3, #1
    d8f8:	442a      	add	r2, r5
    d8fa:	2b07      	cmp	r3, #7
    d8fc:	f8c8 5004 	str.w	r5, [r8, #4]
    d900:	9227      	str	r2, [sp, #156]	; 0x9c
    d902:	9326      	str	r3, [sp, #152]	; 0x98
    d904:	f300 8205 	bgt.w	dd12 <_vfprintf_r+0x4da>
    d908:	f108 0808 	add.w	r8, r8, #8
    d90c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d90e:	442b      	add	r3, r5
    d910:	930b      	str	r3, [sp, #44]	; 0x2c
    d912:	7823      	ldrb	r3, [r4, #0]
    d914:	2b00      	cmp	r3, #0
    d916:	f000 83fe 	beq.w	e116 <_vfprintf_r+0x8de>
    d91a:	2300      	movs	r3, #0
    d91c:	461a      	mov	r2, r3
    d91e:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
    d922:	4619      	mov	r1, r3
    d924:	930c      	str	r3, [sp, #48]	; 0x30
    d926:	469b      	mov	fp, r3
    d928:	7866      	ldrb	r6, [r4, #1]
    d92a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d92e:	f104 0901 	add.w	r9, r4, #1
    d932:	9309      	str	r3, [sp, #36]	; 0x24
    d934:	f109 0901 	add.w	r9, r9, #1
    d938:	f1a6 0320 	sub.w	r3, r6, #32
    d93c:	2b58      	cmp	r3, #88	; 0x58
    d93e:	f200 83cd 	bhi.w	e0dc <_vfprintf_r+0x8a4>
    d942:	e8df f013 	tbh	[pc, r3, lsl #1]
    d946:	02e5      	.short	0x02e5
    d948:	03cb03cb 	.word	0x03cb03cb
    d94c:	03cb0354 	.word	0x03cb0354
    d950:	03cb03cb 	.word	0x03cb03cb
    d954:	03cb03cb 	.word	0x03cb03cb
    d958:	035903cb 	.word	0x035903cb
    d95c:	03cb030d 	.word	0x03cb030d
    d960:	02ed021e 	.word	0x02ed021e
    d964:	030803cb 	.word	0x030803cb
    d968:	033f033f 	.word	0x033f033f
    d96c:	033f033f 	.word	0x033f033f
    d970:	033f033f 	.word	0x033f033f
    d974:	033f033f 	.word	0x033f033f
    d978:	03cb033f 	.word	0x03cb033f
    d97c:	03cb03cb 	.word	0x03cb03cb
    d980:	03cb03cb 	.word	0x03cb03cb
    d984:	03cb03cb 	.word	0x03cb03cb
    d988:	03cb03cb 	.word	0x03cb03cb
    d98c:	034e03cb 	.word	0x034e03cb
    d990:	03cb0367 	.word	0x03cb0367
    d994:	03cb0367 	.word	0x03cb0367
    d998:	03cb03cb 	.word	0x03cb03cb
    d99c:	03b003cb 	.word	0x03b003cb
    d9a0:	03cb03cb 	.word	0x03cb03cb
    d9a4:	03cb006f 	.word	0x03cb006f
    d9a8:	03cb03cb 	.word	0x03cb03cb
    d9ac:	03cb03cb 	.word	0x03cb03cb
    d9b0:	03cb0059 	.word	0x03cb0059
    d9b4:	032303cb 	.word	0x032303cb
    d9b8:	03cb03cb 	.word	0x03cb03cb
    d9bc:	03cb03cb 	.word	0x03cb03cb
    d9c0:	03cb03cb 	.word	0x03cb03cb
    d9c4:	03cb03cb 	.word	0x03cb03cb
    d9c8:	03cb03cb 	.word	0x03cb03cb
    d9cc:	02780329 	.word	0x02780329
    d9d0:	03670367 	.word	0x03670367
    d9d4:	02bc0367 	.word	0x02bc0367
    d9d8:	03cb0278 	.word	0x03cb0278
    d9dc:	02c103cb 	.word	0x02c103cb
    d9e0:	02ce03cb 	.word	0x02ce03cb
    d9e4:	03120071 	.word	0x03120071
    d9e8:	03cb024b 	.word	0x03cb024b
    d9ec:	03cb0257 	.word	0x03cb0257
    d9f0:	03cb005b 	.word	0x03cb005b
    d9f4:	022303cb 	.word	0x022303cb
    d9f8:	f04b 0b10 	orr.w	fp, fp, #16
    d9fc:	f01b 0f20 	tst.w	fp, #32
    da00:	f040 8361 	bne.w	e0c6 <_vfprintf_r+0x88e>
    da04:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    da06:	f01b 0f10 	tst.w	fp, #16
    da0a:	4613      	mov	r3, r2
    da0c:	f040 85ca 	bne.w	e5a4 <_vfprintf_r+0xd6c>
    da10:	f01b 0f40 	tst.w	fp, #64	; 0x40
    da14:	f000 85c6 	beq.w	e5a4 <_vfprintf_r+0xd6c>
    da18:	8814      	ldrh	r4, [r2, #0]
    da1a:	3204      	adds	r2, #4
    da1c:	2500      	movs	r5, #0
    da1e:	2301      	movs	r3, #1
    da20:	920e      	str	r2, [sp, #56]	; 0x38
    da22:	e014      	b.n	da4e <_vfprintf_r+0x216>
    da24:	f04b 0b10 	orr.w	fp, fp, #16
    da28:	f01b 0320 	ands.w	r3, fp, #32
    da2c:	f040 8340 	bne.w	e0b0 <_vfprintf_r+0x878>
    da30:	f01b 0210 	ands.w	r2, fp, #16
    da34:	f040 85a5 	bne.w	e582 <_vfprintf_r+0xd4a>
    da38:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
    da3c:	f000 85a1 	beq.w	e582 <_vfprintf_r+0xd4a>
    da40:	990e      	ldr	r1, [sp, #56]	; 0x38
    da42:	4613      	mov	r3, r2
    da44:	460a      	mov	r2, r1
    da46:	3204      	adds	r2, #4
    da48:	880c      	ldrh	r4, [r1, #0]
    da4a:	920e      	str	r2, [sp, #56]	; 0x38
    da4c:	2500      	movs	r5, #0
    da4e:	f04f 0a00 	mov.w	sl, #0
    da52:	f88d a077 	strb.w	sl, [sp, #119]	; 0x77
    da56:	9909      	ldr	r1, [sp, #36]	; 0x24
    da58:	1c4a      	adds	r2, r1, #1
    da5a:	f000 8210 	beq.w	de7e <_vfprintf_r+0x646>
    da5e:	f02b 0280 	bic.w	r2, fp, #128	; 0x80
    da62:	9206      	str	r2, [sp, #24]
    da64:	ea54 0205 	orrs.w	r2, r4, r5
    da68:	f040 820f 	bne.w	de8a <_vfprintf_r+0x652>
    da6c:	2900      	cmp	r1, #0
    da6e:	f040 847c 	bne.w	e36a <_vfprintf_r+0xb32>
    da72:	2b00      	cmp	r3, #0
    da74:	f040 853a 	bne.w	e4ec <_vfprintf_r+0xcb4>
    da78:	f01b 0301 	ands.w	r3, fp, #1
    da7c:	930d      	str	r3, [sp, #52]	; 0x34
    da7e:	f000 8676 	beq.w	e76e <_vfprintf_r+0xf36>
    da82:	af42      	add	r7, sp, #264	; 0x108
    da84:	2330      	movs	r3, #48	; 0x30
    da86:	f807 3d41 	strb.w	r3, [r7, #-65]!
    da8a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    da8c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    da8e:	4293      	cmp	r3, r2
    da90:	bfb8      	it	lt
    da92:	4613      	movlt	r3, r2
    da94:	9307      	str	r3, [sp, #28]
    da96:	2300      	movs	r3, #0
    da98:	9310      	str	r3, [sp, #64]	; 0x40
    da9a:	f1ba 0f00 	cmp.w	sl, #0
    da9e:	d002      	beq.n	daa6 <_vfprintf_r+0x26e>
    daa0:	9b07      	ldr	r3, [sp, #28]
    daa2:	3301      	adds	r3, #1
    daa4:	9307      	str	r3, [sp, #28]
    daa6:	9b06      	ldr	r3, [sp, #24]
    daa8:	f013 0302 	ands.w	r3, r3, #2
    daac:	930f      	str	r3, [sp, #60]	; 0x3c
    daae:	d002      	beq.n	dab6 <_vfprintf_r+0x27e>
    dab0:	9b07      	ldr	r3, [sp, #28]
    dab2:	3302      	adds	r3, #2
    dab4:	9307      	str	r3, [sp, #28]
    dab6:	9b06      	ldr	r3, [sp, #24]
    dab8:	f013 0584 	ands.w	r5, r3, #132	; 0x84
    dabc:	f040 8329 	bne.w	e112 <_vfprintf_r+0x8da>
    dac0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    dac2:	9a07      	ldr	r2, [sp, #28]
    dac4:	eba3 0b02 	sub.w	fp, r3, r2
    dac8:	f1bb 0f00 	cmp.w	fp, #0
    dacc:	f340 8321 	ble.w	e112 <_vfprintf_r+0x8da>
    dad0:	f1bb 0f10 	cmp.w	fp, #16
    dad4:	9927      	ldr	r1, [sp, #156]	; 0x9c
    dad6:	9a26      	ldr	r2, [sp, #152]	; 0x98
    dad8:	dd2c      	ble.n	db34 <_vfprintf_r+0x2fc>
    dada:	4643      	mov	r3, r8
    dadc:	2410      	movs	r4, #16
    dade:	46a8      	mov	r8, r5
    dae0:	f8dd a020 	ldr.w	sl, [sp, #32]
    dae4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    dae6:	e00a      	b.n	dafe <_vfprintf_r+0x2c6>
	...
    daf0:	f1ab 0b10 	sub.w	fp, fp, #16
    daf4:	f1bb 0f10 	cmp.w	fp, #16
    daf8:	f103 0308 	add.w	r3, r3, #8
    dafc:	dd18      	ble.n	db30 <_vfprintf_r+0x2f8>
    dafe:	3201      	adds	r2, #1
    db00:	48b9      	ldr	r0, [pc, #740]	; (dde8 <_vfprintf_r+0x5b0>)
    db02:	9226      	str	r2, [sp, #152]	; 0x98
    db04:	3110      	adds	r1, #16
    db06:	2a07      	cmp	r2, #7
    db08:	9127      	str	r1, [sp, #156]	; 0x9c
    db0a:	e883 0011 	stmia.w	r3, {r0, r4}
    db0e:	ddef      	ble.n	daf0 <_vfprintf_r+0x2b8>
    db10:	aa25      	add	r2, sp, #148	; 0x94
    db12:	4629      	mov	r1, r5
    db14:	4650      	mov	r0, sl
    db16:	f7fe fffb 	bl	cb10 <__sprint_r>
    db1a:	2800      	cmp	r0, #0
    db1c:	f040 8374 	bne.w	e208 <_vfprintf_r+0x9d0>
    db20:	f1ab 0b10 	sub.w	fp, fp, #16
    db24:	f1bb 0f10 	cmp.w	fp, #16
    db28:	9927      	ldr	r1, [sp, #156]	; 0x9c
    db2a:	9a26      	ldr	r2, [sp, #152]	; 0x98
    db2c:	ab32      	add	r3, sp, #200	; 0xc8
    db2e:	dce6      	bgt.n	dafe <_vfprintf_r+0x2c6>
    db30:	4645      	mov	r5, r8
    db32:	4698      	mov	r8, r3
    db34:	3201      	adds	r2, #1
    db36:	4bac      	ldr	r3, [pc, #688]	; (dde8 <_vfprintf_r+0x5b0>)
    db38:	9226      	str	r2, [sp, #152]	; 0x98
    db3a:	eb0b 0401 	add.w	r4, fp, r1
    db3e:	2a07      	cmp	r2, #7
    db40:	9427      	str	r4, [sp, #156]	; 0x9c
    db42:	e888 0808 	stmia.w	r8, {r3, fp}
    db46:	f300 84d6 	bgt.w	e4f6 <_vfprintf_r+0xcbe>
    db4a:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
    db4e:	f108 0808 	add.w	r8, r8, #8
    db52:	f1ba 0f00 	cmp.w	sl, #0
    db56:	d00e      	beq.n	db76 <_vfprintf_r+0x33e>
    db58:	9b26      	ldr	r3, [sp, #152]	; 0x98
    db5a:	3301      	adds	r3, #1
    db5c:	3401      	adds	r4, #1
    db5e:	f10d 0177 	add.w	r1, sp, #119	; 0x77
    db62:	2201      	movs	r2, #1
    db64:	2b07      	cmp	r3, #7
    db66:	9427      	str	r4, [sp, #156]	; 0x9c
    db68:	9326      	str	r3, [sp, #152]	; 0x98
    db6a:	e888 0006 	stmia.w	r8, {r1, r2}
    db6e:	f300 8413 	bgt.w	e398 <_vfprintf_r+0xb60>
    db72:	f108 0808 	add.w	r8, r8, #8
    db76:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    db78:	b16b      	cbz	r3, db96 <_vfprintf_r+0x35e>
    db7a:	9b26      	ldr	r3, [sp, #152]	; 0x98
    db7c:	3301      	adds	r3, #1
    db7e:	3402      	adds	r4, #2
    db80:	a91e      	add	r1, sp, #120	; 0x78
    db82:	2202      	movs	r2, #2
    db84:	2b07      	cmp	r3, #7
    db86:	9427      	str	r4, [sp, #156]	; 0x9c
    db88:	9326      	str	r3, [sp, #152]	; 0x98
    db8a:	e888 0006 	stmia.w	r8, {r1, r2}
    db8e:	f300 840f 	bgt.w	e3b0 <_vfprintf_r+0xb78>
    db92:	f108 0808 	add.w	r8, r8, #8
    db96:	2d80      	cmp	r5, #128	; 0x80
    db98:	f000 8338 	beq.w	e20c <_vfprintf_r+0x9d4>
    db9c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    db9e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    dba0:	eba3 0a02 	sub.w	sl, r3, r2
    dba4:	f1ba 0f00 	cmp.w	sl, #0
    dba8:	dd3b      	ble.n	dc22 <_vfprintf_r+0x3ea>
    dbaa:	f1ba 0f10 	cmp.w	sl, #16
    dbae:	9b26      	ldr	r3, [sp, #152]	; 0x98
    dbb0:	4d8e      	ldr	r5, [pc, #568]	; (ddec <_vfprintf_r+0x5b4>)
    dbb2:	dd2b      	ble.n	dc0c <_vfprintf_r+0x3d4>
    dbb4:	4642      	mov	r2, r8
    dbb6:	4621      	mov	r1, r4
    dbb8:	46b0      	mov	r8, r6
    dbba:	f04f 0b10 	mov.w	fp, #16
    dbbe:	462e      	mov	r6, r5
    dbc0:	9c08      	ldr	r4, [sp, #32]
    dbc2:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    dbc4:	e006      	b.n	dbd4 <_vfprintf_r+0x39c>
    dbc6:	f1aa 0a10 	sub.w	sl, sl, #16
    dbca:	f1ba 0f10 	cmp.w	sl, #16
    dbce:	f102 0208 	add.w	r2, r2, #8
    dbd2:	dd17      	ble.n	dc04 <_vfprintf_r+0x3cc>
    dbd4:	3301      	adds	r3, #1
    dbd6:	3110      	adds	r1, #16
    dbd8:	2b07      	cmp	r3, #7
    dbda:	9127      	str	r1, [sp, #156]	; 0x9c
    dbdc:	9326      	str	r3, [sp, #152]	; 0x98
    dbde:	e882 0840 	stmia.w	r2, {r6, fp}
    dbe2:	ddf0      	ble.n	dbc6 <_vfprintf_r+0x38e>
    dbe4:	aa25      	add	r2, sp, #148	; 0x94
    dbe6:	4629      	mov	r1, r5
    dbe8:	4620      	mov	r0, r4
    dbea:	f7fe ff91 	bl	cb10 <__sprint_r>
    dbee:	2800      	cmp	r0, #0
    dbf0:	f040 830a 	bne.w	e208 <_vfprintf_r+0x9d0>
    dbf4:	f1aa 0a10 	sub.w	sl, sl, #16
    dbf8:	f1ba 0f10 	cmp.w	sl, #16
    dbfc:	9927      	ldr	r1, [sp, #156]	; 0x9c
    dbfe:	9b26      	ldr	r3, [sp, #152]	; 0x98
    dc00:	aa32      	add	r2, sp, #200	; 0xc8
    dc02:	dce7      	bgt.n	dbd4 <_vfprintf_r+0x39c>
    dc04:	4635      	mov	r5, r6
    dc06:	460c      	mov	r4, r1
    dc08:	4646      	mov	r6, r8
    dc0a:	4690      	mov	r8, r2
    dc0c:	3301      	adds	r3, #1
    dc0e:	4454      	add	r4, sl
    dc10:	2b07      	cmp	r3, #7
    dc12:	9427      	str	r4, [sp, #156]	; 0x9c
    dc14:	9326      	str	r3, [sp, #152]	; 0x98
    dc16:	e888 0420 	stmia.w	r8, {r5, sl}
    dc1a:	f300 83b2 	bgt.w	e382 <_vfprintf_r+0xb4a>
    dc1e:	f108 0808 	add.w	r8, r8, #8
    dc22:	9b06      	ldr	r3, [sp, #24]
    dc24:	05db      	lsls	r3, r3, #23
    dc26:	f100 828f 	bmi.w	e148 <_vfprintf_r+0x910>
    dc2a:	9b26      	ldr	r3, [sp, #152]	; 0x98
    dc2c:	990d      	ldr	r1, [sp, #52]	; 0x34
    dc2e:	f8c8 7000 	str.w	r7, [r8]
    dc32:	3301      	adds	r3, #1
    dc34:	440c      	add	r4, r1
    dc36:	2b07      	cmp	r3, #7
    dc38:	9427      	str	r4, [sp, #156]	; 0x9c
    dc3a:	f8c8 1004 	str.w	r1, [r8, #4]
    dc3e:	9326      	str	r3, [sp, #152]	; 0x98
    dc40:	f300 837e 	bgt.w	e340 <_vfprintf_r+0xb08>
    dc44:	f108 0808 	add.w	r8, r8, #8
    dc48:	9b06      	ldr	r3, [sp, #24]
    dc4a:	0759      	lsls	r1, r3, #29
    dc4c:	d53b      	bpl.n	dcc6 <_vfprintf_r+0x48e>
    dc4e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    dc50:	9a07      	ldr	r2, [sp, #28]
    dc52:	1a9d      	subs	r5, r3, r2
    dc54:	2d00      	cmp	r5, #0
    dc56:	dd36      	ble.n	dcc6 <_vfprintf_r+0x48e>
    dc58:	2d10      	cmp	r5, #16
    dc5a:	9b26      	ldr	r3, [sp, #152]	; 0x98
    dc5c:	dd21      	ble.n	dca2 <_vfprintf_r+0x46a>
    dc5e:	2610      	movs	r6, #16
    dc60:	9f08      	ldr	r7, [sp, #32]
    dc62:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    dc66:	e004      	b.n	dc72 <_vfprintf_r+0x43a>
    dc68:	3d10      	subs	r5, #16
    dc6a:	2d10      	cmp	r5, #16
    dc6c:	f108 0808 	add.w	r8, r8, #8
    dc70:	dd17      	ble.n	dca2 <_vfprintf_r+0x46a>
    dc72:	3301      	adds	r3, #1
    dc74:	4a5c      	ldr	r2, [pc, #368]	; (dde8 <_vfprintf_r+0x5b0>)
    dc76:	9326      	str	r3, [sp, #152]	; 0x98
    dc78:	3410      	adds	r4, #16
    dc7a:	2b07      	cmp	r3, #7
    dc7c:	9427      	str	r4, [sp, #156]	; 0x9c
    dc7e:	e888 0044 	stmia.w	r8, {r2, r6}
    dc82:	ddf1      	ble.n	dc68 <_vfprintf_r+0x430>
    dc84:	aa25      	add	r2, sp, #148	; 0x94
    dc86:	4651      	mov	r1, sl
    dc88:	4638      	mov	r0, r7
    dc8a:	f7fe ff41 	bl	cb10 <__sprint_r>
    dc8e:	2800      	cmp	r0, #0
    dc90:	f040 8249 	bne.w	e126 <_vfprintf_r+0x8ee>
    dc94:	3d10      	subs	r5, #16
    dc96:	2d10      	cmp	r5, #16
    dc98:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    dc9a:	9b26      	ldr	r3, [sp, #152]	; 0x98
    dc9c:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    dca0:	dce7      	bgt.n	dc72 <_vfprintf_r+0x43a>
    dca2:	3301      	adds	r3, #1
    dca4:	4a50      	ldr	r2, [pc, #320]	; (dde8 <_vfprintf_r+0x5b0>)
    dca6:	9326      	str	r3, [sp, #152]	; 0x98
    dca8:	442c      	add	r4, r5
    dcaa:	2b07      	cmp	r3, #7
    dcac:	9427      	str	r4, [sp, #156]	; 0x9c
    dcae:	e888 0024 	stmia.w	r8, {r2, r5}
    dcb2:	dd08      	ble.n	dcc6 <_vfprintf_r+0x48e>
    dcb4:	aa25      	add	r2, sp, #148	; 0x94
    dcb6:	990a      	ldr	r1, [sp, #40]	; 0x28
    dcb8:	9808      	ldr	r0, [sp, #32]
    dcba:	f7fe ff29 	bl	cb10 <__sprint_r>
    dcbe:	2800      	cmp	r0, #0
    dcc0:	f040 8350 	bne.w	e364 <_vfprintf_r+0xb2c>
    dcc4:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    dcc6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dcc8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    dcca:	9907      	ldr	r1, [sp, #28]
    dccc:	428a      	cmp	r2, r1
    dcce:	bfac      	ite	ge
    dcd0:	189b      	addge	r3, r3, r2
    dcd2:	185b      	addlt	r3, r3, r1
    dcd4:	930b      	str	r3, [sp, #44]	; 0x2c
    dcd6:	2c00      	cmp	r4, #0
    dcd8:	f040 833c 	bne.w	e354 <_vfprintf_r+0xb1c>
    dcdc:	2300      	movs	r3, #0
    dcde:	9326      	str	r3, [sp, #152]	; 0x98
    dce0:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    dce4:	e5f3      	b.n	d8ce <_vfprintf_r+0x96>
    dce6:	4651      	mov	r1, sl
    dce8:	9808      	ldr	r0, [sp, #32]
    dcea:	f001 f977 	bl	efdc <__swsetup_r>
    dcee:	2800      	cmp	r0, #0
    dcf0:	d038      	beq.n	dd64 <_vfprintf_r+0x52c>
    dcf2:	f8da 3064 	ldr.w	r3, [sl, #100]	; 0x64
    dcf6:	07dd      	lsls	r5, r3, #31
    dcf8:	d404      	bmi.n	dd04 <_vfprintf_r+0x4cc>
    dcfa:	f8ba 300c 	ldrh.w	r3, [sl, #12]
    dcfe:	059c      	lsls	r4, r3, #22
    dd00:	f140 85da 	bpl.w	e8b8 <_vfprintf_r+0x1080>
    dd04:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    dd08:	930b      	str	r3, [sp, #44]	; 0x2c
    dd0a:	980b      	ldr	r0, [sp, #44]	; 0x2c
    dd0c:	b043      	add	sp, #268	; 0x10c
    dd0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd12:	aa25      	add	r2, sp, #148	; 0x94
    dd14:	990a      	ldr	r1, [sp, #40]	; 0x28
    dd16:	9808      	ldr	r0, [sp, #32]
    dd18:	f7fe fefa 	bl	cb10 <__sprint_r>
    dd1c:	2800      	cmp	r0, #0
    dd1e:	f040 8321 	bne.w	e364 <_vfprintf_r+0xb2c>
    dd22:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    dd26:	e5f1      	b.n	d90c <_vfprintf_r+0xd4>
    dd28:	9808      	ldr	r0, [sp, #32]
    dd2a:	f7fc fc83 	bl	a634 <__sinit>
    dd2e:	e599      	b.n	d864 <_vfprintf_r+0x2c>
    dd30:	f9ba 200e 	ldrsh.w	r2, [sl, #14]
    dd34:	2a00      	cmp	r2, #0
    dd36:	f6ff adba 	blt.w	d8ae <_vfprintf_r+0x76>
    dd3a:	f8da 2064 	ldr.w	r2, [sl, #100]	; 0x64
    dd3e:	07d0      	lsls	r0, r2, #31
    dd40:	d405      	bmi.n	dd4e <_vfprintf_r+0x516>
    dd42:	0599      	lsls	r1, r3, #22
    dd44:	d403      	bmi.n	dd4e <_vfprintf_r+0x516>
    dd46:	f8da 0058 	ldr.w	r0, [sl, #88]	; 0x58
    dd4a:	f7fc ffe7 	bl	ad1c <__retarget_lock_release_recursive>
    dd4e:	462b      	mov	r3, r5
    dd50:	464a      	mov	r2, r9
    dd52:	4651      	mov	r1, sl
    dd54:	9808      	ldr	r0, [sp, #32]
    dd56:	f001 f839 	bl	edcc <__sbprintf>
    dd5a:	900b      	str	r0, [sp, #44]	; 0x2c
    dd5c:	980b      	ldr	r0, [sp, #44]	; 0x2c
    dd5e:	b043      	add	sp, #268	; 0x10c
    dd60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd64:	f8ba 300c 	ldrh.w	r3, [sl, #12]
    dd68:	e59c      	b.n	d8a4 <_vfprintf_r+0x6c>
    dd6a:	f8da 0058 	ldr.w	r0, [sl, #88]	; 0x58
    dd6e:	f7fc ffd3 	bl	ad18 <__retarget_lock_acquire_recursive>
    dd72:	f9ba 200c 	ldrsh.w	r2, [sl, #12]
    dd76:	b293      	uxth	r3, r2
    dd78:	e57f      	b.n	d87a <_vfprintf_r+0x42>
    dd7a:	980c      	ldr	r0, [sp, #48]	; 0x30
    dd7c:	930e      	str	r3, [sp, #56]	; 0x38
    dd7e:	4240      	negs	r0, r0
    dd80:	900c      	str	r0, [sp, #48]	; 0x30
    dd82:	f04b 0b04 	orr.w	fp, fp, #4
    dd86:	f899 6000 	ldrb.w	r6, [r9]
    dd8a:	e5d3      	b.n	d934 <_vfprintf_r+0xfc>
    dd8c:	2a00      	cmp	r2, #0
    dd8e:	f040 87f7 	bne.w	ed80 <_vfprintf_r+0x1548>
    dd92:	4b17      	ldr	r3, [pc, #92]	; (ddf0 <_vfprintf_r+0x5b8>)
    dd94:	9316      	str	r3, [sp, #88]	; 0x58
    dd96:	f01b 0f20 	tst.w	fp, #32
    dd9a:	f040 84cd 	bne.w	e738 <_vfprintf_r+0xf00>
    dd9e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    dda0:	f01b 0f10 	tst.w	fp, #16
    dda4:	4613      	mov	r3, r2
    dda6:	f040 83e7 	bne.w	e578 <_vfprintf_r+0xd40>
    ddaa:	f01b 0f40 	tst.w	fp, #64	; 0x40
    ddae:	f000 83e3 	beq.w	e578 <_vfprintf_r+0xd40>
    ddb2:	3304      	adds	r3, #4
    ddb4:	8814      	ldrh	r4, [r2, #0]
    ddb6:	930e      	str	r3, [sp, #56]	; 0x38
    ddb8:	2500      	movs	r5, #0
    ddba:	f01b 0f01 	tst.w	fp, #1
    ddbe:	f000 832b 	beq.w	e418 <_vfprintf_r+0xbe0>
    ddc2:	ea54 0305 	orrs.w	r3, r4, r5
    ddc6:	f000 8327 	beq.w	e418 <_vfprintf_r+0xbe0>
    ddca:	2330      	movs	r3, #48	; 0x30
    ddcc:	f88d 3078 	strb.w	r3, [sp, #120]	; 0x78
    ddd0:	f88d 6079 	strb.w	r6, [sp, #121]	; 0x79
    ddd4:	f04b 0b02 	orr.w	fp, fp, #2
    ddd8:	2302      	movs	r3, #2
    ddda:	e638      	b.n	da4e <_vfprintf_r+0x216>
    dddc:	f04b 0b20 	orr.w	fp, fp, #32
    dde0:	f899 6000 	ldrb.w	r6, [r9]
    dde4:	e5a6      	b.n	d934 <_vfprintf_r+0xfc>
    dde6:	bf00      	nop
    dde8:	00012a70 	.word	0x00012a70
    ddec:	00012a80 	.word	0x00012a80
    ddf0:	00012a10 	.word	0x00012a10
    ddf4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    ddf6:	6817      	ldr	r7, [r2, #0]
    ddf8:	2400      	movs	r4, #0
    ddfa:	f88d 4077 	strb.w	r4, [sp, #119]	; 0x77
    ddfe:	1d15      	adds	r5, r2, #4
    de00:	2f00      	cmp	r7, #0
    de02:	f000 865d 	beq.w	eac0 <_vfprintf_r+0x1288>
    de06:	9a09      	ldr	r2, [sp, #36]	; 0x24
    de08:	1c53      	adds	r3, r2, #1
    de0a:	f000 85db 	beq.w	e9c4 <_vfprintf_r+0x118c>
    de0e:	4621      	mov	r1, r4
    de10:	4638      	mov	r0, r7
    de12:	f7f2 fd35 	bl	880 <memchr>
    de16:	2800      	cmp	r0, #0
    de18:	f000 86da 	beq.w	ebd0 <_vfprintf_r+0x1398>
    de1c:	1bc3      	subs	r3, r0, r7
    de1e:	930d      	str	r3, [sp, #52]	; 0x34
    de20:	9409      	str	r4, [sp, #36]	; 0x24
    de22:	950e      	str	r5, [sp, #56]	; 0x38
    de24:	f8cd b018 	str.w	fp, [sp, #24]
    de28:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    de2c:	9307      	str	r3, [sp, #28]
    de2e:	9410      	str	r4, [sp, #64]	; 0x40
    de30:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
    de34:	e631      	b.n	da9a <_vfprintf_r+0x262>
    de36:	2a00      	cmp	r2, #0
    de38:	f040 87ad 	bne.w	ed96 <_vfprintf_r+0x155e>
    de3c:	f01b 0f20 	tst.w	fp, #32
    de40:	f040 8488 	bne.w	e754 <_vfprintf_r+0xf1c>
    de44:	f01b 0f10 	tst.w	fp, #16
    de48:	f040 83a3 	bne.w	e592 <_vfprintf_r+0xd5a>
    de4c:	f01b 0f40 	tst.w	fp, #64	; 0x40
    de50:	f000 839f 	beq.w	e592 <_vfprintf_r+0xd5a>
    de54:	990e      	ldr	r1, [sp, #56]	; 0x38
    de56:	f9b1 4000 	ldrsh.w	r4, [r1]
    de5a:	3104      	adds	r1, #4
    de5c:	17e5      	asrs	r5, r4, #31
    de5e:	4622      	mov	r2, r4
    de60:	462b      	mov	r3, r5
    de62:	910e      	str	r1, [sp, #56]	; 0x38
    de64:	2a00      	cmp	r2, #0
    de66:	f173 0300 	sbcs.w	r3, r3, #0
    de6a:	f2c0 8490 	blt.w	e78e <_vfprintf_r+0xf56>
    de6e:	9909      	ldr	r1, [sp, #36]	; 0x24
    de70:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
    de74:	1c4a      	adds	r2, r1, #1
    de76:	f04f 0301 	mov.w	r3, #1
    de7a:	f47f adf0 	bne.w	da5e <_vfprintf_r+0x226>
    de7e:	ea54 0205 	orrs.w	r2, r4, r5
    de82:	f000 8274 	beq.w	e36e <_vfprintf_r+0xb36>
    de86:	f8cd b018 	str.w	fp, [sp, #24]
    de8a:	2b01      	cmp	r3, #1
    de8c:	f000 8310 	beq.w	e4b0 <_vfprintf_r+0xc78>
    de90:	2b02      	cmp	r3, #2
    de92:	f040 829d 	bne.w	e3d0 <_vfprintf_r+0xb98>
    de96:	9816      	ldr	r0, [sp, #88]	; 0x58
    de98:	af32      	add	r7, sp, #200	; 0xc8
    de9a:	0923      	lsrs	r3, r4, #4
    de9c:	f004 010f 	and.w	r1, r4, #15
    dea0:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
    dea4:	092a      	lsrs	r2, r5, #4
    dea6:	461c      	mov	r4, r3
    dea8:	4615      	mov	r5, r2
    deaa:	5c43      	ldrb	r3, [r0, r1]
    deac:	f807 3d01 	strb.w	r3, [r7, #-1]!
    deb0:	ea54 0305 	orrs.w	r3, r4, r5
    deb4:	d1f1      	bne.n	de9a <_vfprintf_r+0x662>
    deb6:	ab32      	add	r3, sp, #200	; 0xc8
    deb8:	1bdb      	subs	r3, r3, r7
    deba:	930d      	str	r3, [sp, #52]	; 0x34
    debc:	e5e5      	b.n	da8a <_vfprintf_r+0x252>
    debe:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
    dec2:	f899 6000 	ldrb.w	r6, [r9]
    dec6:	e535      	b.n	d934 <_vfprintf_r+0xfc>
    dec8:	f899 6000 	ldrb.w	r6, [r9]
    decc:	2e6c      	cmp	r6, #108	; 0x6c
    dece:	bf03      	ittte	eq
    ded0:	f899 6001 	ldrbeq.w	r6, [r9, #1]
    ded4:	f04b 0b20 	orreq.w	fp, fp, #32
    ded8:	f109 0901 	addeq.w	r9, r9, #1
    dedc:	f04b 0b10 	orrne.w	fp, fp, #16
    dee0:	e528      	b.n	d934 <_vfprintf_r+0xfc>
    dee2:	2a00      	cmp	r2, #0
    dee4:	f040 8767 	bne.w	edb6 <_vfprintf_r+0x157e>
    dee8:	f01b 0f20 	tst.w	fp, #32
    deec:	f040 854e 	bne.w	e98c <_vfprintf_r+0x1154>
    def0:	f01b 0f10 	tst.w	fp, #16
    def4:	f040 8105 	bne.w	e102 <_vfprintf_r+0x8ca>
    def8:	f01b 0f40 	tst.w	fp, #64	; 0x40
    defc:	f000 8101 	beq.w	e102 <_vfprintf_r+0x8ca>
    df00:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    df02:	6813      	ldr	r3, [r2, #0]
    df04:	3204      	adds	r2, #4
    df06:	920e      	str	r2, [sp, #56]	; 0x38
    df08:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
    df0c:	801a      	strh	r2, [r3, #0]
    df0e:	e4de      	b.n	d8ce <_vfprintf_r+0x96>
    df10:	f899 6000 	ldrb.w	r6, [r9]
    df14:	2900      	cmp	r1, #0
    df16:	f47f ad0d 	bne.w	d934 <_vfprintf_r+0xfc>
    df1a:	2201      	movs	r2, #1
    df1c:	2120      	movs	r1, #32
    df1e:	e509      	b.n	d934 <_vfprintf_r+0xfc>
    df20:	f899 6000 	ldrb.w	r6, [r9]
    df24:	2e2a      	cmp	r6, #42	; 0x2a
    df26:	f109 0001 	add.w	r0, r9, #1
    df2a:	f000 8707 	beq.w	ed3c <_vfprintf_r+0x1504>
    df2e:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
    df32:	2b09      	cmp	r3, #9
    df34:	4681      	mov	r9, r0
    df36:	bf98      	it	ls
    df38:	2000      	movls	r0, #0
    df3a:	f200 865b 	bhi.w	ebf4 <_vfprintf_r+0x13bc>
    df3e:	f819 6b01 	ldrb.w	r6, [r9], #1
    df42:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    df46:	eb03 0040 	add.w	r0, r3, r0, lsl #1
    df4a:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
    df4e:	2b09      	cmp	r3, #9
    df50:	d9f5      	bls.n	df3e <_vfprintf_r+0x706>
    df52:	9009      	str	r0, [sp, #36]	; 0x24
    df54:	e4f0      	b.n	d938 <_vfprintf_r+0x100>
    df56:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
    df5a:	f899 6000 	ldrb.w	r6, [r9]
    df5e:	e4e9      	b.n	d934 <_vfprintf_r+0xfc>
    df60:	f899 6000 	ldrb.w	r6, [r9]
    df64:	2201      	movs	r2, #1
    df66:	212b      	movs	r1, #43	; 0x2b
    df68:	e4e4      	b.n	d934 <_vfprintf_r+0xfc>
    df6a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    df6c:	4bb2      	ldr	r3, [pc, #712]	; (e238 <_vfprintf_r+0xa00>)
    df6e:	6814      	ldr	r4, [r2, #0]
    df70:	9316      	str	r3, [sp, #88]	; 0x58
    df72:	2678      	movs	r6, #120	; 0x78
    df74:	2330      	movs	r3, #48	; 0x30
    df76:	3204      	adds	r2, #4
    df78:	f88d 3078 	strb.w	r3, [sp, #120]	; 0x78
    df7c:	f04b 0b02 	orr.w	fp, fp, #2
    df80:	920e      	str	r2, [sp, #56]	; 0x38
    df82:	2500      	movs	r5, #0
    df84:	f88d 6079 	strb.w	r6, [sp, #121]	; 0x79
    df88:	2302      	movs	r3, #2
    df8a:	e560      	b.n	da4e <_vfprintf_r+0x216>
    df8c:	2a00      	cmp	r2, #0
    df8e:	f040 870e 	bne.w	edae <_vfprintf_r+0x1576>
    df92:	4baa      	ldr	r3, [pc, #680]	; (e23c <_vfprintf_r+0xa04>)
    df94:	9316      	str	r3, [sp, #88]	; 0x58
    df96:	e6fe      	b.n	dd96 <_vfprintf_r+0x55e>
    df98:	990e      	ldr	r1, [sp, #56]	; 0x38
    df9a:	f8cd b018 	str.w	fp, [sp, #24]
    df9e:	680a      	ldr	r2, [r1, #0]
    dfa0:	f88d 20a0 	strb.w	r2, [sp, #160]	; 0xa0
    dfa4:	2300      	movs	r3, #0
    dfa6:	460a      	mov	r2, r1
    dfa8:	469a      	mov	sl, r3
    dfaa:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
    dfae:	3204      	adds	r2, #4
    dfb0:	2301      	movs	r3, #1
    dfb2:	9307      	str	r3, [sp, #28]
    dfb4:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
    dfb8:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
    dfbc:	920e      	str	r2, [sp, #56]	; 0x38
    dfbe:	930d      	str	r3, [sp, #52]	; 0x34
    dfc0:	af28      	add	r7, sp, #160	; 0xa0
    dfc2:	e570      	b.n	daa6 <_vfprintf_r+0x26e>
    dfc4:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
    dfc8:	2000      	movs	r0, #0
    dfca:	f819 6b01 	ldrb.w	r6, [r9], #1
    dfce:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    dfd2:	eb03 0040 	add.w	r0, r3, r0, lsl #1
    dfd6:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
    dfda:	2b09      	cmp	r3, #9
    dfdc:	d9f5      	bls.n	dfca <_vfprintf_r+0x792>
    dfde:	900c      	str	r0, [sp, #48]	; 0x30
    dfe0:	e4aa      	b.n	d938 <_vfprintf_r+0x100>
    dfe2:	2a00      	cmp	r2, #0
    dfe4:	f040 86df 	bne.w	eda6 <_vfprintf_r+0x156e>
    dfe8:	f04b 0b10 	orr.w	fp, fp, #16
    dfec:	e726      	b.n	de3c <_vfprintf_r+0x604>
    dfee:	f04b 0b01 	orr.w	fp, fp, #1
    dff2:	f899 6000 	ldrb.w	r6, [r9]
    dff6:	e49d      	b.n	d934 <_vfprintf_r+0xfc>
    dff8:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    dffa:	6823      	ldr	r3, [r4, #0]
    dffc:	930c      	str	r3, [sp, #48]	; 0x30
    dffe:	4618      	mov	r0, r3
    e000:	2800      	cmp	r0, #0
    e002:	4623      	mov	r3, r4
    e004:	f103 0304 	add.w	r3, r3, #4
    e008:	f6ff aeb7 	blt.w	dd7a <_vfprintf_r+0x542>
    e00c:	930e      	str	r3, [sp, #56]	; 0x38
    e00e:	f899 6000 	ldrb.w	r6, [r9]
    e012:	e48f      	b.n	d934 <_vfprintf_r+0xfc>
    e014:	2a00      	cmp	r2, #0
    e016:	f040 86b7 	bne.w	ed88 <_vfprintf_r+0x1550>
    e01a:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    e01c:	f01b 0f08 	tst.w	fp, #8
    e020:	f105 0507 	add.w	r5, r5, #7
    e024:	f000 843d 	beq.w	e8a2 <_vfprintf_r+0x106a>
    e028:	f025 0307 	bic.w	r3, r5, #7
    e02c:	ed93 7b00 	vldr	d7, [r3]
    e030:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
    e034:	f103 0208 	add.w	r2, r3, #8
    e038:	920e      	str	r2, [sp, #56]	; 0x38
    e03a:	e9dd 1212 	ldrd	r1, r2, [sp, #72]	; 0x48
    e03e:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
    e042:	9118      	str	r1, [sp, #96]	; 0x60
    e044:	9319      	str	r3, [sp, #100]	; 0x64
    e046:	e9dd 4518 	ldrd	r4, r5, [sp, #96]	; 0x60
    e04a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    e04e:	4620      	mov	r0, r4
    e050:	4629      	mov	r1, r5
    e052:	4b7b      	ldr	r3, [pc, #492]	; (e240 <_vfprintf_r+0xa08>)
    e054:	f7f3 f9d4 	bl	1400 <__aeabi_dcmpun>
    e058:	2800      	cmp	r0, #0
    e05a:	f040 83a2 	bne.w	e7a2 <_vfprintf_r+0xf6a>
    e05e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    e062:	4b77      	ldr	r3, [pc, #476]	; (e240 <_vfprintf_r+0xa08>)
    e064:	4620      	mov	r0, r4
    e066:	4629      	mov	r1, r5
    e068:	f7f3 f9ac 	bl	13c4 <__aeabi_dcmple>
    e06c:	2800      	cmp	r0, #0
    e06e:	f040 8398 	bne.w	e7a2 <_vfprintf_r+0xf6a>
    e072:	2200      	movs	r2, #0
    e074:	2300      	movs	r3, #0
    e076:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    e07a:	f7f3 f999 	bl	13b0 <__aeabi_dcmplt>
    e07e:	2800      	cmp	r0, #0
    e080:	f040 8438 	bne.w	e8f4 <_vfprintf_r+0x10bc>
    e084:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
    e088:	4f6e      	ldr	r7, [pc, #440]	; (e244 <_vfprintf_r+0xa0c>)
    e08a:	4b6f      	ldr	r3, [pc, #444]	; (e248 <_vfprintf_r+0xa10>)
    e08c:	2203      	movs	r2, #3
    e08e:	2100      	movs	r1, #0
    e090:	f02b 0080 	bic.w	r0, fp, #128	; 0x80
    e094:	9207      	str	r2, [sp, #28]
    e096:	9109      	str	r1, [sp, #36]	; 0x24
    e098:	9006      	str	r0, [sp, #24]
    e09a:	2e47      	cmp	r6, #71	; 0x47
    e09c:	bfd8      	it	le
    e09e:	461f      	movle	r7, r3
    e0a0:	920d      	str	r2, [sp, #52]	; 0x34
    e0a2:	9110      	str	r1, [sp, #64]	; 0x40
    e0a4:	e4f9      	b.n	da9a <_vfprintf_r+0x262>
    e0a6:	f04b 0b08 	orr.w	fp, fp, #8
    e0aa:	f899 6000 	ldrb.w	r6, [r9]
    e0ae:	e441      	b.n	d934 <_vfprintf_r+0xfc>
    e0b0:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    e0b2:	3507      	adds	r5, #7
    e0b4:	f025 0307 	bic.w	r3, r5, #7
    e0b8:	f103 0208 	add.w	r2, r3, #8
    e0bc:	e9d3 4500 	ldrd	r4, r5, [r3]
    e0c0:	920e      	str	r2, [sp, #56]	; 0x38
    e0c2:	2300      	movs	r3, #0
    e0c4:	e4c3      	b.n	da4e <_vfprintf_r+0x216>
    e0c6:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    e0c8:	3507      	adds	r5, #7
    e0ca:	f025 0307 	bic.w	r3, r5, #7
    e0ce:	f103 0208 	add.w	r2, r3, #8
    e0d2:	e9d3 4500 	ldrd	r4, r5, [r3]
    e0d6:	920e      	str	r2, [sp, #56]	; 0x38
    e0d8:	2301      	movs	r3, #1
    e0da:	e4b8      	b.n	da4e <_vfprintf_r+0x216>
    e0dc:	2a00      	cmp	r2, #0
    e0de:	f040 865e 	bne.w	ed9e <_vfprintf_r+0x1566>
    e0e2:	b1c6      	cbz	r6, e116 <_vfprintf_r+0x8de>
    e0e4:	2300      	movs	r3, #0
    e0e6:	2201      	movs	r2, #1
    e0e8:	469a      	mov	sl, r3
    e0ea:	9207      	str	r2, [sp, #28]
    e0ec:	f88d 60a0 	strb.w	r6, [sp, #160]	; 0xa0
    e0f0:	f8cd b018 	str.w	fp, [sp, #24]
    e0f4:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
    e0f8:	9309      	str	r3, [sp, #36]	; 0x24
    e0fa:	9310      	str	r3, [sp, #64]	; 0x40
    e0fc:	920d      	str	r2, [sp, #52]	; 0x34
    e0fe:	af28      	add	r7, sp, #160	; 0xa0
    e100:	e4d1      	b.n	daa6 <_vfprintf_r+0x26e>
    e102:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    e104:	6813      	ldr	r3, [r2, #0]
    e106:	3204      	adds	r2, #4
    e108:	920e      	str	r2, [sp, #56]	; 0x38
    e10a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    e10c:	601a      	str	r2, [r3, #0]
    e10e:	f7ff bbde 	b.w	d8ce <_vfprintf_r+0x96>
    e112:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e114:	e51d      	b.n	db52 <_vfprintf_r+0x31a>
    e116:	9b27      	ldr	r3, [sp, #156]	; 0x9c
    e118:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    e11c:	2b00      	cmp	r3, #0
    e11e:	f040 856d 	bne.w	ebfc <_vfprintf_r+0x13c4>
    e122:	2300      	movs	r3, #0
    e124:	9326      	str	r3, [sp, #152]	; 0x98
    e126:	f8da 3064 	ldr.w	r3, [sl, #100]	; 0x64
    e12a:	f013 0f01 	tst.w	r3, #1
    e12e:	f8ba 300c 	ldrh.w	r3, [sl, #12]
    e132:	d102      	bne.n	e13a <_vfprintf_r+0x902>
    e134:	059a      	lsls	r2, r3, #22
    e136:	f140 8248 	bpl.w	e5ca <_vfprintf_r+0xd92>
    e13a:	065b      	lsls	r3, r3, #25
    e13c:	f53f ade2 	bmi.w	dd04 <_vfprintf_r+0x4cc>
    e140:	980b      	ldr	r0, [sp, #44]	; 0x2c
    e142:	b043      	add	sp, #268	; 0x10c
    e144:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e148:	2e65      	cmp	r6, #101	; 0x65
    e14a:	f340 80b1 	ble.w	e2b0 <_vfprintf_r+0xa78>
    e14e:	2200      	movs	r2, #0
    e150:	2300      	movs	r3, #0
    e152:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    e156:	f7f3 f921 	bl	139c <__aeabi_dcmpeq>
    e15a:	2800      	cmp	r0, #0
    e15c:	f000 815f 	beq.w	e41e <_vfprintf_r+0xbe6>
    e160:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e162:	4a3a      	ldr	r2, [pc, #232]	; (e24c <_vfprintf_r+0xa14>)
    e164:	f8c8 2000 	str.w	r2, [r8]
    e168:	3301      	adds	r3, #1
    e16a:	3401      	adds	r4, #1
    e16c:	2201      	movs	r2, #1
    e16e:	2b07      	cmp	r3, #7
    e170:	9427      	str	r4, [sp, #156]	; 0x9c
    e172:	9326      	str	r3, [sp, #152]	; 0x98
    e174:	f8c8 2004 	str.w	r2, [r8, #4]
    e178:	f300 83c5 	bgt.w	e906 <_vfprintf_r+0x10ce>
    e17c:	f108 0808 	add.w	r8, r8, #8
    e180:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    e182:	9a11      	ldr	r2, [sp, #68]	; 0x44
    e184:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e186:	4293      	cmp	r3, r2
    e188:	db03      	blt.n	e192 <_vfprintf_r+0x95a>
    e18a:	9b06      	ldr	r3, [sp, #24]
    e18c:	07df      	lsls	r7, r3, #31
    e18e:	f57f ad5b 	bpl.w	dc48 <_vfprintf_r+0x410>
    e192:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e194:	9914      	ldr	r1, [sp, #80]	; 0x50
    e196:	9a15      	ldr	r2, [sp, #84]	; 0x54
    e198:	f8c8 2000 	str.w	r2, [r8]
    e19c:	3301      	adds	r3, #1
    e19e:	440c      	add	r4, r1
    e1a0:	2b07      	cmp	r3, #7
    e1a2:	f8c8 1004 	str.w	r1, [r8, #4]
    e1a6:	9427      	str	r4, [sp, #156]	; 0x9c
    e1a8:	9326      	str	r3, [sp, #152]	; 0x98
    e1aa:	f300 83fe 	bgt.w	e9aa <_vfprintf_r+0x1172>
    e1ae:	f108 0808 	add.w	r8, r8, #8
    e1b2:	9b11      	ldr	r3, [sp, #68]	; 0x44
    e1b4:	1e5e      	subs	r6, r3, #1
    e1b6:	2e00      	cmp	r6, #0
    e1b8:	f77f ad46 	ble.w	dc48 <_vfprintf_r+0x410>
    e1bc:	2e10      	cmp	r6, #16
    e1be:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e1c0:	4d23      	ldr	r5, [pc, #140]	; (e250 <_vfprintf_r+0xa18>)
    e1c2:	f340 81cf 	ble.w	e564 <_vfprintf_r+0xd2c>
    e1c6:	2710      	movs	r7, #16
    e1c8:	f8dd a020 	ldr.w	sl, [sp, #32]
    e1cc:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    e1d0:	e005      	b.n	e1de <_vfprintf_r+0x9a6>
    e1d2:	f108 0808 	add.w	r8, r8, #8
    e1d6:	3e10      	subs	r6, #16
    e1d8:	2e10      	cmp	r6, #16
    e1da:	f340 81c3 	ble.w	e564 <_vfprintf_r+0xd2c>
    e1de:	3301      	adds	r3, #1
    e1e0:	3410      	adds	r4, #16
    e1e2:	2b07      	cmp	r3, #7
    e1e4:	9427      	str	r4, [sp, #156]	; 0x9c
    e1e6:	9326      	str	r3, [sp, #152]	; 0x98
    e1e8:	e888 00a0 	stmia.w	r8, {r5, r7}
    e1ec:	ddf1      	ble.n	e1d2 <_vfprintf_r+0x99a>
    e1ee:	aa25      	add	r2, sp, #148	; 0x94
    e1f0:	4659      	mov	r1, fp
    e1f2:	4650      	mov	r0, sl
    e1f4:	f7fe fc8c 	bl	cb10 <__sprint_r>
    e1f8:	2800      	cmp	r0, #0
    e1fa:	f040 83d3 	bne.w	e9a4 <_vfprintf_r+0x116c>
    e1fe:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e200:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e202:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e206:	e7e6      	b.n	e1d6 <_vfprintf_r+0x99e>
    e208:	46aa      	mov	sl, r5
    e20a:	e78c      	b.n	e126 <_vfprintf_r+0x8ee>
    e20c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    e20e:	9a07      	ldr	r2, [sp, #28]
    e210:	eba3 0a02 	sub.w	sl, r3, r2
    e214:	f1ba 0f00 	cmp.w	sl, #0
    e218:	f77f acc0 	ble.w	db9c <_vfprintf_r+0x364>
    e21c:	f1ba 0f10 	cmp.w	sl, #16
    e220:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e222:	4d0b      	ldr	r5, [pc, #44]	; (e250 <_vfprintf_r+0xa18>)
    e224:	dd38      	ble.n	e298 <_vfprintf_r+0xa60>
    e226:	4642      	mov	r2, r8
    e228:	4621      	mov	r1, r4
    e22a:	46b0      	mov	r8, r6
    e22c:	f04f 0b10 	mov.w	fp, #16
    e230:	462e      	mov	r6, r5
    e232:	9c08      	ldr	r4, [sp, #32]
    e234:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    e236:	e014      	b.n	e262 <_vfprintf_r+0xa2a>
    e238:	00012a10 	.word	0x00012a10
    e23c:	000129fc 	.word	0x000129fc
    e240:	7fefffff 	.word	0x7fefffff
    e244:	000129f0 	.word	0x000129f0
    e248:	000129ec 	.word	0x000129ec
    e24c:	00012a2c 	.word	0x00012a2c
    e250:	00012a80 	.word	0x00012a80
    e254:	f1aa 0a10 	sub.w	sl, sl, #16
    e258:	f1ba 0f10 	cmp.w	sl, #16
    e25c:	f102 0208 	add.w	r2, r2, #8
    e260:	dd16      	ble.n	e290 <_vfprintf_r+0xa58>
    e262:	3301      	adds	r3, #1
    e264:	3110      	adds	r1, #16
    e266:	2b07      	cmp	r3, #7
    e268:	9127      	str	r1, [sp, #156]	; 0x9c
    e26a:	9326      	str	r3, [sp, #152]	; 0x98
    e26c:	e882 0840 	stmia.w	r2, {r6, fp}
    e270:	ddf0      	ble.n	e254 <_vfprintf_r+0xa1c>
    e272:	aa25      	add	r2, sp, #148	; 0x94
    e274:	4629      	mov	r1, r5
    e276:	4620      	mov	r0, r4
    e278:	f7fe fc4a 	bl	cb10 <__sprint_r>
    e27c:	2800      	cmp	r0, #0
    e27e:	d1c3      	bne.n	e208 <_vfprintf_r+0x9d0>
    e280:	f1aa 0a10 	sub.w	sl, sl, #16
    e284:	f1ba 0f10 	cmp.w	sl, #16
    e288:	9927      	ldr	r1, [sp, #156]	; 0x9c
    e28a:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e28c:	aa32      	add	r2, sp, #200	; 0xc8
    e28e:	dce8      	bgt.n	e262 <_vfprintf_r+0xa2a>
    e290:	4635      	mov	r5, r6
    e292:	460c      	mov	r4, r1
    e294:	4646      	mov	r6, r8
    e296:	4690      	mov	r8, r2
    e298:	3301      	adds	r3, #1
    e29a:	4454      	add	r4, sl
    e29c:	2b07      	cmp	r3, #7
    e29e:	9427      	str	r4, [sp, #156]	; 0x9c
    e2a0:	9326      	str	r3, [sp, #152]	; 0x98
    e2a2:	e888 0420 	stmia.w	r8, {r5, sl}
    e2a6:	f300 8265 	bgt.w	e774 <_vfprintf_r+0xf3c>
    e2aa:	f108 0808 	add.w	r8, r8, #8
    e2ae:	e475      	b.n	db9c <_vfprintf_r+0x364>
    e2b0:	9b11      	ldr	r3, [sp, #68]	; 0x44
    e2b2:	9e26      	ldr	r6, [sp, #152]	; 0x98
    e2b4:	2b01      	cmp	r3, #1
    e2b6:	f340 81fe 	ble.w	e6b6 <_vfprintf_r+0xe7e>
    e2ba:	3601      	adds	r6, #1
    e2bc:	3401      	adds	r4, #1
    e2be:	2301      	movs	r3, #1
    e2c0:	2e07      	cmp	r6, #7
    e2c2:	9427      	str	r4, [sp, #156]	; 0x9c
    e2c4:	9626      	str	r6, [sp, #152]	; 0x98
    e2c6:	f8c8 7000 	str.w	r7, [r8]
    e2ca:	f8c8 3004 	str.w	r3, [r8, #4]
    e2ce:	f300 820f 	bgt.w	e6f0 <_vfprintf_r+0xeb8>
    e2d2:	f108 0808 	add.w	r8, r8, #8
    e2d6:	9a14      	ldr	r2, [sp, #80]	; 0x50
    e2d8:	9b15      	ldr	r3, [sp, #84]	; 0x54
    e2da:	f8c8 3000 	str.w	r3, [r8]
    e2de:	3601      	adds	r6, #1
    e2e0:	4414      	add	r4, r2
    e2e2:	2e07      	cmp	r6, #7
    e2e4:	9427      	str	r4, [sp, #156]	; 0x9c
    e2e6:	9626      	str	r6, [sp, #152]	; 0x98
    e2e8:	f8c8 2004 	str.w	r2, [r8, #4]
    e2ec:	f300 820d 	bgt.w	e70a <_vfprintf_r+0xed2>
    e2f0:	f108 0808 	add.w	r8, r8, #8
    e2f4:	2300      	movs	r3, #0
    e2f6:	2200      	movs	r2, #0
    e2f8:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    e2fc:	f7f3 f84e 	bl	139c <__aeabi_dcmpeq>
    e300:	9b11      	ldr	r3, [sp, #68]	; 0x44
    e302:	2800      	cmp	r0, #0
    e304:	f040 8106 	bne.w	e514 <_vfprintf_r+0xcdc>
    e308:	3b01      	subs	r3, #1
    e30a:	3601      	adds	r6, #1
    e30c:	3701      	adds	r7, #1
    e30e:	441c      	add	r4, r3
    e310:	2e07      	cmp	r6, #7
    e312:	9626      	str	r6, [sp, #152]	; 0x98
    e314:	9427      	str	r4, [sp, #156]	; 0x9c
    e316:	f8c8 7000 	str.w	r7, [r8]
    e31a:	f8c8 3004 	str.w	r3, [r8, #4]
    e31e:	f300 81da 	bgt.w	e6d6 <_vfprintf_r+0xe9e>
    e322:	f108 0808 	add.w	r8, r8, #8
    e326:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    e328:	f8c8 2004 	str.w	r2, [r8, #4]
    e32c:	3601      	adds	r6, #1
    e32e:	4414      	add	r4, r2
    e330:	ab21      	add	r3, sp, #132	; 0x84
    e332:	2e07      	cmp	r6, #7
    e334:	9427      	str	r4, [sp, #156]	; 0x9c
    e336:	9626      	str	r6, [sp, #152]	; 0x98
    e338:	f8c8 3000 	str.w	r3, [r8]
    e33c:	f77f ac82 	ble.w	dc44 <_vfprintf_r+0x40c>
    e340:	aa25      	add	r2, sp, #148	; 0x94
    e342:	990a      	ldr	r1, [sp, #40]	; 0x28
    e344:	9808      	ldr	r0, [sp, #32]
    e346:	f7fe fbe3 	bl	cb10 <__sprint_r>
    e34a:	b958      	cbnz	r0, e364 <_vfprintf_r+0xb2c>
    e34c:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e34e:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e352:	e479      	b.n	dc48 <_vfprintf_r+0x410>
    e354:	aa25      	add	r2, sp, #148	; 0x94
    e356:	990a      	ldr	r1, [sp, #40]	; 0x28
    e358:	9808      	ldr	r0, [sp, #32]
    e35a:	f7fe fbd9 	bl	cb10 <__sprint_r>
    e35e:	2800      	cmp	r0, #0
    e360:	f43f acbc 	beq.w	dcdc <_vfprintf_r+0x4a4>
    e364:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    e368:	e6dd      	b.n	e126 <_vfprintf_r+0x8ee>
    e36a:	f8dd b018 	ldr.w	fp, [sp, #24]
    e36e:	2b01      	cmp	r3, #1
    e370:	f000 8121 	beq.w	e5b6 <_vfprintf_r+0xd7e>
    e374:	2b02      	cmp	r3, #2
    e376:	d127      	bne.n	e3c8 <_vfprintf_r+0xb90>
    e378:	f8cd b018 	str.w	fp, [sp, #24]
    e37c:	2400      	movs	r4, #0
    e37e:	2500      	movs	r5, #0
    e380:	e589      	b.n	de96 <_vfprintf_r+0x65e>
    e382:	aa25      	add	r2, sp, #148	; 0x94
    e384:	990a      	ldr	r1, [sp, #40]	; 0x28
    e386:	9808      	ldr	r0, [sp, #32]
    e388:	f7fe fbc2 	bl	cb10 <__sprint_r>
    e38c:	2800      	cmp	r0, #0
    e38e:	d1e9      	bne.n	e364 <_vfprintf_r+0xb2c>
    e390:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e392:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e396:	e444      	b.n	dc22 <_vfprintf_r+0x3ea>
    e398:	aa25      	add	r2, sp, #148	; 0x94
    e39a:	990a      	ldr	r1, [sp, #40]	; 0x28
    e39c:	9808      	ldr	r0, [sp, #32]
    e39e:	f7fe fbb7 	bl	cb10 <__sprint_r>
    e3a2:	2800      	cmp	r0, #0
    e3a4:	d1de      	bne.n	e364 <_vfprintf_r+0xb2c>
    e3a6:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e3a8:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e3ac:	f7ff bbe3 	b.w	db76 <_vfprintf_r+0x33e>
    e3b0:	aa25      	add	r2, sp, #148	; 0x94
    e3b2:	990a      	ldr	r1, [sp, #40]	; 0x28
    e3b4:	9808      	ldr	r0, [sp, #32]
    e3b6:	f7fe fbab 	bl	cb10 <__sprint_r>
    e3ba:	2800      	cmp	r0, #0
    e3bc:	d1d2      	bne.n	e364 <_vfprintf_r+0xb2c>
    e3be:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e3c0:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e3c4:	f7ff bbe7 	b.w	db96 <_vfprintf_r+0x35e>
    e3c8:	f8cd b018 	str.w	fp, [sp, #24]
    e3cc:	2400      	movs	r4, #0
    e3ce:	2500      	movs	r5, #0
    e3d0:	a932      	add	r1, sp, #200	; 0xc8
    e3d2:	e000      	b.n	e3d6 <_vfprintf_r+0xb9e>
    e3d4:	4639      	mov	r1, r7
    e3d6:	08e2      	lsrs	r2, r4, #3
    e3d8:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
    e3dc:	08e8      	lsrs	r0, r5, #3
    e3de:	f004 0307 	and.w	r3, r4, #7
    e3e2:	4605      	mov	r5, r0
    e3e4:	4614      	mov	r4, r2
    e3e6:	3330      	adds	r3, #48	; 0x30
    e3e8:	ea54 0205 	orrs.w	r2, r4, r5
    e3ec:	f801 3c01 	strb.w	r3, [r1, #-1]
    e3f0:	f101 37ff 	add.w	r7, r1, #4294967295	; 0xffffffff
    e3f4:	d1ee      	bne.n	e3d4 <_vfprintf_r+0xb9c>
    e3f6:	9a06      	ldr	r2, [sp, #24]
    e3f8:	07d2      	lsls	r2, r2, #31
    e3fa:	f57f ad5c 	bpl.w	deb6 <_vfprintf_r+0x67e>
    e3fe:	2b30      	cmp	r3, #48	; 0x30
    e400:	f43f ad59 	beq.w	deb6 <_vfprintf_r+0x67e>
    e404:	2330      	movs	r3, #48	; 0x30
    e406:	3902      	subs	r1, #2
    e408:	f807 3c01 	strb.w	r3, [r7, #-1]
    e40c:	ab32      	add	r3, sp, #200	; 0xc8
    e40e:	1a5b      	subs	r3, r3, r1
    e410:	930d      	str	r3, [sp, #52]	; 0x34
    e412:	460f      	mov	r7, r1
    e414:	f7ff bb39 	b.w	da8a <_vfprintf_r+0x252>
    e418:	2302      	movs	r3, #2
    e41a:	f7ff bb18 	b.w	da4e <_vfprintf_r+0x216>
    e41e:	991f      	ldr	r1, [sp, #124]	; 0x7c
    e420:	2900      	cmp	r1, #0
    e422:	f340 827b 	ble.w	e91c <_vfprintf_r+0x10e4>
    e426:	9b10      	ldr	r3, [sp, #64]	; 0x40
    e428:	9a11      	ldr	r2, [sp, #68]	; 0x44
    e42a:	4293      	cmp	r3, r2
    e42c:	bfa8      	it	ge
    e42e:	4613      	movge	r3, r2
    e430:	2b00      	cmp	r3, #0
    e432:	461e      	mov	r6, r3
    e434:	dd0d      	ble.n	e452 <_vfprintf_r+0xc1a>
    e436:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e438:	f8c8 7000 	str.w	r7, [r8]
    e43c:	3301      	adds	r3, #1
    e43e:	4434      	add	r4, r6
    e440:	2b07      	cmp	r3, #7
    e442:	9427      	str	r4, [sp, #156]	; 0x9c
    e444:	f8c8 6004 	str.w	r6, [r8, #4]
    e448:	9326      	str	r3, [sp, #152]	; 0x98
    e44a:	f300 832d 	bgt.w	eaa8 <_vfprintf_r+0x1270>
    e44e:	f108 0808 	add.w	r8, r8, #8
    e452:	9b10      	ldr	r3, [sp, #64]	; 0x40
    e454:	2e00      	cmp	r6, #0
    e456:	bfa8      	it	ge
    e458:	1b9b      	subge	r3, r3, r6
    e45a:	2b00      	cmp	r3, #0
    e45c:	461e      	mov	r6, r3
    e45e:	f340 80d0 	ble.w	e602 <_vfprintf_r+0xdca>
    e462:	2e10      	cmp	r6, #16
    e464:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e466:	4dba      	ldr	r5, [pc, #744]	; (e750 <_vfprintf_r+0xf18>)
    e468:	f340 80b7 	ble.w	e5da <_vfprintf_r+0xda2>
    e46c:	4622      	mov	r2, r4
    e46e:	f04f 0a10 	mov.w	sl, #16
    e472:	f8dd b020 	ldr.w	fp, [sp, #32]
    e476:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    e478:	e005      	b.n	e486 <_vfprintf_r+0xc4e>
    e47a:	f108 0808 	add.w	r8, r8, #8
    e47e:	3e10      	subs	r6, #16
    e480:	2e10      	cmp	r6, #16
    e482:	f340 80a9 	ble.w	e5d8 <_vfprintf_r+0xda0>
    e486:	3301      	adds	r3, #1
    e488:	3210      	adds	r2, #16
    e48a:	2b07      	cmp	r3, #7
    e48c:	9227      	str	r2, [sp, #156]	; 0x9c
    e48e:	9326      	str	r3, [sp, #152]	; 0x98
    e490:	e888 0420 	stmia.w	r8, {r5, sl}
    e494:	ddf1      	ble.n	e47a <_vfprintf_r+0xc42>
    e496:	aa25      	add	r2, sp, #148	; 0x94
    e498:	4621      	mov	r1, r4
    e49a:	4658      	mov	r0, fp
    e49c:	f7fe fb38 	bl	cb10 <__sprint_r>
    e4a0:	2800      	cmp	r0, #0
    e4a2:	f040 832b 	bne.w	eafc <_vfprintf_r+0x12c4>
    e4a6:	9a27      	ldr	r2, [sp, #156]	; 0x9c
    e4a8:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e4aa:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e4ae:	e7e6      	b.n	e47e <_vfprintf_r+0xc46>
    e4b0:	2d00      	cmp	r5, #0
    e4b2:	bf08      	it	eq
    e4b4:	2c0a      	cmpeq	r4, #10
    e4b6:	d37c      	bcc.n	e5b2 <_vfprintf_r+0xd7a>
    e4b8:	af32      	add	r7, sp, #200	; 0xc8
    e4ba:	4620      	mov	r0, r4
    e4bc:	4629      	mov	r1, r5
    e4be:	220a      	movs	r2, #10
    e4c0:	2300      	movs	r3, #0
    e4c2:	f7f2 ffdb 	bl	147c <__aeabi_uldivmod>
    e4c6:	3230      	adds	r2, #48	; 0x30
    e4c8:	f807 2d01 	strb.w	r2, [r7, #-1]!
    e4cc:	4620      	mov	r0, r4
    e4ce:	4629      	mov	r1, r5
    e4d0:	2300      	movs	r3, #0
    e4d2:	220a      	movs	r2, #10
    e4d4:	f7f2 ffd2 	bl	147c <__aeabi_uldivmod>
    e4d8:	4604      	mov	r4, r0
    e4da:	460d      	mov	r5, r1
    e4dc:	ea54 0305 	orrs.w	r3, r4, r5
    e4e0:	d1eb      	bne.n	e4ba <_vfprintf_r+0xc82>
    e4e2:	ab32      	add	r3, sp, #200	; 0xc8
    e4e4:	1bdb      	subs	r3, r3, r7
    e4e6:	930d      	str	r3, [sp, #52]	; 0x34
    e4e8:	f7ff bacf 	b.w	da8a <_vfprintf_r+0x252>
    e4ec:	9b09      	ldr	r3, [sp, #36]	; 0x24
    e4ee:	930d      	str	r3, [sp, #52]	; 0x34
    e4f0:	af32      	add	r7, sp, #200	; 0xc8
    e4f2:	f7ff baca 	b.w	da8a <_vfprintf_r+0x252>
    e4f6:	aa25      	add	r2, sp, #148	; 0x94
    e4f8:	990a      	ldr	r1, [sp, #40]	; 0x28
    e4fa:	9808      	ldr	r0, [sp, #32]
    e4fc:	f7fe fb08 	bl	cb10 <__sprint_r>
    e500:	2800      	cmp	r0, #0
    e502:	f47f af2f 	bne.w	e364 <_vfprintf_r+0xb2c>
    e506:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
    e50a:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e50c:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e510:	f7ff bb1f 	b.w	db52 <_vfprintf_r+0x31a>
    e514:	1e5f      	subs	r7, r3, #1
    e516:	2f00      	cmp	r7, #0
    e518:	f77f af05 	ble.w	e326 <_vfprintf_r+0xaee>
    e51c:	2f10      	cmp	r7, #16
    e51e:	4d8c      	ldr	r5, [pc, #560]	; (e750 <_vfprintf_r+0xf18>)
    e520:	f340 8100 	ble.w	e724 <_vfprintf_r+0xeec>
    e524:	f04f 0a10 	mov.w	sl, #16
    e528:	f8dd b020 	ldr.w	fp, [sp, #32]
    e52c:	e005      	b.n	e53a <_vfprintf_r+0xd02>
    e52e:	f108 0808 	add.w	r8, r8, #8
    e532:	3f10      	subs	r7, #16
    e534:	2f10      	cmp	r7, #16
    e536:	f340 80f5 	ble.w	e724 <_vfprintf_r+0xeec>
    e53a:	3601      	adds	r6, #1
    e53c:	3410      	adds	r4, #16
    e53e:	2e07      	cmp	r6, #7
    e540:	9427      	str	r4, [sp, #156]	; 0x9c
    e542:	9626      	str	r6, [sp, #152]	; 0x98
    e544:	e888 0420 	stmia.w	r8, {r5, sl}
    e548:	ddf1      	ble.n	e52e <_vfprintf_r+0xcf6>
    e54a:	aa25      	add	r2, sp, #148	; 0x94
    e54c:	990a      	ldr	r1, [sp, #40]	; 0x28
    e54e:	4658      	mov	r0, fp
    e550:	f7fe fade 	bl	cb10 <__sprint_r>
    e554:	2800      	cmp	r0, #0
    e556:	f47f af05 	bne.w	e364 <_vfprintf_r+0xb2c>
    e55a:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e55c:	9e26      	ldr	r6, [sp, #152]	; 0x98
    e55e:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e562:	e7e6      	b.n	e532 <_vfprintf_r+0xcfa>
    e564:	3301      	adds	r3, #1
    e566:	4434      	add	r4, r6
    e568:	2b07      	cmp	r3, #7
    e56a:	9427      	str	r4, [sp, #156]	; 0x9c
    e56c:	9326      	str	r3, [sp, #152]	; 0x98
    e56e:	e888 0060 	stmia.w	r8, {r5, r6}
    e572:	f77f ab67 	ble.w	dc44 <_vfprintf_r+0x40c>
    e576:	e6e3      	b.n	e340 <_vfprintf_r+0xb08>
    e578:	681c      	ldr	r4, [r3, #0]
    e57a:	3304      	adds	r3, #4
    e57c:	930e      	str	r3, [sp, #56]	; 0x38
    e57e:	2500      	movs	r5, #0
    e580:	e41b      	b.n	ddba <_vfprintf_r+0x582>
    e582:	990e      	ldr	r1, [sp, #56]	; 0x38
    e584:	460a      	mov	r2, r1
    e586:	3204      	adds	r2, #4
    e588:	680c      	ldr	r4, [r1, #0]
    e58a:	920e      	str	r2, [sp, #56]	; 0x38
    e58c:	2500      	movs	r5, #0
    e58e:	f7ff ba5e 	b.w	da4e <_vfprintf_r+0x216>
    e592:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    e594:	6814      	ldr	r4, [r2, #0]
    e596:	4613      	mov	r3, r2
    e598:	3304      	adds	r3, #4
    e59a:	17e5      	asrs	r5, r4, #31
    e59c:	930e      	str	r3, [sp, #56]	; 0x38
    e59e:	4622      	mov	r2, r4
    e5a0:	462b      	mov	r3, r5
    e5a2:	e45f      	b.n	de64 <_vfprintf_r+0x62c>
    e5a4:	3204      	adds	r2, #4
    e5a6:	681c      	ldr	r4, [r3, #0]
    e5a8:	920e      	str	r2, [sp, #56]	; 0x38
    e5aa:	2301      	movs	r3, #1
    e5ac:	2500      	movs	r5, #0
    e5ae:	f7ff ba4e 	b.w	da4e <_vfprintf_r+0x216>
    e5b2:	f8dd b018 	ldr.w	fp, [sp, #24]
    e5b6:	f8cd b018 	str.w	fp, [sp, #24]
    e5ba:	af42      	add	r7, sp, #264	; 0x108
    e5bc:	3430      	adds	r4, #48	; 0x30
    e5be:	2301      	movs	r3, #1
    e5c0:	f807 4d41 	strb.w	r4, [r7, #-65]!
    e5c4:	930d      	str	r3, [sp, #52]	; 0x34
    e5c6:	f7ff ba60 	b.w	da8a <_vfprintf_r+0x252>
    e5ca:	f8da 0058 	ldr.w	r0, [sl, #88]	; 0x58
    e5ce:	f7fc fba5 	bl	ad1c <__retarget_lock_release_recursive>
    e5d2:	f8ba 300c 	ldrh.w	r3, [sl, #12]
    e5d6:	e5b0      	b.n	e13a <_vfprintf_r+0x902>
    e5d8:	4614      	mov	r4, r2
    e5da:	3301      	adds	r3, #1
    e5dc:	4434      	add	r4, r6
    e5de:	2b07      	cmp	r3, #7
    e5e0:	9427      	str	r4, [sp, #156]	; 0x9c
    e5e2:	9326      	str	r3, [sp, #152]	; 0x98
    e5e4:	e888 0060 	stmia.w	r8, {r5, r6}
    e5e8:	f340 8174 	ble.w	e8d4 <_vfprintf_r+0x109c>
    e5ec:	aa25      	add	r2, sp, #148	; 0x94
    e5ee:	990a      	ldr	r1, [sp, #40]	; 0x28
    e5f0:	9808      	ldr	r0, [sp, #32]
    e5f2:	f7fe fa8d 	bl	cb10 <__sprint_r>
    e5f6:	2800      	cmp	r0, #0
    e5f8:	f47f aeb4 	bne.w	e364 <_vfprintf_r+0xb2c>
    e5fc:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e5fe:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e602:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    e604:	9a11      	ldr	r2, [sp, #68]	; 0x44
    e606:	4293      	cmp	r3, r2
    e608:	f280 815f 	bge.w	e8ca <_vfprintf_r+0x1092>
    e60c:	9a26      	ldr	r2, [sp, #152]	; 0x98
    e60e:	9814      	ldr	r0, [sp, #80]	; 0x50
    e610:	9915      	ldr	r1, [sp, #84]	; 0x54
    e612:	f8c8 1000 	str.w	r1, [r8]
    e616:	3201      	adds	r2, #1
    e618:	4404      	add	r4, r0
    e61a:	2a07      	cmp	r2, #7
    e61c:	9427      	str	r4, [sp, #156]	; 0x9c
    e61e:	f8c8 0004 	str.w	r0, [r8, #4]
    e622:	9226      	str	r2, [sp, #152]	; 0x98
    e624:	f300 8159 	bgt.w	e8da <_vfprintf_r+0x10a2>
    e628:	f108 0808 	add.w	r8, r8, #8
    e62c:	9a11      	ldr	r2, [sp, #68]	; 0x44
    e62e:	9910      	ldr	r1, [sp, #64]	; 0x40
    e630:	1ad3      	subs	r3, r2, r3
    e632:	1a56      	subs	r6, r2, r1
    e634:	429e      	cmp	r6, r3
    e636:	bfa8      	it	ge
    e638:	461e      	movge	r6, r3
    e63a:	2e00      	cmp	r6, #0
    e63c:	dd0e      	ble.n	e65c <_vfprintf_r+0xe24>
    e63e:	9a26      	ldr	r2, [sp, #152]	; 0x98
    e640:	f8c8 6004 	str.w	r6, [r8, #4]
    e644:	3201      	adds	r2, #1
    e646:	440f      	add	r7, r1
    e648:	4434      	add	r4, r6
    e64a:	2a07      	cmp	r2, #7
    e64c:	f8c8 7000 	str.w	r7, [r8]
    e650:	9427      	str	r4, [sp, #156]	; 0x9c
    e652:	9226      	str	r2, [sp, #152]	; 0x98
    e654:	f300 8243 	bgt.w	eade <_vfprintf_r+0x12a6>
    e658:	f108 0808 	add.w	r8, r8, #8
    e65c:	2e00      	cmp	r6, #0
    e65e:	bfac      	ite	ge
    e660:	1b9e      	subge	r6, r3, r6
    e662:	461e      	movlt	r6, r3
    e664:	2e00      	cmp	r6, #0
    e666:	f77f aaef 	ble.w	dc48 <_vfprintf_r+0x410>
    e66a:	2e10      	cmp	r6, #16
    e66c:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e66e:	4d38      	ldr	r5, [pc, #224]	; (e750 <_vfprintf_r+0xf18>)
    e670:	f77f af78 	ble.w	e564 <_vfprintf_r+0xd2c>
    e674:	2710      	movs	r7, #16
    e676:	f8dd a020 	ldr.w	sl, [sp, #32]
    e67a:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    e67e:	e005      	b.n	e68c <_vfprintf_r+0xe54>
    e680:	f108 0808 	add.w	r8, r8, #8
    e684:	3e10      	subs	r6, #16
    e686:	2e10      	cmp	r6, #16
    e688:	f77f af6c 	ble.w	e564 <_vfprintf_r+0xd2c>
    e68c:	3301      	adds	r3, #1
    e68e:	3410      	adds	r4, #16
    e690:	2b07      	cmp	r3, #7
    e692:	9427      	str	r4, [sp, #156]	; 0x9c
    e694:	9326      	str	r3, [sp, #152]	; 0x98
    e696:	e888 00a0 	stmia.w	r8, {r5, r7}
    e69a:	ddf1      	ble.n	e680 <_vfprintf_r+0xe48>
    e69c:	aa25      	add	r2, sp, #148	; 0x94
    e69e:	4659      	mov	r1, fp
    e6a0:	4650      	mov	r0, sl
    e6a2:	f7fe fa35 	bl	cb10 <__sprint_r>
    e6a6:	2800      	cmp	r0, #0
    e6a8:	f040 817c 	bne.w	e9a4 <_vfprintf_r+0x116c>
    e6ac:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e6ae:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e6b0:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e6b4:	e7e6      	b.n	e684 <_vfprintf_r+0xe4c>
    e6b6:	9b06      	ldr	r3, [sp, #24]
    e6b8:	07d8      	lsls	r0, r3, #31
    e6ba:	f53f adfe 	bmi.w	e2ba <_vfprintf_r+0xa82>
    e6be:	3601      	adds	r6, #1
    e6c0:	3401      	adds	r4, #1
    e6c2:	2301      	movs	r3, #1
    e6c4:	2e07      	cmp	r6, #7
    e6c6:	9427      	str	r4, [sp, #156]	; 0x9c
    e6c8:	9626      	str	r6, [sp, #152]	; 0x98
    e6ca:	f8c8 7000 	str.w	r7, [r8]
    e6ce:	f8c8 3004 	str.w	r3, [r8, #4]
    e6d2:	f77f ae26 	ble.w	e322 <_vfprintf_r+0xaea>
    e6d6:	aa25      	add	r2, sp, #148	; 0x94
    e6d8:	990a      	ldr	r1, [sp, #40]	; 0x28
    e6da:	9808      	ldr	r0, [sp, #32]
    e6dc:	f7fe fa18 	bl	cb10 <__sprint_r>
    e6e0:	2800      	cmp	r0, #0
    e6e2:	f47f ae3f 	bne.w	e364 <_vfprintf_r+0xb2c>
    e6e6:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e6e8:	9e26      	ldr	r6, [sp, #152]	; 0x98
    e6ea:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e6ee:	e61a      	b.n	e326 <_vfprintf_r+0xaee>
    e6f0:	aa25      	add	r2, sp, #148	; 0x94
    e6f2:	990a      	ldr	r1, [sp, #40]	; 0x28
    e6f4:	9808      	ldr	r0, [sp, #32]
    e6f6:	f7fe fa0b 	bl	cb10 <__sprint_r>
    e6fa:	2800      	cmp	r0, #0
    e6fc:	f47f ae32 	bne.w	e364 <_vfprintf_r+0xb2c>
    e700:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e702:	9e26      	ldr	r6, [sp, #152]	; 0x98
    e704:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e708:	e5e5      	b.n	e2d6 <_vfprintf_r+0xa9e>
    e70a:	aa25      	add	r2, sp, #148	; 0x94
    e70c:	990a      	ldr	r1, [sp, #40]	; 0x28
    e70e:	9808      	ldr	r0, [sp, #32]
    e710:	f7fe f9fe 	bl	cb10 <__sprint_r>
    e714:	2800      	cmp	r0, #0
    e716:	f47f ae25 	bne.w	e364 <_vfprintf_r+0xb2c>
    e71a:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e71c:	9e26      	ldr	r6, [sp, #152]	; 0x98
    e71e:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e722:	e5e7      	b.n	e2f4 <_vfprintf_r+0xabc>
    e724:	3601      	adds	r6, #1
    e726:	443c      	add	r4, r7
    e728:	2e07      	cmp	r6, #7
    e72a:	9427      	str	r4, [sp, #156]	; 0x9c
    e72c:	9626      	str	r6, [sp, #152]	; 0x98
    e72e:	e888 00a0 	stmia.w	r8, {r5, r7}
    e732:	f77f adf6 	ble.w	e322 <_vfprintf_r+0xaea>
    e736:	e7ce      	b.n	e6d6 <_vfprintf_r+0xe9e>
    e738:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    e73a:	3507      	adds	r5, #7
    e73c:	f025 0307 	bic.w	r3, r5, #7
    e740:	f103 0208 	add.w	r2, r3, #8
    e744:	920e      	str	r2, [sp, #56]	; 0x38
    e746:	e9d3 4500 	ldrd	r4, r5, [r3]
    e74a:	f7ff bb36 	b.w	ddba <_vfprintf_r+0x582>
    e74e:	bf00      	nop
    e750:	00012a80 	.word	0x00012a80
    e754:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    e756:	3507      	adds	r5, #7
    e758:	f025 0507 	bic.w	r5, r5, #7
    e75c:	e9d5 2300 	ldrd	r2, r3, [r5]
    e760:	f105 0108 	add.w	r1, r5, #8
    e764:	910e      	str	r1, [sp, #56]	; 0x38
    e766:	4614      	mov	r4, r2
    e768:	461d      	mov	r5, r3
    e76a:	f7ff bb7b 	b.w	de64 <_vfprintf_r+0x62c>
    e76e:	af32      	add	r7, sp, #200	; 0xc8
    e770:	f7ff b98b 	b.w	da8a <_vfprintf_r+0x252>
    e774:	aa25      	add	r2, sp, #148	; 0x94
    e776:	990a      	ldr	r1, [sp, #40]	; 0x28
    e778:	9808      	ldr	r0, [sp, #32]
    e77a:	f7fe f9c9 	bl	cb10 <__sprint_r>
    e77e:	2800      	cmp	r0, #0
    e780:	f47f adf0 	bne.w	e364 <_vfprintf_r+0xb2c>
    e784:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e786:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e78a:	f7ff ba07 	b.w	db9c <_vfprintf_r+0x364>
    e78e:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
    e792:	4264      	negs	r4, r4
    e794:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
    e798:	f88d a077 	strb.w	sl, [sp, #119]	; 0x77
    e79c:	2301      	movs	r3, #1
    e79e:	f7ff b95a 	b.w	da56 <_vfprintf_r+0x21e>
    e7a2:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    e7a6:	4602      	mov	r2, r0
    e7a8:	460b      	mov	r3, r1
    e7aa:	f7f2 fe29 	bl	1400 <__aeabi_dcmpun>
    e7ae:	2800      	cmp	r0, #0
    e7b0:	f040 828d 	bne.w	ecce <_vfprintf_r+0x1496>
    e7b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    e7b6:	3301      	adds	r3, #1
    e7b8:	f026 0a20 	bic.w	sl, r6, #32
    e7bc:	f000 80a0 	beq.w	e900 <_vfprintf_r+0x10c8>
    e7c0:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
    e7c4:	d104      	bne.n	e7d0 <_vfprintf_r+0xf98>
    e7c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    e7c8:	2b00      	cmp	r3, #0
    e7ca:	bf08      	it	eq
    e7cc:	2301      	moveq	r3, #1
    e7ce:	9309      	str	r3, [sp, #36]	; 0x24
    e7d0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    e7d2:	f44b 7280 	orr.w	r2, fp, #256	; 0x100
    e7d6:	2b00      	cmp	r3, #0
    e7d8:	9206      	str	r2, [sp, #24]
    e7da:	f2c0 81aa 	blt.w	eb32 <_vfprintf_r+0x12fa>
    e7de:	ed9d 7b12 	vldr	d7, [sp, #72]	; 0x48
    e7e2:	ed8d 7b1a 	vstr	d7, [sp, #104]	; 0x68
    e7e6:	2300      	movs	r3, #0
    e7e8:	930f      	str	r3, [sp, #60]	; 0x3c
    e7ea:	2e66      	cmp	r6, #102	; 0x66
    e7ec:	f000 8189 	beq.w	eb02 <_vfprintf_r+0x12ca>
    e7f0:	2e46      	cmp	r6, #70	; 0x46
    e7f2:	f000 81db 	beq.w	ebac <_vfprintf_r+0x1374>
    e7f6:	f1ba 0f45 	cmp.w	sl, #69	; 0x45
    e7fa:	bf0a      	itet	eq
    e7fc:	9b09      	ldreq	r3, [sp, #36]	; 0x24
    e7fe:	9d09      	ldrne	r5, [sp, #36]	; 0x24
    e800:	1c5d      	addeq	r5, r3, #1
    e802:	a823      	add	r0, sp, #140	; 0x8c
    e804:	a920      	add	r1, sp, #128	; 0x80
    e806:	aa1f      	add	r2, sp, #124	; 0x7c
    e808:	2302      	movs	r3, #2
    e80a:	9004      	str	r0, [sp, #16]
    e80c:	9202      	str	r2, [sp, #8]
    e80e:	9300      	str	r3, [sp, #0]
    e810:	9501      	str	r5, [sp, #4]
    e812:	9103      	str	r1, [sp, #12]
    e814:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
    e818:	9808      	ldr	r0, [sp, #32]
    e81a:	f000 fcf1 	bl	f200 <_dtoa_r>
    e81e:	2e67      	cmp	r6, #103	; 0x67
    e820:	4607      	mov	r7, r0
    e822:	f040 81aa 	bne.w	eb7a <_vfprintf_r+0x1342>
    e826:	f01b 0f01 	tst.w	fp, #1
    e82a:	f000 8246 	beq.w	ecba <_vfprintf_r+0x1482>
    e82e:	197c      	adds	r4, r7, r5
    e830:	2200      	movs	r2, #0
    e832:	2300      	movs	r3, #0
    e834:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
    e838:	f7f2 fdb0 	bl	139c <__aeabi_dcmpeq>
    e83c:	2800      	cmp	r0, #0
    e83e:	f040 8131 	bne.w	eaa4 <_vfprintf_r+0x126c>
    e842:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    e844:	42a3      	cmp	r3, r4
    e846:	d206      	bcs.n	e856 <_vfprintf_r+0x101e>
    e848:	2130      	movs	r1, #48	; 0x30
    e84a:	1c5a      	adds	r2, r3, #1
    e84c:	9223      	str	r2, [sp, #140]	; 0x8c
    e84e:	7019      	strb	r1, [r3, #0]
    e850:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    e852:	429c      	cmp	r4, r3
    e854:	d8f9      	bhi.n	e84a <_vfprintf_r+0x1012>
    e856:	1bdb      	subs	r3, r3, r7
    e858:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
    e85c:	9311      	str	r3, [sp, #68]	; 0x44
    e85e:	f000 80c4 	beq.w	e9ea <_vfprintf_r+0x11b2>
    e862:	2e65      	cmp	r6, #101	; 0x65
    e864:	f340 8289 	ble.w	ed7a <_vfprintf_r+0x1542>
    e868:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    e86a:	9310      	str	r3, [sp, #64]	; 0x40
    e86c:	2e66      	cmp	r6, #102	; 0x66
    e86e:	f000 8176 	beq.w	eb5e <_vfprintf_r+0x1326>
    e872:	9b11      	ldr	r3, [sp, #68]	; 0x44
    e874:	9a10      	ldr	r2, [sp, #64]	; 0x40
    e876:	4619      	mov	r1, r3
    e878:	4291      	cmp	r1, r2
    e87a:	f300 8163 	bgt.w	eb44 <_vfprintf_r+0x130c>
    e87e:	f01b 0f01 	tst.w	fp, #1
    e882:	f040 8211 	bne.w	eca8 <_vfprintf_r+0x1470>
    e886:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    e88a:	9307      	str	r3, [sp, #28]
    e88c:	920d      	str	r2, [sp, #52]	; 0x34
    e88e:	2667      	movs	r6, #103	; 0x67
    e890:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    e892:	2b00      	cmp	r3, #0
    e894:	f040 80a1 	bne.w	e9da <_vfprintf_r+0x11a2>
    e898:	9309      	str	r3, [sp, #36]	; 0x24
    e89a:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
    e89e:	f7ff b8fc 	b.w	da9a <_vfprintf_r+0x262>
    e8a2:	f025 0507 	bic.w	r5, r5, #7
    e8a6:	ed95 7b00 	vldr	d7, [r5]
    e8aa:	f105 0308 	add.w	r3, r5, #8
    e8ae:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
    e8b2:	930e      	str	r3, [sp, #56]	; 0x38
    e8b4:	f7ff bbc1 	b.w	e03a <_vfprintf_r+0x802>
    e8b8:	f8da 0058 	ldr.w	r0, [sl, #88]	; 0x58
    e8bc:	f7fc fa2e 	bl	ad1c <__retarget_lock_release_recursive>
    e8c0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    e8c4:	930b      	str	r3, [sp, #44]	; 0x2c
    e8c6:	f7ff ba20 	b.w	dd0a <_vfprintf_r+0x4d2>
    e8ca:	9a06      	ldr	r2, [sp, #24]
    e8cc:	07d5      	lsls	r5, r2, #31
    e8ce:	f57f aead 	bpl.w	e62c <_vfprintf_r+0xdf4>
    e8d2:	e69b      	b.n	e60c <_vfprintf_r+0xdd4>
    e8d4:	f108 0808 	add.w	r8, r8, #8
    e8d8:	e693      	b.n	e602 <_vfprintf_r+0xdca>
    e8da:	aa25      	add	r2, sp, #148	; 0x94
    e8dc:	990a      	ldr	r1, [sp, #40]	; 0x28
    e8de:	9808      	ldr	r0, [sp, #32]
    e8e0:	f7fe f916 	bl	cb10 <__sprint_r>
    e8e4:	2800      	cmp	r0, #0
    e8e6:	f47f ad3d 	bne.w	e364 <_vfprintf_r+0xb2c>
    e8ea:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    e8ec:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e8ee:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e8f2:	e69b      	b.n	e62c <_vfprintf_r+0xdf4>
    e8f4:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
    e8f8:	f88d a077 	strb.w	sl, [sp, #119]	; 0x77
    e8fc:	f7ff bbc4 	b.w	e088 <_vfprintf_r+0x850>
    e900:	2306      	movs	r3, #6
    e902:	9309      	str	r3, [sp, #36]	; 0x24
    e904:	e764      	b.n	e7d0 <_vfprintf_r+0xf98>
    e906:	aa25      	add	r2, sp, #148	; 0x94
    e908:	990a      	ldr	r1, [sp, #40]	; 0x28
    e90a:	9808      	ldr	r0, [sp, #32]
    e90c:	f7fe f900 	bl	cb10 <__sprint_r>
    e910:	2800      	cmp	r0, #0
    e912:	f47f ad27 	bne.w	e364 <_vfprintf_r+0xb2c>
    e916:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e91a:	e431      	b.n	e180 <_vfprintf_r+0x948>
    e91c:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e91e:	4ab2      	ldr	r2, [pc, #712]	; (ebe8 <_vfprintf_r+0x13b0>)
    e920:	f8c8 2000 	str.w	r2, [r8]
    e924:	3301      	adds	r3, #1
    e926:	3401      	adds	r4, #1
    e928:	2201      	movs	r2, #1
    e92a:	2b07      	cmp	r3, #7
    e92c:	9427      	str	r4, [sp, #156]	; 0x9c
    e92e:	9326      	str	r3, [sp, #152]	; 0x98
    e930:	f8c8 2004 	str.w	r2, [r8, #4]
    e934:	f300 812d 	bgt.w	eb92 <_vfprintf_r+0x135a>
    e938:	f108 0808 	add.w	r8, r8, #8
    e93c:	b929      	cbnz	r1, e94a <_vfprintf_r+0x1112>
    e93e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    e940:	b91b      	cbnz	r3, e94a <_vfprintf_r+0x1112>
    e942:	9b06      	ldr	r3, [sp, #24]
    e944:	07de      	lsls	r6, r3, #31
    e946:	f57f a97f 	bpl.w	dc48 <_vfprintf_r+0x410>
    e94a:	9b26      	ldr	r3, [sp, #152]	; 0x98
    e94c:	9814      	ldr	r0, [sp, #80]	; 0x50
    e94e:	9a15      	ldr	r2, [sp, #84]	; 0x54
    e950:	f8c8 2000 	str.w	r2, [r8]
    e954:	3301      	adds	r3, #1
    e956:	4602      	mov	r2, r0
    e958:	4422      	add	r2, r4
    e95a:	2b07      	cmp	r3, #7
    e95c:	9227      	str	r2, [sp, #156]	; 0x9c
    e95e:	f8c8 0004 	str.w	r0, [r8, #4]
    e962:	9326      	str	r3, [sp, #152]	; 0x98
    e964:	f300 817a 	bgt.w	ec5c <_vfprintf_r+0x1424>
    e968:	f108 0808 	add.w	r8, r8, #8
    e96c:	2900      	cmp	r1, #0
    e96e:	f2c0 814f 	blt.w	ec10 <_vfprintf_r+0x13d8>
    e972:	9911      	ldr	r1, [sp, #68]	; 0x44
    e974:	f8c8 7000 	str.w	r7, [r8]
    e978:	3301      	adds	r3, #1
    e97a:	188c      	adds	r4, r1, r2
    e97c:	2b07      	cmp	r3, #7
    e97e:	9427      	str	r4, [sp, #156]	; 0x9c
    e980:	9326      	str	r3, [sp, #152]	; 0x98
    e982:	f8c8 1004 	str.w	r1, [r8, #4]
    e986:	f77f a95d 	ble.w	dc44 <_vfprintf_r+0x40c>
    e98a:	e4d9      	b.n	e340 <_vfprintf_r+0xb08>
    e98c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    e98e:	990b      	ldr	r1, [sp, #44]	; 0x2c
    e990:	6813      	ldr	r3, [r2, #0]
    e992:	17cd      	asrs	r5, r1, #31
    e994:	4608      	mov	r0, r1
    e996:	3204      	adds	r2, #4
    e998:	4629      	mov	r1, r5
    e99a:	920e      	str	r2, [sp, #56]	; 0x38
    e99c:	e9c3 0100 	strd	r0, r1, [r3]
    e9a0:	f7fe bf95 	b.w	d8ce <_vfprintf_r+0x96>
    e9a4:	46da      	mov	sl, fp
    e9a6:	f7ff bbbe 	b.w	e126 <_vfprintf_r+0x8ee>
    e9aa:	aa25      	add	r2, sp, #148	; 0x94
    e9ac:	990a      	ldr	r1, [sp, #40]	; 0x28
    e9ae:	9808      	ldr	r0, [sp, #32]
    e9b0:	f7fe f8ae 	bl	cb10 <__sprint_r>
    e9b4:	2800      	cmp	r0, #0
    e9b6:	f47f acd5 	bne.w	e364 <_vfprintf_r+0xb2c>
    e9ba:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    e9bc:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    e9c0:	f7ff bbf7 	b.w	e1b2 <_vfprintf_r+0x97a>
    e9c4:	4638      	mov	r0, r7
    e9c6:	9409      	str	r4, [sp, #36]	; 0x24
    e9c8:	f7f2 f85a 	bl	a80 <strlen>
    e9cc:	950e      	str	r5, [sp, #56]	; 0x38
    e9ce:	900d      	str	r0, [sp, #52]	; 0x34
    e9d0:	f8cd b018 	str.w	fp, [sp, #24]
    e9d4:	4603      	mov	r3, r0
    e9d6:	f7ff ba27 	b.w	de28 <_vfprintf_r+0x5f0>
    e9da:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
    e9de:	2300      	movs	r3, #0
    e9e0:	f88d a077 	strb.w	sl, [sp, #119]	; 0x77
    e9e4:	9309      	str	r3, [sp, #36]	; 0x24
    e9e6:	f7ff b85b 	b.w	daa0 <_vfprintf_r+0x268>
    e9ea:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    e9ec:	9310      	str	r3, [sp, #64]	; 0x40
    e9ee:	461a      	mov	r2, r3
    e9f0:	3303      	adds	r3, #3
    e9f2:	db04      	blt.n	e9fe <_vfprintf_r+0x11c6>
    e9f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    e9f6:	4619      	mov	r1, r3
    e9f8:	4291      	cmp	r1, r2
    e9fa:	f6bf af3a 	bge.w	e872 <_vfprintf_r+0x103a>
    e9fe:	3e02      	subs	r6, #2
    ea00:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ea02:	f88d 6084 	strb.w	r6, [sp, #132]	; 0x84
    ea06:	3b01      	subs	r3, #1
    ea08:	2b00      	cmp	r3, #0
    ea0a:	931f      	str	r3, [sp, #124]	; 0x7c
    ea0c:	bfbd      	ittte	lt
    ea0e:	9b10      	ldrlt	r3, [sp, #64]	; 0x40
    ea10:	f1c3 0301 	rsblt	r3, r3, #1
    ea14:	222d      	movlt	r2, #45	; 0x2d
    ea16:	222b      	movge	r2, #43	; 0x2b
    ea18:	2b09      	cmp	r3, #9
    ea1a:	f88d 2085 	strb.w	r2, [sp, #133]	; 0x85
    ea1e:	f340 814e 	ble.w	ecbe <_vfprintf_r+0x1486>
    ea22:	f10d 0493 	add.w	r4, sp, #147	; 0x93
    ea26:	4620      	mov	r0, r4
    ea28:	4d70      	ldr	r5, [pc, #448]	; (ebec <_vfprintf_r+0x13b4>)
    ea2a:	e000      	b.n	ea2e <_vfprintf_r+0x11f6>
    ea2c:	4610      	mov	r0, r2
    ea2e:	fb85 1203 	smull	r1, r2, r5, r3
    ea32:	17d9      	asrs	r1, r3, #31
    ea34:	ebc1 01a2 	rsb	r1, r1, r2, asr #2
    ea38:	eb01 0281 	add.w	r2, r1, r1, lsl #2
    ea3c:	eba3 0242 	sub.w	r2, r3, r2, lsl #1
    ea40:	3230      	adds	r2, #48	; 0x30
    ea42:	2909      	cmp	r1, #9
    ea44:	f800 2c01 	strb.w	r2, [r0, #-1]
    ea48:	460b      	mov	r3, r1
    ea4a:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    ea4e:	dced      	bgt.n	ea2c <_vfprintf_r+0x11f4>
    ea50:	3330      	adds	r3, #48	; 0x30
    ea52:	3802      	subs	r0, #2
    ea54:	b2d9      	uxtb	r1, r3
    ea56:	4284      	cmp	r4, r0
    ea58:	f802 1c01 	strb.w	r1, [r2, #-1]
    ea5c:	f240 8198 	bls.w	ed90 <_vfprintf_r+0x1558>
    ea60:	f10d 0086 	add.w	r0, sp, #134	; 0x86
    ea64:	4613      	mov	r3, r2
    ea66:	e001      	b.n	ea6c <_vfprintf_r+0x1234>
    ea68:	f813 1b01 	ldrb.w	r1, [r3], #1
    ea6c:	f800 1b01 	strb.w	r1, [r0], #1
    ea70:	42a3      	cmp	r3, r4
    ea72:	d1f9      	bne.n	ea68 <_vfprintf_r+0x1230>
    ea74:	3301      	adds	r3, #1
    ea76:	1a9b      	subs	r3, r3, r2
    ea78:	f10d 0286 	add.w	r2, sp, #134	; 0x86
    ea7c:	4413      	add	r3, r2
    ea7e:	aa21      	add	r2, sp, #132	; 0x84
    ea80:	1a9b      	subs	r3, r3, r2
    ea82:	9a11      	ldr	r2, [sp, #68]	; 0x44
    ea84:	9317      	str	r3, [sp, #92]	; 0x5c
    ea86:	2a01      	cmp	r2, #1
    ea88:	4413      	add	r3, r2
    ea8a:	930d      	str	r3, [sp, #52]	; 0x34
    ea8c:	f340 814c 	ble.w	ed28 <_vfprintf_r+0x14f0>
    ea90:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    ea92:	9a14      	ldr	r2, [sp, #80]	; 0x50
    ea94:	4413      	add	r3, r2
    ea96:	930d      	str	r3, [sp, #52]	; 0x34
    ea98:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    ea9c:	9307      	str	r3, [sp, #28]
    ea9e:	2300      	movs	r3, #0
    eaa0:	9310      	str	r3, [sp, #64]	; 0x40
    eaa2:	e6f5      	b.n	e890 <_vfprintf_r+0x1058>
    eaa4:	4623      	mov	r3, r4
    eaa6:	e6d6      	b.n	e856 <_vfprintf_r+0x101e>
    eaa8:	aa25      	add	r2, sp, #148	; 0x94
    eaaa:	990a      	ldr	r1, [sp, #40]	; 0x28
    eaac:	9808      	ldr	r0, [sp, #32]
    eaae:	f7fe f82f 	bl	cb10 <__sprint_r>
    eab2:	2800      	cmp	r0, #0
    eab4:	f47f ac56 	bne.w	e364 <_vfprintf_r+0xb2c>
    eab8:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    eaba:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    eabe:	e4c8      	b.n	e452 <_vfprintf_r+0xc1a>
    eac0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    eac2:	9710      	str	r7, [sp, #64]	; 0x40
    eac4:	2b06      	cmp	r3, #6
    eac6:	bf28      	it	cs
    eac8:	2306      	movcs	r3, #6
    eaca:	9709      	str	r7, [sp, #36]	; 0x24
    eacc:	46ba      	mov	sl, r7
    eace:	9307      	str	r3, [sp, #28]
    ead0:	950e      	str	r5, [sp, #56]	; 0x38
    ead2:	f8cd b018 	str.w	fp, [sp, #24]
    ead6:	930d      	str	r3, [sp, #52]	; 0x34
    ead8:	4f45      	ldr	r7, [pc, #276]	; (ebf0 <_vfprintf_r+0x13b8>)
    eada:	f7fe bfde 	b.w	da9a <_vfprintf_r+0x262>
    eade:	aa25      	add	r2, sp, #148	; 0x94
    eae0:	990a      	ldr	r1, [sp, #40]	; 0x28
    eae2:	9808      	ldr	r0, [sp, #32]
    eae4:	f7fe f814 	bl	cb10 <__sprint_r>
    eae8:	2800      	cmp	r0, #0
    eaea:	f47f ac3b 	bne.w	e364 <_vfprintf_r+0xb2c>
    eaee:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    eaf0:	9a11      	ldr	r2, [sp, #68]	; 0x44
    eaf2:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    eaf4:	1ad3      	subs	r3, r2, r3
    eaf6:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    eafa:	e5af      	b.n	e65c <_vfprintf_r+0xe24>
    eafc:	46a2      	mov	sl, r4
    eafe:	f7ff bb12 	b.w	e126 <_vfprintf_r+0x8ee>
    eb02:	9d09      	ldr	r5, [sp, #36]	; 0x24
    eb04:	9501      	str	r5, [sp, #4]
    eb06:	a823      	add	r0, sp, #140	; 0x8c
    eb08:	a920      	add	r1, sp, #128	; 0x80
    eb0a:	aa1f      	add	r2, sp, #124	; 0x7c
    eb0c:	2303      	movs	r3, #3
    eb0e:	9004      	str	r0, [sp, #16]
    eb10:	9202      	str	r2, [sp, #8]
    eb12:	9300      	str	r3, [sp, #0]
    eb14:	9103      	str	r1, [sp, #12]
    eb16:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
    eb1a:	9808      	ldr	r0, [sp, #32]
    eb1c:	f000 fb70 	bl	f200 <_dtoa_r>
    eb20:	4607      	mov	r7, r0
    eb22:	1944      	adds	r4, r0, r5
    eb24:	783b      	ldrb	r3, [r7, #0]
    eb26:	2b30      	cmp	r3, #48	; 0x30
    eb28:	f000 80de 	beq.w	ece8 <_vfprintf_r+0x14b0>
    eb2c:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
    eb2e:	442c      	add	r4, r5
    eb30:	e67e      	b.n	e830 <_vfprintf_r+0xff8>
    eb32:	e9dd 1212 	ldrd	r1, r2, [sp, #72]	; 0x48
    eb36:	f102 4300 	add.w	r3, r2, #2147483648	; 0x80000000
    eb3a:	931b      	str	r3, [sp, #108]	; 0x6c
    eb3c:	232d      	movs	r3, #45	; 0x2d
    eb3e:	911a      	str	r1, [sp, #104]	; 0x68
    eb40:	930f      	str	r3, [sp, #60]	; 0x3c
    eb42:	e652      	b.n	e7ea <_vfprintf_r+0xfb2>
    eb44:	9a14      	ldr	r2, [sp, #80]	; 0x50
    eb46:	9b11      	ldr	r3, [sp, #68]	; 0x44
    eb48:	4413      	add	r3, r2
    eb4a:	9a10      	ldr	r2, [sp, #64]	; 0x40
    eb4c:	930d      	str	r3, [sp, #52]	; 0x34
    eb4e:	2a00      	cmp	r2, #0
    eb50:	f340 80e2 	ble.w	ed18 <_vfprintf_r+0x14e0>
    eb54:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    eb58:	9307      	str	r3, [sp, #28]
    eb5a:	2667      	movs	r6, #103	; 0x67
    eb5c:	e698      	b.n	e890 <_vfprintf_r+0x1058>
    eb5e:	2b00      	cmp	r3, #0
    eb60:	f340 80f9 	ble.w	ed56 <_vfprintf_r+0x151e>
    eb64:	9a09      	ldr	r2, [sp, #36]	; 0x24
    eb66:	2a00      	cmp	r2, #0
    eb68:	f040 80cc 	bne.w	ed04 <_vfprintf_r+0x14cc>
    eb6c:	f01b 0f01 	tst.w	fp, #1
    eb70:	f040 80c8 	bne.w	ed04 <_vfprintf_r+0x14cc>
    eb74:	9307      	str	r3, [sp, #28]
    eb76:	930d      	str	r3, [sp, #52]	; 0x34
    eb78:	e68a      	b.n	e890 <_vfprintf_r+0x1058>
    eb7a:	2e47      	cmp	r6, #71	; 0x47
    eb7c:	f47f ae57 	bne.w	e82e <_vfprintf_r+0xff6>
    eb80:	f01b 0f01 	tst.w	fp, #1
    eb84:	f000 80f1 	beq.w	ed6a <_vfprintf_r+0x1532>
    eb88:	2e46      	cmp	r6, #70	; 0x46
    eb8a:	eb07 0405 	add.w	r4, r7, r5
    eb8e:	d0c9      	beq.n	eb24 <_vfprintf_r+0x12ec>
    eb90:	e64e      	b.n	e830 <_vfprintf_r+0xff8>
    eb92:	aa25      	add	r2, sp, #148	; 0x94
    eb94:	990a      	ldr	r1, [sp, #40]	; 0x28
    eb96:	9808      	ldr	r0, [sp, #32]
    eb98:	f7fd ffba 	bl	cb10 <__sprint_r>
    eb9c:	2800      	cmp	r0, #0
    eb9e:	f47f abe1 	bne.w	e364 <_vfprintf_r+0xb2c>
    eba2:	991f      	ldr	r1, [sp, #124]	; 0x7c
    eba4:	9c27      	ldr	r4, [sp, #156]	; 0x9c
    eba6:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    ebaa:	e6c7      	b.n	e93c <_vfprintf_r+0x1104>
    ebac:	9c09      	ldr	r4, [sp, #36]	; 0x24
    ebae:	9401      	str	r4, [sp, #4]
    ebb0:	a823      	add	r0, sp, #140	; 0x8c
    ebb2:	a920      	add	r1, sp, #128	; 0x80
    ebb4:	aa1f      	add	r2, sp, #124	; 0x7c
    ebb6:	2303      	movs	r3, #3
    ebb8:	9004      	str	r0, [sp, #16]
    ebba:	9202      	str	r2, [sp, #8]
    ebbc:	9300      	str	r3, [sp, #0]
    ebbe:	9103      	str	r1, [sp, #12]
    ebc0:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
    ebc4:	9808      	ldr	r0, [sp, #32]
    ebc6:	f000 fb1b 	bl	f200 <_dtoa_r>
    ebca:	4625      	mov	r5, r4
    ebcc:	4607      	mov	r7, r0
    ebce:	e7db      	b.n	eb88 <_vfprintf_r+0x1350>
    ebd0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ebd2:	9307      	str	r3, [sp, #28]
    ebd4:	930d      	str	r3, [sp, #52]	; 0x34
    ebd6:	9009      	str	r0, [sp, #36]	; 0x24
    ebd8:	950e      	str	r5, [sp, #56]	; 0x38
    ebda:	f8cd b018 	str.w	fp, [sp, #24]
    ebde:	9010      	str	r0, [sp, #64]	; 0x40
    ebe0:	f89d a077 	ldrb.w	sl, [sp, #119]	; 0x77
    ebe4:	f7fe bf59 	b.w	da9a <_vfprintf_r+0x262>
    ebe8:	00012a2c 	.word	0x00012a2c
    ebec:	66666667 	.word	0x66666667
    ebf0:	00012a24 	.word	0x00012a24
    ebf4:	2300      	movs	r3, #0
    ebf6:	9309      	str	r3, [sp, #36]	; 0x24
    ebf8:	f7fe be9e 	b.w	d938 <_vfprintf_r+0x100>
    ebfc:	9808      	ldr	r0, [sp, #32]
    ebfe:	aa25      	add	r2, sp, #148	; 0x94
    ec00:	4651      	mov	r1, sl
    ec02:	f7fd ff85 	bl	cb10 <__sprint_r>
    ec06:	2800      	cmp	r0, #0
    ec08:	f43f aa8b 	beq.w	e122 <_vfprintf_r+0x8ea>
    ec0c:	f7ff ba8b 	b.w	e126 <_vfprintf_r+0x8ee>
    ec10:	424e      	negs	r6, r1
    ec12:	3110      	adds	r1, #16
    ec14:	4d6a      	ldr	r5, [pc, #424]	; (edc0 <_vfprintf_r+0x1588>)
    ec16:	da2f      	bge.n	ec78 <_vfprintf_r+0x1440>
    ec18:	2410      	movs	r4, #16
    ec1a:	f8dd a020 	ldr.w	sl, [sp, #32]
    ec1e:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    ec22:	e004      	b.n	ec2e <_vfprintf_r+0x13f6>
    ec24:	f108 0808 	add.w	r8, r8, #8
    ec28:	3e10      	subs	r6, #16
    ec2a:	2e10      	cmp	r6, #16
    ec2c:	dd24      	ble.n	ec78 <_vfprintf_r+0x1440>
    ec2e:	3301      	adds	r3, #1
    ec30:	3210      	adds	r2, #16
    ec32:	2b07      	cmp	r3, #7
    ec34:	9227      	str	r2, [sp, #156]	; 0x9c
    ec36:	9326      	str	r3, [sp, #152]	; 0x98
    ec38:	f8c8 5000 	str.w	r5, [r8]
    ec3c:	f8c8 4004 	str.w	r4, [r8, #4]
    ec40:	ddf0      	ble.n	ec24 <_vfprintf_r+0x13ec>
    ec42:	aa25      	add	r2, sp, #148	; 0x94
    ec44:	4659      	mov	r1, fp
    ec46:	4650      	mov	r0, sl
    ec48:	f7fd ff62 	bl	cb10 <__sprint_r>
    ec4c:	2800      	cmp	r0, #0
    ec4e:	f47f aea9 	bne.w	e9a4 <_vfprintf_r+0x116c>
    ec52:	9a27      	ldr	r2, [sp, #156]	; 0x9c
    ec54:	9b26      	ldr	r3, [sp, #152]	; 0x98
    ec56:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    ec5a:	e7e5      	b.n	ec28 <_vfprintf_r+0x13f0>
    ec5c:	aa25      	add	r2, sp, #148	; 0x94
    ec5e:	990a      	ldr	r1, [sp, #40]	; 0x28
    ec60:	9808      	ldr	r0, [sp, #32]
    ec62:	f7fd ff55 	bl	cb10 <__sprint_r>
    ec66:	2800      	cmp	r0, #0
    ec68:	f47f ab7c 	bne.w	e364 <_vfprintf_r+0xb2c>
    ec6c:	991f      	ldr	r1, [sp, #124]	; 0x7c
    ec6e:	9a27      	ldr	r2, [sp, #156]	; 0x9c
    ec70:	9b26      	ldr	r3, [sp, #152]	; 0x98
    ec72:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    ec76:	e679      	b.n	e96c <_vfprintf_r+0x1134>
    ec78:	3301      	adds	r3, #1
    ec7a:	4432      	add	r2, r6
    ec7c:	2b07      	cmp	r3, #7
    ec7e:	e888 0060 	stmia.w	r8, {r5, r6}
    ec82:	9227      	str	r2, [sp, #156]	; 0x9c
    ec84:	9326      	str	r3, [sp, #152]	; 0x98
    ec86:	f108 0808 	add.w	r8, r8, #8
    ec8a:	f77f ae72 	ble.w	e972 <_vfprintf_r+0x113a>
    ec8e:	aa25      	add	r2, sp, #148	; 0x94
    ec90:	990a      	ldr	r1, [sp, #40]	; 0x28
    ec92:	9808      	ldr	r0, [sp, #32]
    ec94:	f7fd ff3c 	bl	cb10 <__sprint_r>
    ec98:	2800      	cmp	r0, #0
    ec9a:	f47f ab63 	bne.w	e364 <_vfprintf_r+0xb2c>
    ec9e:	9a27      	ldr	r2, [sp, #156]	; 0x9c
    eca0:	9b26      	ldr	r3, [sp, #152]	; 0x98
    eca2:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
    eca6:	e664      	b.n	e972 <_vfprintf_r+0x113a>
    eca8:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ecaa:	9a14      	ldr	r2, [sp, #80]	; 0x50
    ecac:	4413      	add	r3, r2
    ecae:	930d      	str	r3, [sp, #52]	; 0x34
    ecb0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    ecb4:	9307      	str	r3, [sp, #28]
    ecb6:	2667      	movs	r6, #103	; 0x67
    ecb8:	e5ea      	b.n	e890 <_vfprintf_r+0x1058>
    ecba:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    ecbc:	e5cb      	b.n	e856 <_vfprintf_r+0x101e>
    ecbe:	3330      	adds	r3, #48	; 0x30
    ecc0:	2230      	movs	r2, #48	; 0x30
    ecc2:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
    ecc6:	f88d 2086 	strb.w	r2, [sp, #134]	; 0x86
    ecca:	ab22      	add	r3, sp, #136	; 0x88
    eccc:	e6d7      	b.n	ea7e <_vfprintf_r+0x1246>
    ecce:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    ecd0:	4f3c      	ldr	r7, [pc, #240]	; (edc4 <_vfprintf_r+0x158c>)
    ecd2:	2b00      	cmp	r3, #0
    ecd4:	bfb6      	itet	lt
    ecd6:	f04f 0a2d 	movlt.w	sl, #45	; 0x2d
    ecda:	f89d a077 	ldrbge.w	sl, [sp, #119]	; 0x77
    ecde:	f88d a077 	strblt.w	sl, [sp, #119]	; 0x77
    ece2:	4b39      	ldr	r3, [pc, #228]	; (edc8 <_vfprintf_r+0x1590>)
    ece4:	f7ff b9d2 	b.w	e08c <_vfprintf_r+0x854>
    ece8:	2200      	movs	r2, #0
    ecea:	2300      	movs	r3, #0
    ecec:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
    ecf0:	f7f2 fb54 	bl	139c <__aeabi_dcmpeq>
    ecf4:	2800      	cmp	r0, #0
    ecf6:	f47f af19 	bne.w	eb2c <_vfprintf_r+0x12f4>
    ecfa:	f1c5 0501 	rsb	r5, r5, #1
    ecfe:	951f      	str	r5, [sp, #124]	; 0x7c
    ed00:	442c      	add	r4, r5
    ed02:	e595      	b.n	e830 <_vfprintf_r+0xff8>
    ed04:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ed06:	9a14      	ldr	r2, [sp, #80]	; 0x50
    ed08:	4413      	add	r3, r2
    ed0a:	9a09      	ldr	r2, [sp, #36]	; 0x24
    ed0c:	441a      	add	r2, r3
    ed0e:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    ed12:	920d      	str	r2, [sp, #52]	; 0x34
    ed14:	9307      	str	r3, [sp, #28]
    ed16:	e5bb      	b.n	e890 <_vfprintf_r+0x1058>
    ed18:	9b10      	ldr	r3, [sp, #64]	; 0x40
    ed1a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    ed1c:	f1c3 0301 	rsb	r3, r3, #1
    ed20:	441a      	add	r2, r3
    ed22:	4613      	mov	r3, r2
    ed24:	920d      	str	r2, [sp, #52]	; 0x34
    ed26:	e715      	b.n	eb54 <_vfprintf_r+0x131c>
    ed28:	f01b 0301 	ands.w	r3, fp, #1
    ed2c:	9310      	str	r3, [sp, #64]	; 0x40
    ed2e:	f47f aeaf 	bne.w	ea90 <_vfprintf_r+0x1258>
    ed32:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    ed34:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    ed38:	9307      	str	r3, [sp, #28]
    ed3a:	e5a9      	b.n	e890 <_vfprintf_r+0x1058>
    ed3c:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    ed3e:	f899 6001 	ldrb.w	r6, [r9, #1]
    ed42:	6823      	ldr	r3, [r4, #0]
    ed44:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
    ed48:	9309      	str	r3, [sp, #36]	; 0x24
    ed4a:	4623      	mov	r3, r4
    ed4c:	3304      	adds	r3, #4
    ed4e:	4681      	mov	r9, r0
    ed50:	930e      	str	r3, [sp, #56]	; 0x38
    ed52:	f7fe bdef 	b.w	d934 <_vfprintf_r+0xfc>
    ed56:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ed58:	b913      	cbnz	r3, ed60 <_vfprintf_r+0x1528>
    ed5a:	f01b 0f01 	tst.w	fp, #1
    ed5e:	d002      	beq.n	ed66 <_vfprintf_r+0x152e>
    ed60:	9b14      	ldr	r3, [sp, #80]	; 0x50
    ed62:	3301      	adds	r3, #1
    ed64:	e7d1      	b.n	ed0a <_vfprintf_r+0x14d2>
    ed66:	2301      	movs	r3, #1
    ed68:	e704      	b.n	eb74 <_vfprintf_r+0x133c>
    ed6a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    ed6c:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
    ed70:	eba3 0307 	sub.w	r3, r3, r7
    ed74:	9311      	str	r3, [sp, #68]	; 0x44
    ed76:	f43f ae38 	beq.w	e9ea <_vfprintf_r+0x11b2>
    ed7a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    ed7c:	9310      	str	r3, [sp, #64]	; 0x40
    ed7e:	e63f      	b.n	ea00 <_vfprintf_r+0x11c8>
    ed80:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
    ed84:	f7ff b805 	b.w	dd92 <_vfprintf_r+0x55a>
    ed88:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
    ed8c:	f7ff b945 	b.w	e01a <_vfprintf_r+0x7e2>
    ed90:	f10d 0386 	add.w	r3, sp, #134	; 0x86
    ed94:	e673      	b.n	ea7e <_vfprintf_r+0x1246>
    ed96:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
    ed9a:	f7ff b84f 	b.w	de3c <_vfprintf_r+0x604>
    ed9e:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
    eda2:	f7ff b99e 	b.w	e0e2 <_vfprintf_r+0x8aa>
    eda6:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
    edaa:	f7ff b91d 	b.w	dfe8 <_vfprintf_r+0x7b0>
    edae:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
    edb2:	f7ff b8ee 	b.w	df92 <_vfprintf_r+0x75a>
    edb6:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
    edba:	f7ff b895 	b.w	dee8 <_vfprintf_r+0x6b0>
    edbe:	bf00      	nop
    edc0:	00012a80 	.word	0x00012a80
    edc4:	000129f8 	.word	0x000129f8
    edc8:	000129f4 	.word	0x000129f4

0000edcc <__sbprintf>:
    edcc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    edd0:	460c      	mov	r4, r1
    edd2:	f5ad 6d8d 	sub.w	sp, sp, #1128	; 0x468
    edd6:	8989      	ldrh	r1, [r1, #12]
    edd8:	6e66      	ldr	r6, [r4, #100]	; 0x64
    edda:	89e5      	ldrh	r5, [r4, #14]
    eddc:	9619      	str	r6, [sp, #100]	; 0x64
    edde:	f021 0102 	bic.w	r1, r1, #2
    ede2:	4606      	mov	r6, r0
    ede4:	69e0      	ldr	r0, [r4, #28]
    ede6:	f8ad 100c 	strh.w	r1, [sp, #12]
    edea:	4617      	mov	r7, r2
    edec:	f44f 6180 	mov.w	r1, #1024	; 0x400
    edf0:	6a62      	ldr	r2, [r4, #36]	; 0x24
    edf2:	f8ad 500e 	strh.w	r5, [sp, #14]
    edf6:	4698      	mov	r8, r3
    edf8:	ad1a      	add	r5, sp, #104	; 0x68
    edfa:	2300      	movs	r3, #0
    edfc:	9007      	str	r0, [sp, #28]
    edfe:	a816      	add	r0, sp, #88	; 0x58
    ee00:	9209      	str	r2, [sp, #36]	; 0x24
    ee02:	9306      	str	r3, [sp, #24]
    ee04:	9500      	str	r5, [sp, #0]
    ee06:	9504      	str	r5, [sp, #16]
    ee08:	9102      	str	r1, [sp, #8]
    ee0a:	9105      	str	r1, [sp, #20]
    ee0c:	f7fb ff80 	bl	ad10 <__retarget_lock_init_recursive>
    ee10:	4643      	mov	r3, r8
    ee12:	463a      	mov	r2, r7
    ee14:	4669      	mov	r1, sp
    ee16:	4630      	mov	r0, r6
    ee18:	f7fe fd0e 	bl	d838 <_vfprintf_r>
    ee1c:	1e05      	subs	r5, r0, #0
    ee1e:	db07      	blt.n	ee30 <__sbprintf+0x64>
    ee20:	4630      	mov	r0, r6
    ee22:	4669      	mov	r1, sp
    ee24:	f7fb fb9c 	bl	a560 <_fflush_r>
    ee28:	2800      	cmp	r0, #0
    ee2a:	bf18      	it	ne
    ee2c:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
    ee30:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    ee34:	065b      	lsls	r3, r3, #25
    ee36:	d503      	bpl.n	ee40 <__sbprintf+0x74>
    ee38:	89a3      	ldrh	r3, [r4, #12]
    ee3a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    ee3e:	81a3      	strh	r3, [r4, #12]
    ee40:	9816      	ldr	r0, [sp, #88]	; 0x58
    ee42:	f7fb ff67 	bl	ad14 <__retarget_lock_close_recursive>
    ee46:	4628      	mov	r0, r5
    ee48:	f50d 6d8d 	add.w	sp, sp, #1128	; 0x468
    ee4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000ee50 <_vsnprintf_r>:
    ee50:	b570      	push	{r4, r5, r6, lr}
    ee52:	1e14      	subs	r4, r2, #0
    ee54:	b09a      	sub	sp, #104	; 0x68
    ee56:	4605      	mov	r5, r0
    ee58:	db2e      	blt.n	eeb8 <_vsnprintf_r+0x68>
    ee5a:	461a      	mov	r2, r3
    ee5c:	f44f 7302 	mov.w	r3, #520	; 0x208
    ee60:	9100      	str	r1, [sp, #0]
    ee62:	9104      	str	r1, [sp, #16]
    ee64:	f8ad 300c 	strh.w	r3, [sp, #12]
    ee68:	d011      	beq.n	ee8e <_vsnprintf_r+0x3e>
    ee6a:	3c01      	subs	r4, #1
    ee6c:	f64f 76ff 	movw	r6, #65535	; 0xffff
    ee70:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    ee72:	9402      	str	r4, [sp, #8]
    ee74:	4669      	mov	r1, sp
    ee76:	9405      	str	r4, [sp, #20]
    ee78:	f8ad 600e 	strh.w	r6, [sp, #14]
    ee7c:	f7fc fbbc 	bl	b5f8 <_svfprintf_r>
    ee80:	1c42      	adds	r2, r0, #1
    ee82:	db12      	blt.n	eeaa <_vsnprintf_r+0x5a>
    ee84:	9b00      	ldr	r3, [sp, #0]
    ee86:	2200      	movs	r2, #0
    ee88:	701a      	strb	r2, [r3, #0]
    ee8a:	b01a      	add	sp, #104	; 0x68
    ee8c:	bd70      	pop	{r4, r5, r6, pc}
    ee8e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    ee90:	9402      	str	r4, [sp, #8]
    ee92:	f64f 76ff 	movw	r6, #65535	; 0xffff
    ee96:	4669      	mov	r1, sp
    ee98:	9405      	str	r4, [sp, #20]
    ee9a:	f8ad 600e 	strh.w	r6, [sp, #14]
    ee9e:	f7fc fbab 	bl	b5f8 <_svfprintf_r>
    eea2:	1c43      	adds	r3, r0, #1
    eea4:	db04      	blt.n	eeb0 <_vsnprintf_r+0x60>
    eea6:	b01a      	add	sp, #104	; 0x68
    eea8:	bd70      	pop	{r4, r5, r6, pc}
    eeaa:	238b      	movs	r3, #139	; 0x8b
    eeac:	602b      	str	r3, [r5, #0]
    eeae:	e7e9      	b.n	ee84 <_vsnprintf_r+0x34>
    eeb0:	238b      	movs	r3, #139	; 0x8b
    eeb2:	602b      	str	r3, [r5, #0]
    eeb4:	b01a      	add	sp, #104	; 0x68
    eeb6:	bd70      	pop	{r4, r5, r6, pc}
    eeb8:	238b      	movs	r3, #139	; 0x8b
    eeba:	6003      	str	r3, [r0, #0]
    eebc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    eec0:	e7f1      	b.n	eea6 <_vsnprintf_r+0x56>
    eec2:	bf00      	nop

0000eec4 <vsnprintf>:
    eec4:	b510      	push	{r4, lr}
    eec6:	b082      	sub	sp, #8
    eec8:	4c05      	ldr	r4, [pc, #20]	; (eee0 <vsnprintf+0x1c>)
    eeca:	9300      	str	r3, [sp, #0]
    eecc:	6824      	ldr	r4, [r4, #0]
    eece:	4613      	mov	r3, r2
    eed0:	460a      	mov	r2, r1
    eed2:	4601      	mov	r1, r0
    eed4:	4620      	mov	r0, r4
    eed6:	f7ff ffbb 	bl	ee50 <_vsnprintf_r>
    eeda:	b002      	add	sp, #8
    eedc:	bd10      	pop	{r4, pc}
    eede:	bf00      	nop
    eee0:	200001c0 	.word	0x200001c0

0000eee4 <__swbuf_r>:
    eee4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    eee6:	460d      	mov	r5, r1
    eee8:	4614      	mov	r4, r2
    eeea:	4606      	mov	r6, r0
    eeec:	b110      	cbz	r0, eef4 <__swbuf_r+0x10>
    eeee:	6b83      	ldr	r3, [r0, #56]	; 0x38
    eef0:	2b00      	cmp	r3, #0
    eef2:	d04b      	beq.n	ef8c <__swbuf_r+0xa8>
    eef4:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    eef8:	69a3      	ldr	r3, [r4, #24]
    eefa:	60a3      	str	r3, [r4, #8]
    eefc:	b291      	uxth	r1, r2
    eefe:	0708      	lsls	r0, r1, #28
    ef00:	d539      	bpl.n	ef76 <__swbuf_r+0x92>
    ef02:	6923      	ldr	r3, [r4, #16]
    ef04:	2b00      	cmp	r3, #0
    ef06:	d036      	beq.n	ef76 <__swbuf_r+0x92>
    ef08:	b2ed      	uxtb	r5, r5
    ef0a:	0489      	lsls	r1, r1, #18
    ef0c:	462f      	mov	r7, r5
    ef0e:	d515      	bpl.n	ef3c <__swbuf_r+0x58>
    ef10:	6822      	ldr	r2, [r4, #0]
    ef12:	6961      	ldr	r1, [r4, #20]
    ef14:	1ad3      	subs	r3, r2, r3
    ef16:	428b      	cmp	r3, r1
    ef18:	da1c      	bge.n	ef54 <__swbuf_r+0x70>
    ef1a:	3301      	adds	r3, #1
    ef1c:	68a1      	ldr	r1, [r4, #8]
    ef1e:	1c50      	adds	r0, r2, #1
    ef20:	3901      	subs	r1, #1
    ef22:	60a1      	str	r1, [r4, #8]
    ef24:	6020      	str	r0, [r4, #0]
    ef26:	7015      	strb	r5, [r2, #0]
    ef28:	6962      	ldr	r2, [r4, #20]
    ef2a:	429a      	cmp	r2, r3
    ef2c:	d01a      	beq.n	ef64 <__swbuf_r+0x80>
    ef2e:	89a3      	ldrh	r3, [r4, #12]
    ef30:	07db      	lsls	r3, r3, #31
    ef32:	d501      	bpl.n	ef38 <__swbuf_r+0x54>
    ef34:	2d0a      	cmp	r5, #10
    ef36:	d015      	beq.n	ef64 <__swbuf_r+0x80>
    ef38:	4638      	mov	r0, r7
    ef3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ef3c:	6e61      	ldr	r1, [r4, #100]	; 0x64
    ef3e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    ef42:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
    ef46:	81a2      	strh	r2, [r4, #12]
    ef48:	6822      	ldr	r2, [r4, #0]
    ef4a:	6661      	str	r1, [r4, #100]	; 0x64
    ef4c:	6961      	ldr	r1, [r4, #20]
    ef4e:	1ad3      	subs	r3, r2, r3
    ef50:	428b      	cmp	r3, r1
    ef52:	dbe2      	blt.n	ef1a <__swbuf_r+0x36>
    ef54:	4621      	mov	r1, r4
    ef56:	4630      	mov	r0, r6
    ef58:	f7fb fb02 	bl	a560 <_fflush_r>
    ef5c:	b940      	cbnz	r0, ef70 <__swbuf_r+0x8c>
    ef5e:	6822      	ldr	r2, [r4, #0]
    ef60:	2301      	movs	r3, #1
    ef62:	e7db      	b.n	ef1c <__swbuf_r+0x38>
    ef64:	4621      	mov	r1, r4
    ef66:	4630      	mov	r0, r6
    ef68:	f7fb fafa 	bl	a560 <_fflush_r>
    ef6c:	2800      	cmp	r0, #0
    ef6e:	d0e3      	beq.n	ef38 <__swbuf_r+0x54>
    ef70:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    ef74:	e7e0      	b.n	ef38 <__swbuf_r+0x54>
    ef76:	4621      	mov	r1, r4
    ef78:	4630      	mov	r0, r6
    ef7a:	f000 f82f 	bl	efdc <__swsetup_r>
    ef7e:	2800      	cmp	r0, #0
    ef80:	d1f6      	bne.n	ef70 <__swbuf_r+0x8c>
    ef82:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    ef86:	6923      	ldr	r3, [r4, #16]
    ef88:	b291      	uxth	r1, r2
    ef8a:	e7bd      	b.n	ef08 <__swbuf_r+0x24>
    ef8c:	f7fb fb52 	bl	a634 <__sinit>
    ef90:	e7b0      	b.n	eef4 <__swbuf_r+0x10>
    ef92:	bf00      	nop

0000ef94 <__ascii_wctomb>:
    ef94:	b121      	cbz	r1, efa0 <__ascii_wctomb+0xc>
    ef96:	2aff      	cmp	r2, #255	; 0xff
    ef98:	d804      	bhi.n	efa4 <__ascii_wctomb+0x10>
    ef9a:	700a      	strb	r2, [r1, #0]
    ef9c:	2001      	movs	r0, #1
    ef9e:	4770      	bx	lr
    efa0:	4608      	mov	r0, r1
    efa2:	4770      	bx	lr
    efa4:	238a      	movs	r3, #138	; 0x8a
    efa6:	6003      	str	r3, [r0, #0]
    efa8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    efac:	4770      	bx	lr
    efae:	bf00      	nop

0000efb0 <_write_r>:
    efb0:	b570      	push	{r4, r5, r6, lr}
    efb2:	460d      	mov	r5, r1
    efb4:	4c08      	ldr	r4, [pc, #32]	; (efd8 <_write_r+0x28>)
    efb6:	4611      	mov	r1, r2
    efb8:	4606      	mov	r6, r0
    efba:	461a      	mov	r2, r3
    efbc:	4628      	mov	r0, r5
    efbe:	2300      	movs	r3, #0
    efc0:	6023      	str	r3, [r4, #0]
    efc2:	f7f4 fa89 	bl	34d8 <_write>
    efc6:	1c43      	adds	r3, r0, #1
    efc8:	d000      	beq.n	efcc <_write_r+0x1c>
    efca:	bd70      	pop	{r4, r5, r6, pc}
    efcc:	6823      	ldr	r3, [r4, #0]
    efce:	2b00      	cmp	r3, #0
    efd0:	d0fb      	beq.n	efca <_write_r+0x1a>
    efd2:	6033      	str	r3, [r6, #0]
    efd4:	bd70      	pop	{r4, r5, r6, pc}
    efd6:	bf00      	nop
    efd8:	2000304c 	.word	0x2000304c

0000efdc <__swsetup_r>:
    efdc:	b538      	push	{r3, r4, r5, lr}
    efde:	4b30      	ldr	r3, [pc, #192]	; (f0a0 <__swsetup_r+0xc4>)
    efe0:	681b      	ldr	r3, [r3, #0]
    efe2:	4605      	mov	r5, r0
    efe4:	460c      	mov	r4, r1
    efe6:	b113      	cbz	r3, efee <__swsetup_r+0x12>
    efe8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    efea:	2a00      	cmp	r2, #0
    efec:	d038      	beq.n	f060 <__swsetup_r+0x84>
    efee:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    eff2:	b293      	uxth	r3, r2
    eff4:	0718      	lsls	r0, r3, #28
    eff6:	d50c      	bpl.n	f012 <__swsetup_r+0x36>
    eff8:	6920      	ldr	r0, [r4, #16]
    effa:	b1a8      	cbz	r0, f028 <__swsetup_r+0x4c>
    effc:	f013 0201 	ands.w	r2, r3, #1
    f000:	d01e      	beq.n	f040 <__swsetup_r+0x64>
    f002:	6963      	ldr	r3, [r4, #20]
    f004:	2200      	movs	r2, #0
    f006:	425b      	negs	r3, r3
    f008:	61a3      	str	r3, [r4, #24]
    f00a:	60a2      	str	r2, [r4, #8]
    f00c:	b1f0      	cbz	r0, f04c <__swsetup_r+0x70>
    f00e:	2000      	movs	r0, #0
    f010:	bd38      	pop	{r3, r4, r5, pc}
    f012:	06d9      	lsls	r1, r3, #27
    f014:	d53c      	bpl.n	f090 <__swsetup_r+0xb4>
    f016:	0758      	lsls	r0, r3, #29
    f018:	d426      	bmi.n	f068 <__swsetup_r+0x8c>
    f01a:	6920      	ldr	r0, [r4, #16]
    f01c:	f042 0308 	orr.w	r3, r2, #8
    f020:	81a3      	strh	r3, [r4, #12]
    f022:	b29b      	uxth	r3, r3
    f024:	2800      	cmp	r0, #0
    f026:	d1e9      	bne.n	effc <__swsetup_r+0x20>
    f028:	f403 7220 	and.w	r2, r3, #640	; 0x280
    f02c:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    f030:	d0e4      	beq.n	effc <__swsetup_r+0x20>
    f032:	4628      	mov	r0, r5
    f034:	4621      	mov	r1, r4
    f036:	f7fb fea1 	bl	ad7c <__smakebuf_r>
    f03a:	89a3      	ldrh	r3, [r4, #12]
    f03c:	6920      	ldr	r0, [r4, #16]
    f03e:	e7dd      	b.n	effc <__swsetup_r+0x20>
    f040:	0799      	lsls	r1, r3, #30
    f042:	bf58      	it	pl
    f044:	6962      	ldrpl	r2, [r4, #20]
    f046:	60a2      	str	r2, [r4, #8]
    f048:	2800      	cmp	r0, #0
    f04a:	d1e0      	bne.n	f00e <__swsetup_r+0x32>
    f04c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    f050:	061a      	lsls	r2, r3, #24
    f052:	d5dd      	bpl.n	f010 <__swsetup_r+0x34>
    f054:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    f058:	81a3      	strh	r3, [r4, #12]
    f05a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    f05e:	bd38      	pop	{r3, r4, r5, pc}
    f060:	4618      	mov	r0, r3
    f062:	f7fb fae7 	bl	a634 <__sinit>
    f066:	e7c2      	b.n	efee <__swsetup_r+0x12>
    f068:	6b21      	ldr	r1, [r4, #48]	; 0x30
    f06a:	b151      	cbz	r1, f082 <__swsetup_r+0xa6>
    f06c:	f104 0340 	add.w	r3, r4, #64	; 0x40
    f070:	4299      	cmp	r1, r3
    f072:	d004      	beq.n	f07e <__swsetup_r+0xa2>
    f074:	4628      	mov	r0, r5
    f076:	f7f3 fc48 	bl	290a <__wrap__free_r>
    f07a:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
    f07e:	2300      	movs	r3, #0
    f080:	6323      	str	r3, [r4, #48]	; 0x30
    f082:	2300      	movs	r3, #0
    f084:	6920      	ldr	r0, [r4, #16]
    f086:	6063      	str	r3, [r4, #4]
    f088:	f022 0224 	bic.w	r2, r2, #36	; 0x24
    f08c:	6020      	str	r0, [r4, #0]
    f08e:	e7c5      	b.n	f01c <__swsetup_r+0x40>
    f090:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    f094:	2309      	movs	r3, #9
    f096:	602b      	str	r3, [r5, #0]
    f098:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    f09c:	81a2      	strh	r2, [r4, #12]
    f09e:	bd38      	pop	{r3, r4, r5, pc}
    f0a0:	200001c0 	.word	0x200001c0

0000f0a4 <abort>:
    f0a4:	b508      	push	{r3, lr}
    f0a6:	2006      	movs	r0, #6
    f0a8:	f001 fbbe 	bl	10828 <raise>
    f0ac:	2001      	movs	r0, #1
    f0ae:	f7f4 fccb 	bl	3a48 <_exit>
    f0b2:	bf00      	nop

0000f0b4 <_close_r>:
    f0b4:	b538      	push	{r3, r4, r5, lr}
    f0b6:	4c07      	ldr	r4, [pc, #28]	; (f0d4 <_close_r+0x20>)
    f0b8:	2300      	movs	r3, #0
    f0ba:	4605      	mov	r5, r0
    f0bc:	4608      	mov	r0, r1
    f0be:	6023      	str	r3, [r4, #0]
    f0c0:	f7f4 f9b8 	bl	3434 <_close>
    f0c4:	1c43      	adds	r3, r0, #1
    f0c6:	d000      	beq.n	f0ca <_close_r+0x16>
    f0c8:	bd38      	pop	{r3, r4, r5, pc}
    f0ca:	6823      	ldr	r3, [r4, #0]
    f0cc:	2b00      	cmp	r3, #0
    f0ce:	d0fb      	beq.n	f0c8 <_close_r+0x14>
    f0d0:	602b      	str	r3, [r5, #0]
    f0d2:	bd38      	pop	{r3, r4, r5, pc}
    f0d4:	2000304c 	.word	0x2000304c

0000f0d8 <quorem>:
    f0d8:	6902      	ldr	r2, [r0, #16]
    f0da:	690b      	ldr	r3, [r1, #16]
    f0dc:	4293      	cmp	r3, r2
    f0de:	f300 808d 	bgt.w	f1fc <quorem+0x124>
    f0e2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f0e6:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    f0ea:	f101 0714 	add.w	r7, r1, #20
    f0ee:	f100 0b14 	add.w	fp, r0, #20
    f0f2:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
    f0f6:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
    f0fa:	ea4f 0488 	mov.w	r4, r8, lsl #2
    f0fe:	b083      	sub	sp, #12
    f100:	3201      	adds	r2, #1
    f102:	fbb3 f9f2 	udiv	r9, r3, r2
    f106:	eb0b 0304 	add.w	r3, fp, r4
    f10a:	9400      	str	r4, [sp, #0]
    f10c:	eb07 0a04 	add.w	sl, r7, r4
    f110:	9301      	str	r3, [sp, #4]
    f112:	f1b9 0f00 	cmp.w	r9, #0
    f116:	d039      	beq.n	f18c <quorem+0xb4>
    f118:	2500      	movs	r5, #0
    f11a:	462e      	mov	r6, r5
    f11c:	46bc      	mov	ip, r7
    f11e:	46de      	mov	lr, fp
    f120:	f85c 4b04 	ldr.w	r4, [ip], #4
    f124:	f8de 3000 	ldr.w	r3, [lr]
    f128:	b2a2      	uxth	r2, r4
    f12a:	fb09 5502 	mla	r5, r9, r2, r5
    f12e:	0c22      	lsrs	r2, r4, #16
    f130:	0c2c      	lsrs	r4, r5, #16
    f132:	fb09 4202 	mla	r2, r9, r2, r4
    f136:	b2ad      	uxth	r5, r5
    f138:	1b75      	subs	r5, r6, r5
    f13a:	b296      	uxth	r6, r2
    f13c:	ebc6 4613 	rsb	r6, r6, r3, lsr #16
    f140:	fa15 f383 	uxtah	r3, r5, r3
    f144:	eb06 4623 	add.w	r6, r6, r3, asr #16
    f148:	b29b      	uxth	r3, r3
    f14a:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
    f14e:	45e2      	cmp	sl, ip
    f150:	ea4f 4512 	mov.w	r5, r2, lsr #16
    f154:	f84e 3b04 	str.w	r3, [lr], #4
    f158:	ea4f 4626 	mov.w	r6, r6, asr #16
    f15c:	d2e0      	bcs.n	f120 <quorem+0x48>
    f15e:	9b00      	ldr	r3, [sp, #0]
    f160:	f85b 3003 	ldr.w	r3, [fp, r3]
    f164:	b993      	cbnz	r3, f18c <quorem+0xb4>
    f166:	9c01      	ldr	r4, [sp, #4]
    f168:	1f23      	subs	r3, r4, #4
    f16a:	459b      	cmp	fp, r3
    f16c:	d20c      	bcs.n	f188 <quorem+0xb0>
    f16e:	f854 3c04 	ldr.w	r3, [r4, #-4]
    f172:	b94b      	cbnz	r3, f188 <quorem+0xb0>
    f174:	f1a4 0308 	sub.w	r3, r4, #8
    f178:	e002      	b.n	f180 <quorem+0xa8>
    f17a:	681a      	ldr	r2, [r3, #0]
    f17c:	3b04      	subs	r3, #4
    f17e:	b91a      	cbnz	r2, f188 <quorem+0xb0>
    f180:	459b      	cmp	fp, r3
    f182:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    f186:	d3f8      	bcc.n	f17a <quorem+0xa2>
    f188:	f8c0 8010 	str.w	r8, [r0, #16]
    f18c:	4604      	mov	r4, r0
    f18e:	f001 fa09 	bl	105a4 <__mcmp>
    f192:	2800      	cmp	r0, #0
    f194:	db2e      	blt.n	f1f4 <quorem+0x11c>
    f196:	f109 0901 	add.w	r9, r9, #1
    f19a:	465d      	mov	r5, fp
    f19c:	2300      	movs	r3, #0
    f19e:	f857 1b04 	ldr.w	r1, [r7], #4
    f1a2:	6828      	ldr	r0, [r5, #0]
    f1a4:	b28a      	uxth	r2, r1
    f1a6:	1a9a      	subs	r2, r3, r2
    f1a8:	0c0b      	lsrs	r3, r1, #16
    f1aa:	fa12 f280 	uxtah	r2, r2, r0
    f1ae:	ebc3 4310 	rsb	r3, r3, r0, lsr #16
    f1b2:	eb03 4322 	add.w	r3, r3, r2, asr #16
    f1b6:	b292      	uxth	r2, r2
    f1b8:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    f1bc:	45ba      	cmp	sl, r7
    f1be:	f845 2b04 	str.w	r2, [r5], #4
    f1c2:	ea4f 4323 	mov.w	r3, r3, asr #16
    f1c6:	d2ea      	bcs.n	f19e <quorem+0xc6>
    f1c8:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
    f1cc:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
    f1d0:	b982      	cbnz	r2, f1f4 <quorem+0x11c>
    f1d2:	1f1a      	subs	r2, r3, #4
    f1d4:	4593      	cmp	fp, r2
    f1d6:	d20b      	bcs.n	f1f0 <quorem+0x118>
    f1d8:	f853 2c04 	ldr.w	r2, [r3, #-4]
    f1dc:	b942      	cbnz	r2, f1f0 <quorem+0x118>
    f1de:	3b08      	subs	r3, #8
    f1e0:	e002      	b.n	f1e8 <quorem+0x110>
    f1e2:	681a      	ldr	r2, [r3, #0]
    f1e4:	3b04      	subs	r3, #4
    f1e6:	b91a      	cbnz	r2, f1f0 <quorem+0x118>
    f1e8:	459b      	cmp	fp, r3
    f1ea:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    f1ee:	d3f8      	bcc.n	f1e2 <quorem+0x10a>
    f1f0:	f8c4 8010 	str.w	r8, [r4, #16]
    f1f4:	4648      	mov	r0, r9
    f1f6:	b003      	add	sp, #12
    f1f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f1fc:	2000      	movs	r0, #0
    f1fe:	4770      	bx	lr

0000f200 <_dtoa_r>:
    f200:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f204:	6c01      	ldr	r1, [r0, #64]	; 0x40
    f206:	b09b      	sub	sp, #108	; 0x6c
    f208:	4604      	mov	r4, r0
    f20a:	9e27      	ldr	r6, [sp, #156]	; 0x9c
    f20c:	4692      	mov	sl, r2
    f20e:	469b      	mov	fp, r3
    f210:	b141      	cbz	r1, f224 <_dtoa_r+0x24>
    f212:	6c42      	ldr	r2, [r0, #68]	; 0x44
    f214:	604a      	str	r2, [r1, #4]
    f216:	2301      	movs	r3, #1
    f218:	4093      	lsls	r3, r2
    f21a:	608b      	str	r3, [r1, #8]
    f21c:	f000 ffea 	bl	101f4 <_Bfree>
    f220:	2300      	movs	r3, #0
    f222:	6423      	str	r3, [r4, #64]	; 0x40
    f224:	f1bb 0f00 	cmp.w	fp, #0
    f228:	465d      	mov	r5, fp
    f22a:	db35      	blt.n	f298 <_dtoa_r+0x98>
    f22c:	2300      	movs	r3, #0
    f22e:	6033      	str	r3, [r6, #0]
    f230:	4b9d      	ldr	r3, [pc, #628]	; (f4a8 <_dtoa_r+0x2a8>)
    f232:	43ab      	bics	r3, r5
    f234:	d015      	beq.n	f262 <_dtoa_r+0x62>
    f236:	2200      	movs	r2, #0
    f238:	2300      	movs	r3, #0
    f23a:	4650      	mov	r0, sl
    f23c:	4659      	mov	r1, fp
    f23e:	f7f2 f8ad 	bl	139c <__aeabi_dcmpeq>
    f242:	4680      	mov	r8, r0
    f244:	2800      	cmp	r0, #0
    f246:	d02d      	beq.n	f2a4 <_dtoa_r+0xa4>
    f248:	9a26      	ldr	r2, [sp, #152]	; 0x98
    f24a:	2301      	movs	r3, #1
    f24c:	6013      	str	r3, [r2, #0]
    f24e:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    f250:	2b00      	cmp	r3, #0
    f252:	f000 80bd 	beq.w	f3d0 <_dtoa_r+0x1d0>
    f256:	4895      	ldr	r0, [pc, #596]	; (f4ac <_dtoa_r+0x2ac>)
    f258:	6018      	str	r0, [r3, #0]
    f25a:	3801      	subs	r0, #1
    f25c:	b01b      	add	sp, #108	; 0x6c
    f25e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f262:	9a26      	ldr	r2, [sp, #152]	; 0x98
    f264:	f242 730f 	movw	r3, #9999	; 0x270f
    f268:	6013      	str	r3, [r2, #0]
    f26a:	f1ba 0f00 	cmp.w	sl, #0
    f26e:	d10d      	bne.n	f28c <_dtoa_r+0x8c>
    f270:	f3c5 0513 	ubfx	r5, r5, #0, #20
    f274:	b955      	cbnz	r5, f28c <_dtoa_r+0x8c>
    f276:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    f278:	488d      	ldr	r0, [pc, #564]	; (f4b0 <_dtoa_r+0x2b0>)
    f27a:	2b00      	cmp	r3, #0
    f27c:	d0ee      	beq.n	f25c <_dtoa_r+0x5c>
    f27e:	f100 0308 	add.w	r3, r0, #8
    f282:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    f284:	6013      	str	r3, [r2, #0]
    f286:	b01b      	add	sp, #108	; 0x6c
    f288:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f28c:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    f28e:	4889      	ldr	r0, [pc, #548]	; (f4b4 <_dtoa_r+0x2b4>)
    f290:	2b00      	cmp	r3, #0
    f292:	d0e3      	beq.n	f25c <_dtoa_r+0x5c>
    f294:	1cc3      	adds	r3, r0, #3
    f296:	e7f4      	b.n	f282 <_dtoa_r+0x82>
    f298:	2301      	movs	r3, #1
    f29a:	f02b 4500 	bic.w	r5, fp, #2147483648	; 0x80000000
    f29e:	6033      	str	r3, [r6, #0]
    f2a0:	46ab      	mov	fp, r5
    f2a2:	e7c5      	b.n	f230 <_dtoa_r+0x30>
    f2a4:	aa18      	add	r2, sp, #96	; 0x60
    f2a6:	ab19      	add	r3, sp, #100	; 0x64
    f2a8:	9201      	str	r2, [sp, #4]
    f2aa:	9300      	str	r3, [sp, #0]
    f2ac:	4652      	mov	r2, sl
    f2ae:	465b      	mov	r3, fp
    f2b0:	4620      	mov	r0, r4
    f2b2:	f001 fa17 	bl	106e4 <__d2b>
    f2b6:	0d2b      	lsrs	r3, r5, #20
    f2b8:	4681      	mov	r9, r0
    f2ba:	d071      	beq.n	f3a0 <_dtoa_r+0x1a0>
    f2bc:	f3cb 0213 	ubfx	r2, fp, #0, #20
    f2c0:	f042 517f 	orr.w	r1, r2, #1069547520	; 0x3fc00000
    f2c4:	9f18      	ldr	r7, [sp, #96]	; 0x60
    f2c6:	f8cd 8050 	str.w	r8, [sp, #80]	; 0x50
    f2ca:	4650      	mov	r0, sl
    f2cc:	f2a3 36ff 	subw	r6, r3, #1023	; 0x3ff
    f2d0:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
    f2d4:	2200      	movs	r2, #0
    f2d6:	4b78      	ldr	r3, [pc, #480]	; (f4b8 <_dtoa_r+0x2b8>)
    f2d8:	f7f1 fc44 	bl	b64 <__aeabi_dsub>
    f2dc:	a36c      	add	r3, pc, #432	; (adr r3, f490 <_dtoa_r+0x290>)
    f2de:	e9d3 2300 	ldrd	r2, r3, [r3]
    f2e2:	f7f1 fdf3 	bl	ecc <__aeabi_dmul>
    f2e6:	a36c      	add	r3, pc, #432	; (adr r3, f498 <_dtoa_r+0x298>)
    f2e8:	e9d3 2300 	ldrd	r2, r3, [r3]
    f2ec:	f7f1 fc3c 	bl	b68 <__adddf3>
    f2f0:	e9cd 0102 	strd	r0, r1, [sp, #8]
    f2f4:	4630      	mov	r0, r6
    f2f6:	f7f1 fd83 	bl	e00 <__aeabi_i2d>
    f2fa:	a369      	add	r3, pc, #420	; (adr r3, f4a0 <_dtoa_r+0x2a0>)
    f2fc:	e9d3 2300 	ldrd	r2, r3, [r3]
    f300:	f7f1 fde4 	bl	ecc <__aeabi_dmul>
    f304:	4602      	mov	r2, r0
    f306:	460b      	mov	r3, r1
    f308:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    f30c:	f7f1 fc2c 	bl	b68 <__adddf3>
    f310:	e9cd 0104 	strd	r0, r1, [sp, #16]
    f314:	f7f2 f88a 	bl	142c <__aeabi_d2iz>
    f318:	2200      	movs	r2, #0
    f31a:	9002      	str	r0, [sp, #8]
    f31c:	2300      	movs	r3, #0
    f31e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    f322:	f7f2 f845 	bl	13b0 <__aeabi_dcmplt>
    f326:	2800      	cmp	r0, #0
    f328:	f040 8173 	bne.w	f612 <_dtoa_r+0x412>
    f32c:	9d02      	ldr	r5, [sp, #8]
    f32e:	2d16      	cmp	r5, #22
    f330:	f200 815d 	bhi.w	f5ee <_dtoa_r+0x3ee>
    f334:	4b61      	ldr	r3, [pc, #388]	; (f4bc <_dtoa_r+0x2bc>)
    f336:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
    f33a:	e9d3 0100 	ldrd	r0, r1, [r3]
    f33e:	4652      	mov	r2, sl
    f340:	465b      	mov	r3, fp
    f342:	f7f2 f853 	bl	13ec <__aeabi_dcmpgt>
    f346:	2800      	cmp	r0, #0
    f348:	f000 81c5 	beq.w	f6d6 <_dtoa_r+0x4d6>
    f34c:	1e6b      	subs	r3, r5, #1
    f34e:	9302      	str	r3, [sp, #8]
    f350:	2300      	movs	r3, #0
    f352:	930e      	str	r3, [sp, #56]	; 0x38
    f354:	1bbf      	subs	r7, r7, r6
    f356:	1e7b      	subs	r3, r7, #1
    f358:	9308      	str	r3, [sp, #32]
    f35a:	f100 8154 	bmi.w	f606 <_dtoa_r+0x406>
    f35e:	2300      	movs	r3, #0
    f360:	930b      	str	r3, [sp, #44]	; 0x2c
    f362:	9b02      	ldr	r3, [sp, #8]
    f364:	2b00      	cmp	r3, #0
    f366:	f2c0 8145 	blt.w	f5f4 <_dtoa_r+0x3f4>
    f36a:	9a08      	ldr	r2, [sp, #32]
    f36c:	930d      	str	r3, [sp, #52]	; 0x34
    f36e:	4611      	mov	r1, r2
    f370:	4419      	add	r1, r3
    f372:	2300      	movs	r3, #0
    f374:	9108      	str	r1, [sp, #32]
    f376:	9306      	str	r3, [sp, #24]
    f378:	9b24      	ldr	r3, [sp, #144]	; 0x90
    f37a:	2b09      	cmp	r3, #9
    f37c:	d82a      	bhi.n	f3d4 <_dtoa_r+0x1d4>
    f37e:	2b05      	cmp	r3, #5
    f380:	f340 863c 	ble.w	fffc <_dtoa_r+0xdfc>
    f384:	3b04      	subs	r3, #4
    f386:	9324      	str	r3, [sp, #144]	; 0x90
    f388:	2500      	movs	r5, #0
    f38a:	9b24      	ldr	r3, [sp, #144]	; 0x90
    f38c:	3b02      	subs	r3, #2
    f38e:	2b03      	cmp	r3, #3
    f390:	f200 863c 	bhi.w	1000c <_dtoa_r+0xe0c>
    f394:	e8df f013 	tbh	[pc, r3, lsl #1]
    f398:	02ca03d5 	.word	0x02ca03d5
    f39c:	046203e0 	.word	0x046203e0
    f3a0:	9f18      	ldr	r7, [sp, #96]	; 0x60
    f3a2:	9e19      	ldr	r6, [sp, #100]	; 0x64
    f3a4:	443e      	add	r6, r7
    f3a6:	f206 4332 	addw	r3, r6, #1074	; 0x432
    f3aa:	2b20      	cmp	r3, #32
    f3ac:	f340 818e 	ble.w	f6cc <_dtoa_r+0x4cc>
    f3b0:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
    f3b4:	f206 4012 	addw	r0, r6, #1042	; 0x412
    f3b8:	409d      	lsls	r5, r3
    f3ba:	fa2a f000 	lsr.w	r0, sl, r0
    f3be:	4328      	orrs	r0, r5
    f3c0:	f7f1 fd0e 	bl	de0 <__aeabi_ui2d>
    f3c4:	2301      	movs	r3, #1
    f3c6:	3e01      	subs	r6, #1
    f3c8:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
    f3cc:	9314      	str	r3, [sp, #80]	; 0x50
    f3ce:	e781      	b.n	f2d4 <_dtoa_r+0xd4>
    f3d0:	483b      	ldr	r0, [pc, #236]	; (f4c0 <_dtoa_r+0x2c0>)
    f3d2:	e743      	b.n	f25c <_dtoa_r+0x5c>
    f3d4:	2100      	movs	r1, #0
    f3d6:	6461      	str	r1, [r4, #68]	; 0x44
    f3d8:	4620      	mov	r0, r4
    f3da:	9125      	str	r1, [sp, #148]	; 0x94
    f3dc:	f000 fee4 	bl	101a8 <_Balloc>
    f3e0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    f3e4:	930a      	str	r3, [sp, #40]	; 0x28
    f3e6:	9a25      	ldr	r2, [sp, #148]	; 0x94
    f3e8:	930f      	str	r3, [sp, #60]	; 0x3c
    f3ea:	2301      	movs	r3, #1
    f3ec:	9004      	str	r0, [sp, #16]
    f3ee:	6420      	str	r0, [r4, #64]	; 0x40
    f3f0:	9224      	str	r2, [sp, #144]	; 0x90
    f3f2:	930c      	str	r3, [sp, #48]	; 0x30
    f3f4:	9b19      	ldr	r3, [sp, #100]	; 0x64
    f3f6:	2b00      	cmp	r3, #0
    f3f8:	f2c0 80d9 	blt.w	f5ae <_dtoa_r+0x3ae>
    f3fc:	9a02      	ldr	r2, [sp, #8]
    f3fe:	2a0e      	cmp	r2, #14
    f400:	f300 80d5 	bgt.w	f5ae <_dtoa_r+0x3ae>
    f404:	4b2d      	ldr	r3, [pc, #180]	; (f4bc <_dtoa_r+0x2bc>)
    f406:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    f40a:	ed93 7b00 	vldr	d7, [r3]
    f40e:	9b25      	ldr	r3, [sp, #148]	; 0x94
    f410:	2b00      	cmp	r3, #0
    f412:	ed8d 7b08 	vstr	d7, [sp, #32]
    f416:	f2c0 83bb 	blt.w	fb90 <_dtoa_r+0x990>
    f41a:	e9dd 5608 	ldrd	r5, r6, [sp, #32]
    f41e:	4650      	mov	r0, sl
    f420:	462a      	mov	r2, r5
    f422:	4633      	mov	r3, r6
    f424:	4659      	mov	r1, fp
    f426:	f7f1 fe7b 	bl	1120 <__aeabi_ddiv>
    f42a:	f7f1 ffff 	bl	142c <__aeabi_d2iz>
    f42e:	4680      	mov	r8, r0
    f430:	f7f1 fce6 	bl	e00 <__aeabi_i2d>
    f434:	462a      	mov	r2, r5
    f436:	4633      	mov	r3, r6
    f438:	f7f1 fd48 	bl	ecc <__aeabi_dmul>
    f43c:	460b      	mov	r3, r1
    f43e:	4602      	mov	r2, r0
    f440:	4659      	mov	r1, fp
    f442:	4650      	mov	r0, sl
    f444:	f7f1 fb8e 	bl	b64 <__aeabi_dsub>
    f448:	9d04      	ldr	r5, [sp, #16]
    f44a:	f108 0330 	add.w	r3, r8, #48	; 0x30
    f44e:	702b      	strb	r3, [r5, #0]
    f450:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f452:	2b01      	cmp	r3, #1
    f454:	4606      	mov	r6, r0
    f456:	460f      	mov	r7, r1
    f458:	f105 0501 	add.w	r5, r5, #1
    f45c:	d068      	beq.n	f530 <_dtoa_r+0x330>
    f45e:	2200      	movs	r2, #0
    f460:	4b18      	ldr	r3, [pc, #96]	; (f4c4 <_dtoa_r+0x2c4>)
    f462:	f7f1 fd33 	bl	ecc <__aeabi_dmul>
    f466:	2200      	movs	r2, #0
    f468:	2300      	movs	r3, #0
    f46a:	4606      	mov	r6, r0
    f46c:	460f      	mov	r7, r1
    f46e:	f7f1 ff95 	bl	139c <__aeabi_dcmpeq>
    f472:	2800      	cmp	r0, #0
    f474:	f040 8088 	bne.w	f588 <_dtoa_r+0x388>
    f478:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
    f47c:	f04f 0a00 	mov.w	sl, #0
    f480:	f8df b040 	ldr.w	fp, [pc, #64]	; f4c4 <_dtoa_r+0x2c4>
    f484:	940c      	str	r4, [sp, #48]	; 0x30
    f486:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
    f48a:	e028      	b.n	f4de <_dtoa_r+0x2de>
    f48c:	f3af 8000 	nop.w
    f490:	636f4361 	.word	0x636f4361
    f494:	3fd287a7 	.word	0x3fd287a7
    f498:	8b60c8b3 	.word	0x8b60c8b3
    f49c:	3fc68a28 	.word	0x3fc68a28
    f4a0:	509f79fb 	.word	0x509f79fb
    f4a4:	3fd34413 	.word	0x3fd34413
    f4a8:	7ff00000 	.word	0x7ff00000
    f4ac:	00012a2d 	.word	0x00012a2d
    f4b0:	00012b94 	.word	0x00012b94
    f4b4:	00012ba0 	.word	0x00012ba0
    f4b8:	3ff80000 	.word	0x3ff80000
    f4bc:	00012bd0 	.word	0x00012bd0
    f4c0:	00012a2c 	.word	0x00012a2c
    f4c4:	40240000 	.word	0x40240000
    f4c8:	f7f1 fd00 	bl	ecc <__aeabi_dmul>
    f4cc:	2200      	movs	r2, #0
    f4ce:	2300      	movs	r3, #0
    f4d0:	4606      	mov	r6, r0
    f4d2:	460f      	mov	r7, r1
    f4d4:	f7f1 ff62 	bl	139c <__aeabi_dcmpeq>
    f4d8:	2800      	cmp	r0, #0
    f4da:	f040 83c2 	bne.w	fc62 <_dtoa_r+0xa62>
    f4de:	4642      	mov	r2, r8
    f4e0:	464b      	mov	r3, r9
    f4e2:	4630      	mov	r0, r6
    f4e4:	4639      	mov	r1, r7
    f4e6:	f7f1 fe1b 	bl	1120 <__aeabi_ddiv>
    f4ea:	f7f1 ff9f 	bl	142c <__aeabi_d2iz>
    f4ee:	4604      	mov	r4, r0
    f4f0:	f7f1 fc86 	bl	e00 <__aeabi_i2d>
    f4f4:	4642      	mov	r2, r8
    f4f6:	464b      	mov	r3, r9
    f4f8:	f7f1 fce8 	bl	ecc <__aeabi_dmul>
    f4fc:	4602      	mov	r2, r0
    f4fe:	460b      	mov	r3, r1
    f500:	4630      	mov	r0, r6
    f502:	4639      	mov	r1, r7
    f504:	f7f1 fb2e 	bl	b64 <__aeabi_dsub>
    f508:	f104 0e30 	add.w	lr, r4, #48	; 0x30
    f50c:	9e04      	ldr	r6, [sp, #16]
    f50e:	f805 eb01 	strb.w	lr, [r5], #1
    f512:	eba5 0e06 	sub.w	lr, r5, r6
    f516:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    f518:	45b6      	cmp	lr, r6
    f51a:	e9cd 0106 	strd	r0, r1, [sp, #24]
    f51e:	4652      	mov	r2, sl
    f520:	465b      	mov	r3, fp
    f522:	d1d1      	bne.n	f4c8 <_dtoa_r+0x2c8>
    f524:	46a0      	mov	r8, r4
    f526:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
    f52a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    f52c:	4606      	mov	r6, r0
    f52e:	460f      	mov	r7, r1
    f530:	4632      	mov	r2, r6
    f532:	463b      	mov	r3, r7
    f534:	4630      	mov	r0, r6
    f536:	4639      	mov	r1, r7
    f538:	f7f1 fb16 	bl	b68 <__adddf3>
    f53c:	4606      	mov	r6, r0
    f53e:	460f      	mov	r7, r1
    f540:	4602      	mov	r2, r0
    f542:	460b      	mov	r3, r1
    f544:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    f548:	f7f1 ff32 	bl	13b0 <__aeabi_dcmplt>
    f54c:	b948      	cbnz	r0, f562 <_dtoa_r+0x362>
    f54e:	4632      	mov	r2, r6
    f550:	463b      	mov	r3, r7
    f552:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    f556:	f7f1 ff21 	bl	139c <__aeabi_dcmpeq>
    f55a:	b1a8      	cbz	r0, f588 <_dtoa_r+0x388>
    f55c:	f018 0f01 	tst.w	r8, #1
    f560:	d012      	beq.n	f588 <_dtoa_r+0x388>
    f562:	f815 8c01 	ldrb.w	r8, [r5, #-1]
    f566:	9a04      	ldr	r2, [sp, #16]
    f568:	1e6b      	subs	r3, r5, #1
    f56a:	e004      	b.n	f576 <_dtoa_r+0x376>
    f56c:	429a      	cmp	r2, r3
    f56e:	f000 8402 	beq.w	fd76 <_dtoa_r+0xb76>
    f572:	f813 8d01 	ldrb.w	r8, [r3, #-1]!
    f576:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
    f57a:	f103 0501 	add.w	r5, r3, #1
    f57e:	d0f5      	beq.n	f56c <_dtoa_r+0x36c>
    f580:	f108 0801 	add.w	r8, r8, #1
    f584:	f883 8000 	strb.w	r8, [r3]
    f588:	4649      	mov	r1, r9
    f58a:	4620      	mov	r0, r4
    f58c:	f000 fe32 	bl	101f4 <_Bfree>
    f590:	2200      	movs	r2, #0
    f592:	9b02      	ldr	r3, [sp, #8]
    f594:	702a      	strb	r2, [r5, #0]
    f596:	9a26      	ldr	r2, [sp, #152]	; 0x98
    f598:	3301      	adds	r3, #1
    f59a:	6013      	str	r3, [r2, #0]
    f59c:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    f59e:	2b00      	cmp	r3, #0
    f5a0:	f000 839c 	beq.w	fcdc <_dtoa_r+0xadc>
    f5a4:	9804      	ldr	r0, [sp, #16]
    f5a6:	601d      	str	r5, [r3, #0]
    f5a8:	b01b      	add	sp, #108	; 0x6c
    f5aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f5ae:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    f5b0:	2a00      	cmp	r2, #0
    f5b2:	d03e      	beq.n	f632 <_dtoa_r+0x432>
    f5b4:	9a24      	ldr	r2, [sp, #144]	; 0x90
    f5b6:	2a01      	cmp	r2, #1
    f5b8:	f340 8312 	ble.w	fbe0 <_dtoa_r+0x9e0>
    f5bc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f5be:	9a06      	ldr	r2, [sp, #24]
    f5c0:	1e5f      	subs	r7, r3, #1
    f5c2:	42ba      	cmp	r2, r7
    f5c4:	f2c0 838d 	blt.w	fce2 <_dtoa_r+0xae2>
    f5c8:	1bd7      	subs	r7, r2, r7
    f5ca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f5cc:	2b00      	cmp	r3, #0
    f5ce:	f2c0 8485 	blt.w	fedc <_dtoa_r+0xcdc>
    f5d2:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    f5d4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f5d6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f5d8:	441a      	add	r2, r3
    f5da:	920b      	str	r2, [sp, #44]	; 0x2c
    f5dc:	9a08      	ldr	r2, [sp, #32]
    f5de:	2101      	movs	r1, #1
    f5e0:	441a      	add	r2, r3
    f5e2:	4620      	mov	r0, r4
    f5e4:	9208      	str	r2, [sp, #32]
    f5e6:	f000 fe9f 	bl	10328 <__i2b>
    f5ea:	4606      	mov	r6, r0
    f5ec:	e024      	b.n	f638 <_dtoa_r+0x438>
    f5ee:	2301      	movs	r3, #1
    f5f0:	930e      	str	r3, [sp, #56]	; 0x38
    f5f2:	e6af      	b.n	f354 <_dtoa_r+0x154>
    f5f4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f5f6:	9b02      	ldr	r3, [sp, #8]
    f5f8:	1ad2      	subs	r2, r2, r3
    f5fa:	425b      	negs	r3, r3
    f5fc:	9306      	str	r3, [sp, #24]
    f5fe:	2300      	movs	r3, #0
    f600:	920b      	str	r2, [sp, #44]	; 0x2c
    f602:	930d      	str	r3, [sp, #52]	; 0x34
    f604:	e6b8      	b.n	f378 <_dtoa_r+0x178>
    f606:	f1c7 0301 	rsb	r3, r7, #1
    f60a:	930b      	str	r3, [sp, #44]	; 0x2c
    f60c:	2300      	movs	r3, #0
    f60e:	9308      	str	r3, [sp, #32]
    f610:	e6a7      	b.n	f362 <_dtoa_r+0x162>
    f612:	9d02      	ldr	r5, [sp, #8]
    f614:	4628      	mov	r0, r5
    f616:	f7f1 fbf3 	bl	e00 <__aeabi_i2d>
    f61a:	4602      	mov	r2, r0
    f61c:	460b      	mov	r3, r1
    f61e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    f622:	f7f1 febb 	bl	139c <__aeabi_dcmpeq>
    f626:	2800      	cmp	r0, #0
    f628:	f47f ae80 	bne.w	f32c <_dtoa_r+0x12c>
    f62c:	1e6b      	subs	r3, r5, #1
    f62e:	9302      	str	r3, [sp, #8]
    f630:	e67c      	b.n	f32c <_dtoa_r+0x12c>
    f632:	9f06      	ldr	r7, [sp, #24]
    f634:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    f636:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    f638:	2d00      	cmp	r5, #0
    f63a:	dd0c      	ble.n	f656 <_dtoa_r+0x456>
    f63c:	9908      	ldr	r1, [sp, #32]
    f63e:	2900      	cmp	r1, #0
    f640:	460b      	mov	r3, r1
    f642:	dd08      	ble.n	f656 <_dtoa_r+0x456>
    f644:	42a9      	cmp	r1, r5
    f646:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f648:	bfa8      	it	ge
    f64a:	462b      	movge	r3, r5
    f64c:	1ad2      	subs	r2, r2, r3
    f64e:	1aed      	subs	r5, r5, r3
    f650:	1acb      	subs	r3, r1, r3
    f652:	920b      	str	r2, [sp, #44]	; 0x2c
    f654:	9308      	str	r3, [sp, #32]
    f656:	9b06      	ldr	r3, [sp, #24]
    f658:	b1d3      	cbz	r3, f690 <_dtoa_r+0x490>
    f65a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    f65c:	2b00      	cmp	r3, #0
    f65e:	f000 82b8 	beq.w	fbd2 <_dtoa_r+0x9d2>
    f662:	2f00      	cmp	r7, #0
    f664:	dd10      	ble.n	f688 <_dtoa_r+0x488>
    f666:	4631      	mov	r1, r6
    f668:	463a      	mov	r2, r7
    f66a:	4620      	mov	r0, r4
    f66c:	f000 fef8 	bl	10460 <__pow5mult>
    f670:	464a      	mov	r2, r9
    f672:	4601      	mov	r1, r0
    f674:	4606      	mov	r6, r0
    f676:	4620      	mov	r0, r4
    f678:	f000 fe60 	bl	1033c <__multiply>
    f67c:	4649      	mov	r1, r9
    f67e:	4680      	mov	r8, r0
    f680:	4620      	mov	r0, r4
    f682:	f000 fdb7 	bl	101f4 <_Bfree>
    f686:	46c1      	mov	r9, r8
    f688:	9b06      	ldr	r3, [sp, #24]
    f68a:	1bda      	subs	r2, r3, r7
    f68c:	f040 82a2 	bne.w	fbd4 <_dtoa_r+0x9d4>
    f690:	2101      	movs	r1, #1
    f692:	4620      	mov	r0, r4
    f694:	f000 fe48 	bl	10328 <__i2b>
    f698:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    f69a:	9006      	str	r0, [sp, #24]
    f69c:	2b00      	cmp	r3, #0
    f69e:	dd1c      	ble.n	f6da <_dtoa_r+0x4da>
    f6a0:	4601      	mov	r1, r0
    f6a2:	461a      	mov	r2, r3
    f6a4:	4620      	mov	r0, r4
    f6a6:	f000 fedb 	bl	10460 <__pow5mult>
    f6aa:	9b24      	ldr	r3, [sp, #144]	; 0x90
    f6ac:	9006      	str	r0, [sp, #24]
    f6ae:	2b01      	cmp	r3, #1
    f6b0:	f340 8255 	ble.w	fb5e <_dtoa_r+0x95e>
    f6b4:	f04f 0800 	mov.w	r8, #0
    f6b8:	9a06      	ldr	r2, [sp, #24]
    f6ba:	6913      	ldr	r3, [r2, #16]
    f6bc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    f6c0:	6918      	ldr	r0, [r3, #16]
    f6c2:	f000 fde1 	bl	10288 <__hi0bits>
    f6c6:	f1c0 0020 	rsb	r0, r0, #32
    f6ca:	e010      	b.n	f6ee <_dtoa_r+0x4ee>
    f6cc:	f1c3 0520 	rsb	r5, r3, #32
    f6d0:	fa0a f005 	lsl.w	r0, sl, r5
    f6d4:	e674      	b.n	f3c0 <_dtoa_r+0x1c0>
    f6d6:	900e      	str	r0, [sp, #56]	; 0x38
    f6d8:	e63c      	b.n	f354 <_dtoa_r+0x154>
    f6da:	9b24      	ldr	r3, [sp, #144]	; 0x90
    f6dc:	2b01      	cmp	r3, #1
    f6de:	f340 8288 	ble.w	fbf2 <_dtoa_r+0x9f2>
    f6e2:	f04f 0800 	mov.w	r8, #0
    f6e6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    f6e8:	2001      	movs	r0, #1
    f6ea:	2b00      	cmp	r3, #0
    f6ec:	d1e4      	bne.n	f6b8 <_dtoa_r+0x4b8>
    f6ee:	9a08      	ldr	r2, [sp, #32]
    f6f0:	4410      	add	r0, r2
    f6f2:	f010 001f 	ands.w	r0, r0, #31
    f6f6:	f000 80a0 	beq.w	f83a <_dtoa_r+0x63a>
    f6fa:	f1c0 0320 	rsb	r3, r0, #32
    f6fe:	2b04      	cmp	r3, #4
    f700:	f340 847f 	ble.w	10002 <_dtoa_r+0xe02>
    f704:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f706:	f1c0 001c 	rsb	r0, r0, #28
    f70a:	4403      	add	r3, r0
    f70c:	930b      	str	r3, [sp, #44]	; 0x2c
    f70e:	4613      	mov	r3, r2
    f710:	4403      	add	r3, r0
    f712:	4405      	add	r5, r0
    f714:	9308      	str	r3, [sp, #32]
    f716:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f718:	2b00      	cmp	r3, #0
    f71a:	dd05      	ble.n	f728 <_dtoa_r+0x528>
    f71c:	4649      	mov	r1, r9
    f71e:	461a      	mov	r2, r3
    f720:	4620      	mov	r0, r4
    f722:	f000 feed 	bl	10500 <__lshift>
    f726:	4681      	mov	r9, r0
    f728:	9b08      	ldr	r3, [sp, #32]
    f72a:	2b00      	cmp	r3, #0
    f72c:	dd05      	ble.n	f73a <_dtoa_r+0x53a>
    f72e:	461a      	mov	r2, r3
    f730:	9906      	ldr	r1, [sp, #24]
    f732:	4620      	mov	r0, r4
    f734:	f000 fee4 	bl	10500 <__lshift>
    f738:	9006      	str	r0, [sp, #24]
    f73a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    f73c:	2b00      	cmp	r3, #0
    f73e:	f040 8085 	bne.w	f84c <_dtoa_r+0x64c>
    f742:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f744:	2b00      	cmp	r3, #0
    f746:	f340 8267 	ble.w	fc18 <_dtoa_r+0xa18>
    f74a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    f74c:	2b00      	cmp	r3, #0
    f74e:	f000 8097 	beq.w	f880 <_dtoa_r+0x680>
    f752:	2d00      	cmp	r5, #0
    f754:	dd05      	ble.n	f762 <_dtoa_r+0x562>
    f756:	4631      	mov	r1, r6
    f758:	462a      	mov	r2, r5
    f75a:	4620      	mov	r0, r4
    f75c:	f000 fed0 	bl	10500 <__lshift>
    f760:	4606      	mov	r6, r0
    f762:	f1b8 0f00 	cmp.w	r8, #0
    f766:	f040 8338 	bne.w	fdda <_dtoa_r+0xbda>
    f76a:	46b0      	mov	r8, r6
    f76c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f76e:	9a04      	ldr	r2, [sp, #16]
    f770:	3b01      	subs	r3, #1
    f772:	18d3      	adds	r3, r2, r3
    f774:	930b      	str	r3, [sp, #44]	; 0x2c
    f776:	f00a 0301 	and.w	r3, sl, #1
    f77a:	930c      	str	r3, [sp, #48]	; 0x30
    f77c:	4617      	mov	r7, r2
    f77e:	f8dd b018 	ldr.w	fp, [sp, #24]
    f782:	4648      	mov	r0, r9
    f784:	4659      	mov	r1, fp
    f786:	f7ff fca7 	bl	f0d8 <quorem>
    f78a:	4631      	mov	r1, r6
    f78c:	4605      	mov	r5, r0
    f78e:	4648      	mov	r0, r9
    f790:	f000 ff08 	bl	105a4 <__mcmp>
    f794:	4642      	mov	r2, r8
    f796:	4659      	mov	r1, fp
    f798:	4682      	mov	sl, r0
    f79a:	4620      	mov	r0, r4
    f79c:	f000 ff1e 	bl	105dc <__mdiff>
    f7a0:	68c2      	ldr	r2, [r0, #12]
    f7a2:	4683      	mov	fp, r0
    f7a4:	f105 0330 	add.w	r3, r5, #48	; 0x30
    f7a8:	2a00      	cmp	r2, #0
    f7aa:	f040 822d 	bne.w	fc08 <_dtoa_r+0xa08>
    f7ae:	4601      	mov	r1, r0
    f7b0:	4648      	mov	r0, r9
    f7b2:	9308      	str	r3, [sp, #32]
    f7b4:	f000 fef6 	bl	105a4 <__mcmp>
    f7b8:	4659      	mov	r1, fp
    f7ba:	900a      	str	r0, [sp, #40]	; 0x28
    f7bc:	4620      	mov	r0, r4
    f7be:	f000 fd19 	bl	101f4 <_Bfree>
    f7c2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    f7c4:	9b08      	ldr	r3, [sp, #32]
    f7c6:	b932      	cbnz	r2, f7d6 <_dtoa_r+0x5d6>
    f7c8:	9924      	ldr	r1, [sp, #144]	; 0x90
    f7ca:	b921      	cbnz	r1, f7d6 <_dtoa_r+0x5d6>
    f7cc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    f7ce:	2a00      	cmp	r2, #0
    f7d0:	f000 83dd 	beq.w	ff8e <_dtoa_r+0xd8e>
    f7d4:	9a24      	ldr	r2, [sp, #144]	; 0x90
    f7d6:	f1ba 0f00 	cmp.w	sl, #0
    f7da:	f2c0 829e 	blt.w	fd1a <_dtoa_r+0xb1a>
    f7de:	d105      	bne.n	f7ec <_dtoa_r+0x5ec>
    f7e0:	9924      	ldr	r1, [sp, #144]	; 0x90
    f7e2:	b919      	cbnz	r1, f7ec <_dtoa_r+0x5ec>
    f7e4:	990c      	ldr	r1, [sp, #48]	; 0x30
    f7e6:	2900      	cmp	r1, #0
    f7e8:	f000 8297 	beq.w	fd1a <_dtoa_r+0xb1a>
    f7ec:	2a00      	cmp	r2, #0
    f7ee:	f300 8308 	bgt.w	fe02 <_dtoa_r+0xc02>
    f7f2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f7f4:	703b      	strb	r3, [r7, #0]
    f7f6:	f107 0a01 	add.w	sl, r7, #1
    f7fa:	4297      	cmp	r7, r2
    f7fc:	4655      	mov	r5, sl
    f7fe:	f000 8309 	beq.w	fe14 <_dtoa_r+0xc14>
    f802:	4649      	mov	r1, r9
    f804:	2300      	movs	r3, #0
    f806:	220a      	movs	r2, #10
    f808:	4620      	mov	r0, r4
    f80a:	f000 fcfd 	bl	10208 <__multadd>
    f80e:	4546      	cmp	r6, r8
    f810:	4681      	mov	r9, r0
    f812:	4631      	mov	r1, r6
    f814:	f04f 0300 	mov.w	r3, #0
    f818:	f04f 020a 	mov.w	r2, #10
    f81c:	4620      	mov	r0, r4
    f81e:	f000 81ed 	beq.w	fbfc <_dtoa_r+0x9fc>
    f822:	f000 fcf1 	bl	10208 <__multadd>
    f826:	4641      	mov	r1, r8
    f828:	4606      	mov	r6, r0
    f82a:	2300      	movs	r3, #0
    f82c:	220a      	movs	r2, #10
    f82e:	4620      	mov	r0, r4
    f830:	f000 fcea 	bl	10208 <__multadd>
    f834:	4657      	mov	r7, sl
    f836:	4680      	mov	r8, r0
    f838:	e7a1      	b.n	f77e <_dtoa_r+0x57e>
    f83a:	201c      	movs	r0, #28
    f83c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f83e:	4403      	add	r3, r0
    f840:	930b      	str	r3, [sp, #44]	; 0x2c
    f842:	9b08      	ldr	r3, [sp, #32]
    f844:	4403      	add	r3, r0
    f846:	4405      	add	r5, r0
    f848:	9308      	str	r3, [sp, #32]
    f84a:	e764      	b.n	f716 <_dtoa_r+0x516>
    f84c:	9906      	ldr	r1, [sp, #24]
    f84e:	4648      	mov	r0, r9
    f850:	f000 fea8 	bl	105a4 <__mcmp>
    f854:	2800      	cmp	r0, #0
    f856:	f6bf af74 	bge.w	f742 <_dtoa_r+0x542>
    f85a:	9f02      	ldr	r7, [sp, #8]
    f85c:	4649      	mov	r1, r9
    f85e:	2300      	movs	r3, #0
    f860:	220a      	movs	r2, #10
    f862:	4620      	mov	r0, r4
    f864:	3f01      	subs	r7, #1
    f866:	9702      	str	r7, [sp, #8]
    f868:	f000 fcce 	bl	10208 <__multadd>
    f86c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    f86e:	4681      	mov	r9, r0
    f870:	2b00      	cmp	r3, #0
    f872:	f040 83a9 	bne.w	ffc8 <_dtoa_r+0xdc8>
    f876:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    f878:	2b00      	cmp	r3, #0
    f87a:	f340 83b2 	ble.w	ffe2 <_dtoa_r+0xde2>
    f87e:	930a      	str	r3, [sp, #40]	; 0x28
    f880:	f8dd 8010 	ldr.w	r8, [sp, #16]
    f884:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    f886:	f8dd b018 	ldr.w	fp, [sp, #24]
    f88a:	4645      	mov	r5, r8
    f88c:	e002      	b.n	f894 <_dtoa_r+0x694>
    f88e:	f000 fcbb 	bl	10208 <__multadd>
    f892:	4681      	mov	r9, r0
    f894:	4659      	mov	r1, fp
    f896:	4648      	mov	r0, r9
    f898:	f7ff fc1e 	bl	f0d8 <quorem>
    f89c:	f100 0a30 	add.w	sl, r0, #48	; 0x30
    f8a0:	f805 ab01 	strb.w	sl, [r5], #1
    f8a4:	eba5 0308 	sub.w	r3, r5, r8
    f8a8:	42bb      	cmp	r3, r7
    f8aa:	f04f 020a 	mov.w	r2, #10
    f8ae:	f04f 0300 	mov.w	r3, #0
    f8b2:	4649      	mov	r1, r9
    f8b4:	4620      	mov	r0, r4
    f8b6:	dbea      	blt.n	f88e <_dtoa_r+0x68e>
    f8b8:	9b04      	ldr	r3, [sp, #16]
    f8ba:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    f8bc:	2a01      	cmp	r2, #1
    f8be:	bfac      	ite	ge
    f8c0:	189b      	addge	r3, r3, r2
    f8c2:	3301      	addlt	r3, #1
    f8c4:	461d      	mov	r5, r3
    f8c6:	f04f 0b00 	mov.w	fp, #0
    f8ca:	4649      	mov	r1, r9
    f8cc:	2201      	movs	r2, #1
    f8ce:	4620      	mov	r0, r4
    f8d0:	f000 fe16 	bl	10500 <__lshift>
    f8d4:	9906      	ldr	r1, [sp, #24]
    f8d6:	4681      	mov	r9, r0
    f8d8:	f000 fe64 	bl	105a4 <__mcmp>
    f8dc:	2800      	cmp	r0, #0
    f8de:	f340 8237 	ble.w	fd50 <_dtoa_r+0xb50>
    f8e2:	f815 2c01 	ldrb.w	r2, [r5, #-1]
    f8e6:	9904      	ldr	r1, [sp, #16]
    f8e8:	1e6b      	subs	r3, r5, #1
    f8ea:	e004      	b.n	f8f6 <_dtoa_r+0x6f6>
    f8ec:	428b      	cmp	r3, r1
    f8ee:	f000 81ae 	beq.w	fc4e <_dtoa_r+0xa4e>
    f8f2:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    f8f6:	2a39      	cmp	r2, #57	; 0x39
    f8f8:	f103 0501 	add.w	r5, r3, #1
    f8fc:	d0f6      	beq.n	f8ec <_dtoa_r+0x6ec>
    f8fe:	3201      	adds	r2, #1
    f900:	701a      	strb	r2, [r3, #0]
    f902:	9906      	ldr	r1, [sp, #24]
    f904:	4620      	mov	r0, r4
    f906:	f000 fc75 	bl	101f4 <_Bfree>
    f90a:	2e00      	cmp	r6, #0
    f90c:	f43f ae3c 	beq.w	f588 <_dtoa_r+0x388>
    f910:	f1bb 0f00 	cmp.w	fp, #0
    f914:	d005      	beq.n	f922 <_dtoa_r+0x722>
    f916:	45b3      	cmp	fp, r6
    f918:	d003      	beq.n	f922 <_dtoa_r+0x722>
    f91a:	4659      	mov	r1, fp
    f91c:	4620      	mov	r0, r4
    f91e:	f000 fc69 	bl	101f4 <_Bfree>
    f922:	4631      	mov	r1, r6
    f924:	4620      	mov	r0, r4
    f926:	f000 fc65 	bl	101f4 <_Bfree>
    f92a:	e62d      	b.n	f588 <_dtoa_r+0x388>
    f92c:	2300      	movs	r3, #0
    f92e:	930c      	str	r3, [sp, #48]	; 0x30
    f930:	9b02      	ldr	r3, [sp, #8]
    f932:	9a25      	ldr	r2, [sp, #148]	; 0x94
    f934:	4413      	add	r3, r2
    f936:	930f      	str	r3, [sp, #60]	; 0x3c
    f938:	3301      	adds	r3, #1
    f93a:	2b01      	cmp	r3, #1
    f93c:	461f      	mov	r7, r3
    f93e:	461e      	mov	r6, r3
    f940:	930a      	str	r3, [sp, #40]	; 0x28
    f942:	bfb8      	it	lt
    f944:	2701      	movlt	r7, #1
    f946:	2100      	movs	r1, #0
    f948:	2f17      	cmp	r7, #23
    f94a:	6461      	str	r1, [r4, #68]	; 0x44
    f94c:	d90a      	bls.n	f964 <_dtoa_r+0x764>
    f94e:	2201      	movs	r2, #1
    f950:	2304      	movs	r3, #4
    f952:	005b      	lsls	r3, r3, #1
    f954:	f103 0014 	add.w	r0, r3, #20
    f958:	4287      	cmp	r7, r0
    f95a:	4611      	mov	r1, r2
    f95c:	f102 0201 	add.w	r2, r2, #1
    f960:	d2f7      	bcs.n	f952 <_dtoa_r+0x752>
    f962:	6461      	str	r1, [r4, #68]	; 0x44
    f964:	4620      	mov	r0, r4
    f966:	f000 fc1f 	bl	101a8 <_Balloc>
    f96a:	2e0e      	cmp	r6, #14
    f96c:	9004      	str	r0, [sp, #16]
    f96e:	6420      	str	r0, [r4, #64]	; 0x40
    f970:	f63f ad40 	bhi.w	f3f4 <_dtoa_r+0x1f4>
    f974:	2d00      	cmp	r5, #0
    f976:	f43f ad3d 	beq.w	f3f4 <_dtoa_r+0x1f4>
    f97a:	9902      	ldr	r1, [sp, #8]
    f97c:	2900      	cmp	r1, #0
    f97e:	e9cd ab10 	strd	sl, fp, [sp, #64]	; 0x40
    f982:	f340 8202 	ble.w	fd8a <_dtoa_r+0xb8a>
    f986:	4bb9      	ldr	r3, [pc, #740]	; (fc6c <_dtoa_r+0xa6c>)
    f988:	f001 020f 	and.w	r2, r1, #15
    f98c:	110d      	asrs	r5, r1, #4
    f98e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    f992:	06e9      	lsls	r1, r5, #27
    f994:	e9d3 6700 	ldrd	r6, r7, [r3]
    f998:	f140 81ab 	bpl.w	fcf2 <_dtoa_r+0xaf2>
    f99c:	4bb4      	ldr	r3, [pc, #720]	; (fc70 <_dtoa_r+0xa70>)
    f99e:	4650      	mov	r0, sl
    f9a0:	4659      	mov	r1, fp
    f9a2:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
    f9a6:	f7f1 fbbb 	bl	1120 <__aeabi_ddiv>
    f9aa:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
    f9ae:	f005 050f 	and.w	r5, r5, #15
    f9b2:	f04f 0a03 	mov.w	sl, #3
    f9b6:	b18d      	cbz	r5, f9dc <_dtoa_r+0x7dc>
    f9b8:	f8df 82b4 	ldr.w	r8, [pc, #692]	; fc70 <_dtoa_r+0xa70>
    f9bc:	07ea      	lsls	r2, r5, #31
    f9be:	d509      	bpl.n	f9d4 <_dtoa_r+0x7d4>
    f9c0:	4630      	mov	r0, r6
    f9c2:	4639      	mov	r1, r7
    f9c4:	e9d8 2300 	ldrd	r2, r3, [r8]
    f9c8:	f7f1 fa80 	bl	ecc <__aeabi_dmul>
    f9cc:	f10a 0a01 	add.w	sl, sl, #1
    f9d0:	4606      	mov	r6, r0
    f9d2:	460f      	mov	r7, r1
    f9d4:	106d      	asrs	r5, r5, #1
    f9d6:	f108 0808 	add.w	r8, r8, #8
    f9da:	d1ef      	bne.n	f9bc <_dtoa_r+0x7bc>
    f9dc:	463b      	mov	r3, r7
    f9de:	4632      	mov	r2, r6
    f9e0:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    f9e4:	f7f1 fb9c 	bl	1120 <__aeabi_ddiv>
    f9e8:	4607      	mov	r7, r0
    f9ea:	4688      	mov	r8, r1
    f9ec:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    f9ee:	b143      	cbz	r3, fa02 <_dtoa_r+0x802>
    f9f0:	2200      	movs	r2, #0
    f9f2:	4ba0      	ldr	r3, [pc, #640]	; (fc74 <_dtoa_r+0xa74>)
    f9f4:	4638      	mov	r0, r7
    f9f6:	4641      	mov	r1, r8
    f9f8:	f7f1 fcda 	bl	13b0 <__aeabi_dcmplt>
    f9fc:	2800      	cmp	r0, #0
    f9fe:	f040 827f 	bne.w	ff00 <_dtoa_r+0xd00>
    fa02:	4650      	mov	r0, sl
    fa04:	f7f1 f9fc 	bl	e00 <__aeabi_i2d>
    fa08:	463a      	mov	r2, r7
    fa0a:	4643      	mov	r3, r8
    fa0c:	f7f1 fa5e 	bl	ecc <__aeabi_dmul>
    fa10:	4b99      	ldr	r3, [pc, #612]	; (fc78 <_dtoa_r+0xa78>)
    fa12:	2200      	movs	r2, #0
    fa14:	f7f1 f8a8 	bl	b68 <__adddf3>
    fa18:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fa1a:	4682      	mov	sl, r0
    fa1c:	f1a1 7b50 	sub.w	fp, r1, #54525952	; 0x3400000
    fa20:	2b00      	cmp	r3, #0
    fa22:	f000 813f 	beq.w	fca4 <_dtoa_r+0xaa4>
    fa26:	9b02      	ldr	r3, [sp, #8]
    fa28:	9315      	str	r3, [sp, #84]	; 0x54
    fa2a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fa2c:	9312      	str	r3, [sp, #72]	; 0x48
    fa2e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    fa30:	2b00      	cmp	r3, #0
    fa32:	f000 81f7 	beq.w	fe24 <_dtoa_r+0xc24>
    fa36:	9a12      	ldr	r2, [sp, #72]	; 0x48
    fa38:	4b8c      	ldr	r3, [pc, #560]	; (fc6c <_dtoa_r+0xa6c>)
    fa3a:	4990      	ldr	r1, [pc, #576]	; (fc7c <_dtoa_r+0xa7c>)
    fa3c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    fa40:	e953 2302 	ldrd	r2, r3, [r3, #-8]
    fa44:	2000      	movs	r0, #0
    fa46:	f7f1 fb6b 	bl	1120 <__aeabi_ddiv>
    fa4a:	4652      	mov	r2, sl
    fa4c:	465b      	mov	r3, fp
    fa4e:	f7f1 f889 	bl	b64 <__aeabi_dsub>
    fa52:	4682      	mov	sl, r0
    fa54:	468b      	mov	fp, r1
    fa56:	4638      	mov	r0, r7
    fa58:	4641      	mov	r1, r8
    fa5a:	f7f1 fce7 	bl	142c <__aeabi_d2iz>
    fa5e:	4605      	mov	r5, r0
    fa60:	f7f1 f9ce 	bl	e00 <__aeabi_i2d>
    fa64:	4602      	mov	r2, r0
    fa66:	460b      	mov	r3, r1
    fa68:	4638      	mov	r0, r7
    fa6a:	4641      	mov	r1, r8
    fa6c:	f7f1 f87a 	bl	b64 <__aeabi_dsub>
    fa70:	3530      	adds	r5, #48	; 0x30
    fa72:	fa5f f885 	uxtb.w	r8, r5
    fa76:	9d04      	ldr	r5, [sp, #16]
    fa78:	4606      	mov	r6, r0
    fa7a:	460f      	mov	r7, r1
    fa7c:	f885 8000 	strb.w	r8, [r5]
    fa80:	4602      	mov	r2, r0
    fa82:	460b      	mov	r3, r1
    fa84:	4650      	mov	r0, sl
    fa86:	4659      	mov	r1, fp
    fa88:	3501      	adds	r5, #1
    fa8a:	f7f1 fcaf 	bl	13ec <__aeabi_dcmpgt>
    fa8e:	2800      	cmp	r0, #0
    fa90:	d154      	bne.n	fb3c <_dtoa_r+0x93c>
    fa92:	4632      	mov	r2, r6
    fa94:	463b      	mov	r3, r7
    fa96:	2000      	movs	r0, #0
    fa98:	4976      	ldr	r1, [pc, #472]	; (fc74 <_dtoa_r+0xa74>)
    fa9a:	f7f1 f863 	bl	b64 <__aeabi_dsub>
    fa9e:	4602      	mov	r2, r0
    faa0:	460b      	mov	r3, r1
    faa2:	4650      	mov	r0, sl
    faa4:	4659      	mov	r1, fp
    faa6:	f7f1 fca1 	bl	13ec <__aeabi_dcmpgt>
    faaa:	2800      	cmp	r0, #0
    faac:	f040 8268 	bne.w	ff80 <_dtoa_r+0xd80>
    fab0:	9a12      	ldr	r2, [sp, #72]	; 0x48
    fab2:	2a01      	cmp	r2, #1
    fab4:	f000 815b 	beq.w	fd6e <_dtoa_r+0xb6e>
    fab8:	9b12      	ldr	r3, [sp, #72]	; 0x48
    faba:	9a04      	ldr	r2, [sp, #16]
    fabc:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
    fac0:	4413      	add	r3, r2
    fac2:	4699      	mov	r9, r3
    fac4:	e00d      	b.n	fae2 <_dtoa_r+0x8e2>
    fac6:	2000      	movs	r0, #0
    fac8:	496a      	ldr	r1, [pc, #424]	; (fc74 <_dtoa_r+0xa74>)
    faca:	f7f1 f84b 	bl	b64 <__aeabi_dsub>
    face:	4652      	mov	r2, sl
    fad0:	465b      	mov	r3, fp
    fad2:	f7f1 fc6d 	bl	13b0 <__aeabi_dcmplt>
    fad6:	2800      	cmp	r0, #0
    fad8:	f040 8250 	bne.w	ff7c <_dtoa_r+0xd7c>
    fadc:	454d      	cmp	r5, r9
    fade:	f000 8144 	beq.w	fd6a <_dtoa_r+0xb6a>
    fae2:	4650      	mov	r0, sl
    fae4:	4659      	mov	r1, fp
    fae6:	2200      	movs	r2, #0
    fae8:	4b65      	ldr	r3, [pc, #404]	; (fc80 <_dtoa_r+0xa80>)
    faea:	f7f1 f9ef 	bl	ecc <__aeabi_dmul>
    faee:	2200      	movs	r2, #0
    faf0:	4b63      	ldr	r3, [pc, #396]	; (fc80 <_dtoa_r+0xa80>)
    faf2:	4682      	mov	sl, r0
    faf4:	468b      	mov	fp, r1
    faf6:	4630      	mov	r0, r6
    faf8:	4639      	mov	r1, r7
    fafa:	f7f1 f9e7 	bl	ecc <__aeabi_dmul>
    fafe:	460f      	mov	r7, r1
    fb00:	4606      	mov	r6, r0
    fb02:	f7f1 fc93 	bl	142c <__aeabi_d2iz>
    fb06:	4680      	mov	r8, r0
    fb08:	f7f1 f97a 	bl	e00 <__aeabi_i2d>
    fb0c:	4602      	mov	r2, r0
    fb0e:	460b      	mov	r3, r1
    fb10:	4630      	mov	r0, r6
    fb12:	4639      	mov	r1, r7
    fb14:	f7f1 f826 	bl	b64 <__aeabi_dsub>
    fb18:	f108 0830 	add.w	r8, r8, #48	; 0x30
    fb1c:	fa5f f888 	uxtb.w	r8, r8
    fb20:	4652      	mov	r2, sl
    fb22:	465b      	mov	r3, fp
    fb24:	f805 8b01 	strb.w	r8, [r5], #1
    fb28:	4606      	mov	r6, r0
    fb2a:	460f      	mov	r7, r1
    fb2c:	f7f1 fc40 	bl	13b0 <__aeabi_dcmplt>
    fb30:	4632      	mov	r2, r6
    fb32:	463b      	mov	r3, r7
    fb34:	2800      	cmp	r0, #0
    fb36:	d0c6      	beq.n	fac6 <_dtoa_r+0x8c6>
    fb38:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
    fb3c:	9b15      	ldr	r3, [sp, #84]	; 0x54
    fb3e:	9302      	str	r3, [sp, #8]
    fb40:	e522      	b.n	f588 <_dtoa_r+0x388>
    fb42:	2300      	movs	r3, #0
    fb44:	930c      	str	r3, [sp, #48]	; 0x30
    fb46:	9b25      	ldr	r3, [sp, #148]	; 0x94
    fb48:	2b00      	cmp	r3, #0
    fb4a:	f340 80d9 	ble.w	fd00 <_dtoa_r+0xb00>
    fb4e:	461f      	mov	r7, r3
    fb50:	461e      	mov	r6, r3
    fb52:	930f      	str	r3, [sp, #60]	; 0x3c
    fb54:	930a      	str	r3, [sp, #40]	; 0x28
    fb56:	e6f6      	b.n	f946 <_dtoa_r+0x746>
    fb58:	2301      	movs	r3, #1
    fb5a:	930c      	str	r3, [sp, #48]	; 0x30
    fb5c:	e7f3      	b.n	fb46 <_dtoa_r+0x946>
    fb5e:	f1ba 0f00 	cmp.w	sl, #0
    fb62:	f47f ada7 	bne.w	f6b4 <_dtoa_r+0x4b4>
    fb66:	f3cb 0313 	ubfx	r3, fp, #0, #20
    fb6a:	2b00      	cmp	r3, #0
    fb6c:	f47f adb9 	bne.w	f6e2 <_dtoa_r+0x4e2>
    fb70:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
    fb74:	0d3f      	lsrs	r7, r7, #20
    fb76:	053f      	lsls	r7, r7, #20
    fb78:	2f00      	cmp	r7, #0
    fb7a:	f000 8205 	beq.w	ff88 <_dtoa_r+0xd88>
    fb7e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fb80:	3301      	adds	r3, #1
    fb82:	930b      	str	r3, [sp, #44]	; 0x2c
    fb84:	9b08      	ldr	r3, [sp, #32]
    fb86:	3301      	adds	r3, #1
    fb88:	9308      	str	r3, [sp, #32]
    fb8a:	f04f 0801 	mov.w	r8, #1
    fb8e:	e5aa      	b.n	f6e6 <_dtoa_r+0x4e6>
    fb90:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fb92:	2b00      	cmp	r3, #0
    fb94:	f73f ac41 	bgt.w	f41a <_dtoa_r+0x21a>
    fb98:	f040 809c 	bne.w	fcd4 <_dtoa_r+0xad4>
    fb9c:	2200      	movs	r2, #0
    fb9e:	4b39      	ldr	r3, [pc, #228]	; (fc84 <_dtoa_r+0xa84>)
    fba0:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    fba4:	f7f1 f992 	bl	ecc <__aeabi_dmul>
    fba8:	465b      	mov	r3, fp
    fbaa:	4652      	mov	r2, sl
    fbac:	f7f1 fc14 	bl	13d8 <__aeabi_dcmpge>
    fbb0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fbb2:	9306      	str	r3, [sp, #24]
    fbb4:	461e      	mov	r6, r3
    fbb6:	2800      	cmp	r0, #0
    fbb8:	d041      	beq.n	fc3e <_dtoa_r+0xa3e>
    fbba:	9b25      	ldr	r3, [sp, #148]	; 0x94
    fbbc:	9d04      	ldr	r5, [sp, #16]
    fbbe:	43db      	mvns	r3, r3
    fbc0:	9302      	str	r3, [sp, #8]
    fbc2:	9906      	ldr	r1, [sp, #24]
    fbc4:	4620      	mov	r0, r4
    fbc6:	f000 fb15 	bl	101f4 <_Bfree>
    fbca:	2e00      	cmp	r6, #0
    fbcc:	f43f acdc 	beq.w	f588 <_dtoa_r+0x388>
    fbd0:	e6a7      	b.n	f922 <_dtoa_r+0x722>
    fbd2:	9a06      	ldr	r2, [sp, #24]
    fbd4:	4649      	mov	r1, r9
    fbd6:	4620      	mov	r0, r4
    fbd8:	f000 fc42 	bl	10460 <__pow5mult>
    fbdc:	4681      	mov	r9, r0
    fbde:	e557      	b.n	f690 <_dtoa_r+0x490>
    fbe0:	9a14      	ldr	r2, [sp, #80]	; 0x50
    fbe2:	2a00      	cmp	r2, #0
    fbe4:	f000 8180 	beq.w	fee8 <_dtoa_r+0xce8>
    fbe8:	f203 4333 	addw	r3, r3, #1075	; 0x433
    fbec:	9f06      	ldr	r7, [sp, #24]
    fbee:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    fbf0:	e4f1      	b.n	f5d6 <_dtoa_r+0x3d6>
    fbf2:	f1ba 0f00 	cmp.w	sl, #0
    fbf6:	f47f ad74 	bne.w	f6e2 <_dtoa_r+0x4e2>
    fbfa:	e7b4      	b.n	fb66 <_dtoa_r+0x966>
    fbfc:	f000 fb04 	bl	10208 <__multadd>
    fc00:	4657      	mov	r7, sl
    fc02:	4606      	mov	r6, r0
    fc04:	4680      	mov	r8, r0
    fc06:	e5ba      	b.n	f77e <_dtoa_r+0x57e>
    fc08:	4601      	mov	r1, r0
    fc0a:	4620      	mov	r0, r4
    fc0c:	930a      	str	r3, [sp, #40]	; 0x28
    fc0e:	f000 faf1 	bl	101f4 <_Bfree>
    fc12:	2201      	movs	r2, #1
    fc14:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fc16:	e5de      	b.n	f7d6 <_dtoa_r+0x5d6>
    fc18:	9b24      	ldr	r3, [sp, #144]	; 0x90
    fc1a:	2b02      	cmp	r3, #2
    fc1c:	f77f ad95 	ble.w	f74a <_dtoa_r+0x54a>
    fc20:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fc22:	2b00      	cmp	r3, #0
    fc24:	d1c9      	bne.n	fbba <_dtoa_r+0x9ba>
    fc26:	9906      	ldr	r1, [sp, #24]
    fc28:	2205      	movs	r2, #5
    fc2a:	4620      	mov	r0, r4
    fc2c:	f000 faec 	bl	10208 <__multadd>
    fc30:	4601      	mov	r1, r0
    fc32:	9006      	str	r0, [sp, #24]
    fc34:	4648      	mov	r0, r9
    fc36:	f000 fcb5 	bl	105a4 <__mcmp>
    fc3a:	2800      	cmp	r0, #0
    fc3c:	ddbd      	ble.n	fbba <_dtoa_r+0x9ba>
    fc3e:	9a02      	ldr	r2, [sp, #8]
    fc40:	9904      	ldr	r1, [sp, #16]
    fc42:	2331      	movs	r3, #49	; 0x31
    fc44:	3201      	adds	r2, #1
    fc46:	9202      	str	r2, [sp, #8]
    fc48:	700b      	strb	r3, [r1, #0]
    fc4a:	1c4d      	adds	r5, r1, #1
    fc4c:	e7b9      	b.n	fbc2 <_dtoa_r+0x9c2>
    fc4e:	9a02      	ldr	r2, [sp, #8]
    fc50:	3201      	adds	r2, #1
    fc52:	9202      	str	r2, [sp, #8]
    fc54:	9a04      	ldr	r2, [sp, #16]
    fc56:	2331      	movs	r3, #49	; 0x31
    fc58:	7013      	strb	r3, [r2, #0]
    fc5a:	e652      	b.n	f902 <_dtoa_r+0x702>
    fc5c:	2301      	movs	r3, #1
    fc5e:	930c      	str	r3, [sp, #48]	; 0x30
    fc60:	e666      	b.n	f930 <_dtoa_r+0x730>
    fc62:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
    fc66:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    fc68:	e48e      	b.n	f588 <_dtoa_r+0x388>
    fc6a:	bf00      	nop
    fc6c:	00012bd0 	.word	0x00012bd0
    fc70:	00012ba8 	.word	0x00012ba8
    fc74:	3ff00000 	.word	0x3ff00000
    fc78:	401c0000 	.word	0x401c0000
    fc7c:	3fe00000 	.word	0x3fe00000
    fc80:	40240000 	.word	0x40240000
    fc84:	40140000 	.word	0x40140000
    fc88:	4650      	mov	r0, sl
    fc8a:	f7f1 f8b9 	bl	e00 <__aeabi_i2d>
    fc8e:	463a      	mov	r2, r7
    fc90:	4643      	mov	r3, r8
    fc92:	f7f1 f91b 	bl	ecc <__aeabi_dmul>
    fc96:	2200      	movs	r2, #0
    fc98:	4bc5      	ldr	r3, [pc, #788]	; (ffb0 <_dtoa_r+0xdb0>)
    fc9a:	f7f0 ff65 	bl	b68 <__adddf3>
    fc9e:	4682      	mov	sl, r0
    fca0:	f1a1 7b50 	sub.w	fp, r1, #54525952	; 0x3400000
    fca4:	4638      	mov	r0, r7
    fca6:	2200      	movs	r2, #0
    fca8:	4bc2      	ldr	r3, [pc, #776]	; (ffb4 <_dtoa_r+0xdb4>)
    fcaa:	4641      	mov	r1, r8
    fcac:	f7f0 ff5a 	bl	b64 <__aeabi_dsub>
    fcb0:	4652      	mov	r2, sl
    fcb2:	465b      	mov	r3, fp
    fcb4:	4606      	mov	r6, r0
    fcb6:	460f      	mov	r7, r1
    fcb8:	f7f1 fb98 	bl	13ec <__aeabi_dcmpgt>
    fcbc:	2800      	cmp	r0, #0
    fcbe:	f040 80ad 	bne.w	fe1c <_dtoa_r+0xc1c>
    fcc2:	4652      	mov	r2, sl
    fcc4:	f10b 4300 	add.w	r3, fp, #2147483648	; 0x80000000
    fcc8:	4630      	mov	r0, r6
    fcca:	4639      	mov	r1, r7
    fccc:	f7f1 fb70 	bl	13b0 <__aeabi_dcmplt>
    fcd0:	2800      	cmp	r0, #0
    fcd2:	d04c      	beq.n	fd6e <_dtoa_r+0xb6e>
    fcd4:	2300      	movs	r3, #0
    fcd6:	9306      	str	r3, [sp, #24]
    fcd8:	461e      	mov	r6, r3
    fcda:	e76e      	b.n	fbba <_dtoa_r+0x9ba>
    fcdc:	9804      	ldr	r0, [sp, #16]
    fcde:	f7ff babd 	b.w	f25c <_dtoa_r+0x5c>
    fce2:	9b06      	ldr	r3, [sp, #24]
    fce4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    fce6:	9706      	str	r7, [sp, #24]
    fce8:	1afb      	subs	r3, r7, r3
    fcea:	441a      	add	r2, r3
    fcec:	920d      	str	r2, [sp, #52]	; 0x34
    fcee:	2700      	movs	r7, #0
    fcf0:	e46b      	b.n	f5ca <_dtoa_r+0x3ca>
    fcf2:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
    fcf6:	f04f 0a02 	mov.w	sl, #2
    fcfa:	ed8d 7b12 	vstr	d7, [sp, #72]	; 0x48
    fcfe:	e65a      	b.n	f9b6 <_dtoa_r+0x7b6>
    fd00:	2100      	movs	r1, #0
    fd02:	2301      	movs	r3, #1
    fd04:	6461      	str	r1, [r4, #68]	; 0x44
    fd06:	4620      	mov	r0, r4
    fd08:	9325      	str	r3, [sp, #148]	; 0x94
    fd0a:	f000 fa4d 	bl	101a8 <_Balloc>
    fd0e:	9b25      	ldr	r3, [sp, #148]	; 0x94
    fd10:	9004      	str	r0, [sp, #16]
    fd12:	6420      	str	r0, [r4, #64]	; 0x40
    fd14:	930a      	str	r3, [sp, #40]	; 0x28
    fd16:	930f      	str	r3, [sp, #60]	; 0x3c
    fd18:	e62c      	b.n	f974 <_dtoa_r+0x774>
    fd1a:	2a00      	cmp	r2, #0
    fd1c:	469a      	mov	sl, r3
    fd1e:	dd11      	ble.n	fd44 <_dtoa_r+0xb44>
    fd20:	4649      	mov	r1, r9
    fd22:	2201      	movs	r2, #1
    fd24:	4620      	mov	r0, r4
    fd26:	f000 fbeb 	bl	10500 <__lshift>
    fd2a:	9906      	ldr	r1, [sp, #24]
    fd2c:	4681      	mov	r9, r0
    fd2e:	f000 fc39 	bl	105a4 <__mcmp>
    fd32:	2800      	cmp	r0, #0
    fd34:	f340 8134 	ble.w	ffa0 <_dtoa_r+0xda0>
    fd38:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
    fd3c:	f000 8104 	beq.w	ff48 <_dtoa_r+0xd48>
    fd40:	f105 0a31 	add.w	sl, r5, #49	; 0x31
    fd44:	46b3      	mov	fp, r6
    fd46:	f887 a000 	strb.w	sl, [r7]
    fd4a:	1c7d      	adds	r5, r7, #1
    fd4c:	4646      	mov	r6, r8
    fd4e:	e5d8      	b.n	f902 <_dtoa_r+0x702>
    fd50:	d104      	bne.n	fd5c <_dtoa_r+0xb5c>
    fd52:	f01a 0f01 	tst.w	sl, #1
    fd56:	d001      	beq.n	fd5c <_dtoa_r+0xb5c>
    fd58:	e5c3      	b.n	f8e2 <_dtoa_r+0x6e2>
    fd5a:	4615      	mov	r5, r2
    fd5c:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    fd60:	2b30      	cmp	r3, #48	; 0x30
    fd62:	f105 32ff 	add.w	r2, r5, #4294967295	; 0xffffffff
    fd66:	d0f8      	beq.n	fd5a <_dtoa_r+0xb5a>
    fd68:	e5cb      	b.n	f902 <_dtoa_r+0x702>
    fd6a:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
    fd6e:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
    fd72:	f7ff bb3f 	b.w	f3f4 <_dtoa_r+0x1f4>
    fd76:	9904      	ldr	r1, [sp, #16]
    fd78:	2230      	movs	r2, #48	; 0x30
    fd7a:	700a      	strb	r2, [r1, #0]
    fd7c:	9a02      	ldr	r2, [sp, #8]
    fd7e:	f815 8c01 	ldrb.w	r8, [r5, #-1]
    fd82:	3201      	adds	r2, #1
    fd84:	9202      	str	r2, [sp, #8]
    fd86:	f7ff bbfb 	b.w	f580 <_dtoa_r+0x380>
    fd8a:	f000 80b4 	beq.w	fef6 <_dtoa_r+0xcf6>
    fd8e:	9b02      	ldr	r3, [sp, #8]
    fd90:	425d      	negs	r5, r3
    fd92:	4b89      	ldr	r3, [pc, #548]	; (ffb8 <_dtoa_r+0xdb8>)
    fd94:	f005 020f 	and.w	r2, r5, #15
    fd98:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    fd9c:	e9d3 2300 	ldrd	r2, r3, [r3]
    fda0:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
    fda4:	f7f1 f892 	bl	ecc <__aeabi_dmul>
    fda8:	112d      	asrs	r5, r5, #4
    fdaa:	4607      	mov	r7, r0
    fdac:	4688      	mov	r8, r1
    fdae:	f000 811d 	beq.w	ffec <_dtoa_r+0xdec>
    fdb2:	4e82      	ldr	r6, [pc, #520]	; (ffbc <_dtoa_r+0xdbc>)
    fdb4:	f04f 0a02 	mov.w	sl, #2
    fdb8:	07eb      	lsls	r3, r5, #31
    fdba:	d509      	bpl.n	fdd0 <_dtoa_r+0xbd0>
    fdbc:	4638      	mov	r0, r7
    fdbe:	4641      	mov	r1, r8
    fdc0:	e9d6 2300 	ldrd	r2, r3, [r6]
    fdc4:	f7f1 f882 	bl	ecc <__aeabi_dmul>
    fdc8:	f10a 0a01 	add.w	sl, sl, #1
    fdcc:	4607      	mov	r7, r0
    fdce:	4688      	mov	r8, r1
    fdd0:	106d      	asrs	r5, r5, #1
    fdd2:	f106 0608 	add.w	r6, r6, #8
    fdd6:	d1ef      	bne.n	fdb8 <_dtoa_r+0xbb8>
    fdd8:	e608      	b.n	f9ec <_dtoa_r+0x7ec>
    fdda:	6871      	ldr	r1, [r6, #4]
    fddc:	4620      	mov	r0, r4
    fdde:	f000 f9e3 	bl	101a8 <_Balloc>
    fde2:	6933      	ldr	r3, [r6, #16]
    fde4:	3302      	adds	r3, #2
    fde6:	009a      	lsls	r2, r3, #2
    fde8:	4605      	mov	r5, r0
    fdea:	f106 010c 	add.w	r1, r6, #12
    fdee:	300c      	adds	r0, #12
    fdf0:	f7f0 fd96 	bl	920 <memcpy>
    fdf4:	4629      	mov	r1, r5
    fdf6:	2201      	movs	r2, #1
    fdf8:	4620      	mov	r0, r4
    fdfa:	f000 fb81 	bl	10500 <__lshift>
    fdfe:	4680      	mov	r8, r0
    fe00:	e4b4      	b.n	f76c <_dtoa_r+0x56c>
    fe02:	2b39      	cmp	r3, #57	; 0x39
    fe04:	f000 80a0 	beq.w	ff48 <_dtoa_r+0xd48>
    fe08:	3301      	adds	r3, #1
    fe0a:	46b3      	mov	fp, r6
    fe0c:	703b      	strb	r3, [r7, #0]
    fe0e:	1c7d      	adds	r5, r7, #1
    fe10:	4646      	mov	r6, r8
    fe12:	e576      	b.n	f902 <_dtoa_r+0x702>
    fe14:	46b3      	mov	fp, r6
    fe16:	469a      	mov	sl, r3
    fe18:	4646      	mov	r6, r8
    fe1a:	e556      	b.n	f8ca <_dtoa_r+0x6ca>
    fe1c:	2300      	movs	r3, #0
    fe1e:	9306      	str	r3, [sp, #24]
    fe20:	461e      	mov	r6, r3
    fe22:	e70c      	b.n	fc3e <_dtoa_r+0xa3e>
    fe24:	9b12      	ldr	r3, [sp, #72]	; 0x48
    fe26:	4964      	ldr	r1, [pc, #400]	; (ffb8 <_dtoa_r+0xdb8>)
    fe28:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
    fe2c:	4652      	mov	r2, sl
    fe2e:	465b      	mov	r3, fp
    fe30:	e951 0102 	ldrd	r0, r1, [r1, #-8]
    fe34:	f7f1 f84a 	bl	ecc <__aeabi_dmul>
    fe38:	e9cd 0116 	strd	r0, r1, [sp, #88]	; 0x58
    fe3c:	4638      	mov	r0, r7
    fe3e:	4641      	mov	r1, r8
    fe40:	f7f1 faf4 	bl	142c <__aeabi_d2iz>
    fe44:	4605      	mov	r5, r0
    fe46:	f7f0 ffdb 	bl	e00 <__aeabi_i2d>
    fe4a:	460b      	mov	r3, r1
    fe4c:	4602      	mov	r2, r0
    fe4e:	4641      	mov	r1, r8
    fe50:	4638      	mov	r0, r7
    fe52:	f7f0 fe87 	bl	b64 <__aeabi_dsub>
    fe56:	9b12      	ldr	r3, [sp, #72]	; 0x48
    fe58:	460f      	mov	r7, r1
    fe5a:	9904      	ldr	r1, [sp, #16]
    fe5c:	3530      	adds	r5, #48	; 0x30
    fe5e:	2b01      	cmp	r3, #1
    fe60:	700d      	strb	r5, [r1, #0]
    fe62:	4606      	mov	r6, r0
    fe64:	f101 0501 	add.w	r5, r1, #1
    fe68:	d026      	beq.n	feb8 <_dtoa_r+0xcb8>
    fe6a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    fe6c:	9a04      	ldr	r2, [sp, #16]
    fe6e:	f8df b154 	ldr.w	fp, [pc, #340]	; ffc4 <_dtoa_r+0xdc4>
    fe72:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
    fe76:	4413      	add	r3, r2
    fe78:	f04f 0a00 	mov.w	sl, #0
    fe7c:	4699      	mov	r9, r3
    fe7e:	4652      	mov	r2, sl
    fe80:	465b      	mov	r3, fp
    fe82:	4630      	mov	r0, r6
    fe84:	4639      	mov	r1, r7
    fe86:	f7f1 f821 	bl	ecc <__aeabi_dmul>
    fe8a:	460f      	mov	r7, r1
    fe8c:	4606      	mov	r6, r0
    fe8e:	f7f1 facd 	bl	142c <__aeabi_d2iz>
    fe92:	4680      	mov	r8, r0
    fe94:	f7f0 ffb4 	bl	e00 <__aeabi_i2d>
    fe98:	f108 0830 	add.w	r8, r8, #48	; 0x30
    fe9c:	4602      	mov	r2, r0
    fe9e:	460b      	mov	r3, r1
    fea0:	4630      	mov	r0, r6
    fea2:	4639      	mov	r1, r7
    fea4:	f7f0 fe5e 	bl	b64 <__aeabi_dsub>
    fea8:	f805 8b01 	strb.w	r8, [r5], #1
    feac:	454d      	cmp	r5, r9
    feae:	4606      	mov	r6, r0
    feb0:	460f      	mov	r7, r1
    feb2:	d1e4      	bne.n	fe7e <_dtoa_r+0xc7e>
    feb4:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
    feb8:	4b41      	ldr	r3, [pc, #260]	; (ffc0 <_dtoa_r+0xdc0>)
    feba:	2200      	movs	r2, #0
    febc:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
    fec0:	f7f0 fe52 	bl	b68 <__adddf3>
    fec4:	4632      	mov	r2, r6
    fec6:	463b      	mov	r3, r7
    fec8:	f7f1 fa72 	bl	13b0 <__aeabi_dcmplt>
    fecc:	2800      	cmp	r0, #0
    fece:	d041      	beq.n	ff54 <_dtoa_r+0xd54>
    fed0:	9b15      	ldr	r3, [sp, #84]	; 0x54
    fed2:	9302      	str	r3, [sp, #8]
    fed4:	f815 8c01 	ldrb.w	r8, [r5, #-1]
    fed8:	f7ff bb45 	b.w	f566 <_dtoa_r+0x366>
    fedc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fede:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    fee0:	1a9d      	subs	r5, r3, r2
    fee2:	2300      	movs	r3, #0
    fee4:	f7ff bb77 	b.w	f5d6 <_dtoa_r+0x3d6>
    fee8:	9b18      	ldr	r3, [sp, #96]	; 0x60
    feea:	9f06      	ldr	r7, [sp, #24]
    feec:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    feee:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
    fef2:	f7ff bb70 	b.w	f5d6 <_dtoa_r+0x3d6>
    fef6:	e9dd 7810 	ldrd	r7, r8, [sp, #64]	; 0x40
    fefa:	f04f 0a02 	mov.w	sl, #2
    fefe:	e575      	b.n	f9ec <_dtoa_r+0x7ec>
    ff00:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ff02:	2b00      	cmp	r3, #0
    ff04:	f43f aec0 	beq.w	fc88 <_dtoa_r+0xa88>
    ff08:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    ff0a:	2d00      	cmp	r5, #0
    ff0c:	f77f af2f 	ble.w	fd6e <_dtoa_r+0xb6e>
    ff10:	2200      	movs	r2, #0
    ff12:	4b2c      	ldr	r3, [pc, #176]	; (ffc4 <_dtoa_r+0xdc4>)
    ff14:	4638      	mov	r0, r7
    ff16:	4641      	mov	r1, r8
    ff18:	f7f0 ffd8 	bl	ecc <__aeabi_dmul>
    ff1c:	4607      	mov	r7, r0
    ff1e:	4688      	mov	r8, r1
    ff20:	f10a 0001 	add.w	r0, sl, #1
    ff24:	f7f0 ff6c 	bl	e00 <__aeabi_i2d>
    ff28:	463a      	mov	r2, r7
    ff2a:	4643      	mov	r3, r8
    ff2c:	f7f0 ffce 	bl	ecc <__aeabi_dmul>
    ff30:	4b1f      	ldr	r3, [pc, #124]	; (ffb0 <_dtoa_r+0xdb0>)
    ff32:	2200      	movs	r2, #0
    ff34:	f7f0 fe18 	bl	b68 <__adddf3>
    ff38:	9b02      	ldr	r3, [sp, #8]
    ff3a:	9512      	str	r5, [sp, #72]	; 0x48
    ff3c:	3b01      	subs	r3, #1
    ff3e:	4682      	mov	sl, r0
    ff40:	f1a1 7b50 	sub.w	fp, r1, #54525952	; 0x3400000
    ff44:	9315      	str	r3, [sp, #84]	; 0x54
    ff46:	e572      	b.n	fa2e <_dtoa_r+0x82e>
    ff48:	2239      	movs	r2, #57	; 0x39
    ff4a:	46b3      	mov	fp, r6
    ff4c:	703a      	strb	r2, [r7, #0]
    ff4e:	4646      	mov	r6, r8
    ff50:	1c7d      	adds	r5, r7, #1
    ff52:	e4c8      	b.n	f8e6 <_dtoa_r+0x6e6>
    ff54:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
    ff58:	2000      	movs	r0, #0
    ff5a:	4919      	ldr	r1, [pc, #100]	; (ffc0 <_dtoa_r+0xdc0>)
    ff5c:	f7f0 fe02 	bl	b64 <__aeabi_dsub>
    ff60:	4632      	mov	r2, r6
    ff62:	463b      	mov	r3, r7
    ff64:	f7f1 fa42 	bl	13ec <__aeabi_dcmpgt>
    ff68:	b908      	cbnz	r0, ff6e <_dtoa_r+0xd6e>
    ff6a:	e700      	b.n	fd6e <_dtoa_r+0xb6e>
    ff6c:	4615      	mov	r5, r2
    ff6e:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    ff72:	2b30      	cmp	r3, #48	; 0x30
    ff74:	f105 32ff 	add.w	r2, r5, #4294967295	; 0xffffffff
    ff78:	d0f8      	beq.n	ff6c <_dtoa_r+0xd6c>
    ff7a:	e5df      	b.n	fb3c <_dtoa_r+0x93c>
    ff7c:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
    ff80:	9b15      	ldr	r3, [sp, #84]	; 0x54
    ff82:	9302      	str	r3, [sp, #8]
    ff84:	f7ff baef 	b.w	f566 <_dtoa_r+0x366>
    ff88:	46b8      	mov	r8, r7
    ff8a:	f7ff bbac 	b.w	f6e6 <_dtoa_r+0x4e6>
    ff8e:	2b39      	cmp	r3, #57	; 0x39
    ff90:	46d3      	mov	fp, sl
    ff92:	469a      	mov	sl, r3
    ff94:	d0d8      	beq.n	ff48 <_dtoa_r+0xd48>
    ff96:	f1bb 0f00 	cmp.w	fp, #0
    ff9a:	f73f aed1 	bgt.w	fd40 <_dtoa_r+0xb40>
    ff9e:	e6d1      	b.n	fd44 <_dtoa_r+0xb44>
    ffa0:	f47f aed0 	bne.w	fd44 <_dtoa_r+0xb44>
    ffa4:	f01a 0f01 	tst.w	sl, #1
    ffa8:	f43f aecc 	beq.w	fd44 <_dtoa_r+0xb44>
    ffac:	e6c4      	b.n	fd38 <_dtoa_r+0xb38>
    ffae:	bf00      	nop
    ffb0:	401c0000 	.word	0x401c0000
    ffb4:	40140000 	.word	0x40140000
    ffb8:	00012bd0 	.word	0x00012bd0
    ffbc:	00012ba8 	.word	0x00012ba8
    ffc0:	3fe00000 	.word	0x3fe00000
    ffc4:	40240000 	.word	0x40240000
    ffc8:	4631      	mov	r1, r6
    ffca:	2300      	movs	r3, #0
    ffcc:	220a      	movs	r2, #10
    ffce:	4620      	mov	r0, r4
    ffd0:	f000 f91a 	bl	10208 <__multadd>
    ffd4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    ffd6:	2b00      	cmp	r3, #0
    ffd8:	4606      	mov	r6, r0
    ffda:	dd0a      	ble.n	fff2 <_dtoa_r+0xdf2>
    ffdc:	930a      	str	r3, [sp, #40]	; 0x28
    ffde:	f7ff bbb8 	b.w	f752 <_dtoa_r+0x552>
    ffe2:	9b24      	ldr	r3, [sp, #144]	; 0x90
    ffe4:	2b02      	cmp	r3, #2
    ffe6:	dc22      	bgt.n	1002e <_dtoa_r+0xe2e>
    ffe8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    ffea:	e448      	b.n	f87e <_dtoa_r+0x67e>
    ffec:	f04f 0a02 	mov.w	sl, #2
    fff0:	e4fc      	b.n	f9ec <_dtoa_r+0x7ec>
    fff2:	9b24      	ldr	r3, [sp, #144]	; 0x90
    fff4:	2b02      	cmp	r3, #2
    fff6:	dc1a      	bgt.n	1002e <_dtoa_r+0xe2e>
    fff8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    fffa:	e7ef      	b.n	ffdc <_dtoa_r+0xddc>
    fffc:	2501      	movs	r5, #1
    fffe:	f7ff b9c4 	b.w	f38a <_dtoa_r+0x18a>
   10002:	f43f ab88 	beq.w	f716 <_dtoa_r+0x516>
   10006:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
   1000a:	e417      	b.n	f83c <_dtoa_r+0x63c>
   1000c:	2500      	movs	r5, #0
   1000e:	6465      	str	r5, [r4, #68]	; 0x44
   10010:	4629      	mov	r1, r5
   10012:	4620      	mov	r0, r4
   10014:	f000 f8c8 	bl	101a8 <_Balloc>
   10018:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1001c:	930a      	str	r3, [sp, #40]	; 0x28
   1001e:	930f      	str	r3, [sp, #60]	; 0x3c
   10020:	2301      	movs	r3, #1
   10022:	9004      	str	r0, [sp, #16]
   10024:	9525      	str	r5, [sp, #148]	; 0x94
   10026:	6420      	str	r0, [r4, #64]	; 0x40
   10028:	930c      	str	r3, [sp, #48]	; 0x30
   1002a:	f7ff b9e3 	b.w	f3f4 <_dtoa_r+0x1f4>
   1002e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   10030:	930a      	str	r3, [sp, #40]	; 0x28
   10032:	e5f5      	b.n	fc20 <_dtoa_r+0xa20>

00010034 <__fputwc>:
   10034:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   10038:	b082      	sub	sp, #8
   1003a:	4680      	mov	r8, r0
   1003c:	4689      	mov	r9, r1
   1003e:	4614      	mov	r4, r2
   10040:	f7fa fe58 	bl	acf4 <__locale_mb_cur_max>
   10044:	2801      	cmp	r0, #1
   10046:	d036      	beq.n	100b6 <__fputwc+0x82>
   10048:	464a      	mov	r2, r9
   1004a:	f104 035c 	add.w	r3, r4, #92	; 0x5c
   1004e:	a901      	add	r1, sp, #4
   10050:	4640      	mov	r0, r8
   10052:	f000 fc85 	bl	10960 <_wcrtomb_r>
   10056:	1c42      	adds	r2, r0, #1
   10058:	4606      	mov	r6, r0
   1005a:	d025      	beq.n	100a8 <__fputwc+0x74>
   1005c:	b3a8      	cbz	r0, 100ca <__fputwc+0x96>
   1005e:	f89d e004 	ldrb.w	lr, [sp, #4]
   10062:	2500      	movs	r5, #0
   10064:	f10d 0a04 	add.w	sl, sp, #4
   10068:	e009      	b.n	1007e <__fputwc+0x4a>
   1006a:	6823      	ldr	r3, [r4, #0]
   1006c:	1c5a      	adds	r2, r3, #1
   1006e:	6022      	str	r2, [r4, #0]
   10070:	f883 e000 	strb.w	lr, [r3]
   10074:	3501      	adds	r5, #1
   10076:	42b5      	cmp	r5, r6
   10078:	d227      	bcs.n	100ca <__fputwc+0x96>
   1007a:	f815 e00a 	ldrb.w	lr, [r5, sl]
   1007e:	68a3      	ldr	r3, [r4, #8]
   10080:	3b01      	subs	r3, #1
   10082:	2b00      	cmp	r3, #0
   10084:	60a3      	str	r3, [r4, #8]
   10086:	daf0      	bge.n	1006a <__fputwc+0x36>
   10088:	69a7      	ldr	r7, [r4, #24]
   1008a:	42bb      	cmp	r3, r7
   1008c:	4671      	mov	r1, lr
   1008e:	4622      	mov	r2, r4
   10090:	4640      	mov	r0, r8
   10092:	db02      	blt.n	1009a <__fputwc+0x66>
   10094:	f1be 0f0a 	cmp.w	lr, #10
   10098:	d1e7      	bne.n	1006a <__fputwc+0x36>
   1009a:	f7fe ff23 	bl	eee4 <__swbuf_r>
   1009e:	1c43      	adds	r3, r0, #1
   100a0:	d1e8      	bne.n	10074 <__fputwc+0x40>
   100a2:	b002      	add	sp, #8
   100a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   100a8:	89a3      	ldrh	r3, [r4, #12]
   100aa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   100ae:	81a3      	strh	r3, [r4, #12]
   100b0:	b002      	add	sp, #8
   100b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   100b6:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
   100ba:	2bfe      	cmp	r3, #254	; 0xfe
   100bc:	d8c4      	bhi.n	10048 <__fputwc+0x14>
   100be:	fa5f fe89 	uxtb.w	lr, r9
   100c2:	4606      	mov	r6, r0
   100c4:	f88d e004 	strb.w	lr, [sp, #4]
   100c8:	e7cb      	b.n	10062 <__fputwc+0x2e>
   100ca:	4648      	mov	r0, r9
   100cc:	b002      	add	sp, #8
   100ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   100d2:	bf00      	nop

000100d4 <_fputwc_r>:
   100d4:	b530      	push	{r4, r5, lr}
   100d6:	6e53      	ldr	r3, [r2, #100]	; 0x64
   100d8:	f013 0f01 	tst.w	r3, #1
   100dc:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
   100e0:	4614      	mov	r4, r2
   100e2:	b083      	sub	sp, #12
   100e4:	4605      	mov	r5, r0
   100e6:	b29a      	uxth	r2, r3
   100e8:	d101      	bne.n	100ee <_fputwc_r+0x1a>
   100ea:	0590      	lsls	r0, r2, #22
   100ec:	d51c      	bpl.n	10128 <_fputwc_r+0x54>
   100ee:	0490      	lsls	r0, r2, #18
   100f0:	d406      	bmi.n	10100 <_fputwc_r+0x2c>
   100f2:	6e62      	ldr	r2, [r4, #100]	; 0x64
   100f4:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   100f8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
   100fc:	81a3      	strh	r3, [r4, #12]
   100fe:	6662      	str	r2, [r4, #100]	; 0x64
   10100:	4628      	mov	r0, r5
   10102:	4622      	mov	r2, r4
   10104:	f7ff ff96 	bl	10034 <__fputwc>
   10108:	6e63      	ldr	r3, [r4, #100]	; 0x64
   1010a:	07da      	lsls	r2, r3, #31
   1010c:	4605      	mov	r5, r0
   1010e:	d402      	bmi.n	10116 <_fputwc_r+0x42>
   10110:	89a3      	ldrh	r3, [r4, #12]
   10112:	059b      	lsls	r3, r3, #22
   10114:	d502      	bpl.n	1011c <_fputwc_r+0x48>
   10116:	4628      	mov	r0, r5
   10118:	b003      	add	sp, #12
   1011a:	bd30      	pop	{r4, r5, pc}
   1011c:	6da0      	ldr	r0, [r4, #88]	; 0x58
   1011e:	f7fa fdfd 	bl	ad1c <__retarget_lock_release_recursive>
   10122:	4628      	mov	r0, r5
   10124:	b003      	add	sp, #12
   10126:	bd30      	pop	{r4, r5, pc}
   10128:	6da0      	ldr	r0, [r4, #88]	; 0x58
   1012a:	9101      	str	r1, [sp, #4]
   1012c:	f7fa fdf4 	bl	ad18 <__retarget_lock_acquire_recursive>
   10130:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   10134:	9901      	ldr	r1, [sp, #4]
   10136:	b29a      	uxth	r2, r3
   10138:	e7d9      	b.n	100ee <_fputwc_r+0x1a>
   1013a:	bf00      	nop

0001013c <_isatty_r>:
   1013c:	b538      	push	{r3, r4, r5, lr}
   1013e:	4c07      	ldr	r4, [pc, #28]	; (1015c <_isatty_r+0x20>)
   10140:	2300      	movs	r3, #0
   10142:	4605      	mov	r5, r0
   10144:	4608      	mov	r0, r1
   10146:	6023      	str	r3, [r4, #0]
   10148:	f7f3 fb88 	bl	385c <_isatty>
   1014c:	1c43      	adds	r3, r0, #1
   1014e:	d000      	beq.n	10152 <_isatty_r+0x16>
   10150:	bd38      	pop	{r3, r4, r5, pc}
   10152:	6823      	ldr	r3, [r4, #0]
   10154:	2b00      	cmp	r3, #0
   10156:	d0fb      	beq.n	10150 <_isatty_r+0x14>
   10158:	602b      	str	r3, [r5, #0]
   1015a:	bd38      	pop	{r3, r4, r5, pc}
   1015c:	2000304c 	.word	0x2000304c

00010160 <_localeconv_r>:
   10160:	4a04      	ldr	r2, [pc, #16]	; (10174 <_localeconv_r+0x14>)
   10162:	4b05      	ldr	r3, [pc, #20]	; (10178 <_localeconv_r+0x18>)
   10164:	6812      	ldr	r2, [r2, #0]
   10166:	6b50      	ldr	r0, [r2, #52]	; 0x34
   10168:	2800      	cmp	r0, #0
   1016a:	bf08      	it	eq
   1016c:	4618      	moveq	r0, r3
   1016e:	30f0      	adds	r0, #240	; 0xf0
   10170:	4770      	bx	lr
   10172:	bf00      	nop
   10174:	200001c0 	.word	0x200001c0
   10178:	200005f0 	.word	0x200005f0

0001017c <_lseek_r>:
   1017c:	b570      	push	{r4, r5, r6, lr}
   1017e:	460d      	mov	r5, r1
   10180:	4c08      	ldr	r4, [pc, #32]	; (101a4 <_lseek_r+0x28>)
   10182:	4611      	mov	r1, r2
   10184:	4606      	mov	r6, r0
   10186:	461a      	mov	r2, r3
   10188:	4628      	mov	r0, r5
   1018a:	2300      	movs	r3, #0
   1018c:	6023      	str	r3, [r4, #0]
   1018e:	f7f3 fb98 	bl	38c2 <_lseek>
   10192:	1c43      	adds	r3, r0, #1
   10194:	d000      	beq.n	10198 <_lseek_r+0x1c>
   10196:	bd70      	pop	{r4, r5, r6, pc}
   10198:	6823      	ldr	r3, [r4, #0]
   1019a:	2b00      	cmp	r3, #0
   1019c:	d0fb      	beq.n	10196 <_lseek_r+0x1a>
   1019e:	6033      	str	r3, [r6, #0]
   101a0:	bd70      	pop	{r4, r5, r6, pc}
   101a2:	bf00      	nop
   101a4:	2000304c 	.word	0x2000304c

000101a8 <_Balloc>:
   101a8:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   101aa:	b570      	push	{r4, r5, r6, lr}
   101ac:	4605      	mov	r5, r0
   101ae:	460c      	mov	r4, r1
   101b0:	b14b      	cbz	r3, 101c6 <_Balloc+0x1e>
   101b2:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
   101b6:	b180      	cbz	r0, 101da <_Balloc+0x32>
   101b8:	6802      	ldr	r2, [r0, #0]
   101ba:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
   101be:	2300      	movs	r3, #0
   101c0:	6103      	str	r3, [r0, #16]
   101c2:	60c3      	str	r3, [r0, #12]
   101c4:	bd70      	pop	{r4, r5, r6, pc}
   101c6:	2221      	movs	r2, #33	; 0x21
   101c8:	2104      	movs	r1, #4
   101ca:	f7f2 fbeb 	bl	29a4 <__wrap__calloc_r>
   101ce:	64e8      	str	r0, [r5, #76]	; 0x4c
   101d0:	4603      	mov	r3, r0
   101d2:	2800      	cmp	r0, #0
   101d4:	d1ed      	bne.n	101b2 <_Balloc+0xa>
   101d6:	2000      	movs	r0, #0
   101d8:	bd70      	pop	{r4, r5, r6, pc}
   101da:	2101      	movs	r1, #1
   101dc:	fa01 f604 	lsl.w	r6, r1, r4
   101e0:	1d72      	adds	r2, r6, #5
   101e2:	4628      	mov	r0, r5
   101e4:	0092      	lsls	r2, r2, #2
   101e6:	f7f2 fbdd 	bl	29a4 <__wrap__calloc_r>
   101ea:	2800      	cmp	r0, #0
   101ec:	d0f3      	beq.n	101d6 <_Balloc+0x2e>
   101ee:	6044      	str	r4, [r0, #4]
   101f0:	6086      	str	r6, [r0, #8]
   101f2:	e7e4      	b.n	101be <_Balloc+0x16>

000101f4 <_Bfree>:
   101f4:	b131      	cbz	r1, 10204 <_Bfree+0x10>
   101f6:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   101f8:	684a      	ldr	r2, [r1, #4]
   101fa:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
   101fe:	6008      	str	r0, [r1, #0]
   10200:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   10204:	4770      	bx	lr
   10206:	bf00      	nop

00010208 <__multadd>:
   10208:	b5f0      	push	{r4, r5, r6, r7, lr}
   1020a:	690c      	ldr	r4, [r1, #16]
   1020c:	b083      	sub	sp, #12
   1020e:	460d      	mov	r5, r1
   10210:	4606      	mov	r6, r0
   10212:	f101 0e14 	add.w	lr, r1, #20
   10216:	2700      	movs	r7, #0
   10218:	f8de 0000 	ldr.w	r0, [lr]
   1021c:	b281      	uxth	r1, r0
   1021e:	fb02 3301 	mla	r3, r2, r1, r3
   10222:	0c01      	lsrs	r1, r0, #16
   10224:	0c18      	lsrs	r0, r3, #16
   10226:	fb02 0101 	mla	r1, r2, r1, r0
   1022a:	b29b      	uxth	r3, r3
   1022c:	3701      	adds	r7, #1
   1022e:	eb03 4301 	add.w	r3, r3, r1, lsl #16
   10232:	42bc      	cmp	r4, r7
   10234:	f84e 3b04 	str.w	r3, [lr], #4
   10238:	ea4f 4311 	mov.w	r3, r1, lsr #16
   1023c:	dcec      	bgt.n	10218 <__multadd+0x10>
   1023e:	b13b      	cbz	r3, 10250 <__multadd+0x48>
   10240:	68aa      	ldr	r2, [r5, #8]
   10242:	4294      	cmp	r4, r2
   10244:	da07      	bge.n	10256 <__multadd+0x4e>
   10246:	eb05 0284 	add.w	r2, r5, r4, lsl #2
   1024a:	3401      	adds	r4, #1
   1024c:	6153      	str	r3, [r2, #20]
   1024e:	612c      	str	r4, [r5, #16]
   10250:	4628      	mov	r0, r5
   10252:	b003      	add	sp, #12
   10254:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10256:	6869      	ldr	r1, [r5, #4]
   10258:	9301      	str	r3, [sp, #4]
   1025a:	3101      	adds	r1, #1
   1025c:	4630      	mov	r0, r6
   1025e:	f7ff ffa3 	bl	101a8 <_Balloc>
   10262:	692a      	ldr	r2, [r5, #16]
   10264:	3202      	adds	r2, #2
   10266:	f105 010c 	add.w	r1, r5, #12
   1026a:	4607      	mov	r7, r0
   1026c:	0092      	lsls	r2, r2, #2
   1026e:	300c      	adds	r0, #12
   10270:	f7f0 fb56 	bl	920 <memcpy>
   10274:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
   10276:	6869      	ldr	r1, [r5, #4]
   10278:	9b01      	ldr	r3, [sp, #4]
   1027a:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
   1027e:	6028      	str	r0, [r5, #0]
   10280:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
   10284:	463d      	mov	r5, r7
   10286:	e7de      	b.n	10246 <__multadd+0x3e>

00010288 <__hi0bits>:
   10288:	0c02      	lsrs	r2, r0, #16
   1028a:	0412      	lsls	r2, r2, #16
   1028c:	4603      	mov	r3, r0
   1028e:	b9b2      	cbnz	r2, 102be <__hi0bits+0x36>
   10290:	0403      	lsls	r3, r0, #16
   10292:	2010      	movs	r0, #16
   10294:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
   10298:	bf04      	itt	eq
   1029a:	021b      	lsleq	r3, r3, #8
   1029c:	3008      	addeq	r0, #8
   1029e:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
   102a2:	bf04      	itt	eq
   102a4:	011b      	lsleq	r3, r3, #4
   102a6:	3004      	addeq	r0, #4
   102a8:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
   102ac:	bf04      	itt	eq
   102ae:	009b      	lsleq	r3, r3, #2
   102b0:	3002      	addeq	r0, #2
   102b2:	2b00      	cmp	r3, #0
   102b4:	db02      	blt.n	102bc <__hi0bits+0x34>
   102b6:	005b      	lsls	r3, r3, #1
   102b8:	d403      	bmi.n	102c2 <__hi0bits+0x3a>
   102ba:	2020      	movs	r0, #32
   102bc:	4770      	bx	lr
   102be:	2000      	movs	r0, #0
   102c0:	e7e8      	b.n	10294 <__hi0bits+0xc>
   102c2:	3001      	adds	r0, #1
   102c4:	4770      	bx	lr
   102c6:	bf00      	nop

000102c8 <__lo0bits>:
   102c8:	6803      	ldr	r3, [r0, #0]
   102ca:	f013 0207 	ands.w	r2, r3, #7
   102ce:	4601      	mov	r1, r0
   102d0:	d007      	beq.n	102e2 <__lo0bits+0x1a>
   102d2:	07da      	lsls	r2, r3, #31
   102d4:	d421      	bmi.n	1031a <__lo0bits+0x52>
   102d6:	0798      	lsls	r0, r3, #30
   102d8:	d421      	bmi.n	1031e <__lo0bits+0x56>
   102da:	089b      	lsrs	r3, r3, #2
   102dc:	600b      	str	r3, [r1, #0]
   102de:	2002      	movs	r0, #2
   102e0:	4770      	bx	lr
   102e2:	b298      	uxth	r0, r3
   102e4:	b198      	cbz	r0, 1030e <__lo0bits+0x46>
   102e6:	4610      	mov	r0, r2
   102e8:	f013 0fff 	tst.w	r3, #255	; 0xff
   102ec:	bf04      	itt	eq
   102ee:	0a1b      	lsreq	r3, r3, #8
   102f0:	3008      	addeq	r0, #8
   102f2:	071a      	lsls	r2, r3, #28
   102f4:	bf04      	itt	eq
   102f6:	091b      	lsreq	r3, r3, #4
   102f8:	3004      	addeq	r0, #4
   102fa:	079a      	lsls	r2, r3, #30
   102fc:	bf04      	itt	eq
   102fe:	089b      	lsreq	r3, r3, #2
   10300:	3002      	addeq	r0, #2
   10302:	07da      	lsls	r2, r3, #31
   10304:	d407      	bmi.n	10316 <__lo0bits+0x4e>
   10306:	085b      	lsrs	r3, r3, #1
   10308:	d104      	bne.n	10314 <__lo0bits+0x4c>
   1030a:	2020      	movs	r0, #32
   1030c:	4770      	bx	lr
   1030e:	0c1b      	lsrs	r3, r3, #16
   10310:	2010      	movs	r0, #16
   10312:	e7e9      	b.n	102e8 <__lo0bits+0x20>
   10314:	3001      	adds	r0, #1
   10316:	600b      	str	r3, [r1, #0]
   10318:	4770      	bx	lr
   1031a:	2000      	movs	r0, #0
   1031c:	4770      	bx	lr
   1031e:	085b      	lsrs	r3, r3, #1
   10320:	600b      	str	r3, [r1, #0]
   10322:	2001      	movs	r0, #1
   10324:	4770      	bx	lr
   10326:	bf00      	nop

00010328 <__i2b>:
   10328:	b510      	push	{r4, lr}
   1032a:	460c      	mov	r4, r1
   1032c:	2101      	movs	r1, #1
   1032e:	f7ff ff3b 	bl	101a8 <_Balloc>
   10332:	2201      	movs	r2, #1
   10334:	6144      	str	r4, [r0, #20]
   10336:	6102      	str	r2, [r0, #16]
   10338:	bd10      	pop	{r4, pc}
   1033a:	bf00      	nop

0001033c <__multiply>:
   1033c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10340:	690c      	ldr	r4, [r1, #16]
   10342:	6915      	ldr	r5, [r2, #16]
   10344:	42ac      	cmp	r4, r5
   10346:	b083      	sub	sp, #12
   10348:	468b      	mov	fp, r1
   1034a:	4616      	mov	r6, r2
   1034c:	da04      	bge.n	10358 <__multiply+0x1c>
   1034e:	4622      	mov	r2, r4
   10350:	46b3      	mov	fp, r6
   10352:	462c      	mov	r4, r5
   10354:	460e      	mov	r6, r1
   10356:	4615      	mov	r5, r2
   10358:	f8db 3008 	ldr.w	r3, [fp, #8]
   1035c:	f8db 1004 	ldr.w	r1, [fp, #4]
   10360:	eb04 0805 	add.w	r8, r4, r5
   10364:	4598      	cmp	r8, r3
   10366:	bfc8      	it	gt
   10368:	3101      	addgt	r1, #1
   1036a:	f7ff ff1d 	bl	101a8 <_Balloc>
   1036e:	f100 0914 	add.w	r9, r0, #20
   10372:	eb09 0a88 	add.w	sl, r9, r8, lsl #2
   10376:	45d1      	cmp	r9, sl
   10378:	9000      	str	r0, [sp, #0]
   1037a:	d205      	bcs.n	10388 <__multiply+0x4c>
   1037c:	464b      	mov	r3, r9
   1037e:	2100      	movs	r1, #0
   10380:	f843 1b04 	str.w	r1, [r3], #4
   10384:	459a      	cmp	sl, r3
   10386:	d8fb      	bhi.n	10380 <__multiply+0x44>
   10388:	f106 0c14 	add.w	ip, r6, #20
   1038c:	eb0c 0385 	add.w	r3, ip, r5, lsl #2
   10390:	f10b 0b14 	add.w	fp, fp, #20
   10394:	459c      	cmp	ip, r3
   10396:	eb0b 0e84 	add.w	lr, fp, r4, lsl #2
   1039a:	d24c      	bcs.n	10436 <__multiply+0xfa>
   1039c:	f8cd a004 	str.w	sl, [sp, #4]
   103a0:	469a      	mov	sl, r3
   103a2:	f8dc 5000 	ldr.w	r5, [ip]
   103a6:	b2af      	uxth	r7, r5
   103a8:	b1ef      	cbz	r7, 103e6 <__multiply+0xaa>
   103aa:	2100      	movs	r1, #0
   103ac:	464d      	mov	r5, r9
   103ae:	465e      	mov	r6, fp
   103b0:	460c      	mov	r4, r1
   103b2:	f856 2b04 	ldr.w	r2, [r6], #4
   103b6:	6828      	ldr	r0, [r5, #0]
   103b8:	b293      	uxth	r3, r2
   103ba:	b281      	uxth	r1, r0
   103bc:	fb07 1303 	mla	r3, r7, r3, r1
   103c0:	0c12      	lsrs	r2, r2, #16
   103c2:	0c01      	lsrs	r1, r0, #16
   103c4:	4423      	add	r3, r4
   103c6:	fb07 1102 	mla	r1, r7, r2, r1
   103ca:	eb01 4113 	add.w	r1, r1, r3, lsr #16
   103ce:	b29b      	uxth	r3, r3
   103d0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   103d4:	45b6      	cmp	lr, r6
   103d6:	f845 3b04 	str.w	r3, [r5], #4
   103da:	ea4f 4411 	mov.w	r4, r1, lsr #16
   103de:	d8e8      	bhi.n	103b2 <__multiply+0x76>
   103e0:	602c      	str	r4, [r5, #0]
   103e2:	f8dc 5000 	ldr.w	r5, [ip]
   103e6:	0c2d      	lsrs	r5, r5, #16
   103e8:	d01d      	beq.n	10426 <__multiply+0xea>
   103ea:	f8d9 3000 	ldr.w	r3, [r9]
   103ee:	4648      	mov	r0, r9
   103f0:	461c      	mov	r4, r3
   103f2:	4659      	mov	r1, fp
   103f4:	2200      	movs	r2, #0
   103f6:	880e      	ldrh	r6, [r1, #0]
   103f8:	0c24      	lsrs	r4, r4, #16
   103fa:	fb05 4406 	mla	r4, r5, r6, r4
   103fe:	4422      	add	r2, r4
   10400:	b29b      	uxth	r3, r3
   10402:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   10406:	f840 3b04 	str.w	r3, [r0], #4
   1040a:	f851 3b04 	ldr.w	r3, [r1], #4
   1040e:	6804      	ldr	r4, [r0, #0]
   10410:	0c1b      	lsrs	r3, r3, #16
   10412:	b2a6      	uxth	r6, r4
   10414:	fb05 6303 	mla	r3, r5, r3, r6
   10418:	eb03 4312 	add.w	r3, r3, r2, lsr #16
   1041c:	458e      	cmp	lr, r1
   1041e:	ea4f 4213 	mov.w	r2, r3, lsr #16
   10422:	d8e8      	bhi.n	103f6 <__multiply+0xba>
   10424:	6003      	str	r3, [r0, #0]
   10426:	f10c 0c04 	add.w	ip, ip, #4
   1042a:	45e2      	cmp	sl, ip
   1042c:	f109 0904 	add.w	r9, r9, #4
   10430:	d8b7      	bhi.n	103a2 <__multiply+0x66>
   10432:	f8dd a004 	ldr.w	sl, [sp, #4]
   10436:	f1b8 0f00 	cmp.w	r8, #0
   1043a:	dd0b      	ble.n	10454 <__multiply+0x118>
   1043c:	f85a 3c04 	ldr.w	r3, [sl, #-4]
   10440:	f1aa 0a04 	sub.w	sl, sl, #4
   10444:	b11b      	cbz	r3, 1044e <__multiply+0x112>
   10446:	e005      	b.n	10454 <__multiply+0x118>
   10448:	f85a 3d04 	ldr.w	r3, [sl, #-4]!
   1044c:	b913      	cbnz	r3, 10454 <__multiply+0x118>
   1044e:	f1b8 0801 	subs.w	r8, r8, #1
   10452:	d1f9      	bne.n	10448 <__multiply+0x10c>
   10454:	9800      	ldr	r0, [sp, #0]
   10456:	f8c0 8010 	str.w	r8, [r0, #16]
   1045a:	b003      	add	sp, #12
   1045c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00010460 <__pow5mult>:
   10460:	f012 0303 	ands.w	r3, r2, #3
   10464:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10468:	4614      	mov	r4, r2
   1046a:	4607      	mov	r7, r0
   1046c:	d12e      	bne.n	104cc <__pow5mult+0x6c>
   1046e:	460d      	mov	r5, r1
   10470:	10a4      	asrs	r4, r4, #2
   10472:	d01c      	beq.n	104ae <__pow5mult+0x4e>
   10474:	6cbe      	ldr	r6, [r7, #72]	; 0x48
   10476:	b396      	cbz	r6, 104de <__pow5mult+0x7e>
   10478:	07e3      	lsls	r3, r4, #31
   1047a:	f04f 0800 	mov.w	r8, #0
   1047e:	d406      	bmi.n	1048e <__pow5mult+0x2e>
   10480:	1064      	asrs	r4, r4, #1
   10482:	d014      	beq.n	104ae <__pow5mult+0x4e>
   10484:	6830      	ldr	r0, [r6, #0]
   10486:	b1a8      	cbz	r0, 104b4 <__pow5mult+0x54>
   10488:	4606      	mov	r6, r0
   1048a:	07e3      	lsls	r3, r4, #31
   1048c:	d5f8      	bpl.n	10480 <__pow5mult+0x20>
   1048e:	4632      	mov	r2, r6
   10490:	4629      	mov	r1, r5
   10492:	4638      	mov	r0, r7
   10494:	f7ff ff52 	bl	1033c <__multiply>
   10498:	b1b5      	cbz	r5, 104c8 <__pow5mult+0x68>
   1049a:	686a      	ldr	r2, [r5, #4]
   1049c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   1049e:	1064      	asrs	r4, r4, #1
   104a0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   104a4:	6029      	str	r1, [r5, #0]
   104a6:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
   104aa:	4605      	mov	r5, r0
   104ac:	d1ea      	bne.n	10484 <__pow5mult+0x24>
   104ae:	4628      	mov	r0, r5
   104b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   104b4:	4632      	mov	r2, r6
   104b6:	4631      	mov	r1, r6
   104b8:	4638      	mov	r0, r7
   104ba:	f7ff ff3f 	bl	1033c <__multiply>
   104be:	6030      	str	r0, [r6, #0]
   104c0:	f8c0 8000 	str.w	r8, [r0]
   104c4:	4606      	mov	r6, r0
   104c6:	e7e0      	b.n	1048a <__pow5mult+0x2a>
   104c8:	4605      	mov	r5, r0
   104ca:	e7d9      	b.n	10480 <__pow5mult+0x20>
   104cc:	1e5a      	subs	r2, r3, #1
   104ce:	4d0b      	ldr	r5, [pc, #44]	; (104fc <__pow5mult+0x9c>)
   104d0:	2300      	movs	r3, #0
   104d2:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
   104d6:	f7ff fe97 	bl	10208 <__multadd>
   104da:	4605      	mov	r5, r0
   104dc:	e7c8      	b.n	10470 <__pow5mult+0x10>
   104de:	2101      	movs	r1, #1
   104e0:	4638      	mov	r0, r7
   104e2:	f7ff fe61 	bl	101a8 <_Balloc>
   104e6:	f240 2171 	movw	r1, #625	; 0x271
   104ea:	2201      	movs	r2, #1
   104ec:	2300      	movs	r3, #0
   104ee:	6141      	str	r1, [r0, #20]
   104f0:	6102      	str	r2, [r0, #16]
   104f2:	4606      	mov	r6, r0
   104f4:	64b8      	str	r0, [r7, #72]	; 0x48
   104f6:	6003      	str	r3, [r0, #0]
   104f8:	e7be      	b.n	10478 <__pow5mult+0x18>
   104fa:	bf00      	nop
   104fc:	00012c98 	.word	0x00012c98

00010500 <__lshift>:
   10500:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10504:	4691      	mov	r9, r2
   10506:	690a      	ldr	r2, [r1, #16]
   10508:	688b      	ldr	r3, [r1, #8]
   1050a:	ea4f 1469 	mov.w	r4, r9, asr #5
   1050e:	eb04 0802 	add.w	r8, r4, r2
   10512:	f108 0501 	add.w	r5, r8, #1
   10516:	429d      	cmp	r5, r3
   10518:	460e      	mov	r6, r1
   1051a:	4607      	mov	r7, r0
   1051c:	6849      	ldr	r1, [r1, #4]
   1051e:	dd04      	ble.n	1052a <__lshift+0x2a>
   10520:	005b      	lsls	r3, r3, #1
   10522:	429d      	cmp	r5, r3
   10524:	f101 0101 	add.w	r1, r1, #1
   10528:	dcfa      	bgt.n	10520 <__lshift+0x20>
   1052a:	4638      	mov	r0, r7
   1052c:	f7ff fe3c 	bl	101a8 <_Balloc>
   10530:	2c00      	cmp	r4, #0
   10532:	f100 0314 	add.w	r3, r0, #20
   10536:	dd06      	ble.n	10546 <__lshift+0x46>
   10538:	eb03 0284 	add.w	r2, r3, r4, lsl #2
   1053c:	2100      	movs	r1, #0
   1053e:	f843 1b04 	str.w	r1, [r3], #4
   10542:	429a      	cmp	r2, r3
   10544:	d1fb      	bne.n	1053e <__lshift+0x3e>
   10546:	6934      	ldr	r4, [r6, #16]
   10548:	f106 0114 	add.w	r1, r6, #20
   1054c:	f019 091f 	ands.w	r9, r9, #31
   10550:	eb01 0e84 	add.w	lr, r1, r4, lsl #2
   10554:	d01d      	beq.n	10592 <__lshift+0x92>
   10556:	f1c9 0c20 	rsb	ip, r9, #32
   1055a:	2200      	movs	r2, #0
   1055c:	680c      	ldr	r4, [r1, #0]
   1055e:	fa04 f409 	lsl.w	r4, r4, r9
   10562:	4314      	orrs	r4, r2
   10564:	f843 4b04 	str.w	r4, [r3], #4
   10568:	f851 2b04 	ldr.w	r2, [r1], #4
   1056c:	458e      	cmp	lr, r1
   1056e:	fa22 f20c 	lsr.w	r2, r2, ip
   10572:	d8f3      	bhi.n	1055c <__lshift+0x5c>
   10574:	601a      	str	r2, [r3, #0]
   10576:	b10a      	cbz	r2, 1057c <__lshift+0x7c>
   10578:	f108 0502 	add.w	r5, r8, #2
   1057c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   1057e:	6872      	ldr	r2, [r6, #4]
   10580:	3d01      	subs	r5, #1
   10582:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   10586:	6105      	str	r5, [r0, #16]
   10588:	6031      	str	r1, [r6, #0]
   1058a:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
   1058e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   10592:	3b04      	subs	r3, #4
   10594:	f851 2b04 	ldr.w	r2, [r1], #4
   10598:	f843 2f04 	str.w	r2, [r3, #4]!
   1059c:	458e      	cmp	lr, r1
   1059e:	d8f9      	bhi.n	10594 <__lshift+0x94>
   105a0:	e7ec      	b.n	1057c <__lshift+0x7c>
   105a2:	bf00      	nop

000105a4 <__mcmp>:
   105a4:	b430      	push	{r4, r5}
   105a6:	690b      	ldr	r3, [r1, #16]
   105a8:	4605      	mov	r5, r0
   105aa:	6900      	ldr	r0, [r0, #16]
   105ac:	1ac0      	subs	r0, r0, r3
   105ae:	d10f      	bne.n	105d0 <__mcmp+0x2c>
   105b0:	009b      	lsls	r3, r3, #2
   105b2:	3514      	adds	r5, #20
   105b4:	3114      	adds	r1, #20
   105b6:	4419      	add	r1, r3
   105b8:	442b      	add	r3, r5
   105ba:	e001      	b.n	105c0 <__mcmp+0x1c>
   105bc:	429d      	cmp	r5, r3
   105be:	d207      	bcs.n	105d0 <__mcmp+0x2c>
   105c0:	f853 4d04 	ldr.w	r4, [r3, #-4]!
   105c4:	f851 2d04 	ldr.w	r2, [r1, #-4]!
   105c8:	4294      	cmp	r4, r2
   105ca:	d0f7      	beq.n	105bc <__mcmp+0x18>
   105cc:	d302      	bcc.n	105d4 <__mcmp+0x30>
   105ce:	2001      	movs	r0, #1
   105d0:	bc30      	pop	{r4, r5}
   105d2:	4770      	bx	lr
   105d4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   105d8:	e7fa      	b.n	105d0 <__mcmp+0x2c>
   105da:	bf00      	nop

000105dc <__mdiff>:
   105dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   105e0:	690f      	ldr	r7, [r1, #16]
   105e2:	460e      	mov	r6, r1
   105e4:	6911      	ldr	r1, [r2, #16]
   105e6:	1a7f      	subs	r7, r7, r1
   105e8:	2f00      	cmp	r7, #0
   105ea:	4690      	mov	r8, r2
   105ec:	d117      	bne.n	1061e <__mdiff+0x42>
   105ee:	0089      	lsls	r1, r1, #2
   105f0:	f106 0514 	add.w	r5, r6, #20
   105f4:	f102 0e14 	add.w	lr, r2, #20
   105f8:	186b      	adds	r3, r5, r1
   105fa:	4471      	add	r1, lr
   105fc:	e001      	b.n	10602 <__mdiff+0x26>
   105fe:	429d      	cmp	r5, r3
   10600:	d25c      	bcs.n	106bc <__mdiff+0xe0>
   10602:	f853 2d04 	ldr.w	r2, [r3, #-4]!
   10606:	f851 4d04 	ldr.w	r4, [r1, #-4]!
   1060a:	42a2      	cmp	r2, r4
   1060c:	d0f7      	beq.n	105fe <__mdiff+0x22>
   1060e:	d25e      	bcs.n	106ce <__mdiff+0xf2>
   10610:	4633      	mov	r3, r6
   10612:	462c      	mov	r4, r5
   10614:	4646      	mov	r6, r8
   10616:	4675      	mov	r5, lr
   10618:	4698      	mov	r8, r3
   1061a:	2701      	movs	r7, #1
   1061c:	e005      	b.n	1062a <__mdiff+0x4e>
   1061e:	db58      	blt.n	106d2 <__mdiff+0xf6>
   10620:	f106 0514 	add.w	r5, r6, #20
   10624:	f108 0414 	add.w	r4, r8, #20
   10628:	2700      	movs	r7, #0
   1062a:	6871      	ldr	r1, [r6, #4]
   1062c:	f7ff fdbc 	bl	101a8 <_Balloc>
   10630:	f8d8 3010 	ldr.w	r3, [r8, #16]
   10634:	6936      	ldr	r6, [r6, #16]
   10636:	60c7      	str	r7, [r0, #12]
   10638:	eb04 0c83 	add.w	ip, r4, r3, lsl #2
   1063c:	46a6      	mov	lr, r4
   1063e:	eb05 0786 	add.w	r7, r5, r6, lsl #2
   10642:	f100 0414 	add.w	r4, r0, #20
   10646:	2300      	movs	r3, #0
   10648:	f85e 1b04 	ldr.w	r1, [lr], #4
   1064c:	f855 8b04 	ldr.w	r8, [r5], #4
   10650:	b28a      	uxth	r2, r1
   10652:	fa13 f388 	uxtah	r3, r3, r8
   10656:	0c09      	lsrs	r1, r1, #16
   10658:	1a9a      	subs	r2, r3, r2
   1065a:	ebc1 4318 	rsb	r3, r1, r8, lsr #16
   1065e:	eb03 4322 	add.w	r3, r3, r2, asr #16
   10662:	b292      	uxth	r2, r2
   10664:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
   10668:	45f4      	cmp	ip, lr
   1066a:	f844 2b04 	str.w	r2, [r4], #4
   1066e:	ea4f 4323 	mov.w	r3, r3, asr #16
   10672:	d8e9      	bhi.n	10648 <__mdiff+0x6c>
   10674:	42af      	cmp	r7, r5
   10676:	d917      	bls.n	106a8 <__mdiff+0xcc>
   10678:	46a4      	mov	ip, r4
   1067a:	46ae      	mov	lr, r5
   1067c:	f85e 2b04 	ldr.w	r2, [lr], #4
   10680:	fa13 f382 	uxtah	r3, r3, r2
   10684:	1419      	asrs	r1, r3, #16
   10686:	eb01 4112 	add.w	r1, r1, r2, lsr #16
   1068a:	b29b      	uxth	r3, r3
   1068c:	ea43 4201 	orr.w	r2, r3, r1, lsl #16
   10690:	4577      	cmp	r7, lr
   10692:	f84c 2b04 	str.w	r2, [ip], #4
   10696:	ea4f 4321 	mov.w	r3, r1, asr #16
   1069a:	d8ef      	bhi.n	1067c <__mdiff+0xa0>
   1069c:	43ed      	mvns	r5, r5
   1069e:	442f      	add	r7, r5
   106a0:	f027 0703 	bic.w	r7, r7, #3
   106a4:	3704      	adds	r7, #4
   106a6:	443c      	add	r4, r7
   106a8:	3c04      	subs	r4, #4
   106aa:	b922      	cbnz	r2, 106b6 <__mdiff+0xda>
   106ac:	f854 3d04 	ldr.w	r3, [r4, #-4]!
   106b0:	3e01      	subs	r6, #1
   106b2:	2b00      	cmp	r3, #0
   106b4:	d0fa      	beq.n	106ac <__mdiff+0xd0>
   106b6:	6106      	str	r6, [r0, #16]
   106b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   106bc:	2100      	movs	r1, #0
   106be:	f7ff fd73 	bl	101a8 <_Balloc>
   106c2:	2201      	movs	r2, #1
   106c4:	2300      	movs	r3, #0
   106c6:	6102      	str	r2, [r0, #16]
   106c8:	6143      	str	r3, [r0, #20]
   106ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   106ce:	4674      	mov	r4, lr
   106d0:	e7ab      	b.n	1062a <__mdiff+0x4e>
   106d2:	4633      	mov	r3, r6
   106d4:	f106 0414 	add.w	r4, r6, #20
   106d8:	f102 0514 	add.w	r5, r2, #20
   106dc:	4616      	mov	r6, r2
   106de:	2701      	movs	r7, #1
   106e0:	4698      	mov	r8, r3
   106e2:	e7a2      	b.n	1062a <__mdiff+0x4e>

000106e4 <__d2b>:
   106e4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   106e8:	b083      	sub	sp, #12
   106ea:	2101      	movs	r1, #1
   106ec:	461c      	mov	r4, r3
   106ee:	f3c3 550a 	ubfx	r5, r3, #20, #11
   106f2:	4617      	mov	r7, r2
   106f4:	9e0a      	ldr	r6, [sp, #40]	; 0x28
   106f6:	f7ff fd57 	bl	101a8 <_Balloc>
   106fa:	f3c4 0413 	ubfx	r4, r4, #0, #20
   106fe:	4681      	mov	r9, r0
   10700:	b10d      	cbz	r5, 10706 <__d2b+0x22>
   10702:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
   10706:	9401      	str	r4, [sp, #4]
   10708:	b31f      	cbz	r7, 10752 <__d2b+0x6e>
   1070a:	a802      	add	r0, sp, #8
   1070c:	f840 7d08 	str.w	r7, [r0, #-8]!
   10710:	f7ff fdda 	bl	102c8 <__lo0bits>
   10714:	2800      	cmp	r0, #0
   10716:	d135      	bne.n	10784 <__d2b+0xa0>
   10718:	e89d 000c 	ldmia.w	sp, {r2, r3}
   1071c:	f8c9 2014 	str.w	r2, [r9, #20]
   10720:	2b00      	cmp	r3, #0
   10722:	bf0c      	ite	eq
   10724:	2101      	moveq	r1, #1
   10726:	2102      	movne	r1, #2
   10728:	f8c9 3018 	str.w	r3, [r9, #24]
   1072c:	f8c9 1010 	str.w	r1, [r9, #16]
   10730:	b9dd      	cbnz	r5, 1076a <__d2b+0x86>
   10732:	eb09 0381 	add.w	r3, r9, r1, lsl #2
   10736:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
   1073a:	6030      	str	r0, [r6, #0]
   1073c:	6918      	ldr	r0, [r3, #16]
   1073e:	f7ff fda3 	bl	10288 <__hi0bits>
   10742:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   10744:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
   10748:	6018      	str	r0, [r3, #0]
   1074a:	4648      	mov	r0, r9
   1074c:	b003      	add	sp, #12
   1074e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   10752:	a801      	add	r0, sp, #4
   10754:	f7ff fdb8 	bl	102c8 <__lo0bits>
   10758:	9b01      	ldr	r3, [sp, #4]
   1075a:	f8c9 3014 	str.w	r3, [r9, #20]
   1075e:	2101      	movs	r1, #1
   10760:	3020      	adds	r0, #32
   10762:	f8c9 1010 	str.w	r1, [r9, #16]
   10766:	2d00      	cmp	r5, #0
   10768:	d0e3      	beq.n	10732 <__d2b+0x4e>
   1076a:	f2a5 4833 	subw	r8, r5, #1075	; 0x433
   1076e:	eb08 0300 	add.w	r3, r8, r0
   10772:	6033      	str	r3, [r6, #0]
   10774:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   10776:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
   1077a:	6018      	str	r0, [r3, #0]
   1077c:	4648      	mov	r0, r9
   1077e:	b003      	add	sp, #12
   10780:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   10784:	e89d 000a 	ldmia.w	sp, {r1, r3}
   10788:	f1c0 0220 	rsb	r2, r0, #32
   1078c:	fa03 f202 	lsl.w	r2, r3, r2
   10790:	430a      	orrs	r2, r1
   10792:	40c3      	lsrs	r3, r0
   10794:	9301      	str	r3, [sp, #4]
   10796:	f8c9 2014 	str.w	r2, [r9, #20]
   1079a:	e7c1      	b.n	10720 <__d2b+0x3c>

0001079c <_read_r>:
   1079c:	b570      	push	{r4, r5, r6, lr}
   1079e:	460d      	mov	r5, r1
   107a0:	4c08      	ldr	r4, [pc, #32]	; (107c4 <_read_r+0x28>)
   107a2:	4611      	mov	r1, r2
   107a4:	4606      	mov	r6, r0
   107a6:	461a      	mov	r2, r3
   107a8:	4628      	mov	r0, r5
   107aa:	2300      	movs	r3, #0
   107ac:	6023      	str	r3, [r4, #0]
   107ae:	f7f2 ff85 	bl	36bc <_read>
   107b2:	1c43      	adds	r3, r0, #1
   107b4:	d000      	beq.n	107b8 <_read_r+0x1c>
   107b6:	bd70      	pop	{r4, r5, r6, pc}
   107b8:	6823      	ldr	r3, [r4, #0]
   107ba:	2b00      	cmp	r3, #0
   107bc:	d0fb      	beq.n	107b6 <_read_r+0x1a>
   107be:	6033      	str	r3, [r6, #0]
   107c0:	bd70      	pop	{r4, r5, r6, pc}
   107c2:	bf00      	nop
   107c4:	2000304c 	.word	0x2000304c

000107c8 <_raise_r>:
   107c8:	291f      	cmp	r1, #31
   107ca:	d828      	bhi.n	1081e <_raise_r+0x56>
   107cc:	b520      	push	{r5, lr}
   107ce:	f8d0 22dc 	ldr.w	r2, [r0, #732]	; 0x2dc
   107d2:	b082      	sub	sp, #8
   107d4:	4605      	mov	r5, r0
   107d6:	b1aa      	cbz	r2, 10804 <_raise_r+0x3c>
   107d8:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   107dc:	b193      	cbz	r3, 10804 <_raise_r+0x3c>
   107de:	2b01      	cmp	r3, #1
   107e0:	d00e      	beq.n	10800 <_raise_r+0x38>
   107e2:	1c58      	adds	r0, r3, #1
   107e4:	d007      	beq.n	107f6 <_raise_r+0x2e>
   107e6:	2500      	movs	r5, #0
   107e8:	4608      	mov	r0, r1
   107ea:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
   107ee:	4798      	blx	r3
   107f0:	4628      	mov	r0, r5
   107f2:	b002      	add	sp, #8
   107f4:	bd20      	pop	{r5, pc}
   107f6:	2316      	movs	r3, #22
   107f8:	2001      	movs	r0, #1
   107fa:	602b      	str	r3, [r5, #0]
   107fc:	b002      	add	sp, #8
   107fe:	bd20      	pop	{r5, pc}
   10800:	2000      	movs	r0, #0
   10802:	e7f6      	b.n	107f2 <_raise_r+0x2a>
   10804:	4628      	mov	r0, r5
   10806:	9101      	str	r1, [sp, #4]
   10808:	f000 f82a 	bl	10860 <_getpid_r>
   1080c:	9901      	ldr	r1, [sp, #4]
   1080e:	460a      	mov	r2, r1
   10810:	4601      	mov	r1, r0
   10812:	4628      	mov	r0, r5
   10814:	b002      	add	sp, #8
   10816:	e8bd 4020 	ldmia.w	sp!, {r5, lr}
   1081a:	f000 b80d 	b.w	10838 <_kill_r>
   1081e:	2316      	movs	r3, #22
   10820:	6003      	str	r3, [r0, #0]
   10822:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   10826:	4770      	bx	lr

00010828 <raise>:
   10828:	4b02      	ldr	r3, [pc, #8]	; (10834 <raise+0xc>)
   1082a:	4601      	mov	r1, r0
   1082c:	6818      	ldr	r0, [r3, #0]
   1082e:	f7ff bfcb 	b.w	107c8 <_raise_r>
   10832:	bf00      	nop
   10834:	200001c0 	.word	0x200001c0

00010838 <_kill_r>:
   10838:	b538      	push	{r3, r4, r5, lr}
   1083a:	460b      	mov	r3, r1
   1083c:	4c07      	ldr	r4, [pc, #28]	; (1085c <_kill_r+0x24>)
   1083e:	4605      	mov	r5, r0
   10840:	4611      	mov	r1, r2
   10842:	4618      	mov	r0, r3
   10844:	2300      	movs	r3, #0
   10846:	6023      	str	r3, [r4, #0]
   10848:	f000 f8bc 	bl	109c4 <_kill>
   1084c:	1c43      	adds	r3, r0, #1
   1084e:	d000      	beq.n	10852 <_kill_r+0x1a>
   10850:	bd38      	pop	{r3, r4, r5, pc}
   10852:	6823      	ldr	r3, [r4, #0]
   10854:	2b00      	cmp	r3, #0
   10856:	d0fb      	beq.n	10850 <_kill_r+0x18>
   10858:	602b      	str	r3, [r5, #0]
   1085a:	bd38      	pop	{r3, r4, r5, pc}
   1085c:	2000304c 	.word	0x2000304c

00010860 <_getpid_r>:
   10860:	f000 b8a8 	b.w	109b4 <_getpid>

00010864 <__ssprint_r>:
   10864:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10868:	6893      	ldr	r3, [r2, #8]
   1086a:	b083      	sub	sp, #12
   1086c:	4690      	mov	r8, r2
   1086e:	2b00      	cmp	r3, #0
   10870:	d070      	beq.n	10954 <__ssprint_r+0xf0>
   10872:	4682      	mov	sl, r0
   10874:	460c      	mov	r4, r1
   10876:	6817      	ldr	r7, [r2, #0]
   10878:	688d      	ldr	r5, [r1, #8]
   1087a:	6808      	ldr	r0, [r1, #0]
   1087c:	e042      	b.n	10904 <__ssprint_r+0xa0>
   1087e:	89a3      	ldrh	r3, [r4, #12]
   10880:	f413 6f90 	tst.w	r3, #1152	; 0x480
   10884:	d02e      	beq.n	108e4 <__ssprint_r+0x80>
   10886:	6965      	ldr	r5, [r4, #20]
   10888:	6921      	ldr	r1, [r4, #16]
   1088a:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   1088e:	eba0 0b01 	sub.w	fp, r0, r1
   10892:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   10896:	f10b 0001 	add.w	r0, fp, #1
   1089a:	106d      	asrs	r5, r5, #1
   1089c:	4430      	add	r0, r6
   1089e:	42a8      	cmp	r0, r5
   108a0:	462a      	mov	r2, r5
   108a2:	bf84      	itt	hi
   108a4:	4605      	movhi	r5, r0
   108a6:	462a      	movhi	r2, r5
   108a8:	055b      	lsls	r3, r3, #21
   108aa:	d538      	bpl.n	1091e <__ssprint_r+0xba>
   108ac:	4611      	mov	r1, r2
   108ae:	4650      	mov	r0, sl
   108b0:	f7f1 ff86 	bl	27c0 <__wrap__malloc_r>
   108b4:	2800      	cmp	r0, #0
   108b6:	d03c      	beq.n	10932 <__ssprint_r+0xce>
   108b8:	465a      	mov	r2, fp
   108ba:	6921      	ldr	r1, [r4, #16]
   108bc:	9001      	str	r0, [sp, #4]
   108be:	f7f0 f82f 	bl	920 <memcpy>
   108c2:	89a2      	ldrh	r2, [r4, #12]
   108c4:	9b01      	ldr	r3, [sp, #4]
   108c6:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
   108ca:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   108ce:	81a2      	strh	r2, [r4, #12]
   108d0:	eba5 020b 	sub.w	r2, r5, fp
   108d4:	eb03 000b 	add.w	r0, r3, fp
   108d8:	6165      	str	r5, [r4, #20]
   108da:	6123      	str	r3, [r4, #16]
   108dc:	6020      	str	r0, [r4, #0]
   108de:	60a2      	str	r2, [r4, #8]
   108e0:	4635      	mov	r5, r6
   108e2:	46b3      	mov	fp, r6
   108e4:	465a      	mov	r2, fp
   108e6:	4649      	mov	r1, r9
   108e8:	f7fa fd68 	bl	b3bc <memmove>
   108ec:	f8d8 3008 	ldr.w	r3, [r8, #8]
   108f0:	68a2      	ldr	r2, [r4, #8]
   108f2:	6820      	ldr	r0, [r4, #0]
   108f4:	1b55      	subs	r5, r2, r5
   108f6:	4458      	add	r0, fp
   108f8:	1b9e      	subs	r6, r3, r6
   108fa:	60a5      	str	r5, [r4, #8]
   108fc:	6020      	str	r0, [r4, #0]
   108fe:	f8c8 6008 	str.w	r6, [r8, #8]
   10902:	b33e      	cbz	r6, 10954 <__ssprint_r+0xf0>
   10904:	687e      	ldr	r6, [r7, #4]
   10906:	463b      	mov	r3, r7
   10908:	3708      	adds	r7, #8
   1090a:	2e00      	cmp	r6, #0
   1090c:	d0fa      	beq.n	10904 <__ssprint_r+0xa0>
   1090e:	42ae      	cmp	r6, r5
   10910:	f8d3 9000 	ldr.w	r9, [r3]
   10914:	46ab      	mov	fp, r5
   10916:	d2b2      	bcs.n	1087e <__ssprint_r+0x1a>
   10918:	4635      	mov	r5, r6
   1091a:	46b3      	mov	fp, r6
   1091c:	e7e2      	b.n	108e4 <__ssprint_r+0x80>
   1091e:	4650      	mov	r0, sl
   10920:	f7f1 ffb8 	bl	2894 <__wrap__realloc_r>
   10924:	4603      	mov	r3, r0
   10926:	2800      	cmp	r0, #0
   10928:	d1d2      	bne.n	108d0 <__ssprint_r+0x6c>
   1092a:	6921      	ldr	r1, [r4, #16]
   1092c:	4650      	mov	r0, sl
   1092e:	f7f1 ffec 	bl	290a <__wrap__free_r>
   10932:	230c      	movs	r3, #12
   10934:	f8ca 3000 	str.w	r3, [sl]
   10938:	89a3      	ldrh	r3, [r4, #12]
   1093a:	2200      	movs	r2, #0
   1093c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   10940:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   10944:	81a3      	strh	r3, [r4, #12]
   10946:	f8c8 2008 	str.w	r2, [r8, #8]
   1094a:	f8c8 2004 	str.w	r2, [r8, #4]
   1094e:	b003      	add	sp, #12
   10950:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10954:	2000      	movs	r0, #0
   10956:	f8c8 0004 	str.w	r0, [r8, #4]
   1095a:	b003      	add	sp, #12
   1095c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00010960 <_wcrtomb_r>:
   10960:	b5f0      	push	{r4, r5, r6, r7, lr}
   10962:	4606      	mov	r6, r0
   10964:	b085      	sub	sp, #20
   10966:	461f      	mov	r7, r3
   10968:	b189      	cbz	r1, 1098e <_wcrtomb_r+0x2e>
   1096a:	4c10      	ldr	r4, [pc, #64]	; (109ac <_wcrtomb_r+0x4c>)
   1096c:	4d10      	ldr	r5, [pc, #64]	; (109b0 <_wcrtomb_r+0x50>)
   1096e:	6824      	ldr	r4, [r4, #0]
   10970:	6b64      	ldr	r4, [r4, #52]	; 0x34
   10972:	2c00      	cmp	r4, #0
   10974:	bf08      	it	eq
   10976:	462c      	moveq	r4, r5
   10978:	f8d4 40e0 	ldr.w	r4, [r4, #224]	; 0xe0
   1097c:	47a0      	blx	r4
   1097e:	1c43      	adds	r3, r0, #1
   10980:	d103      	bne.n	1098a <_wcrtomb_r+0x2a>
   10982:	2200      	movs	r2, #0
   10984:	238a      	movs	r3, #138	; 0x8a
   10986:	603a      	str	r2, [r7, #0]
   10988:	6033      	str	r3, [r6, #0]
   1098a:	b005      	add	sp, #20
   1098c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1098e:	460c      	mov	r4, r1
   10990:	4906      	ldr	r1, [pc, #24]	; (109ac <_wcrtomb_r+0x4c>)
   10992:	4a07      	ldr	r2, [pc, #28]	; (109b0 <_wcrtomb_r+0x50>)
   10994:	6809      	ldr	r1, [r1, #0]
   10996:	6b49      	ldr	r1, [r1, #52]	; 0x34
   10998:	2900      	cmp	r1, #0
   1099a:	bf08      	it	eq
   1099c:	4611      	moveq	r1, r2
   1099e:	4622      	mov	r2, r4
   109a0:	f8d1 40e0 	ldr.w	r4, [r1, #224]	; 0xe0
   109a4:	a901      	add	r1, sp, #4
   109a6:	47a0      	blx	r4
   109a8:	e7e9      	b.n	1097e <_wcrtomb_r+0x1e>
   109aa:	bf00      	nop
   109ac:	200001c0 	.word	0x200001c0
   109b0:	200005f0 	.word	0x200005f0

000109b4 <_getpid>:
   109b4:	4b02      	ldr	r3, [pc, #8]	; (109c0 <_getpid+0xc>)
   109b6:	2258      	movs	r2, #88	; 0x58
   109b8:	601a      	str	r2, [r3, #0]
   109ba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   109be:	4770      	bx	lr
   109c0:	2000304c 	.word	0x2000304c

000109c4 <_kill>:
   109c4:	4b02      	ldr	r3, [pc, #8]	; (109d0 <_kill+0xc>)
   109c6:	2258      	movs	r2, #88	; 0x58
   109c8:	601a      	str	r2, [r3, #0]
   109ca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   109ce:	4770      	bx	lr
   109d0:	2000304c 	.word	0x2000304c
   109d4:	65726854 	.word	0x65726854
   109d8:	203a6461 	.word	0x203a6461
   109dc:	6c257830 	.word	0x6c257830
   109e0:	53202c58 	.word	0x53202c58
   109e4:	6b636174 	.word	0x6b636174
   109e8:	7a697320 	.word	0x7a697320
   109ec:	25203a65 	.word	0x25203a65
   109f0:	2f20756c 	.word	0x2f20756c
   109f4:	756c2520 	.word	0x756c2520
   109f8:	00000a0d 	.word	0x00000a0d
   109fc:	70616548 	.word	0x70616548
   10a00:	7a697320 	.word	0x7a697320
   10a04:	25203a65 	.word	0x25203a65
   10a08:	2f20756c 	.word	0x2f20756c
   10a0c:	756c2520 	.word	0x756c2520
   10a10:	74796220 	.word	0x74796220
   10a14:	0a0d7365 	.word	0x0a0d7365
   10a18:	00000000 	.word	0x00000000
   10a1c:	626d2f2e 	.word	0x626d2f2e
   10a20:	6f2d6465 	.word	0x6f2d6465
   10a24:	6c702f73 	.word	0x6c702f73
   10a28:	6f667461 	.word	0x6f667461
   10a2c:	532f6d72 	.word	0x532f6d72
   10a30:	6c676e69 	.word	0x6c676e69
   10a34:	6e6f7465 	.word	0x6e6f7465
   10a38:	2e727450 	.word	0x2e727450
   10a3c:	00000068 	.word	0x00000068
   10a40:	7274705f 	.word	0x7274705f
   10a44:	203d3d20 	.word	0x203d3d20
   10a48:	2a205428 	.word	0x2a205428
   10a4c:	645f2629 	.word	0x645f2629
   10a50:	00617461 	.word	0x00617461
   10a54:	626d2f2e 	.word	0x626d2f2e
   10a58:	6f2d6465 	.word	0x6f2d6465
   10a5c:	61682f73 	.word	0x61682f73
   10a60:	626d2f6c 	.word	0x626d2f6c
   10a64:	635f6465 	.word	0x635f6465
   10a68:	69746972 	.word	0x69746972
   10a6c:	5f6c6163 	.word	0x5f6c6163
   10a70:	74636573 	.word	0x74636573
   10a74:	5f6e6f69 	.word	0x5f6e6f69
   10a78:	2e697061 	.word	0x2e697061
   10a7c:	00000063 	.word	0x00000063
   10a80:	65726121 	.word	0x65726121
   10a84:	746e695f 	.word	0x746e695f
   10a88:	75727265 	.word	0x75727265
   10a8c:	5f737470 	.word	0x5f737470
   10a90:	62616e65 	.word	0x62616e65
   10a94:	2864656c 	.word	0x2864656c
   10a98:	00000029 	.word	0x00000029
   10a9c:	6c756f63 	.word	0x6c756f63
   10aa0:	6f6e2064 	.word	0x6f6e2064
   10aa4:	69702074 	.word	0x69702074
   10aa8:	74756f6e 	.word	0x74756f6e
   10aac:	00000000 	.word	0x00000000
   10ab0:	6d6e6970 	.word	0x6d6e6970
   10ab4:	6d207061 	.word	0x6d207061
   10ab8:	6d2d7369 	.word	0x6d2d7369
   10abc:	68637461 	.word	0x68637461
   10ac0:	00000000 	.word	0x00000000
   10ac4:	6d6e6970 	.word	0x6d6e6970
   10ac8:	6e207061 	.word	0x6e207061
   10acc:	6620746f 	.word	0x6620746f
   10ad0:	646e756f 	.word	0x646e756f
   10ad4:	726f6620 	.word	0x726f6620
   10ad8:	72657020 	.word	0x72657020
   10adc:	65687069 	.word	0x65687069
   10ae0:	006c6172 	.word	0x006c6172
   10ae4:	6d6e6970 	.word	0x6d6e6970
   10ae8:	6e207061 	.word	0x6e207061
   10aec:	6620746f 	.word	0x6620746f
   10af0:	646e756f 	.word	0x646e756f
   10af4:	726f6620 	.word	0x726f6620
   10af8:	6e756620 	.word	0x6e756620
   10afc:	6f697463 	.word	0x6f697463
   10b00:	0000006e 	.word	0x0000006e
   10b04:	70656544 	.word	0x70656544
   10b08:	65656c53 	.word	0x65656c53
   10b0c:	636f4c70 	.word	0x636f4c70
   10b10:	766f206b 	.word	0x766f206b
   10b14:	6c667265 	.word	0x6c667265
   10b18:	2820776f 	.word	0x2820776f
   10b1c:	5355203e 	.word	0x5355203e
   10b20:	5f545248 	.word	0x5f545248
   10b24:	2958414d 	.word	0x2958414d
   10b28:	00000000 	.word	0x00000000
   10b2c:	70656544 	.word	0x70656544
   10b30:	65656c53 	.word	0x65656c53
   10b34:	636f4c70 	.word	0x636f4c70
   10b38:	6e75206b 	.word	0x6e75206b
   10b3c:	66726564 	.word	0x66726564
   10b40:	20776f6c 	.word	0x20776f6c
   10b44:	30203c28 	.word	0x30203c28
   10b48:	00000029 	.word	0x00000029
   10b4c:	626d2f2e 	.word	0x626d2f2e
   10b50:	6f2d6465 	.word	0x6f2d6465
   10b54:	61682f73 	.word	0x61682f73
   10b58:	626d2f6c 	.word	0x626d2f6c
   10b5c:	745f6465 	.word	0x745f6465
   10b60:	656b6369 	.word	0x656b6369
   10b64:	70615f72 	.word	0x70615f72
   10b68:	00632e69 	.word	0x00632e69
   10b6c:	00000030 	.word	0x00000030
   10b70:	6465626d 	.word	0x6465626d
   10b74:	73736120 	.word	0x73736120
   10b78:	61747265 	.word	0x61747265
   10b7c:	6e6f6974 	.word	0x6e6f6974
   10b80:	69616620 	.word	0x69616620
   10b84:	3a64656c 	.word	0x3a64656c
   10b88:	2c732520 	.word	0x2c732520
   10b8c:	6c696620 	.word	0x6c696620
   10b90:	25203a65 	.word	0x25203a65
   10b94:	6c202c73 	.word	0x6c202c73
   10b98:	20656e69 	.word	0x20656e69
   10b9c:	0a206425 	.word	0x0a206425
   10ba0:	00000000 	.word	0x00000000
   10ba4:	626d2f2e 	.word	0x626d2f2e
   10ba8:	6f2d6465 	.word	0x6f2d6465
   10bac:	6c702f73 	.word	0x6c702f73
   10bb0:	6f667461 	.word	0x6f667461
   10bb4:	6d2f6d72 	.word	0x6d2f6d72
   10bb8:	5f646562 	.word	0x5f646562
   10bbc:	74697263 	.word	0x74697263
   10bc0:	6c616369 	.word	0x6c616369
   10bc4:	0000632e 	.word	0x0000632e
   10bc8:	74697263 	.word	0x74697263
   10bcc:	6c616369 	.word	0x6c616369
   10bd0:	6365735f 	.word	0x6365735f
   10bd4:	6e6f6974 	.word	0x6e6f6974
   10bd8:	6565725f 	.word	0x6565725f
   10bdc:	6172746e 	.word	0x6172746e
   10be0:	5f79636e 	.word	0x5f79636e
   10be4:	6e756f63 	.word	0x6e756f63
   10be8:	20726574 	.word	0x20726574
   10bec:	4955203c 	.word	0x4955203c
   10bf0:	3233544e 	.word	0x3233544e
   10bf4:	58414d5f 	.word	0x58414d5f
   10bf8:	00000000 	.word	0x00000000
   10bfc:	61746146 	.word	0x61746146
   10c00:	7552206c 	.word	0x7552206c
   10c04:	69742d6e 	.word	0x69742d6e
   10c08:	6520656d 	.word	0x6520656d
   10c0c:	726f7272 	.word	0x726f7272
   10c10:	00000000 	.word	0x00000000
   10c14:	2b2b0a0a 	.word	0x2b2b0a0a
   10c18:	65624d20 	.word	0x65624d20
   10c1c:	20534f64 	.word	0x20534f64
   10c20:	6f727245 	.word	0x6f727245
   10c24:	6e492072 	.word	0x6e492072
   10c28:	2b206f66 	.word	0x2b206f66
   10c2c:	72450a2b 	.word	0x72450a2b
   10c30:	20726f72 	.word	0x20726f72
   10c34:	74617453 	.word	0x74617453
   10c38:	203a7375 	.word	0x203a7375
   10c3c:	58257830 	.word	0x58257830
   10c40:	646f4320 	.word	0x646f4320
   10c44:	25203a65 	.word	0x25203a65
   10c48:	6f4d2064 	.word	0x6f4d2064
   10c4c:	656c7564 	.word	0x656c7564
   10c50:	6425203a 	.word	0x6425203a
   10c54:	7272450a 	.word	0x7272450a
   10c58:	4d20726f 	.word	0x4d20726f
   10c5c:	61737365 	.word	0x61737365
   10c60:	203a6567 	.word	0x203a6567
   10c64:	00000000 	.word	0x00000000
   10c68:	6e72654b 	.word	0x6e72654b
   10c6c:	45206c65 	.word	0x45206c65
   10c70:	726f7272 	.word	0x726f7272
   10c74:	7830203a 	.word	0x7830203a
   10c78:	202c5825 	.word	0x202c5825
   10c7c:	00000000 	.word	0x00000000
   10c80:	65726854 	.word	0x65726854
   10c84:	203a6461 	.word	0x203a6461
   10c88:	58257830 	.word	0x58257830
   10c8c:	0000202c 	.word	0x0000202c
   10c90:	6574754d 	.word	0x6574754d
   10c94:	30203a78 	.word	0x30203a78
   10c98:	2c582578 	.word	0x2c582578
   10c9c:	00000020 	.word	0x00000020
   10ca0:	616d6553 	.word	0x616d6553
   10ca4:	726f6870 	.word	0x726f6870
   10ca8:	30203a65 	.word	0x30203a65
   10cac:	2c582578 	.word	0x2c582578
   10cb0:	00000020 	.word	0x00000020
   10cb4:	6f6d654d 	.word	0x6f6d654d
   10cb8:	6f507972 	.word	0x6f507972
   10cbc:	203a6c6f 	.word	0x203a6c6f
   10cc0:	58257830 	.word	0x58257830
   10cc4:	0000202c 	.word	0x0000202c
   10cc8:	6e657645 	.word	0x6e657645
   10ccc:	616c4674 	.word	0x616c4674
   10cd0:	203a7367 	.word	0x203a7367
   10cd4:	58257830 	.word	0x58257830
   10cd8:	0000202c 	.word	0x0000202c
   10cdc:	656d6954 	.word	0x656d6954
   10ce0:	30203a72 	.word	0x30203a72
   10ce4:	2c582578 	.word	0x2c582578
   10ce8:	00000020 	.word	0x00000020
   10cec:	7373654d 	.word	0x7373654d
   10cf0:	51656761 	.word	0x51656761
   10cf4:	65756575 	.word	0x65756575
   10cf8:	7830203a 	.word	0x7830203a
   10cfc:	202c5825 	.word	0x202c5825
   10d00:	00000000 	.word	0x00000000
   10d04:	636f4c0a 	.word	0x636f4c0a
   10d08:	6f697461 	.word	0x6f697461
   10d0c:	30203a6e 	.word	0x30203a6e
   10d10:	00582578 	.word	0x00582578
   10d14:	7272450a 	.word	0x7272450a
   10d18:	5620726f 	.word	0x5620726f
   10d1c:	65756c61 	.word	0x65756c61
   10d20:	7830203a 	.word	0x7830203a
   10d24:	00005825 	.word	0x00005825
   10d28:	7275430a 	.word	0x7275430a
   10d2c:	746e6572 	.word	0x746e6572
   10d30:	72685420 	.word	0x72685420
   10d34:	3a646165 	.word	0x3a646165
   10d38:	3a644920 	.word	0x3a644920
   10d3c:	25783020 	.word	0x25783020
   10d40:	6e452058 	.word	0x6e452058
   10d44:	3a797274 	.word	0x3a797274
   10d48:	25783020 	.word	0x25783020
   10d4c:	74532058 	.word	0x74532058
   10d50:	536b6361 	.word	0x536b6361
   10d54:	3a657a69 	.word	0x3a657a69
   10d58:	25783020 	.word	0x25783020
   10d5c:	74532058 	.word	0x74532058
   10d60:	4d6b6361 	.word	0x4d6b6361
   10d64:	203a6d65 	.word	0x203a6d65
   10d68:	58257830 	.word	0x58257830
   10d6c:	3a505320 	.word	0x3a505320
   10d70:	25783020 	.word	0x25783020
   10d74:	00002058 	.word	0x00002058
   10d78:	202d2d0a 	.word	0x202d2d0a
   10d7c:	6465624d 	.word	0x6465624d
   10d80:	4520534f 	.word	0x4520534f
   10d84:	726f7272 	.word	0x726f7272
   10d88:	666e4920 	.word	0x666e4920
   10d8c:	2d2d206f 	.word	0x2d2d206f
   10d90:	0000000a 	.word	0x0000000a
   10d94:	253a6d23 	.word	0x253a6d23
   10d98:	70253b70 	.word	0x70253b70
   10d9c:	0a75252d 	.word	0x0a75252d
   10da0:	00000000 	.word	0x00000000
   10da4:	253a7223 	.word	0x253a7223
   10da8:	70253b70 	.word	0x70253b70
   10dac:	3b70252d 	.word	0x3b70252d
   10db0:	000a7525 	.word	0x000a7525
   10db4:	253a6323 	.word	0x253a6323
   10db8:	70253b70 	.word	0x70253b70
   10dbc:	3b75252d 	.word	0x3b75252d
   10dc0:	000a7525 	.word	0x000a7525
   10dc4:	253a6623 	.word	0x253a6623
   10dc8:	70253b70 	.word	0x70253b70
   10dcc:	0a70252d 	.word	0x0a70252d
   10dd0:	00000000 	.word	0x00000000
   10dd4:	00000a3f 	.word	0x00000a3f
   10dd8:	626d2f2e 	.word	0x626d2f2e
   10ddc:	6f2d6465 	.word	0x6f2d6465
   10de0:	6c702f73 	.word	0x6c702f73
   10de4:	6f667461 	.word	0x6f667461
   10de8:	532f6d72 	.word	0x532f6d72
   10dec:	6c676e69 	.word	0x6c676e69
   10df0:	6e6f7465 	.word	0x6e6f7465
   10df4:	2e727450 	.word	0x2e727450
   10df8:	00000068 	.word	0x00000068
   10dfc:	7274705f 	.word	0x7274705f
   10e00:	203d3d20 	.word	0x203d3d20
   10e04:	2a205428 	.word	0x2a205428
   10e08:	645f2629 	.word	0x645f2629
   10e0c:	00617461 	.word	0x00617461
   10e10:	6f727245 	.word	0x6f727245
   10e14:	202d2072 	.word	0x202d2072
   10e18:	74697277 	.word	0x74697277
   10e1c:	20676e69 	.word	0x20676e69
   10e20:	61206f74 	.word	0x61206f74
   10e24:	6c696620 	.word	0x6c696620
   10e28:	6e692065 	.word	0x6e692065
   10e2c:	206e6120 	.word	0x206e6120
   10e30:	20525349 	.word	0x20525349
   10e34:	6320726f 	.word	0x6320726f
   10e38:	69746972 	.word	0x69746972
   10e3c:	206c6163 	.word	0x206c6163
   10e40:	74636573 	.word	0x74636573
   10e44:	0d6e6f69 	.word	0x0d6e6f69
   10e48:	0000000a 	.word	0x0000000a
   10e4c:	0000000d 	.word	0x0000000d
   10e50:	6f727245 	.word	0x6f727245
   10e54:	202d2072 	.word	0x202d2072
   10e58:	64616572 	.word	0x64616572
   10e5c:	20676e69 	.word	0x20676e69
   10e60:	6d6f7266 	.word	0x6d6f7266
   10e64:	66206120 	.word	0x66206120
   10e68:	20656c69 	.word	0x20656c69
   10e6c:	61206e69 	.word	0x61206e69
   10e70:	5349206e 	.word	0x5349206e
   10e74:	726f2052 	.word	0x726f2052
   10e78:	69726320 	.word	0x69726320
   10e7c:	61636974 	.word	0x61636974
   10e80:	6573206c 	.word	0x6573206c
   10e84:	6f697463 	.word	0x6f697463
   10e88:	000a0d6e 	.word	0x000a0d6e
   10e8c:	65637845 	.word	0x65637845
   10e90:	6f697470 	.word	0x6f697470
   10e94:	0000006e 	.word	0x0000006e
   10e98:	626d2f2e 	.word	0x626d2f2e
   10e9c:	6f2d6465 	.word	0x6f2d6465
   10ea0:	6c702f73 	.word	0x6c702f73
   10ea4:	6f667461 	.word	0x6f667461
   10ea8:	6d2f6d72 	.word	0x6d2f6d72
   10eac:	5f646562 	.word	0x5f646562
   10eb0:	61746572 	.word	0x61746572
   10eb4:	74656772 	.word	0x74656772
   10eb8:	7070632e 	.word	0x7070632e
   10ebc:	00000000 	.word	0x00000000
   10ec0:	3d3d2030 	.word	0x3d3d2030
   10ec4:	672a2820 	.word	0x672a2820
   10ec8:	64726175 	.word	0x64726175
   10ecc:	6a626f5f 	.word	0x6a626f5f
   10ed0:	20746365 	.word	0x20746365
   10ed4:	58432026 	.word	0x58432026
   10ed8:	55475f41 	.word	0x55475f41
   10edc:	5f445241 	.word	0x5f445241
   10ee0:	4b53414d 	.word	0x4b53414d
   10ee4:	00000029 	.word	0x00000029
   10ee8:	5f415843 	.word	0x5f415843
   10eec:	52415547 	.word	0x52415547
   10ef0:	4e495f44 	.word	0x4e495f44
   10ef4:	495f5449 	.word	0x495f5449
   10ef8:	52505f4e 	.word	0x52505f4e
   10efc:	4552474f 	.word	0x4552474f
   10f00:	3d205353 	.word	0x3d205353
   10f04:	2a28203d 	.word	0x2a28203d
   10f08:	72617567 	.word	0x72617567
   10f0c:	626f5f64 	.word	0x626f5f64
   10f10:	7463656a 	.word	0x7463656a
   10f14:	43202620 	.word	0x43202620
   10f18:	475f4158 	.word	0x475f4158
   10f1c:	44524155 	.word	0x44524155
   10f20:	53414d5f 	.word	0x53414d5f
   10f24:	0000294b 	.word	0x0000294b
   10f28:	7265704f 	.word	0x7265704f
   10f2c:	726f7461 	.word	0x726f7461
   10f30:	77656e20 	.word	0x77656e20
   10f34:	74756f20 	.word	0x74756f20
   10f38:	20666f20 	.word	0x20666f20
   10f3c:	6f6d656d 	.word	0x6f6d656d
   10f40:	0a0d7972 	.word	0x0a0d7972
   10f44:	00000000 	.word	0x00000000
   10f48:	626d2f2e 	.word	0x626d2f2e
   10f4c:	6f2d6465 	.word	0x6f2d6465
   10f50:	6c702f73 	.word	0x6c702f73
   10f54:	6f667461 	.word	0x6f667461
   10f58:	532f6d72 	.word	0x532f6d72
   10f5c:	6c676e69 	.word	0x6c676e69
   10f60:	6e6f7465 	.word	0x6e6f7465
   10f64:	2e727450 	.word	0x2e727450
   10f68:	00000068 	.word	0x00000068
   10f6c:	7274705f 	.word	0x7274705f
   10f70:	203d3d20 	.word	0x203d3d20
   10f74:	2a205428 	.word	0x2a205428
   10f78:	645f2629 	.word	0x645f2629
   10f7c:	00617461 	.word	0x00617461
   10f80:	626d2f2e 	.word	0x626d2f2e
   10f84:	6f2d6465 	.word	0x6f2d6465
   10f88:	6c702f73 	.word	0x6c702f73
   10f8c:	6f667461 	.word	0x6f667461
   10f90:	6d2f6d72 	.word	0x6d2f6d72
   10f94:	5f646562 	.word	0x5f646562
   10f98:	74617473 	.word	0x74617473
   10f9c:	00632e73 	.word	0x00632e73
   10fa0:	74617473 	.word	0x74617473
   10fa4:	3d212073 	.word	0x3d212073
   10fa8:	4c554e20 	.word	0x4c554e20
   10fac:	0000004c 	.word	0x0000004c
   10fb0:	65726874 	.word	0x65726874
   10fb4:	20736461 	.word	0x20736461
   10fb8:	4e203d21 	.word	0x4e203d21
   10fbc:	004c4c55 	.word	0x004c4c55
   10fc0:	696c7061 	.word	0x696c7061
   10fc4:	69746163 	.word	0x69746163
   10fc8:	755f6e6f 	.word	0x755f6e6f
   10fcc:	6d616e6e 	.word	0x6d616e6e
   10fd0:	6d5f6465 	.word	0x6d5f6465
   10fd4:	78657475 	.word	0x78657475
   10fd8:	00000000 	.word	0x00000000
   10fdc:	626d2f2e 	.word	0x626d2f2e
   10fe0:	6f2d6465 	.word	0x6f2d6465
   10fe4:	74722f73 	.word	0x74722f73
   10fe8:	4d2f736f 	.word	0x4d2f736f
   10fec:	78657475 	.word	0x78657475
   10ff0:	7070632e 	.word	0x7070632e
   10ff4:	00000000 	.word	0x00000000
   10ff8:	0064695f 	.word	0x0064695f
   10ffc:	74617473 	.word	0x74617473
   11000:	3d207375 	.word	0x3d207375
   11004:	736f203d 	.word	0x736f203d
   11008:	6f727245 	.word	0x6f727245
   1100c:	6d695472 	.word	0x6d695472
   11010:	74756f65 	.word	0x74756f65
   11014:	207c7c20 	.word	0x207c7c20
   11018:	74617473 	.word	0x74617473
   1101c:	3d207375 	.word	0x3d207375
   11020:	736f203d 	.word	0x736f203d
   11024:	6f727245 	.word	0x6f727245
   11028:	73655272 	.word	0x73655272
   1102c:	6372756f 	.word	0x6372756f
   11030:	00000065 	.word	0x00000065
   11034:	202b2b0a 	.word	0x202b2b0a
   11038:	6465624d 	.word	0x6465624d
   1103c:	4620534f 	.word	0x4620534f
   11040:	746c7561 	.word	0x746c7561
   11044:	6e614820 	.word	0x6e614820
   11048:	72656c64 	.word	0x72656c64
   1104c:	0a2b2b20 	.word	0x0a2b2b20
   11050:	7561460a 	.word	0x7561460a
   11054:	7954746c 	.word	0x7954746c
   11058:	203a6570 	.word	0x203a6570
   1105c:	00000000 	.word	0x00000000
   11060:	4d6d654d 	.word	0x4d6d654d
   11064:	67616e61 	.word	0x67616e61
   11068:	75614665 	.word	0x75614665
   1106c:	0000746c 	.word	0x0000746c
   11070:	46737542 	.word	0x46737542
   11074:	746c7561 	.word	0x746c7561
   11078:	00000000 	.word	0x00000000
   1107c:	67617355 	.word	0x67617355
   11080:	75614665 	.word	0x75614665
   11084:	0000746c 	.word	0x0000746c
   11088:	64726148 	.word	0x64726148
   1108c:	6c756146 	.word	0x6c756146
   11090:	00000074 	.word	0x00000074
   11094:	6f430a0a 	.word	0x6f430a0a
   11098:	7865746e 	.word	0x7865746e
   1109c:	00003a74 	.word	0x00003a74
   110a0:	2d2d0a0a 	.word	0x2d2d0a0a
   110a4:	65624d20 	.word	0x65624d20
   110a8:	20534f64 	.word	0x20534f64
   110ac:	6c756146 	.word	0x6c756146
   110b0:	61482074 	.word	0x61482074
   110b4:	656c646e 	.word	0x656c646e
   110b8:	2d2d2072 	.word	0x2d2d2072
   110bc:	00000a0a 	.word	0x00000a0a
   110c0:	6c756146 	.word	0x6c756146
   110c4:	78652074 	.word	0x78652074
   110c8:	74706563 	.word	0x74706563
   110cc:	006e6f69 	.word	0x006e6f69
   110d0:	2d25520a 	.word	0x2d25520a
   110d4:	203a6434 	.word	0x203a6434
   110d8:	58383025 	.word	0x58383025
   110dc:	00000000 	.word	0x00000000
   110e0:	2050530a 	.word	0x2050530a
   110e4:	203a2020 	.word	0x203a2020
   110e8:	58383025 	.word	0x58383025
   110ec:	20524c0a 	.word	0x20524c0a
   110f0:	203a2020 	.word	0x203a2020
   110f4:	58383025 	.word	0x58383025
   110f8:	2043500a 	.word	0x2043500a
   110fc:	203a2020 	.word	0x203a2020
   11100:	58383025 	.word	0x58383025
   11104:	5350780a 	.word	0x5350780a
   11108:	203a2052 	.word	0x203a2052
   1110c:	58383025 	.word	0x58383025
   11110:	5053500a 	.word	0x5053500a
   11114:	203a2020 	.word	0x203a2020
   11118:	58383025 	.word	0x58383025
   1111c:	50534d0a 	.word	0x50534d0a
   11120:	203a2020 	.word	0x203a2020
   11124:	58383025 	.word	0x58383025
   11128:	00000000 	.word	0x00000000
   1112c:	5550430a 	.word	0x5550430a
   11130:	203a4449 	.word	0x203a4449
   11134:	58383025 	.word	0x58383025
   11138:	00000000 	.word	0x00000000
   1113c:	5346480a 	.word	0x5346480a
   11140:	203a2052 	.word	0x203a2052
   11144:	58383025 	.word	0x58383025
   11148:	464d4d0a 	.word	0x464d4d0a
   1114c:	203a5253 	.word	0x203a5253
   11150:	58383025 	.word	0x58383025
   11154:	5346420a 	.word	0x5346420a
   11158:	203a2052 	.word	0x203a2052
   1115c:	58383025 	.word	0x58383025
   11160:	5346550a 	.word	0x5346550a
   11164:	203a2052 	.word	0x203a2052
   11168:	58383025 	.word	0x58383025
   1116c:	5346440a 	.word	0x5346440a
   11170:	203a2052 	.word	0x203a2052
   11174:	58383025 	.word	0x58383025
   11178:	5346410a 	.word	0x5346410a
   1117c:	203a2052 	.word	0x203a2052
   11180:	58383025 	.word	0x58383025
   11184:	00000000 	.word	0x00000000
   11188:	464d4d0a 	.word	0x464d4d0a
   1118c:	203a5241 	.word	0x203a5241
   11190:	58383025 	.word	0x58383025
   11194:	00000000 	.word	0x00000000
   11198:	4146420a 	.word	0x4146420a
   1119c:	203a2052 	.word	0x203a2052
   111a0:	58383025 	.word	0x58383025
   111a4:	00000000 	.word	0x00000000
   111a8:	646f4d0a 	.word	0x646f4d0a
   111ac:	203a2065 	.word	0x203a2065
   111b0:	65726854 	.word	0x65726854
   111b4:	00006461 	.word	0x00006461
   111b8:	6972500a 	.word	0x6972500a
   111bc:	203a2076 	.word	0x203a2076
   111c0:	72657355 	.word	0x72657355
   111c4:	00000000 	.word	0x00000000
   111c8:	6972500a 	.word	0x6972500a
   111cc:	203a2076 	.word	0x203a2076
   111d0:	76697250 	.word	0x76697250
   111d4:	67656c69 	.word	0x67656c69
   111d8:	00006465 	.word	0x00006465
   111dc:	646f4d0a 	.word	0x646f4d0a
   111e0:	203a2065 	.word	0x203a2065
   111e4:	646e6148 	.word	0x646e6148
   111e8:	0072656c 	.word	0x0072656c
   111ec:	6174530a 	.word	0x6174530a
   111f0:	203a6b63 	.word	0x203a6b63
   111f4:	00505350 	.word	0x00505350
   111f8:	6174530a 	.word	0x6174530a
   111fc:	203a6b63 	.word	0x203a6b63
   11200:	0050534d 	.word	0x0050534d
   11204:	6e69616d 	.word	0x6e69616d
   11208:	7268745f 	.word	0x7268745f
   1120c:	00646165 	.word	0x00646165
   11210:	20657250 	.word	0x20657250
   11214:	6e69616d 	.word	0x6e69616d
   11218:	72687420 	.word	0x72687420
   1121c:	20646165 	.word	0x20646165
   11220:	20746f6e 	.word	0x20746f6e
   11224:	61657263 	.word	0x61657263
   11228:	00646574 	.word	0x00646574
   1122c:	676e6973 	.word	0x676e6973
   11230:	6f74656c 	.word	0x6f74656c
   11234:	756d5f6e 	.word	0x756d5f6e
   11238:	00786574 	.word	0x00786574
   1123c:	6c6c616d 	.word	0x6c6c616d
   11240:	6d5f636f 	.word	0x6d5f636f
   11244:	78657475 	.word	0x78657475
   11248:	00000000 	.word	0x00000000
   1124c:	5f766e65 	.word	0x5f766e65
   11250:	6574756d 	.word	0x6574756d
   11254:	00000078 	.word	0x00000078
   11258:	49534d43 	.word	0x49534d43
   1125c:	54522d53 	.word	0x54522d53
   11260:	6520534f 	.word	0x6520534f
   11264:	726f7272 	.word	0x726f7272
   11268:	7453203a 	.word	0x7453203a
   1126c:	206b6361 	.word	0x206b6361
   11270:	7265766f 	.word	0x7265766f
   11274:	776f6c66 	.word	0x776f6c66
   11278:	00000000 	.word	0x00000000
   1127c:	49534d43 	.word	0x49534d43
   11280:	54522d53 	.word	0x54522d53
   11284:	6520534f 	.word	0x6520534f
   11288:	726f7272 	.word	0x726f7272
   1128c:	5349203a 	.word	0x5349203a
   11290:	75512052 	.word	0x75512052
   11294:	20657565 	.word	0x20657565
   11298:	7265766f 	.word	0x7265766f
   1129c:	776f6c66 	.word	0x776f6c66
   112a0:	00000000 	.word	0x00000000
   112a4:	49534d43 	.word	0x49534d43
   112a8:	54522d53 	.word	0x54522d53
   112ac:	6520534f 	.word	0x6520534f
   112b0:	726f7272 	.word	0x726f7272
   112b4:	7355203a 	.word	0x7355203a
   112b8:	54207265 	.word	0x54207265
   112bc:	72656d69 	.word	0x72656d69
   112c0:	6c614320 	.word	0x6c614320
   112c4:	6361626c 	.word	0x6361626c
   112c8:	7551206b 	.word	0x7551206b
   112cc:	20657565 	.word	0x20657565
   112d0:	7265766f 	.word	0x7265766f
   112d4:	776f6c66 	.word	0x776f6c66
   112d8:	00000000 	.word	0x00000000
   112dc:	49534d43 	.word	0x49534d43
   112e0:	54522d53 	.word	0x54522d53
   112e4:	6520534f 	.word	0x6520534f
   112e8:	726f7272 	.word	0x726f7272
   112ec:	5453203a 	.word	0x5453203a
   112f0:	2f432044 	.word	0x2f432044
   112f4:	202b2b43 	.word	0x202b2b43
   112f8:	7262696c 	.word	0x7262696c
   112fc:	20797261 	.word	0x20797261
   11300:	7362696c 	.word	0x7362696c
   11304:	65636170 	.word	0x65636170
   11308:	746f6e20 	.word	0x746f6e20
   1130c:	61766120 	.word	0x61766120
   11310:	62616c69 	.word	0x62616c69
   11314:	0000656c 	.word	0x0000656c
   11318:	49534d43 	.word	0x49534d43
   1131c:	54522d53 	.word	0x54522d53
   11320:	6520534f 	.word	0x6520534f
   11324:	726f7272 	.word	0x726f7272
   11328:	5453203a 	.word	0x5453203a
   1132c:	2f432044 	.word	0x2f432044
   11330:	202b2b43 	.word	0x202b2b43
   11334:	7262696c 	.word	0x7262696c
   11338:	20797261 	.word	0x20797261
   1133c:	6574756d 	.word	0x6574756d
   11340:	6e692078 	.word	0x6e692078
   11344:	61697469 	.word	0x61697469
   11348:	617a696c 	.word	0x617a696c
   1134c:	6e6f6974 	.word	0x6e6f6974
   11350:	69616620 	.word	0x69616620
   11354:	0064656c 	.word	0x0064656c
   11358:	49534d43 	.word	0x49534d43
   1135c:	54522d53 	.word	0x54522d53
   11360:	6520534f 	.word	0x6520534f
   11364:	726f7272 	.word	0x726f7272
   11368:	6e55203a 	.word	0x6e55203a
   1136c:	776f6e6b 	.word	0x776f6e6b
   11370:	0000006e 	.word	0x0000006e
   11374:	70736e55 	.word	0x70736e55
   11378:	66696365 	.word	0x66696365
   1137c:	20646569 	.word	0x20646569
   11380:	534f5452 	.word	0x534f5452
   11384:	72726520 	.word	0x72726520
   11388:	0000726f 	.word	0x0000726f
   1138c:	7265704f 	.word	0x7265704f
   11390:	6f697461 	.word	0x6f697461
   11394:	6f6e206e 	.word	0x6f6e206e
   11398:	6f632074 	.word	0x6f632074
   1139c:	656c706d 	.word	0x656c706d
   113a0:	20646574 	.word	0x20646574
   113a4:	68746977 	.word	0x68746977
   113a8:	74206e69 	.word	0x74206e69
   113ac:	74206568 	.word	0x74206568
   113b0:	6f656d69 	.word	0x6f656d69
   113b4:	70207475 	.word	0x70207475
   113b8:	6f697265 	.word	0x6f697265
   113bc:	00000064 	.word	0x00000064
   113c0:	6f736552 	.word	0x6f736552
   113c4:	65637275 	.word	0x65637275
   113c8:	746f6e20 	.word	0x746f6e20
   113cc:	61766120 	.word	0x61766120
   113d0:	62616c69 	.word	0x62616c69
   113d4:	0000656c 	.word	0x0000656c
   113d8:	61726150 	.word	0x61726150
   113dc:	6574656d 	.word	0x6574656d
   113e0:	72652072 	.word	0x72652072
   113e4:	00726f72 	.word	0x00726f72
   113e8:	74737953 	.word	0x74737953
   113ec:	69206d65 	.word	0x69206d65
   113f0:	756f2073 	.word	0x756f2073
   113f4:	666f2074 	.word	0x666f2074
   113f8:	6d656d20 	.word	0x6d656d20
   113fc:	0079726f 	.word	0x0079726f
   11400:	20746f4e 	.word	0x20746f4e
   11404:	6f6c6c61 	.word	0x6f6c6c61
   11408:	20646577 	.word	0x20646577
   1140c:	49206e69 	.word	0x49206e69
   11410:	63205253 	.word	0x63205253
   11414:	65746e6f 	.word	0x65746e6f
   11418:	00007478 	.word	0x00007478
   1141c:	6e6b6e55 	.word	0x6e6b6e55
   11420:	006e776f 	.word	0x006e776f
   11424:	20585452 	.word	0x20585452
   11428:	332e3556 	.word	0x332e3556
   1142c:	0000302e 	.word	0x0000302e
   11430:	656c6469 	.word	0x656c6469
   11434:	7268745f 	.word	0x7268745f
   11438:	00646165 	.word	0x00646165
   1143c:	656d6974 	.word	0x656d6974
   11440:	68745f72 	.word	0x68745f72
   11444:	64616572 	.word	0x64616572
   11448:	00000000 	.word	0x00000000

0001144c <osRtxConfig>:
   1144c:	00000007 000003e8 00000005 20000e30     ............0..
   1145c:	00000010 00000000 00000000 00000000     ................
	...
   114a0:	00001000 0001258c 000125b0 000125d4     .....%...%...%..
   114b0:	00000004                                ....

000114b4 <os_cb_sections>:
	...
   114ec:	74785f67 46306c61 00716572 626d2f2e     g_xtal0Freq../mb
   114fc:	6f2d6465 61742f73 74656772 41542f73     ed-os/targets/TA
   1150c:	54454752 6572465f 61637365 542f656c     RGET_Freescale/T
   1151c:	45475241 434d5f54 72705855 6f737365     ARGET_MCUXpresso
   1152c:	55434d5f 41542f53 54454752 55434d5f     _MCUS/TARGET_MCU
   1153c:	34364b5f 72642f46 72657669 73662f73     _K64F/drivers/fs
   1154c:	6c635f6c 2e6b636f 00000063 74785f67     l_clock.c...g_xt
   1155c:	32336c61 71657246 00000000 7067636d     al32Freq....mcgp
   1156c:	63306c6c 00006b6c 666e6f63 00006769     ll0clk..config..
   1157c:	74736e69 65636e61 41203c20 59415252     instance < ARRAY
   1158c:	5a49535f 5f732845 69707364 65736142     _SIZE(s_dspiBase
   1159c:	00002973 626d2f2e 6f2d6465 61742f73     s).../mbed-os/ta
   115ac:	74656772 41542f73 54454752 6572465f     rgets/TARGET_Fre
   115bc:	61637365 542f656c 45475241 434d5f54     escale/TARGET_MC
   115cc:	72705855 6f737365 55434d5f 41542f53     UXpresso_MCUS/TA
   115dc:	54454752 55434d5f 34364b5f 72642f46     RGET_MCU_K64F/dr
   115ec:	72657669 73662f73 73645f6c 632e6970     ivers/fsl_dspi.c
   115fc:	00000000 7473616d 6f437265 6769666e     ....masterConfig
   1160c:	00000000 736c6166 00000065 76616c73     ....false...slav
   1161c:	6e6f4365 00676966 6d6d6f63 00646e61     eConfig.command.
   1162c:	646e6168 0000656c 6e617274 72656673     handle..transfer
   1163c:	00000000 73645f67 61486970 656c646e     ....g_dspiHandle
   1164c:	005d305b 73645f67 61486970 656c646e     [0].g_dspiHandle
   1165c:	005d315b 73645f67 61486970 656c646e     [1].g_dspiHandle
   1166c:	005d325b 74736e69 65636e61 46203c20     [2].instance < F
   1167c:	465f4c53 55544145 535f4552 455f434f     SL_FEATURE_SOC_E
   1168c:	5f414d44 4e554f43 00000054 626d2f2e     DMA_COUNT..../mb
   1169c:	6f2d6465 61742f73 74656772 41542f73     ed-os/targets/TA
   116ac:	54454752 6572465f 61637365 542f656c     RGET_Freescale/T
   116bc:	45475241 434d5f54 72705855 6f737365     ARGET_MCUXpresso
   116cc:	55434d5f 41542f53 54454752 55434d5f     _MCUS/TARGET_MCU
   116dc:	34364b5f 72642f46 72657669 73662f73     _K64F/drivers/fs
   116ec:	64655f6c 632e616d 00000000 6e616863     l_edma.c....chan
   116fc:	206c656e 5346203c 45465f4c 52555441     nel < FSL_FEATUR
   1170c:	44455f45 4d5f414d 4c55444f 48435f45     E_EDMA_MODULE_CH
   1171c:	454e4e41 0000004c 20646374 4e203d21     ANNEL...tcd != N
   1172c:	004c4c55 69752828 3233746e 7429745f     ULL.((uint32_t)t
   1173c:	26206463 31783020 20295546 30203d3d     cd & 0x1FU) == 0
   1174c:	00000000 666e6f63 21206769 554e203d     ....config != NU
   1175c:	00004c4c 69752828 3233746e 6e29745f     LL..((uint32_t)n
   1176c:	54747865 26206463 31783020 20295546     extTcd & 0x1FU)
   1177c:	30203d3d 00000000 6b6e696c 68436465     == 0....linkedCh
   1178c:	656e6e61 203c206c 5f4c5346 54414546     annel < FSL_FEAT
   1179c:	5f455255 414d4445 444f4d5f 5f454c55     URE_EDMA_MODULE_
   117ac:	4e414843 004c454e 646e6168 2120656c     CHANNEL.handle !
   117bc:	554e203d 00004c4c 69752828 3233746e     = NULL..((uint32
   117cc:	7429745f 6f506463 26206c6f 31783020     _t)tcdPool & 0x1
   117dc:	20295546 30203d3d 00000000 41637273     FU) == 0....srcA
   117ec:	20726464 4e203d21 004c4c55 74736564     ddr != NULL.dest
   117fc:	72646441 203d2120 4c4c554e 00000000     Addr != NULL....
   1180c:	63727328 74646957 3d3d2068 29553120     (srcWidth == 1U)
   1181c:	207c7c20 63727328 74646957 3d3d2068      || (srcWidth ==
   1182c:	29553220 207c7c20 63727328 74646957      2U) || (srcWidt
   1183c:	3d3d2068 29553420 207c7c20 63727328     h == 4U) || (src
   1184c:	74646957 3d3d2068 55363120 7c7c2029     Width == 16U) ||
   1185c:	72732820 64695763 3d206874 3233203d      (srcWidth == 32
   1186c:	00002955 73656428 64695774 3d206874     U)..(destWidth =
   1187c:	5531203d 7c7c2029 65642820 69577473     = 1U) || (destWi
   1188c:	20687464 32203d3d 7c202955 6428207c     dth == 2U) || (d
   1189c:	57747365 68746469 203d3d20 20295534     estWidth == 4U)
   118ac:	28207c7c 74736564 74646957 3d3d2068     || (destWidth ==
   118bc:	55363120 7c7c2029 65642820 69577473      16U) || (destWi
   118cc:	20687464 33203d3d 00295532 6e617274     dth == 32U).tran
   118dc:	72656673 65747942 20252073 65747962     sferBytes % byte
   118ec:	63614573 71655268 74736575 203d3d20     sEachRequest ==
   118fc:	00000030 74736e69 65636e61 46203c20     0...instance < F
   1190c:	465f4c53 55544145 535f4552 465f434f     SL_FEATURE_SOC_F
   1191c:	4358454c 435f4e41 544e554f 00000000     LEXCAN_COUNT....
   1192c:	626d2f2e 6f2d6465 61742f73 74656772     ./mbed-os/target
   1193c:	41542f73 54454752 6572465f 61637365     s/TARGET_Freesca
   1194c:	542f656c 45475241 434d5f54 72705855     le/TARGET_MCUXpr
   1195c:	6f737365 55434d5f 41542f53 54454752     esso_MCUS/TARGET
   1196c:	55434d5f 34364b5f 72642f46 72657669     _MCU_K64F/driver
   1197c:	73662f73 6c665f6c 61637865 00632e6e     s/fsl_flexcan.c.
   1198c:	6449626d 203c2078 5f4c5346 54414546     mbIdx < FSL_FEAT
   1199c:	5f455255 58454c46 5f4e4143 5f534148     URE_FLEXCAN_HAS_
   119ac:	5353454d 5f454741 46465542 4d5f5245     MESSAGE_BUFFER_M
   119bc:	4e5f5841 45424d55 62286e52 29657361     AX_NUMBERn(base)
   119cc:	00000000 61622821 3e2d6573 2052434d     ....!(base->MCR
   119dc:	41432026 434d5f4e 444d5f52 4d5f5349     & CAN_MCR_MDIS_M
   119ec:	294b5341 00000000 64756162 65746152     ASK)....baudRate
   119fc:	7370425f 203d3c20 30303031 55303030     _Bps <= 1000000U
   11a0c:	00000000 44697270 3c207669 6f73203d     ....priDiv <= so
   11a1c:	65637275 636f6c43 7a485f6b 00000000     urceClock_Hz....
   11a2c:	666e6f63 00006769 6e6f6328 2d676966     config..(config-
   11a3c:	78616d3e 754e624d 203e206d 26202930     >maxMbNum > 0) &
   11a4c:	63282026 69666e6f 6d3e2d67 624d7861     & (config->maxMb
   11a5c:	206d754e 46203d3c 465f4c53 55544145     Num <= FSL_FEATU
   11a6c:	465f4552 4358454c 485f4e41 4d5f5341     RE_FLEXCAN_HAS_M
   11a7c:	41535345 425f4547 45464655 414d5f52     ESSAGE_BUFFER_MA
   11a8c:	554e5f58 5245424d 6162286e 29296573     X_NUMBERn(base))
   11a9c:	00000000 6b73616d 20786449 28203d3c     ....maskIdx <= (
   11aac:	65736162 434d3e2d 20262052 5f4e4143     base->MCR & CAN_
   11abc:	5f52434d 4d58414d 414d5f42 00294b53     MCR_MAXMB_MASK).
   11acc:	6449626d 3d3c2078 61622820 3e2d6573     mbIdx <= (base->
   11adc:	2052434d 41432026 434d5f4e 414d5f52     MCR & CAN_MCR_MA
   11aec:	5f424d58 4b53414d 00000029 454c4621     XMB_MASK)...!FLE
   11afc:	4e414358 4d73495f 63634f62 65697075     XCAN_IsMbOccupie
   11b0c:	61622864 202c6573 6449626d 00002978     d(base, mbIdx)..
   11b1c:	6f632828 6769666e 7c7c2029 61662820     ((config) || (fa
   11b2c:	2065736c 65203d3d 6c62616e 00292965     lse == enable)).
   11b3c:	6e6f6328 29676966 207c7c20 6c616628     (config) || (fal
   11b4c:	3d206573 6e65203d 656c6261 00000029     se == enable)...
   11b5c:	666e6f63 3e2d6769 69466469 7265746c     config->idFilter
   11b6c:	206d754e 31203d3c 00003832 65732828     Num <= 128..((se
   11b7c:	5f707574 2d20626d 20293820 3228202d     tup_mb - 8) - (2
   11b8c:	72202a20 296e6666 203e2029 00000030      * rffn)) > 0...
   11b9c:	72467874 00656d61 72467874 2d656d61     txFrame.txFrame-
   11bac:	6e656c3e 20687467 38203d3c 00000000     >length <= 8....
   11bbc:	72467872 00656d61 646e6168 0000656c     rxFrame.handle..
   11bcc:	72656678 00000000 72656678 626d3e2d     xfer....xfer->mb
   11bdc:	20786449 28203d3c 65736162 434d3e2d     Idx <= (base->MC
   11bec:	20262052 5f4e4143 5f52434d 4d58414d     R & CAN_MCR_MAXM
   11bfc:	414d5f42 00294b53 454c4621 4e414358     B_MASK).!FLEXCAN
   11c0c:	4d73495f 63634f62 65697075 61622864     _IsMbOccupied(ba
   11c1c:	202c6573 72656678 626d3e2d 29786449     se, xfer->mbIdx)
   11c2c:	00000000 6c665f73 61637865 6e61486e     ....s_flexcanHan
   11c3c:	5b656c64 00005d30 74736e69 65636e61     dle[0]..instance
   11c4c:	46203c20 465f4c53 55544145 535f4552      < FSL_FEATURE_S
   11c5c:	505f434f 435f5449 544e554f 00000000     OC_PIT_COUNT....
   11c6c:	626d2f2e 6f2d6465 61742f73 74656772     ./mbed-os/target
   11c7c:	41542f73 54454752 6572465f 61637365     s/TARGET_Freesca
   11c8c:	542f656c 45475241 434d5f54 72705855     le/TARGET_MCUXpr
   11c9c:	6f737365 55434d5f 41542f53 54454752     esso_MCUS/TARGET
   11cac:	55434d5f 34364b5f 72642f46 72657669     _MCU_K64F/driver
   11cbc:	73662f73 69705f6c 00632e74 666e6f63     s/fsl_pit.c.conf
   11ccc:	00006769 74736e69 65636e61 46203c20     ig..instance < F
   11cdc:	465f4c53 55544145 535f4552 495f434f     SL_FEATURE_SOC_I
   11cec:	435f5332 544e554f 00000000 626d2f2e     2S_COUNT...../mb
   11cfc:	6f2d6465 61742f73 74656772 41542f73     ed-os/targets/TA
   11d0c:	54454752 6572465f 61637365 542f656c     RGET_Freescale/T
   11d1c:	45475241 434d5f54 72705855 6f737365     ARGET_MCUXpresso
   11d2c:	55434d5f 41542f53 54454752 55434d5f     _MCUS/TARGET_MCU
   11d3c:	34364b5f 72642f46 72657669 73662f73     _K64F/drivers/fs
   11d4c:	61735f6c 00632e69 646e6168 0000656c     l_sai.c.handle..
   11d5c:	61735f73 6e614869 5b656c64 305b5d30     s_saiHandle[0][0
   11d6c:	0000005d 61735f73 6e614869 5b656c64     ]...s_saiHandle[
   11d7c:	315b5d30 0000005d 65646e69 203c2078     0][1]...index <
   11d8c:	00005534 626d2f2e 6f2d6465 61742f73     4U.../mbed-os/ta
   11d9c:	74656772 41542f73 54454752 6572465f     rgets/TARGET_Fre
   11dac:	61637365 542f656c 45475241 434d5f54     escale/TARGET_MC
   11dbc:	72705855 6f737365 55434d5f 41542f53     UXpresso_MCUS/TA
   11dcc:	54454752 55434d5f 34364b5f 72642f46     RGET_MCU_K64F/dr
   11ddc:	72657669 73662f73 64735f6c 682e6368     ivers/fsl_sdhc.h
   11dec:	00000000 74736e69 65636e61 46203c20     ....instance < F
   11dfc:	465f4c53 55544145 535f4552 535f434f     SL_FEATURE_SOC_S
   11e0c:	5f434844 4e554f43 00000054 626d2f2e     DHC_COUNT..../mb
   11e1c:	6f2d6465 61742f73 74656772 41542f73     ed-os/targets/TA
   11e2c:	54454752 6572465f 61637365 542f656c     RGET_Freescale/T
   11e3c:	45475241 434d5f54 72705855 6f737365     ARGET_MCUXpresso
   11e4c:	55434d5f 41542f53 54454752 55434d5f     _MCUS/TARGET_MCU
   11e5c:	34364b5f 72642f46 72657669 73662f73     _K64F/drivers/fs
   11e6c:	64735f6c 632e6368 00000000 646e6168     l_sdhc.c....hand
   11e7c:	3e2d656c 6d6d6f63 00646e61 646e6168     le->command.hand
   11e8c:	3e2d656c 61746164 00000000 666e6f63     le->data....conf
   11e9c:	00006769 666e6f63 3e2d6769 4d616d64     ig..config->dmaM
   11eac:	2065646f 6b203d21 43484453 616d445f     ode != kSDHC_Dma
   11ebc:	65646f4d 616d6441 00000031 6e6f6328     ModeAdma1...(con
   11ecc:	2d676966 6972773e 61576574 6d726574     fig->writeWaterm
   11edc:	4c6b7261 6c657665 203d3e20 20295531     arkLevel >= 1U)
   11eec:	28202626 666e6f63 3e2d6769 74697277     && (config->writ
   11efc:	74615765 616d7265 654c6b72 206c6576     eWatermarkLevel
   11f0c:	31203d3c 29553832 00000000 6e6f6328     <= 128U)....(con
   11f1c:	2d676966 6165723e 74615764 616d7265     fig->readWaterma
   11f2c:	654c6b72 206c6576 31203d3e 26202955     rkLevel >= 1U) &
   11f3c:	63282026 69666e6f 723e2d67 57646165     & (config->readW
   11f4c:	72657461 6b72616d 6576654c 3d3c206c     atermarkLevel <=
   11f5c:	38323120 00002955 61706163 696c6962      128U)..capabili
   11f6c:	00007974 43637273 6b636f6c 207a485f     ty..srcClock_Hz
   11f7c:	30203d21 00000055 73756228 636f6c43     != 0U...(busCloc
   11f8c:	7a485f6b 203d2120 20295530 28202626     k_Hz != 0U) && (
   11f9c:	43737562 6b636f6c 207a485f 73203d3c     busClock_Hz <= s
   11fac:	6c436372 5f6b636f 00297a48 666e6f63     rcClock_Hz).conf
   11fbc:	3e2d6769 61746164 636f6c42 7a69536b     ig->dataBlockSiz
   11fcc:	3d3c2065 44532820 425f4348 54414b4c     e <= (SDHC_BLKAT
   11fdc:	425f5254 49534b4c 4d5f455a 204b5341     TR_BLKSIZE_MASK
   11fec:	53203e3e 5f434844 414b4c42 5f525454     >> SDHC_BLKATTR_
   11ffc:	534b4c42 5f455a49 46494853 00002954     BLKSIZE_SHIFT)..
   1200c:	666e6f63 3e2d6769 61746164 636f6c42     config->dataBloc
   1201c:	756f436b 3c20746e 5328203d 5f434844     kCount <= (SDHC_
   1202c:	414b4c42 5f525454 434b4c42 4d5f544e     BLKATTR_BLKCNT_M
   1203c:	204b5341 53203e3e 5f434844 414b4c42     ASK >> SDHC_BLKA
   1204c:	5f525454 434b4c42 535f544e 54464948     TTR_BLKCNT_SHIFT
   1205c:	00000029 666e6f63 3e2d6769 546b6361     )...config->ackT
   1206c:	6f656d69 6f437475 20746e75 28203d3c     imeoutCount <= (
   1207c:	43484453 434d4d5f 544f4f42 4f54445f     SDHC_MMCBOOT_DTO
   1208c:	43415643 414d5f4b 3e204b53 4453203e     CVACK_MASK >> SD
   1209c:	4d5f4348 4f42434d 445f544f 56434f54     HC_MMCBOOT_DTOCV
   120ac:	5f4b4341 46494853 00002954 666e6f63     ACK_SHIFT)..conf
   120bc:	3e2d6769 636f6c62 756f436b 3c20746e     ig->blockCount <
   120cc:	5328203d 5f434844 42434d4d 5f544f4f     = (SDHC_MMCBOOT_
   120dc:	544f4f42 434b4c42 4d5f544e 204b5341     BOOTBLKCNT_MASK
   120ec:	53203e3e 5f434844 42434d4d 5f544f4f     >> SDHC_MMCBOOT_
   120fc:	544f4f42 434b4c42 535f544e 54464948     BOOTBLKCNT_SHIFT
   1210c:	00000029 6e617274 72656673 00000000     )...transfer....
   1211c:	646e6168 0000656c 6c6c6163 6b636162     handle..callback
   1212c:	00000000 64735f73 61486368 656c646e     ....s_sdhcHandle
   1213c:	005d305b 74736e69 65636e61 75203c20     [0].instance < u
   1214c:	41747261 79617272 6e756f43 00000074     artArrayCount...
   1215c:	626d2f2e 6f2d6465 61742f73 74656772     ./mbed-os/target
   1216c:	41542f73 54454752 6572465f 61637365     s/TARGET_Freesca
   1217c:	542f656c 45475241 434d5f54 72705855     le/TARGET_MCUXpr
   1218c:	6f737365 55434d5f 41542f53 54454752     esso_MCUS/TARGET
   1219c:	55434d5f 34364b5f 72642f46 72657669     _MCU_K64F/driver
   121ac:	73662f73 61755f6c 632e7472 00000000     s/fsl_uart.c....
   121bc:	646e6168 0000656c 666e6f63 00006769     handle..config..
   121cc:	666e6f63 3e2d6769 64756162 65746152     config->baudRate
   121dc:	7370425f 00000000 5f4c5346 54414546     _Bps....FSL_FEAT
   121ec:	5f455255 54524155 4649465f 49535f4f     URE_UART_FIFO_SI
   121fc:	286e455a 65736162 3d3e2029 6e6f6320     ZEn(base) >= con
   1220c:	2d676966 4678743e 576f6669 72657461     fig->txFifoWater
   1221c:	6b72616d 00000000 5f4c5346 54414546     mark....FSL_FEAT
   1222c:	5f455255 54524155 4649465f 49535f4f     URE_UART_FIFO_SI
   1223c:	286e455a 65736162 3d3e2029 6e6f6320     ZEn(base) >= con
   1224c:	2d676966 4678723e 576f6669 72657461     fig->rxFifoWater
   1225c:	6b72616d 00000000 64756162 65746152     mark....baudRate
   1226c:	7370425f 00000000 61746164 00000000     _Bps....data....
   1227c:	676e6972 66667542 00007265 72656678     ringBuffer..xfer
   1228c:	00000000 72656678 61643e2d 69536174     ....xfer->dataSi
   1229c:	0000657a 72656678 61643e2d 00006174     ze..xfer->data..
   122ac:	6e756f63 00000074 626d2f2e 6f2d6465     count..../mbed-o
   122bc:	61742f73 74656772 41542f73 54454752     s/targets/TARGET
   122cc:	6572465f 61637365 542f656c 45475241     _Freescale/TARGE
   122dc:	434d5f54 72705855 6f737365 55434d5f     T_MCUXpresso_MCU
   122ec:	41542f53 54454752 55434d5f 34364b5f     S/TARGET_MCU_K64
   122fc:	65732f46 6c616972 6970615f 0000632e     F/serial_api.c..
   1230c:	746e6928 6a626f29 65733e2d 6c616972     (int)obj->serial
   1231c:	646e692e 21207865 434e203d 00000000     .index != NC....
   1232c:	00000030 2523211f 00004442 01040102     0....!#%BD......
   1233c:	01080106 010b010a 01050103 01090107     ................
   1234c:	010b010a 21207874 7628203d 2a64696f     ....tx != (void*
   1235c:	00003029 74646977 3d3d2068 00003820     )0..width == 8..
   1236c:	21207872 7628203d 2a64696f 00003029     rx != (void*)0..
   1237c:	666e6f63 00006769 626d2f2e 6f2d6465     config.../mbed-o
   1238c:	61742f73 74656772 41542f73 54454752     s/targets/TARGET
   1239c:	6572465f 61637365 542f656c 45475241     _Freescale/TARGE
   123ac:	434d5f54 72705855 6f737365 55434d5f     T_MCUXpresso_MCU
   123bc:	41542f53 54454752 55434d5f 34364b5f     S/TARGET_MCU_K64
   123cc:	72642f46 72657669 73662f73 69705f6c     F/drivers/fsl_pi
   123dc:	00682e74 626d2f2e 6f2d6465 61742f73     t.h../mbed-os/ta
   123ec:	74656772 41542f73 54454752 6572465f     rgets/TARGET_Fre
   123fc:	61637365 542f656c 45475241 434d5f54     escale/TARGET_MC
   1240c:	72705855 6f737365 55434d5f 70612f53     UXpresso_MCUS/ap
   1241c:	70672f69 615f6f69 632e6970 00000000     i/gpio_api.c....
   1242c:	206e6970 28203d21 4e6e6950 29656d61     pin != (PinName)
   1243c:	0000434e 2d6a626f 6e69703e 203d2120     NC..obj->pin !=
   1244c:	6e695028 656d614e 00434e29 626d2f2e     (PinName)NC../mb
   1245c:	6f2d6465 61742f73 74656772 41542f73     ed-os/targets/TA
   1246c:	54454752 6572465f 61637365 542f656c     RGET_Freescale/T
   1247c:	45475241 434d5f54 72705855 6f737365     ARGET_MCUXpresso
   1248c:	55434d5f 70612f53 69702f69 70616d6e     _MCUS/api/pinmap
   1249c:	0000632e 206e6970 28203d21 4e6e6950     .c..pin != (PinN
   124ac:	29656d61 0000434e 10380009 1038000a     ame)NC....8...8.
   124bc:	1038000b 1038000c 1038000d              ..8...8...8.

000124c8 <us_interface>:
   124c8:	00009e81 00009f51 00009f69 00009f7d     ....Q...i...}...
   124d8:	00009f91 0000a001 00009e41              ........A...

000124e4 <us_data>:
   124e4:	000124c8 20000c70                       .$..p..

000124ec <_ZTVN4mbed10FileHandleE>:
	...
   124fc:	000039bb 000039bb 000039bb 000039bb     .9...9...9...9..
   1250c:	0000270d 00002719 00001a85 00001aa5     .'...'..........
   1251c:	00002725 000019a1 000019c5 000019e1     %'..............
   1252c:	000019fd 00001a1d 00001a29 00001a3b     ........)...;...

0001253c <_ZTV12DirectSerial>:
	...
   12544:	00003bf1 00003c15 0000327d 0000323d     .;...<..}2..=2..
   12554:	000031b5 000031e1 0000270d 000031d5     .1...1...'...1..
   12564:	00001a85 00001aa5 000031c7 000019a1     .........1......
   12574:	000019c5 000019e1 000019fd 00001a1d     ................
   12584:	000032b1 00001a3b                       .2..;...

0001258c <os_idle_thread_attr>:
   1258c:	00011430 00000000 20000e70 00000048     0.......p.. H...
   1259c:	20000f00 00000200 00000001 00000001     ... ............
   125ac:	00000000                                ....

000125b0 <os_timer_thread_attr>:
   125b0:	0001143c 00000000 20000eb8 00000048     <.......... H...
   125c0:	20001100 00000300 00000028 00000001     ... ....(.......
   125d0:	00000000                                ....

000125d4 <os_timer_mq_attr>:
	...
   125dc:	20001400 00000034 20001434 00000050     ... 4...4.. P...

000125ec <osRtxUserSVC>:
   125ec:	00000000                                ....

000125f0 <PinMap_UART_TX>:
   125f0:	00001011 00000000 00000003 00002011     ............. ..
   12600:	00000003 00000003 00003007 00000000     .........0......
   12610:	00000003 00003003 00000002 00000003     .....0..........
   12620:	00002004 00000001 00000003 0000200f     . ........... ..
   12630:	00000004 00000003 0000100b 00000003     ................
   12640:	00000003 0000000e 00000000 00000003     ................
   12650:	00004018 00000004 00000003 00004004     .@...........@..
   12660:	00000003 00000003 00004000 00000001     .........@......
   12670:	00000003 ffffffff ffffffff 00000000     ................

00012680 <PinMap_UART_RX>:
   12680:	00001010 00000000 00000003 00004001     .............@..
   12690:	00000001 00000003 00004005 00000003     .........@......
   126a0:	00000003 00004019 00000004 00000003     .....@..........
   126b0:	0000000f 00000000 00000003 00002010     ............. ..
   126c0:	00000003 00000003 0000100a 00000003     ................
   126d0:	00000003 00002003 00000001 00000003     ..... ..........
   126e0:	0000200e 00000004 00000003 00003002     . ...........0..
   126f0:	00000002 00000003 00003006 00000000     .........0......
   12700:	00000003 ffffffff ffffffff 00000000     ................

00012710 <g_defaultClockConfigRun>:
   12710:	00000207 00000007 00181300 00000201     ................
   12720:	01140000 02faf080 00800000 07270e00     ..............'.

00012730 <__func__.7523>:
   12730:	434f4c43 65475f4b 67634d74 43747845     CLOCK_GetMcgExtC
   12740:	72466b6c 00007165                       lkFreq..

00012748 <__func__.7568>:
   12748:	434f4c43 65475f4b 63734f74 43724530     CLOCK_GetOsc0ErC
   12758:	72466b6c 00007165                       lkFreq..

00012760 <__func__.7576>:
   12760:	434f4c43 65475f4b 33724574 6c436b32     CLOCK_GetEr32kCl
   12770:	6572466b 00000071                       kFreq...

00012778 <fllFactorTable.7651>:
   12778:	02dc0280 05b80500 08950780 0b710a00     ..............q.

00012788 <__func__.7666>:
   12788:	434f4c43 65475f4b 6c6c5074 65724630     CLOCK_GetPll0Fre
   12798:	00000071                                q...

0001279c <__func__.7714>:
   1279c:	434f4c43 6e455f4b 656c6261 306c6c50     CLOCK_EnablePll0
   127ac:	00000000                                ....

000127b0 <__func__.7850>:
   127b0:	434f4c43 65535f4b 65625074 65646f4d     CLOCK_SetPbeMode
   127c0:	00000000                                ....

000127c4 <__func__.7914>:
   127c4:	434f4c43 6f425f4b 6f54746f 4d656550     CLOCK_BootToPeeM
   127d4:	0065646f                                ode.

000127d8 <__func__.8198>:
   127d8:	30495053 6972445f 49726576 61485152     SPI0_DriverIRQHa
   127e8:	656c646e 00000072                       ndler...

000127f0 <__func__.8202>:
   127f0:	31495053 6972445f 49726576 61485152     SPI1_DriverIRQHa
   12800:	656c646e 00000072                       ndler...

00012808 <__func__.8206>:
   12808:	32495053 6972445f 49726576 61485152     SPI2_DriverIRQHa
   12818:	656c646e 00000072                       ndler...

00012820 <__func__.8001>:
   12820:	414d4445 6e61485f 49656c64 00005152     EDMA_HandleIRQ..

00012830 <__func__.8066>:
   12830:	304e4143 6972445f 49726576 61485152     CAN0_DriverIRQHa
   12840:	656c646e 00000072                       ndler...

00012848 <__func__.7572>:
   12848:	5f544950 49746547 6174736e 0065636e     PIT_GetInstance.

00012858 <__func__.7577>:
   12858:	5f544950 74696e49 00000000              PIT_Init....

00012864 <__func__.8050>:
   12864:	30533249 5f78545f 76697244 52497265     I2S0_Tx_DriverIR
   12874:	6e614851 72656c64 00000000              QHandler....

00012880 <__func__.8054>:
   12880:	30533249 5f78525f 76697244 52497265     I2S0_Rx_DriverIR
   12890:	6e614851 72656c64 00000000              QHandler....

0001289c <__func__.8238>:
   1289c:	43484453 6972445f 49726576 61485152     SDHC_DriverIRQHa
   128ac:	656c646e 00000072                       ndler...

000128b4 <s_uartBases>:
   128b4:	4006a000 4006b000 4006c000 4006d000     ...@...@...@...@
   128c4:	400ea000 400eb000                       ...@...@

000128cc <s_uartClock>:
   128cc:	1034000a 1034000b 1034000c 1034000d     ..4...4...4...4.
   128dc:	1028000a 1028000b                       ..(...(.

000128e4 <__func__.7722>:
   128e4:	54524155 7465475f 74736e49 65636e61     UART_GetInstance
   128f4:	00000000                                ....

000128f8 <__func__.7738>:
   128f8:	54524155 696e495f 00000074              UART_Init...

00012904 <__func__.7756>:
   12904:	54524155 7465475f 61666544 43746c75     UART_GetDefaultC
   12914:	69666e6f 00000067                       onfig...

0001291c <__func__.7762>:
   1291c:	54524155 7465535f 64756142 65746152     UART_SetBaudRate
   1292c:	00000000                                ....

00012930 <uart_addrs>:
   12930:	4006a000 4006b000 4006c000 4006d000     ...@...@...@...@
   12940:	400ea000 400eb000                       ...@...@

00012948 <uart_clocks>:
   12948:	02020000 00000202                       ........

00012950 <info.9334>:
   12950:	000f4240 00000020                       @B.. ...

00012958 <__func__.9282>:
   12958:	5f544950 44746547 75616665 6f43746c     PIT_GetDefaultCo
   12968:	6769666e 00000000                       nfig....

00012970 <gpio_addrs>:
   12970:	400ff000 400ff040 400ff080 400ff0c0     ...@@..@...@...@
   12980:	400ff100                                ...@

00012984 <port_addrs>:
   12984:	40049000 4004a000 4004b000 4004c000     ...@...@...@...@
   12994:	4004d000 7566202c 6974636e 203a6e6f     ...@, function:
   129a4:	00000000 65737361 6f697472 2522206e     ....assertion "%
   129b4:	66202273 656c6961 66203a64 20656c69     s" failed: file
   129c4:	22732522 696c202c 2520656e 25732564     "%s", line %d%s%
   129d4:	00000a73                                s...

000129d8 <_global_impure_ptr>:
   129d8:	200001c8 00000043 49534f50 00000058     ... C...POSIX...
   129e8:	0000002e 00464e49 00666e69 004e414e     ....INF.inf.NAN.
   129f8:	006e616e 33323130 37363534 42413938     nan.0123456789AB
   12a08:	46454443 00000000 33323130 37363534     CDEF....01234567
   12a18:	62613938 66656463 00000000 6c756e28     89abcdef....(nul
   12a28:	0000296c 00000030                       l)..0...

00012a30 <blanks.8346>:
   12a30:	20202020 20202020 20202020 20202020

00012a40 <zeroes.8347>:
   12a40:	30303030 30303030 30303030 30303030     0000000000000000

00012a50 <blanks.8340>:
   12a50:	20202020 20202020 20202020 20202020

00012a60 <zeroes.8341>:
   12a60:	30303030 30303030 30303030 30303030     0000000000000000

00012a70 <blanks.8361>:
   12a70:	20202020 20202020 20202020 20202020

00012a80 <zeroes.8362>:
   12a80:	30303030 30303030 30303030 30303030     0000000000000000

00012a90 <_ctype_>:
   12a90:	20202000 20202020 28282020 20282828     .         (((((
   12aa0:	20202020 20202020 20202020 20202020
   12ab0:	10108820 10101010 10101010 10101010      ...............
   12ac0:	04040410 04040404 10040404 10101010     ................
   12ad0:	41411010 41414141 01010101 01010101     ..AAAAAA........
   12ae0:	01010101 01010101 01010101 10101010     ................
   12af0:	42421010 42424242 02020202 02020202     ..BBBBBB........
   12b00:	02020202 02020202 02020202 10101010     ................
   12b10:	00000020 00000000 00000000 00000000      ...............
	...
   12b94:	69666e49 7974696e 00000000 004e614e     Infinity....NaN.
   12ba4:	00000000                                ....

00012ba8 <__mprec_bigtens>:
   12ba8:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
   12bb8:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
   12bc8:	7f73bf3c 75154fdd                       <.s..O.u

00012bd0 <__mprec_tens>:
   12bd0:	00000000 3ff00000 00000000 40240000     .......?......$@
   12be0:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
   12bf0:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
   12c00:	00000000 412e8480 00000000 416312d0     .......A......cA
   12c10:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
   12c20:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
   12c30:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
   12c40:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
   12c50:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
   12c60:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
   12c70:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
   12c80:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
   12c90:	79d99db4 44ea7843                       ...yCx.D

00012c98 <p05.7178>:
   12c98:	00000005 00000019 0000007d              ........}...

00012ca4 <_init>:
   12ca4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12ca6:	bf00      	nop
   12ca8:	bcf8      	pop	{r3, r4, r5, r6, r7}
   12caa:	bc08      	pop	{r3}
   12cac:	469e      	mov	lr, r3
   12cae:	4770      	bx	lr

00012cb0 <_fini>:
   12cb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12cb2:	bf00      	nop
   12cb4:	bcf8      	pop	{r3, r4, r5, r6, r7}
   12cb6:	bc08      	pop	{r3}
   12cb8:	469e      	mov	lr, r3
   12cba:	4770      	bx	lr
